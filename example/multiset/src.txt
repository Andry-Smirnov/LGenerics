{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic helper utils for arrays.                                        *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGArrayHelpers;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  math,
  typinfo,
  LGUtils,
  {%H-}LGHelpers;

type

  TSortOrder   = LGUtils.TSortOrder;
  {.$DEFINE FPC_REQUIRES_PROPER_ALIGNMENT  for test purpose only}

  { TGArrayHelpUtil }

  generic TGArrayHelpUtil<T> = class
  public
  type
    TItem             = T;
    PItem             = ^T;
    TArray            = specialize TGArray<T>;
    TOptional         = specialize TGOptional<T>;
    TEqualCompare     = specialize TGEqualCompare<T>;
    TOnEqualCompare   = specialize TGOnEqualCompare<T>;
    TNestEqualCompare = specialize TGNestEqualCompare<T>;
    TTest             = specialize TGTest<T>;
    TOnTest           = specialize TGOnTest<T>;
    TNestTest         = specialize TGNestTest<T>;
    TFold             = specialize TGFold<T, T>;
    TOnFold           = specialize TGOnFold<T, T>;
    TNestFold         = specialize TGNestFold<T, T>;

    TSearchResult = record
      FoundIndex,
      InsertIndex: SizeInt;
    end;

  protected
  const
    HEAP_INSERT_CUTOFF  = 63;
    QUICK_INSERT_CUTOFF = 31;
    MEDIAN_OF9_CUTOFF   = 511;
    DPQ_INSERT_CUTOFF   = 47;
    INTRO_LOG_FACTOR    = 2;
  type
    //to supress unnecessary refcounting
    TFake      = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(SizeOf(T))] of Byte{$ELSE}T{$ENDIF};
    TFakeArray = array of TFake;
    //TOptional  = specialize TGOptional<T>;
    TSortSplit = record
      Left,
      Right: SizeInt;
    end;

    TMergeSortBase = object
    protected
    const
      MERGE_STACK_INIT_SIZE  = 16;
      MERGE_BUFFER_INIT_SIZE = 64;
      MIN_MERGE_POW          = 5;
      MIN_MERGE_LEN          = SizeInt(1) shl MIN_MERGE_POW;
    type
      TRun       = record
        Base, Count: SizeInt;
      end;
      TRunArray  = array of TRun;
    var
      FData: PItem; // pointer to data array
      FBuffer: TFakeArray;
      FStack: TRunArray;
      FStackSize: SizeInt;
      procedure PushRun(aBase, aCount: SizeInt);
      function  EnsureBufferCapacity(aSize: SizeInt): PItem; inline;
      procedure Init(A: PItem);
      class function  MinRunLen(aTotalSize: SizeInt): SizeInt; static;
    end;

    class procedure CopyItems(aSrc, aDst: PItem; aCount: SizeInt); static;
    class procedure DoReverse(p: PItem; R: SizeInt); static;
    class procedure DoSwap(p: PItem; L, R: SizeInt); static; inline;
  public
    class function  CreateCopy(constref A: array of T): TArray; static;
    class function  CreateReverseCopy(constref A: array of T): TArray; static;
    class function  CreateMerge(constref L, R: array of T): TArray; static;
    class function  CreateRandomShuffle(constref A: array of T): TArray; static;
    class function  Append(constref aValue: T; var A: TArray): SizeInt;
  { if aSrc <> aDst appends aSrc to aDst, sets aSrc to nil and returns count of merged elements,
    otherwise returns 0}
    class function  Merge(var aDst, aSrc: TArray): SizeInt; static;
  { returns array of elements of A starting at aIndex(0-based) to High(A);
    length of A becomes aIndex;
    if A = nil or aIndex > High(A), then Result is empty }
    class function  Split(var A: TArray; aIndex: SizeInt): TArray; static;
  { extracts array of aCount elements of A starting at aIndex(0-based);
    if aIndex > High(A) or aCount < 1, then Result is empty;
    if aCount > length A then Result is truncated }
    class function  Extract(var A: TArray; aIndex, aCount: SizeInt): TArray; static;
    class procedure Reverse(var A: array of T); static;
    class procedure RandomShuffle(var A: array of T); static;//TGEqualCompare
  { returns 0-based position of aValue in array A, -1 if not found }
    class function  SequentSearch(constref A: array of T; constref aValue: T; c: TEqualCompare): SizeInt;
                    static;
    class function  SequentSearch(constref A: array of T; constref aValue: T; c: TOnEqualCompare): SizeInt;
                    static;
    class function  SequentSearch(constref A: array of T; constref aValue: T; c: TNestEqualCompare): SizeInt;
                    static;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(constref A, B: array of T; c: TEqualCompare): Boolean; static;
    class function  Same(constref A, B: array of T; c: TOnEqualCompare): Boolean; static;
    class function  Same(constref A, B: array of T; c: TNestEqualCompare): Boolean; static;
    class function  Select(constref A: array of T; aTest: TTest): TArray;
    class function  Select(constref A: array of T; aTest: TOnTest): TArray;
    class function  Select(constref A: array of T; aTest: TNestTest): TArray;
    { left-associative linear fold }
    class function  FoldL(constref A: array of T; aFold: TFold; constref v0: T): T; static;
    class function  FoldL(constref A: array of T; aFold: TFold): TOptional; static;
    class function  FoldL(constref A: array of T; aFold: TOnFold; constref v0: T): T; static;
    class function  FoldL(constref A: array of T; aFold: TOnFold): TOptional; static;
    class function  FoldL(constref A: array of T; aFold: TNestFold; constref v0: T): T; static;
    class function  FoldL(constref A: array of T; aFold: TNestFold): TOptional; static;
  { right-associative linear fold }
    class function  FoldR(constref A: array of T; aFold: TFold; constref v0: T): T; static;
    class function  FoldR(constref A: array of T; aFold: TFold): TOptional; static;
    class function  FoldR(constref A: array of T; aFold: TOnFold; constref v0: T): T; static;
    class function  FoldR(constref A: array of T; aFold: TOnFold): TOptional; static;
    class function  FoldR(constref A: array of T; aFold: TNestFold; constref v0: T): T; static;
    class function  FoldR(constref A: array of T; aFold: TNestFold): TOptional; static;
  end;

  { TGBaseArrayHelper
      functor TCmpRel(comparision relation) must provide:
        class function Compare([const[ref]] L, R: T): SizeInt }
  generic TGBaseArrayHelper<T, TCmpRel> = class(specialize TGArrayHelpUtil<T>)
  protected
  type

    TMergeSort = object(TMergeSortBase)
    private
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      procedure MergeLoA(From, CountLo, CountHi: SizeInt);
      procedure MergeLoD(From, CountLo, CountHi: SizeInt);
      procedure MergeHiA(From, CountLo, CountHi: SizeInt);
      procedure MergeHiD(From, CountLo, CountHi: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt); static;
      class function  CountRunAsc(A: PItem; R: SizeInt): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt); static;
      class procedure SortDesc(A: PItem; R: SizeInt); static;
    end;

    class function  CountRun2Asc(A: PItem; R: SizeInt): SizeInt; static;
    class procedure InsertionSort(A: PItem; R: SizeInt); static;
    class function  DoBinSearch(A: PItem; R: SizeInt; constref aValue: T): SizeInt; static;
    class function  DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T): TSearchResult; static;
    class function  DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T): TSearchResult; static;
    class function  DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T): TSearchResult; static;
    class procedure DoHeapSort(A: PItem; R: SizeInt); static;
    class function  QSplitR(A: PItem; R: SizeInt): TSortSplit; static;
    class procedure DoQSort(A: PItem; R: SizeInt); static;
    class function  MedianOf3(constref v1, v2, v3: T): T; static; inline;
    class function  QSplitMo9(A: PItem; R: SizeInt): TSortSplit; static;
    class procedure DoIntroSort(A: PItem; R, Ttl: SizeInt); static;
    class function  DPQSplit(A: PItem; R: SizeInt): TSortSplit; static;
    class procedure DoDPQSort(A: PItem; R: SizeInt); static;
  { QuickSelect with random pivot, does not checks indexes }
    class function  QSelectR(A: PItem; R, N: SizeInt): T; static;
  public
  { returns 0-based position of aValue in array A, -1 if not found }
    class function  SequentSearch(constref A: array of T; constref aValue: T): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A, -1 if not found }
    class function  BinarySearch(constref A: array of T; constref aValue: T): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A in Result.FoundIndex(-1 if not found);
    returns position for insertion in Result.InsertIndex(-1 if array is empty);
    in case of array of single element or constant array assumes ascending state }
    class function  BinarySearchPos(constref A: array of T; constref aValue: T): TSearchResult; static;
  { returns 0-based position of minimal value in A, -1 if A is empty }
    class function  IndexOfMin(constref A: array of T): SizeInt; static;
  { returns 0-based position of maximal value in A, -1 if A is empty }
    class function  IndexOfMax(constref A: array of T): SizeInt; static;
  { returns smallest element of A in TOptional.Value if A is nonempty }
    class function  GetMin(constref A: array of T): TOptional; static;
  { returns greatest element of A in TOptional.Value if A is nonempty }
    class function  GetMax(constref A: array of T): TOptional; static;
  { returns True and smallest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMin(constref A: array of T; out aValue: T): Boolean; static;
  { returns True and greatest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMax(constref A: array of T; out aValue: T): Boolean; static;
  { returns True, smallest element of A in aMin and greatest element of A in aMax, if A is nonempty,
    False otherwise }
    class function  FindMinMax(constref A: array of T; out aMin, aMax: T): Boolean; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  NthSmallest(var A: array of T; N: SizeInt): TOptional; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  FindNthSmallestND(constref A: array of T; N: SizeInt; out aValue: T): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  NthSmallestND(constref A: array of T; N: SizeInt): TOptional; static;
  { returns True if permutation towards nondescending state of A has done, False otherwise }
    class function  NextPermutation2Asc(var A: array of T): Boolean; static;
  { returns True if permutation towards nonascending state of A has done, False otherwise }
    class function  NextPermutation2Desc(var A: array of T): Boolean; static;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(constref A: array of T): Boolean; static;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(constref A: array of T): Boolean; static;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(constref A: array of T): Boolean; static;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(constref A: array of T): Boolean; static;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(constref A, B: array of T): Boolean; static;
  { slightly modified optimized quicksort with random pivot selection }
    class procedure QuickSort(var A: array of T; o: TSortOrder = soAsc); static;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(var A: array of T; o: TSortOrder = soAsc); static;
  { slightly modified V.Yaroslavskiy proposed the dual pivot Quicksort algorithm with random pivot selection }
    class procedure DualPivotQuickSort(var A: array of T; o: TSortOrder = soAsc); static;
  { stable, adaptive mergesort inspired by Java Timsort }
    class procedure MergeSort(var A: array of T; o: TSortOrder = soAsc); static;
  { default sort algorithm, currently it is IntroSort}
    class procedure Sort(var A: array of T; o: TSortOrder = soAsc); static;
    class function  Sorted(constref A: array of T; o: TSortOrder = soAsc): TArray; static;
  { copies only distinct values from A }
    class function  SelectDistinct(constref A: array of T): TArray; static;
  end;

  { TGArrayHelper assumes that type T implements TCmpRel }
  generic TGArrayHelper<T> = class(specialize TGBaseArrayHelper<T, T>);

  {TGComparableArrayHelper assumes that type T defines comparision operators }
  generic TGComparableArrayHelper<T> = class(specialize TGArrayHelpUtil<T>)
  protected
  type
    TMergeSort = object(TMergeSortBase)
    private
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      procedure MergeLoA(From, CountLo, CountHi: SizeInt);
      procedure MergeLoD(From, CountLo, CountHi: SizeInt);
      procedure MergeHiA(From, CountLo, CountHi: SizeInt);
      procedure MergeHiD(From, CountLo, CountHi: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt); static;
      class function  CountRunAsc(A: PItem; R: SizeInt): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt); static;
      class procedure SortDesc(A: PItem; R: SizeInt); static;
    end;

    class function  CountRun2Asc(A: PItem; R: SizeInt): SizeInt; static;
    class procedure InsertionSort(A: PItem; R: SizeInt); static;
    class function  DoBinSearch(A: PItem; R: SizeInt; constref aValue: T): SizeInt; static;
    class function  DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T): TSearchResult; static;
    class function  DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T): TSearchResult; static;
    class function  DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T): TSearchResult; static;
    class procedure DoHeapSort(A: PItem; R: SizeInt); static;
    class function  QSplitR(A: PItem; R: SizeInt): TSortSplit; static;
    class procedure DoQSort(A: PItem; R: SizeInt); static;
    class function  MedianOf3(constref v1, v2, v3: T): T; static; inline;
    class function  QSplitMo9(A: PItem; R: SizeInt): TSortSplit; static;
    class procedure DoIntroSort(A: PItem; R, Ttl: SizeInt); static;
    class function  DPQSplit(A: PItem; R: SizeInt): TSortSplit; static;
    class procedure DoDPQSort(A: PItem; R: SizeInt); static;
  { QuickSelect with random pivot, does not checks indexes }
    class function  QSelectR(A: PItem; R, N: SizeInt): T; static;
  public
  { returns 0-based position of aValue in array A, -1 if not found }
    class function  SequentSearch(constref A: array of T; constref aValue: T): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A, -1 if not found }
    class function  BinarySearch(constref A: array of T; constref aValue: T): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A in Result.FoundIndex(-1 if not found);
    returns position for insertion in Result.InsertIndex(-1 if array is empty);
    in case of array of single element or constant array assumes ascending state }
    class function  BinarySearchPos(constref A: array of T; constref aValue: T): TSearchResult; static;
  { returns 0-based position of minimal value in A, -1 if A is empty }
    class function  IndexOfMin(constref A: array of T): SizeInt; static;
  { returns 0-based position of maximal value in A, -1 if A is empty }
    class function  IndexOfMax(constref A: array of T): SizeInt; static;
  { returns smallest element of A in TOptional.Value if A is nonempty }
    class function  GetMin(constref A: array of T): TOptional; static;
  { returns greatest element of A in TOptional.Value if A is nonempty }
    class function  GetMax(constref A: array of T): TOptional; static;
  { retursn True and smallest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMin(constref A: array of T; out aValue: T): Boolean; static;
  { returns True and  greatest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMax(constref A: array of T; out aValue: T): Boolean; static;
  { returns True, smallest element of A in aMin and greatest element of A in aMax,
    if A is nonempty, False otherwise }
    class function  FindMinMax(constref A: array of T; out aMin, aMax: T): Boolean; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  NthSmallest(var A: array of T; N: SizeInt): TOptional; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  FindNthSmallestND(constref A: array of T; N: SizeInt; out aValue: T): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  NthSmallestND(constref A: array of T; N: SizeInt): TOptional; static;
  { returns True if permutation towards nondescending state of A has done, False otherwise }
    class function  NextPermutation2Asc(var A: array of T): Boolean; static;
  { returns True if permutation towards nonascending state of A has done, False otherwise }
    class function  NextPermutation2Desc(var A: array of T): Boolean; static;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(constref A: array of T): Boolean; static;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(constref A: array of T): Boolean; static;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(constref A: array of T): Boolean; static;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(constref A: array of T): Boolean; static;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(constref A, B: array of T): Boolean; static;
  { slightly modified optimized quicksort with random pivot selection }
    class procedure QuickSort(var A: array of T; o: TSortOrder = soAsc); static;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(var A: array of T; o: TSortOrder = soAsc); static;
  { slightly modified V.Yaroslavskiy proposed dual pivot Quicksort algorithm with random pivot selection }
    class procedure DualPivotQuickSort(var A: array of T; o: TSortOrder = soAsc); static;
  { stable, adaptive mergesort inspired by Java Timsort }
    class procedure MergeSort(var A: array of T; o: TSortOrder = soAsc); static;
  { default sort algorithm, currently it is IntroSort }
    class procedure Sort(var A: array of T; o: TSortOrder = soAsc); static;
    class function  Sorted(constref A: array of T; o: TSortOrder = soAsc): TArray; static;
  { copies only distinct values from A }
    class function  SelectDistinct(constref A: array of T): TArray; static;
  end;

  { TGRegularArrayHelper: with regular comparator}
  generic TGRegularArrayHelper<T> = class(specialize TGArrayHelpUtil<T>)
  public
  type
    TCompare = specialize TGCompare<T>;

  protected
  type

    TMergeSort = object(TMergeSortBase)
    private
      FCompare: TCompare;
      procedure Init(A: PItem; c: TCompare);
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      procedure MergeLoA(From, CountLo, CountHi: SizeInt);
      procedure MergeLoD(From, CountLo, CountHi: SizeInt);
      procedure MergeHiA(From, CountLo, CountHi: SizeInt);
      procedure MergeHiD(From, CountLo, CountHi: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt; c: TCompare); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt; c: TCompare); static;
      class function  CountRunAsc(A: PItem; R: SizeInt; c: TCompare): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt; c: TCompare): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt; c: TCompare); static;
      class procedure SortDesc(A: PItem; R: SizeInt; c: TCompare); static;
    end;

    class function  CountRun2Asc(A: PItem; R: SizeInt; c: TCompare): SizeInt; static;
    class procedure InsertionSort(A: PItem; R: SizeInt; c: TCompare); static;
    class function  DoBinSearch(A: PItem; R: SizeInt; constref aValue: T; c: TCompare): SizeInt; static;
    class function  DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T; c: TCompare): TSearchResult;
                    static;
    class function  DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T; c: TCompare): TSearchResult;
                    static;
    class function  DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T; c: TCompare): TSearchResult;
                    static;
    class procedure DoHeapSort(A: PItem; R: SizeInt; c: TCompare); static;
    class function  QSplitR(A: PItem; R: SizeInt; c: TCompare): TSortSplit; static;
    class procedure DoQSort(A: PItem; R: SizeInt; c: TCompare); static;
    class function  MedianOf3(constref v1, v2, v3: T; c: TCompare): T; static; inline;
    class function  QSplitMo9(A: PItem; R: SizeInt; c: TCompare): TSortSplit; static;
    class procedure DoIntroSort(A: PItem; R, Ttl: SizeInt; c: TCompare); static;
    class function  DPQSplit(A: PItem; R: SizeInt; c: TCompare): TSortSplit; static;
    class procedure DoDPQSort(A: PItem; R: SizeInt; c: TCompare); static;
  { QuickSelect with random pivot, does not checks indexes }
    class function  QSelectR(A: PItem; R, N: SizeInt; c: TCompare): T; static;
  public
  { returns 0-based position of aValue in array A, -1 if not found }
    class function  SequentSearch(constref A: array of T; constref aValue: T; c: TCompare): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A, -1 if not found }
    class function  BinarySearch(constref A: array of T; constref aValue: T; c: TCompare): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A in Result.FoundIndex(-1 if not found);
    returns position for insertion in Result.InsertIndex(-1 if array is empty);
    in case of array of single element or constant array assumes ascending state }
    class function  BinarySearchPos(constref A: array of T; constref aValue: T; c: TCompare): TSearchResult;
                    static;
  { returns 0-based position of minimal value in A, -1 if A is empty }
    class function  IndexOfMin(constref A: array of T; c: TCompare): SizeInt; static;
  { returns 0-based position of maximal value in A, -1 if A is empty }
    class function  IndexOfMax(constref A: array of T; c: TCompare): SizeInt; static;
  { returns smallest element of A in TOptional.Value if A <> nil }
    class function  GetMin(constref A: array of T; c: TCompare): TOptional; static;
  { returns greatest element of A in TOptional.Value if A is nonempty }
    class function  GetMax(constref A: array of T; c: TCompare): TOptional; static;
  { returns True and smallest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMin(constref A: array of T; out aValue: T; c: TCompare): Boolean; static;
  { returns True and  greatest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMax(constref A: array of T; out aValue: T; c: TCompare): Boolean; static;
  { returns True, smallest element of A in aMin and greatest element of A in aMax,
    if A is nonempty, False otherwise }
    class function  FindMinMax(constref A: array of T; out aMin, aMax: T; c: TCompare): Boolean; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T; c: TCompare): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  NthSmallest(var A: array of T; N: SizeInt; c: TCompare): TOptional; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  FindNthSmallestND(constref A: array of T; N: SizeInt; out aValue: T; c: TCompare): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  NthSmallestND(constref A: array of T; N: SizeInt; c: TCompare): TOptional; static;
  { returns True if permutation towards nondescending state of A has done, False otherwise }
    class function  NextPermutation2Asc(var A: array of T; c: TCompare): Boolean; static;
  { returns True if permutation towards nonascending state of A has done, False otherwise }
    class function  NextPermutation2Desc(var A: array of T; c: TCompare): Boolean; static;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(constref A: array of T; c: TCompare): Boolean; static;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(constref A: array of T; c: TCompare): Boolean; static;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(constref A: array of T; c: TCompare): Boolean; static;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(constref A: array of T; c: TCompare): Boolean; static;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(constref A, B: array of T; c: TCompare): Boolean; static;
  { slightly modified optimized quicksort with random pivot selection }
    class procedure QuickSort(var A: array of T; c: TCompare; o: TSortOrder = soAsc); static;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(var A: array of T; c: TCompare; o: TSortOrder = soAsc); static;
  { slightly modified V.Yaroslavskiy proposed the dual pivot Quicksort algorithm with random pivot selection }
    class procedure DualPivotQuickSort(var A: array of T; c: TCompare; o: TSortOrder = soAsc); static;
  { stable, adaptive mergesort inspired by Java Timsort }
    class procedure MergeSort(var A: array of T; c: TCompare; o: TSortOrder = soAsc); static;
  { default sort algorithm, currently it is IntroSort }
    class procedure Sort(var A: array of T; c: TCompare; o: TSortOrder = soAsc); static;
    class function  Sorted(constref A: array of T; c: TCompare; o: TSortOrder = soAsc): TArray; static;
  { copies only distinct values from A }
    class function  SelectDistinct(constref A: array of T; c: TCompare): TArray;
                    static;
  end;

  { TGDelegatedArrayHelper: with delegated comparator}
  generic TGDelegatedArrayHelper<T> = class(specialize TGArrayHelpUtil<T>)
  public
  type
    TOnCompare = specialize TGOnCompare<T>;

  protected
  type

    TMergeSort = object(TMergeSortBase)
    protected
      FCompare: TOnCompare;
      procedure Init(A: PItem; c: TOnCompare);
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      procedure MergeLoA(From, CountLo, CountHi: SizeInt);
      procedure MergeLoD(From, CountLo, CountHi: SizeInt);
      procedure MergeHiA(From, CountLo, CountHi: SizeInt);
      procedure MergeHiD(From, CountLo, CountHi: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt; c: TOnCompare); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt; c: TOnCompare); static;
      class function  CountRunAsc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt; c: TOnCompare); static;
      class procedure SortDesc(A: PItem; R: SizeInt; c: TOnCompare); static;
    end;

    class function  CountRun2Asc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt; static;
    class procedure InsertionSort(A: PItem; R: SizeInt; c: TOnCompare); static;
    class function  DoBinSearch(A: PItem; R: SizeInt; constref aValue: T; c: TOnCompare): SizeInt; static;
    class function  DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T; c: TOnCompare): TSearchResult;
                    static;
    class function  DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T; c: TOnCompare): TSearchResult;
                    static;
    class function  DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T; c: TOnCompare): TSearchResult;
                    static;
    class procedure DoHeapSort(A: PItem; R: SizeInt; c: TOnCompare); static;
    class function  QSplitR(A: PItem; R: SizeInt; c: TOnCompare): TSortSplit; static;
    class procedure DoQSort(A: PItem; R: SizeInt; c: TOnCompare); static;
    class function  MedianOf3(constref v1, v2, v3: T; c: TOnCompare): T; static; inline;
    class function  QSplitMo9(A: PItem; R: SizeInt; c: TOnCompare): TSortSplit; static;
    class procedure DoIntroSort(A: PItem; R, Ttl: SizeInt; c: TOnCompare); static;
    class function  DPQSplit(A: PItem; R: SizeInt; c: TOnCompare): TSortSplit; static;
    class procedure DoDPQSort(A: PItem; R: SizeInt; c: TOnCompare); static;
  { QuickSelect with random pivot, does not checks indexes }
    class function  QSelectR(A: PItem; R, N: SizeInt; c: TOnCompare): T; static;
  public
  { returns 0-based position of aValue in array A, -1 if not found }
    class function  SequentSearch(constref A: array of T; constref aValue: T; c: TOnCompare): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A, -1 if not found }
    class function  BinarySearch(constref A: array of T; constref aValue: T; c: TOnCompare): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A in Result.FoundIndex(-1 if not found);
    returns position for insertion in Result.InsertIndex(-1 if array is empty);
    in case of array of single element or constant array assumes ascending state }
    class function  BinarySearchPos(constref A: array of T; constref aValue: T; c: TOnCompare): TSearchResult;
                    static;
  { returns 0-based position of minimal value in A, -1 if A is empty }
    class function  IndexOfMin(constref A: array of T; c: TOnCompare): SizeInt; static;
  { returns 0-based position of maximal value in A, -1 if A is empty }
    class function  IndexOfMax(constref A: array of T; c: TOnCompare): SizeInt; static;
  { returns smallest element of A in TOptional.Value if A is nonempty }
    class function  GetMin(constref A: array of T; c: TOnCompare): TOptional; static;
  { returns greatest element of A in TOptional.Value if A is nonempty }
    class function  GetMax(constref A: array of T; c: TOnCompare): TOptional; static;
  { returns True and smallest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMin(constref A: array of T; out aValue: T; c: TOnCompare): Boolean; static;
  { returns True and  greatest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMax(constref A: array of T; out aValue: T; c: TOnCompare): Boolean; static;
  { returns True, smallest element of A in aMin and greatest element of A in aMax,
    if A is nonempty, False otherwise }
    class function  FindMinMax(constref A: array of T; out aMin, aMax: T; c: TOnCompare): Boolean; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T; c: TOnCompare): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  NthSmallest(var A: array of T; N: SizeInt; c: TOnCompare): TOptional; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  FindNthSmallestND(constref A: array of T;N: SizeInt; out aValue: T; c: TOnCompare): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  NthSmallestND(constref A: array of T; N: SizeInt; c: TOnCompare): TOptional; static;
  { returns True if permutation towards nondescending state of A has done, False otherwise }
    class function  NextPermutation2Asc(var A: array of T; c: TOnCompare): Boolean; static;
  { returns True if permutation towards nonascending state of A has done, False otherwise }
    class function  NextPermutation2Desc(var A: array of T; c: TOnCompare): Boolean; static;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(constref A: array of T; c: TOnCompare): Boolean; static;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(constref A: array of T; c: TOnCompare): Boolean; static;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(constref A: array of T; c: TOnCompare): Boolean; static;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(constref A: array of T; c: TOnCompare): Boolean; static;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(constref A, B: array of T; c: TOnCompare): Boolean; static;
  { slightly modified optimized quicksort with random pivot selection }
    class procedure QuickSort(var A: array of T; c: TOnCompare; o: TSortOrder = soAsc); static;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(var A: array of T; c: TOnCompare; o: TSortOrder = soAsc); static;
  { slightly modified V.Yaroslavskiy proposed the dual pivot Quicksort algorithm with random pivot selection }
    class procedure DualPivotQuickSort(var A: array of T; c: TOnCompare; o: TSortOrder = soAsc); static;
  { stable, adaptive mergesort inspired by Java Timsort }
    class procedure MergeSort(var A: array of T; c: TOnCompare; o: TSortOrder = soAsc); static;
  { default sort algorithm, currently it is IntroSort }
    class procedure Sort(var A: array of T; c: TOnCompare; o: TSortOrder = soAsc); static;
    class function  Sorted(constref A: array of T; c: TOnCompare; o: TSortOrder = soAsc): TArray; static;
  { copies only distinct values from A }
    class function  SelectDistinct(constref A: array of T; c: TOnCompare): TArray;
                    static;
  end;

  { TGNestedArrayHelper: with nested comparator}
  generic TGNestedArrayHelper<T> = class(specialize TGArrayHelpUtil<T>)
  public
  type
    TNestCompare = specialize TGNestCompare<T>;

  protected
  type

    TMergeSort = object(TMergeSortBase)
    protected
      FCompare: TNestCompare;
      procedure Init(A: PItem; c: TNestCompare);
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      procedure MergeLoA(From, CountLo, CountHi: SizeInt);
      procedure MergeLoD(From, CountLo, CountHi: SizeInt);
      procedure MergeHiA(From, CountLo, CountHi: SizeInt);
      procedure MergeHiD(From, CountLo, CountHi: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt; c: TNestCompare); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt; c: TNestCompare); static;
      class function  CountRunAsc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt; c: TNestCompare); static;
      class procedure SortDesc(A: PItem; R: SizeInt; c: TNestCompare); static;
    end;

    class function  CountRun2Asc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt; static;
    class procedure InsertionSort(A: PItem; R: SizeInt; c: TNestCompare); static;
    class function  DoBinSearch(A: PItem; R: SizeInt; constref aValue: T; c: TNestCompare): SizeInt; static;
    class function  DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T; c: TNestCompare): TSearchResult;
                    static;
    class function  DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T; c: TNestCompare): TSearchResult;
                    static;
    class function  DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T; c: TNestCompare): TSearchResult;
                    static;
    class procedure DoHeapSort(A: PItem; R: SizeInt; c: TNestCompare); static;
    class function  QSplitR(A: PItem; R: SizeInt; c: TNestCompare): TSortSplit; static;
    class procedure DoQSort(A: PItem; R: SizeInt; c: TNestCompare); static;
    class function  MedianOf3(constref v1, v2, v3: T; c: TNestCompare): T; static; inline;
    class function  QSplitMo9(A: PItem; R: SizeInt; c: TNestCompare): TSortSplit; static;
    class procedure DoIntroSort(A: PItem; R, Ttl: SizeInt; c: TNestCompare); static;
    class function  DPQSplit(A: PItem; R: SizeInt; c: TNestCompare): TSortSplit; static;
    class procedure DoDPQSort(A: PItem; R: SizeInt; c: TNestCompare); static;
  { QuickSelect with random pivot, does not checks indexes }
    class function  QSelectR(A: PItem; R, N: SizeInt; c: TNestCompare): T; static;
  public
  { returns 0-based position of aValue in array A, -1 if not found }
    class function  SequentSearch(constref A: array of T; constref aValue: T; c: TNestCompare): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A, -1 if not found }
    class function  BinarySearch(constref A: array of T; constref aValue: T; c: TNestCompare): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A in Result.FoundIndex(-1 if not found);
    returns position for insertion in Result.InsertIndex(-1 if array is empty);
    in case of array of single element or constant array assumes ascending state }
    class function  BinarySearchPos(constref A: array of T; constref aValue: T; c: TNestCompare): TSearchResult;
                    static;
  { returns 0-based position of minimal value in A, -1 if A is empty }
    class function  IndexOfMin(constref A: array of T; c: TNestCompare): SizeInt; static;
  { returns 0-based position of maximal value in A, -1 if A is empty }
    class function  IndexOfMax(constref A: array of T; c: TNestCompare): SizeInt; static;
  { returns smallest element of A in TOptional.Value if A is nonempty }
    class function  GetMin(constref A: array of T; c: TNestCompare): TOptional; static;
  { returns greatest element of A in TOptional.Value if A is nonempty }
    class function  GetMax(constref A: array of T; c: TNestCompare): TOptional; static;
  { returns True and smallest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMin(constref A: array of T; out aValue: T; c: TNestCompare): Boolean; static;
  { returns True and  greatest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMax(constref A: array of T; out aValue: T; c: TNestCompare): Boolean; static;
  { returns True, smallest element of A in aMin and greatest element of A in aMax,
    if A is nonempty, False otherwise }
    class function  FindMinMax(constref A: array of T; out aMin, aMax: T; c: TNestCompare): Boolean; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T; c: TNestCompare): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  NthSmallest(var A: array of T; N: SizeInt; c: TNestCompare): TOptional; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  FindNthSmallestND(constref A: array of T;N: SizeInt; out aValue: T; c: TNestCompare): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  NthSmallestND(constref A: array of T; N: SizeInt; c: TNestCompare): TOptional; static;
  { returns True if permutation towards nondescending state of A has done, False otherwise }
    class function  NextPermutation2Asc(var A: array of T; c: TNestCompare): Boolean; static;
  { returns True if permutation towards nonascending state of A has done, False otherwise }
    class function  NextPermutation2Desc(var A: array of T; c: TNestCompare): Boolean; static;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(constref A: array of T; c: TNestCompare): Boolean; static;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(constref A: array of T; c: TNestCompare): Boolean; static;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(constref A: array of T; c: TNestCompare): Boolean; static;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(constref A: array of T; c: TNestCompare): Boolean; static;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(constref A, B: array of T; c: TNestCompare): Boolean; static;
  { slightly modified optimized quicksort with random pivot selection }
    class procedure QuickSort(var A: array of T; c: TNestCompare; o: TSortOrder = soAsc); static;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(var A: array of T; c: TNestCompare; o: TSortOrder = soAsc); static;
  { slightly modified V.Yaroslavskiy proposed the dual pivot Quicksort algorithm with random pivot selection }
    class procedure DualPivotQuickSort(var A: array of T; c: TNestCompare; o: TSortOrder = soAsc); static;
  { stable, adaptive mergesort inspired by Java Timsort }
    class procedure MergeSort(var A: array of T; c: TNestCompare; o: TSortOrder = soAsc); static;
  { default sort algorithm, currently it is IntroSort }
    class procedure Sort(var A: array of T; c: TNestCompare; o: TSortOrder = soAsc); static;
    class function  Sorted(constref A: array of T; c: TNestCompare; o: TSortOrder = soAsc): TArray; static;
  { copies only distinct values from A }
    class function  SelectDistinct(constref A: array of T; c: TNestCompare): TArray;
                    static;
  end;

  { TGNumArrayHelper: for numeric or ordinal types }
  generic TGNumArrayHelper<T> = class(specialize TGArrayHelpUtil<T>)
  public //todo: why TGNumArrayHelper ???
  private
    class function  CountRun2Asc(var A: array of T; L, R: SizeInt): SizeInt; static;
    class procedure InsertionSort(var A: array of T; L, R: SizeInt); static;
    class function  DoBinSearch(A: PItem; R: SizeInt; constref aValue: T): SizeInt; static;
    class function  DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T): TSearchResult; static;
    class function  DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T): TSearchResult; static;
    class function  DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T): TSearchResult; static;
    class procedure DoHeapSort(A: PItem; R: SizeInt); static;
    class function  QSplitR(var A: array of T; L, R: SizeInt): TSortSplit; static;
    class procedure DoQSort(var A: array of T; L, R: SizeInt); static;
    class function  MedianOf3(const v1, v2, v3: T): T; static; inline;
    class function  GetMo9Pivot(constref A: array of T; L, R: SizeInt): T; static;
    class function  QSplitMo9(var A: array of T; L, R: SizeInt): TSortSplit; static;
    class procedure DoIntroSort(var A: array of T; L, R, Ttl: SizeInt); static;
    class function  DPQSplit(var A: array of T; L, R: SizeInt): TSortSplit; static;
    class procedure DoDPQSort(var A: array of T; L, R: SizeInt); static;
    class procedure DoSwap(p: PItem; L, R: SizeInt); static; inline;
    class procedure DoReverse(var A: array of T; L, R: SizeInt); static;
  { QuickSelect with random pivot, does not checks indexes }
    class function  QSelectR(var A: array of T; N: SizeInt): T; static;
  public
    class procedure Reverse(var A: array of T); static;
  { returns 0-based position of aValue in array A, -1 if not found }
    class function  SequentSearch(constref A: array of T; constref aValue: T): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A, -1 if not found }
    class function  BinarySearch(constref A: array of T; constref aValue: T): SizeInt; static;
  { returns 0-based position of aValue in SORTED array A in Result.FoundIndex(-1 if not found);
    returns position for insertion in Result.InsertIndex(-1 if array is empty);
    in case of array of single element or constant array assumes ascending state }
    class function  BinarySearchPos(constref A: array of T; constref aValue: T): TSearchResult; static;
  { returns 0-based position of minimal value in A, -1 if A is empty }
    class function  IndexOfMin(constref A: array of T): SizeInt; static;
  { returns 0-based position of maximal value in A, -1 if A is empty }
    class function  IndexOfMax(constref A: array of T): SizeInt; static;
  { returns smallest element of A in TOptional.Value if A is nonempty }
    class function  GetMin(constref A: array of T): TOptional; static;
  { returns greatest element of A in TOptional.Value if A is nonempty }
    class function  GetMax(constref A: array of T): TOptional; static;
  { returns True and smallest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMin(constref A: array of T; out aValue: T): Boolean; static;
  { returns True and  greatest element of A in aValue if A is nonempty, False otherwise }
    class function  FindMax(constref A: array of T; out aValue: T): Boolean; static;
  { returns True, smallest element of A in aMin and greatest element of A in aMax,
    if A is nonempty, False otherwise }
    class function  FindMinMax(constref A: array of T; out aMin, aMax: T): Boolean; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    destuctive: changes order of elements in A }
    class function  FindNthSmallest(var  A: array of T; N: SizeInt; out aValue: T): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is destuctive: changes order of elements in A }
    class function  NthSmallest(var  A: array of T; N: SizeInt): TOptional; static;
  { returns True and A's Nth order statistic(0-based) in aValue if A is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  FindNthSmallestND(constref  A: array of T; N: SizeInt; out aValue: T): Boolean; static;
  { returns A's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(A) then N sets to High(A);
    is nondestuctive: creates temp copy of A }
    class function  NthSmallestND(constref  A: array of T; N: SizeInt): TOptional; static;
  { returns True if permutation towards nondescending state of A has done, False otherwise }
    class function  NextPermutation2Asc(var A: array of T): Boolean; static;
  { returns True if permutation towards nonascending state of A has done, False otherwise }
    class function  NextPermutation2Desc(var A: array of T): Boolean; static;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(constref A: array of T): Boolean; static;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(constref A: array of T): Boolean; static;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(constref A: array of T): Boolean; static;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(constref A: array of T): Boolean; static;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(constref A, B: array of T): Boolean; static;
  { slightly modified optimized quicksort with random pivot selection }
    class procedure QuickSort(var A: array of T; o: TSortOrder = soAsc); static;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(var A: array of T; o: TSortOrder = soAsc); static;
  { slightly modified V.Yaroslavskiy proposed the dual pivot Quicksort algorithm with random pivot selection }
    class procedure DualPivotQuickSort(var A: array of T; o: TSortOrder = soAsc); static;
  { default sort algorithm, currently it is IntroSort }
    class procedure Sort(var A: array of T; o: TSortOrder = soAsc); static;
    class function  Sorted(constref A: array of T; o: TSortOrder = soAsc): TArray; static;
  { copies only distinct values from A }
    class function  SelectDistinct(constref A: array of T): TArray; static;
  end;

  { TGOrdinalArrayHelper: for ordinal types only }
  generic TGOrdinalArrayHelper<T> = class(specialize TGNumArrayHelper<T>)
  private
  const
    ORD_TYPES  = [tkInteger, tkChar, tkEnumeration, tkBool, tkWChar];
    MAX_BITLEN = 15;
    class function  TypeInfo: PTypeInfo; static; inline;
    class function  TypeData: PTypeData; static; inline;
    class function  TypeKind: TTypeKind; static; inline;
    class function  CountSortAvailable(out aMinValue, aMaxValue: SizeInt): Boolean; static; inline;
    class procedure CountSort(var A: array of T; aMinValue, aMaxValue: SizeInt); static;
  public
    class procedure Sort(var A: array of T; aOrder: TSortOrder = soAsc); static;
    class function  Sorted(constref A: array of T; o: TSortOrder = soAsc): TArray; static;
  end;

implementation
{$B-}{$COPERATORS ON}{$POINTERMATH ON}{$GOTO ON}

{ TGArrayHelpUtil.TMergeSortBase }

procedure TGArrayHelpUtil.TMergeSortBase.PushRun(aBase, aCount: SizeInt);
var
  I: SizeInt;
begin
  I := FStackSize;
  Inc(FStackSize);
  if System.Length(FStack) = I then
    System.SetLength(FStack, I * 2);
  FStack[I].Base := aBase;
  FStack[I].Count := aCount;
end;

function TGArrayHelpUtil.TMergeSortBase.EnsureBufferCapacity(aSize: SizeInt): PItem;
begin
  if aSize > System.Length(FBuffer) then
    System.SetLength(FBuffer, LGUtils.RoundUpTwoPower(aSize));
  Result := @FBuffer[0];
end;

procedure TGArrayHelpUtil.TMergeSortBase.Init(A: PItem);
begin
  FData := A;
  FStackSize := 0;
  if System.Length(FBuffer) < MERGE_BUFFER_INIT_SIZE then
    System.SetLength(FBuffer, MERGE_BUFFER_INIT_SIZE);
  if System.Length(FStack) < MERGE_STACK_INIT_SIZE then
    System.SetLength(FStack, MERGE_STACK_INIT_SIZE);
end;

class function TGArrayHelpUtil.TMergeSortBase.MinRunLen(aTotalSize: SizeInt): SizeInt;
var
  s: SizeInt;
begin
  if aTotalSize > MIN_MERGE_LEN then
    begin
      s := LGUtils.NSB(aTotalSize) - MIN_MERGE_POW;
      Result := aTotalSize shr s;
      Result += Ord((Result shl s xor aTotalSize) <> 0);
    end
  else
    Result := aTotalSize;
end;

{ TGArrayHelpUtil }

class procedure TGArrayHelpUtil.CopyItems(aSrc, aDst: PItem; aCount: SizeInt);
begin
  if (aDst <> aSrc) and (aCount > 0) then  //else nothing to do
    if aDst > aSrc then // forward copy
      begin
        aSrc += aCount - 1;
        aDst += aCount - 1;
        while aCount >= 4 do
          begin
            aDst[ 0] := aSrc[ 0];
            aDst[-1] := aSrc[-1];
            aDst[-2] := aSrc[-2];
            aDst[-3] := aSrc[-3];
            aSrc -= 4;
            aDst -= 4;
            aCount -= 4;
          end;
        case aCount of
          1: aDst[0] := aSrc[0];
          2:
            begin
              aDst[ 0] := aSrc[ 0];
              aDst[-1] := aSrc[-1];
            end;
          3:
            begin
              aDst[ 0] := aSrc[ 0];
              aDst[-1] := aSrc[-1];
              aDst[-2] := aSrc[-2];
            end;
        end;
      end
    else              // backward copy
      begin
        while aCount >= 4 do
          begin
            aDst[0] := aSrc[0];
            aDst[1] := aSrc[1];
            aDst[2] := aSrc[2];
            aDst[3] := aSrc[3];
            aSrc += 4;
            aDst += 4;
            aCount -= 4;
          end;
        case aCount of
          1: aDst[0] := aSrc[0];
          2:
            begin
              aDst[0] := aSrc[0];
              aDst[1] := aSrc[1];
            end;
          3:
            begin
              aDst[0] := aSrc[0];
              aDst[1] := aSrc[1];
              aDst[2] := aSrc[2];
            end;
        end;
      end;
end;

class procedure TGArrayHelpUtil.DoReverse(p: PItem; R: SizeInt);
var
  v0, v1, v2, v3: TFake;
  L: SizeInt;
begin
  L := 0;
  while R - L >= 7 do
    begin
      v0 := TFake(p[L    ]);
      v1 := TFake(p[L + 1]);
      v2 := TFake(p[L + 2]);
      v3 := TFake(p[L + 3]);
      TFake(p[L    ]) := TFake(p[R    ]);
      TFake(p[L + 1]) := TFake(p[R - 1]);
      TFake(p[L + 2]) := TFake(p[R - 2]);
      TFake(p[L + 3]) := TFake(p[R - 3]);
      TFake(p[R    ]) := v0;
      TFake(p[R - 1]) := v1;
      TFake(p[R - 2]) := v2;
      TFake(p[R - 3]) := v3;
      L += 4;
      R -= 4;
    end;
  case R - L of
    1..2:
      begin
        v0 := TFake(p[L]);
        TFake(p[L]) := TFake(p[R]);
        TFake(p[R]) := v0;
      end;
    3..4:
      begin
        v0 := TFake(p[L    ]);
        v1 := TFake(p[L + 1]);
        TFake(p[L    ]) := TFake(p[R    ]);
        TFake(p[L + 1]) := TFake(p[R - 1]);
        TFake(p[R    ]) := v0;
        TFake(p[R - 1]) := v1;
      end;
    5..6:
      begin
        v0 := TFake(p[L    ]);
        v1 := TFake(p[L + 1]);
        v2 := TFake(p[L + 2]);
        TFake(p[L    ]) := TFake(p[R    ]);
        TFake(p[L + 1]) := TFake(p[R - 1]);
        TFake(p[L + 2]) := TFake(p[R - 2]);
        TFake(p[R    ]) := v0;
        TFake(p[R - 1]) := v1;
        TFake(p[R - 2]) := v2;
      end;
  end;
end;

class procedure TGArrayHelpUtil.DoSwap(p: PItem; L, R: SizeInt);
var
  v: TFake;
begin
  v := TFake(p[L]);
  TFake(p[L]) := TFake(p[R]);
  TFake(p[R]) := v;
end;

class function TGArrayHelpUtil.CreateCopy(constref A: array of T): TArray;
begin
  System.SetLength(Result, System.Length(A));
  if System.Length(Result) > 0 then
    CopyItems(@A[0], @Result[0], System.Length(Result));
end;

class function TGArrayHelpUtil.CreateReverseCopy(constref A: array of T): TArray;
var
  L, R: SizeInt;
begin
  R := System.High(A);
  System.SetLength(Result, Succ(R));
  if R >= 0 then
    begin
      L := 0;
      while R >= 3 do
        begin
          Result[R    ] := A[L    ];
          Result[R - 1] := A[L + 1];
          Result[R - 2] := A[L + 2];
          Result[R - 3] := A[L + 3];
          L += 4;
          R -= 4;
        end;
      case R of
        0: Result[R] := A[L];
        1:
          begin
            Result[R    ] := A[L    ];
            Result[R - 1] := A[L + 1];
          end;
        2:
          begin
            Result[R    ] := A[L    ];
            Result[R - 1] := A[L + 1];
            Result[R - 2] := A[L + 2];
          end;
      end;
    end;
end;

class function TGArrayHelpUtil.CreateMerge(constref L, R: array of T): TArray;
var
  LenL, LenR: SizeInt;
begin
  LenL := System.Length(L);
  LenR := System.Length(R);
  System.SetLength(Result, LenL + LenR);
  if LenL > 0 then
    CopyItems(@L[0], @Result[0], LenL);
  if LenR > 0 then
    CopyItems(@R[0], @Result[LenL], LenR);
end;

class function TGArrayHelpUtil.CreateRandomShuffle(constref A: array of T): TArray;
begin
  Result := CreateCopy(A);
  RandomShuffle(Result);
end;

class function TGArrayHelpUtil.Append(constref aValue: T; var A: TArray): SizeInt;
begin
  Result := System.Length(A);
  System.SetLength(A, Succ(Result));
  A[Result] := aValue;
end;

class function TGArrayHelpUtil.Merge(var aDst, aSrc: TArray): SizeInt;
var
  DstLen: SizeInt;
begin
  if aSrc <> aDst then
    begin
      Result := System.Length(aSrc);
      if Result > 0 then
        begin
          if aDst <> aSrc then
            begin
              DstLen := System.Length(aDst);
              System.SetLength(aDst, DstLen + Result);
              System.Move(aSrc[0], aDst[DstLen], SizeOf(T) * Result);
              System.FillChar(aSrc[0], SizeOf(T) * Result, 0);
              System.SetLength(aSrc, 0);
            end
          else
            begin
              System.SetLength(aDst, Result shl 1);
              CopyItems(@aSrc[0], @aDst[Result], Result);
            end;
        end;
    end
  else
    Result := 0;
end;

class function TGArrayHelpUtil.Split(var A: TArray; aIndex: SizeInt): TArray;
var
  ALen, RLen: SizeInt;
begin
  if A = nil then
    exit(nil);
  if aIndex < 0 then
    aIndex := 0;
  ALen := System.Length(A);
  if aIndex < ALen then
    begin
      RLen := ALen - aIndex;
      System.SetLength(Result, RLen);
      System.Move(A[aIndex], Result[0], SizeOf(T) * RLen);
      System.FillChar(A[aIndex], SizeOf(T) * RLen, 0);
      System.SetLength(A, aIndex);
    end
  else
    Result := nil;
end;

class function TGArrayHelpUtil.Extract(var A: TArray; aIndex, aCount: SizeInt): TArray;
var
  Len: SizeInt;
begin
  if (A = nil) or (aCount < 1) then
    exit(nil);
  if aIndex < 0 then
    aIndex := 0;
  Len := System.Length(A);
  if aIndex < Len then
    begin
      aCount := Math.Min(aCount, Len - aIndex);
      System.SetLength(Result, aCount);
      if aCount > 0 then
        begin
          System.Move(A[aIndex], Result[0], SizeOf(T) * aCount);
          Len -= aCount;
          System.Move(A[aIndex + aCount], A[aIndex], SizeOf(T) * (Len - aIndex));
          System.FillChar(A[Len], SizeOf(T) * aCount, 0);
          System.SetLength(A, Len);
        end;
    end
  else
    Result := nil;
end;

class procedure TGArrayHelpUtil.Reverse(var A: array of T);
begin
  if System.High(A) > 0 then
    DoReverse(@A[0], System.High(A));
end;


class procedure TGArrayHelpUtil.RandomShuffle(var A: array of T);
var
  I, J: SizeInt;
  v: TFake;
begin
  for I := System.High(A) downto 1 do
    begin
      J := Random(I);
      v := TFake(A[I]);
      TFake(A[I]) := TFake(A[J]);
      TFake(A[J]) := v;
    end;
end;

class function TGArrayHelpUtil.SequentSearch(constref A: array of T; constref aValue: T;
  c: TEqualCompare): SizeInt;
begin
  for Result := 0 to System.High(A) do
    if c(aValue, A[Result]) then
      exit;
  Result := -1;
end;

class function TGArrayHelpUtil.SequentSearch(constref A: array of T; constref aValue: T;
  c: TOnEqualCompare): SizeInt;
begin
  for Result := 0 to System.High(A) do
    if c(aValue, A[Result]) then
      exit;
  Result := -1;
end;

class function TGArrayHelpUtil.SequentSearch(constref A: array of T; constref aValue: T;
  c: TNestEqualCompare): SizeInt;
begin
  for Result := 0 to System.High(A) do
    if c(aValue, A[Result]) then
      exit;
  Result := -1;
end;

class function TGArrayHelpUtil.Same(constref A, B: array of T; c: TEqualCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  if System.High(B) <> R then
    exit(False);
  for I := 0 to R do
    if not c(A[I], B[I]) then
      exit(False);
  Result := True;
end;

class function TGArrayHelpUtil.Same(constref A, B: array of T; c: TOnEqualCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  if System.High(B) <> R then
    exit(False);
  for I := 0 to R do
    if not c(A[I], B[I]) then
      exit(False);
  Result := True;
end;

class function TGArrayHelpUtil.Same(constref A, B: array of T; c: TNestEqualCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  if System.High(B) <> R then
    exit(False);
  for I := 0 to R do
    if not c(A[I], B[I]) then
      exit(False);
  Result := True;
end;

class function TGArrayHelpUtil.Select(constref A: array of T; aTest: TTest): TArray;
var
  I, Len: SizeInt;
  v: T;
begin
  Len := ARRAY_INITIAL_SIZE;
  SetLength(Result, ARRAY_INITIAL_SIZE);
  I := 0;
  for v in A do
    if aTest(v) then
      begin
        if I = Len then
          begin
            Len += Len;
            SetLength(Result, Len);
          end;
        Result[I] := v;
        Inc(I);
      end;
  SetLength(Result, I);
end;

class function TGArrayHelpUtil.Select(constref A: array of T; aTest: TOnTest): TArray;
var
  I, Len: SizeInt;
  v: T;
begin
  Len := ARRAY_INITIAL_SIZE;
  SetLength(Result, ARRAY_INITIAL_SIZE);
  I := 0;
  for v in A do
    if aTest(v) then
      begin
        if I = Len then
          begin
            Len += Len;
            SetLength(Result, Len);
          end;
        Result[I] := v;
        Inc(I);
      end;
  SetLength(Result, I);
end;

class function TGArrayHelpUtil.Select(constref A: array of T; aTest: TNestTest): TArray;
var
  I, Len: SizeInt;
  v: T;
begin
  Len := ARRAY_INITIAL_SIZE;
  SetLength(Result, ARRAY_INITIAL_SIZE);
  I := 0;
  for v in A do
    if aTest(v) then
      begin
        if I = Len then
          begin
            Len += Len;
            SetLength(Result, Len);
          end;
        Result[I] := v;
        Inc(I);
      end;
  SetLength(Result, I);
end;

class function TGArrayHelpUtil.FoldL(constref A: array of T; aFold: TFold; constref v0: T): T;
var
  v: T;
begin
  Result := v0;
  for v in A do
    Result := aFold(v, Result);
end;

class function TGArrayHelpUtil.FoldL(constref A: array of T; aFold: TFold): TOptional;
var
  I, Last: SizeInt;
  v: T;
begin
  Last := System.High(A);
  if Last >= 0 then
    begin
      v := A[0];
      for I := 1 to Last do
        v := aFold(A[I], v);
      Result.Assign(v);
    end;
end;

class function TGArrayHelpUtil.FoldL(constref A: array of T; aFold: TOnFold; constref v0: T): T;
var
  v: T;
begin
  Result := v0;
  for v in A do
    Result := aFold(v, Result);
end;

class function TGArrayHelpUtil.FoldL(constref A: array of T; aFold: TOnFold): TOptional;
var
  I, Last: SizeInt;
  v: T;
begin
  Last := System.High(A);
  if Last >= 0 then
    begin
      v := A[0];
      for I := 1 to Last do
        v := aFold(A[I], v);
      Result.Assign(v);
    end;
end;

class function TGArrayHelpUtil.FoldL(constref A: array of T; aFold: TNestFold; constref v0: T): T;
var
  v: T;
begin
  Result := v0;
  for v in A do
    Result := aFold(v, Result);
end;

class function TGArrayHelpUtil.FoldL(constref A: array of T; aFold: TNestFold): TOptional;
var
  I, Last: SizeInt;
  v: T;
begin
  Last := System.High(A);
  if Last >= 0 then
    begin
      v := A[0];
      for I := 1 to Last do
        v := aFold(A[I], v);
      Result.Assign(v);
    end;
end;

class function TGArrayHelpUtil.FoldR(constref A: array of T; aFold: TFold; constref v0: T): T;
var
  I: SizeInt;
begin
  Result := v0;
  for I := System.High(A) downto 0 do
    Result := aFold(A[I], Result);
end;

class function TGArrayHelpUtil.FoldR(constref A: array of T; aFold: TFold): TOptional;
var
  I, Last: SizeInt;
  v: T;
begin
  Last := System.High(A);
  if Last >= 0 then
    begin
      v := A[Last];
      for I := Pred(Last) downto 0 do
        v := aFold(A[I], v);
      Result.Assign(v);
    end;
end;

class function TGArrayHelpUtil.FoldR(constref A: array of T; aFold: TOnFold; constref v0: T): T;
var
  I: SizeInt;
begin
  Result := v0;
  for I := System.High(A) downto 0 do
    Result := aFold(A[I], Result);
end;

class function TGArrayHelpUtil.FoldR(constref A: array of T; aFold: TOnFold): TOptional;
var
  I, Last: SizeInt;
  v: T;
begin
  Last := System.High(A);
  if Last >= 0 then
    begin
      v := A[Last];
      for I := Pred(Last) downto 0 do
        v := aFold(A[I], v);
      Result.Assign(v);
    end;
end;

class function TGArrayHelpUtil.FoldR(constref A: array of T; aFold: TNestFold; constref v0: T): T;
var
  I: SizeInt;
begin
  Result := v0;
  for I := System.High(A) downto 0 do
    Result := aFold(A[I], Result);
end;

class function TGArrayHelpUtil.FoldR(constref A: array of T; aFold: TNestFold): TOptional;
var
  I, Last: SizeInt;
  v: T;
begin
  Last := System.High(A);
  if Last >= 0 then
    begin
      v := A[Last];
      for I := Pred(Last) downto 0 do
        v := aFold(A[I], v);
      Result.Assign(v);
    end;
end;

{ TGBaseArrayHelper.TMergeSort }

procedure TGBaseArrayHelper.TMergeSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGBaseArrayHelper.TMergeSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGBaseArrayHelper.TMergeSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGBaseArrayHelper.TMergeSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGBaseArrayHelper.TMergeSort.MergeAtA(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoA(Base, CountLo, CountHi)
  else
    MergeHiA(Base, CountLo, CountHi);
end;

procedure TGBaseArrayHelper.TMergeSort.MergeAtD(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoD(Base, CountLo, CountHi)
  else
    MergeHiD(Base, CountLo, CountHi);
end;

procedure TGBaseArrayHelper.TMergeSort.MergeLoA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
begin
  LocA := FData;
  if TCmpRel.Compare(FData[Pred(From + CountLo)], FData[From + CountLo]) > 0 then
    begin
      LocB := EnsureBufferCapacity(CountLo);
    {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T));
    {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
    {$ENDIF}
      if TCmpRel.Compare(LocA[Pred(From + CountLo + CountHi)], LocA[From]) >= 0 then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if TCmpRel.Compare(LocB[pLo], LocA[pHi]) <= 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T)); ///
          {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
          {$ENDIF}
        end
      else
        begin
        {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));///
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));   ///
        {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
        {$ENDIF}
        end;
    end;
end;

procedure TGBaseArrayHelper.TMergeSort.MergeLoD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
begin
  LocA := FData;
  if TCmpRel.Compare(FData[Pred(From + CountLo)], FData[From + CountLo]) < 0 then
    begin
      LocB := EnsureBufferCapacity(CountLo);
    {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T)); ///
    {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
    {$ENDIF}
      if TCmpRel.Compare(LocA[Pred(From + CountLo + CountHi)], LocA[From]) <= 0 then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if TCmpRel.Compare(LocB[pLo], LocA[pHi]) >= 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T));///
          {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
          {$ENDIF}
        end
      else
        begin
        {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));///
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));   ///
        {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
        {$ENDIF}
        end;
    end;
end;

procedure TGBaseArrayHelper.TMergeSort.MergeHiA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
begin
  LocA := FData;
  if TCmpRel.Compare(FData[Pred(From + CountLo)], FData[From + CountLo]) > 0 then
    begin
      LocB := EnsureBufferCapacity(CountHi);
    {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T));///
    {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
    {$ENDIF}
      if TCmpRel.Compare(LocA[Pred(From + CountLo + CountHi)], LocA[From]) >= 0 then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if TCmpRel.Compare(LocA[pLo], LocB[pHi]) > 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T)); ///
          {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
          {$ENDIF}
        end
      else
        begin
        {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T)); ///
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));  ///
        {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
        {$ENDIF}
        end;
    end;
end;

procedure TGBaseArrayHelper.TMergeSort.MergeHiD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
begin
  LocA := FData;
  if TCmpRel.Compare(FData[Pred(From + CountLo)], FData[From + CountLo]) < 0 then
    begin
      LocB := EnsureBufferCapacity(CountHi);
    {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T)); ///
    {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
    {$ENDIF}
      if TCmpRel.Compare(LocA[Pred(From + CountLo + CountHi)], LocA[From]) <= 0 then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if TCmpRel.Compare(LocA[pLo], LocB[pHi]) < 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T)); ///
          {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
          {$ENDIF}
        end
      else
        begin
        {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T)); ///
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));              ///
        {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
        {$ENDIF}
        end;
    end;
end;

class procedure TGBaseArrayHelper.TMergeSort.InsertSortA(A: PItem; R, At: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (TCmpRel.Compare(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGBaseArrayHelper.TMergeSort.InsertSortD(A: PItem; R, At: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (TCmpRel.Compare(A[J], T(v)) < 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGBaseArrayHelper.TMergeSort.CountRunAsc(A: PItem; R: SizeInt): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if TCmpRel.Compare(A[0], A[1]) <= 0 then  // ascending
        while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                                      // descending
        begin
          while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) > 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGBaseArrayHelper.TMergeSort.CountRunDesc(A: PItem; R: SizeInt): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if TCmpRel.Compare(A[0], A[1]) >= 0 then  // descending
        while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) >= 0) do
          Inc(Result)
      else                                      // ascending
        begin
          while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) < 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGBaseArrayHelper.TMergeSort.SortAsc(A: PItem; R: SizeInt);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN then
    begin
      ms.Init(A);
      L := 0;
      MinLen := MinRunLen(R - L + 1);
       repeat
         RunLen := Succ(CountRunAsc(@A[L], R - L));
         if RunLen < MinLen then
           begin
             Len := Math.Min(Succ(R - L), MinLen);
             InsertSortA(@A[L], Pred(Len), RunLen);
             RunLen := Len;
           end;
         ms.PushRun(L, RunLen);
         L += RunLen;
         ms.CollapseA;
       until L > R;
       ms.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R)));
end;

class procedure TGBaseArrayHelper.TMergeSort.SortDesc(A: PItem; R: SizeInt);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN then
    begin
      ms.Init(A);
      L := 0;
      MinLen := MinRunLen(R - L + 1);
       repeat
         RunLen := Succ(CountRunDesc(@A[L], R - L));
         if RunLen < MinLen then
           begin
             Len := Math.Min(Succ(R - L), MinLen);
             InsertSortD(@A[L], Pred(Len), RunLen);
             RunLen := Len;
           end;
         ms.PushRun(L, RunLen);
         L += RunLen;
         ms.CollapseD;
       until L > R;
       ms.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R)));
end;


{ TGBaseArrayHelper }

class function TGBaseArrayHelper.CountRun2Asc(A: PItem; R: SizeInt): SizeInt;
begin
  Result := 0;
  while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) = 0) do
    Inc(Result);
  if Result < R then
    begin
      Inc(Result);
      if TCmpRel.Compare(A[Pred(Result)], A[Result]) < 0 then   // ascending
        while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                                                      // descending
        begin
          while (Result < R) and (TCmpRel.Compare(A[Succ(Result)], A[Result]) <= 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end;
end;

class procedure TGBaseArrayHelper.InsertionSort(A: PItem; R: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  for I := 1 to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (TCmpRel.Compare(T(v), A[J]) < 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGBaseArrayHelper.DoBinSearch(A: PItem; R: SizeInt; constref aValue: T): SizeInt;
var
  L, M, c: SizeInt;
begin
  //here R must be >= 0;
  Result := -1;
  L := 0;
  c := TCmpRel.Compare(A[R], A[0]);
  if c > 0 then  //ascending
    begin
      while L < R do
        begin
          M := L + (R - L) shr 1;
          c := TCmpRel.Compare(A[M], aValue);
          if c < 0 then
            L := Succ(M)
          else
            begin
              if c = 0 then
                exit(M);
              R := M;
            end;
        end;
      //here L >= R
      if TCmpRel.Compare(A[R], aValue) = 0 then
        Result := R;
    end
  else
    if c < 0 then  //descending
      begin
        while L < R do
          begin
            M := L + ((R - L) shr 1);
            c := TCmpRel.Compare(A[M], aValue);
            if c > 0 then
              L := Succ(M)
            else
              begin
                if c = 0 then
                  exit(M);
                R := M;
              end;
          end;
        //here L >= R
        if TCmpRel.Compare(A[R], aValue) = 0 then
          Result := R;
      end
    else           //constant
      if TCmpRel.Compare(A[L], aValue) = 0 then
        exit(L);
end;

class function TGBaseArrayHelper.DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T): TSearchResult;
var
  L, M, Cmp: SizeInt;
begin
  //here exists at least 2 ascending elements;
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      Cmp := TCmpRel.Compare(A[M], aValue);
      if Cmp < 0 then
        L := Succ(M)
      else
        begin
          if Cmp = 0 then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  Cmp := TCmpRel.Compare(aValue, A[R]);
  if Cmp < 0 then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if Cmp = 0 then
        Result.FoundIndex := R;
    end;
end;

class function TGBaseArrayHelper.DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T): TSearchResult;
var
  L, M, Cmp: SizeInt;
begin
  //here exists at least 2 descending elements
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      Cmp := TCmpRel.Compare(A[M], aValue);
      if Cmp > 0 then
        L := Succ(M)
      else
        begin
          if Cmp = 0 then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  Cmp := TCmpRel.Compare(aValue, A[R]);
  if Cmp > 0 then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if Cmp = 0 then
        Result.FoundIndex := R;
    end;
end;

class function TGBaseArrayHelper.DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T): TSearchResult;
var
  Cmp: SizeInt;
begin
  //here R must be >= 0;
  Cmp := TCmpRel.Compare(A[R], A[0]);
  if Cmp > 0 then   //ascending
    Result := DoBinSearchPosA(A, R, aValue)
  else
    if Cmp < 0 then //descending
      Result := DoBinSearchPosD(A, R, aValue)
    else            //constant
      begin
        Cmp := TCmpRel.Compare(aValue, A[R]);
        Result.FoundIndex := -1;
        if Cmp < 0 then
           Result.InsertIndex := 0
        else
          begin
            Result.InsertIndex := Succ(R);
            if Cmp = 0 then
              Result.FoundIndex := 0;
          end;
      end;
end;

class procedure TGBaseArrayHelper.DoHeapSort(A: PItem; R: SizeInt);
var
  I, Curr, Next: SizeInt;
  v: TFake;
begin
  if R > HEAP_INSERT_CUTOFF then
    begin
      for I := Pred(Succ(R) shr 1) downto 0 do
        begin
          Curr := I;
          Next := Succ(I shl 1);
          v := TFake(A[Curr]);
          while Next <= R do
            begin
              if(Succ(Next) <= R) and (TCmpRel.Compare(A[Next], A[Succ(Next)]) < 0)then
                Inc(Next);
              if TCmpRel.Compare(T(v), A[Next]) >= 0 then
                break;
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          TFake(A[Curr]) := v;
        end;
      for I := R downto 1 do
        begin
          Curr := 0;
          Next := 1;
          v := TFake(A[I]);
          TFake(A[I]) := TFake(A[0]);
          while Next < I do
            begin
              if(Succ(Next) < I) and (TCmpRel.Compare(A[Next], A[Succ(Next)]) < 0) then
                Inc(Next);
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          Next := Pred(Curr) shr 1;
          while (Curr > 0) and (TCmpRel.Compare(T(v), A[Next]) > 0) do
            begin
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Pred(Next) shr 1;
            end;
          TFake(A[Curr]) := v;
        end;
    end
  else
    InsertionSort(A, R);
end;

class function TGBaseArrayHelper.QSplitR(A: PItem; R: SizeInt): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  Pivot := A[Succ(Random(Pred(R)))];
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until TCmpRel.Compare(A[pL], Pivot) >= 0;
    repeat Dec(pR) until TCmpRel.Compare(A[pR], Pivot) <= 0;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGBaseArrayHelper.DoQSort(A: PItem; R: SizeInt);
begin
  while R > QUICK_INSERT_CUTOFF do
    with QSplitR(A, R) do
      if Left <= R - Right then
        begin
          DoQSort(A, Left);
          A := @A[Right];
          R -= Right;
        end
      else
        begin
          DoQSort(@A[Right], R - Right);
          R := Left;
        end;
  if R > 0 then
    InsertionSort(A, R);
end;

class function TGBaseArrayHelper.MedianOf3(constref v1, v2, v3: T): T;
begin
  Result := v2;
  if TCmpRel.Compare(v1, Result) < 0 then
    begin
      if TCmpRel.Compare(v3, Result) < 0 then
        begin
          if TCmpRel.Compare(v1, v3) < 0 then
            Result := v3
          else
            Result := v1;
        end;
    end
  else { v1 >= Result }
    begin
      if TCmpRel.Compare(v3, Result) > 0 then
        begin
          if TCmpRel.Compare(v1, v3) > 0 then
            Result := v3
          else
            Result := v1;
        end;
    end;
end;

class function TGBaseArrayHelper.QSplitMo9(A: PItem; R: SizeInt): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  if R > MEDIAN_OF9_CUTOFF then
    Pivot := MedianOf3(
      MedianOf3(A[0],
                A[Succ(R) shr 3],
                A[Succ(R) shr 2]),
      MedianOf3(A[Succ(R) shr 1 - Succ(R) shr 3],
                A[Succ(R) shr 1],
                A[Succ(R) shr 1 + Succ(R) shr 3]),
      MedianOf3(A[R - Succ(R) shr 2],
                A[R - Succ(R) shr 3],
                A[R]))
  else
    Pivot := MedianOf3(A[0], A[Succ(R) shr 1], A[R]);
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until  TCmpRel.Compare(A[pL], Pivot) >= 0;
    repeat Dec(pR) until  TCmpRel.Compare(A[pR], Pivot) <= 0;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGBaseArrayHelper.DoIntroSort(A: PItem; R, Ttl: SizeInt);
begin
  if R > QUICK_INSERT_CUTOFF then
    if Ttl > 0 then
      with QSplitMo9(A, R) do
        begin
          DoIntroSort(A, Left, Pred(Ttl));
          DoIntroSort(@A[Right], R - Right, Pred(Ttl));
        end
    else
      DoHeapSort(A, R)
  else
    if R > 0 then
      InsertionSort(A, R);
end;

class function TGBaseArrayHelper.DPQSplit(A: PItem; R: SizeInt): TSortSplit;
var
  v, Pivot1, Pivot2: TFake;
  pL, pR, I: SizeInt;
begin
  pL := Succ(Random(Pred(R shr 1)));
  pR := Pred(R - Random(Pred(R shr 1)));

  if TCmpRel.Compare(A[pL], A[pR]) <= 0 then
    begin
      Pivot1 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[0]);
      Pivot2 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[R]);
    end
  else
    begin
      Pivot2 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[R]);
      Pivot1 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[0]);
    end;

  pL := 1;
  I  := 1;
  pR := Pred(R);
  while I <= pR do
    begin
      v := TFake(A[I]);
      if TCmpRel.Compare(T(v), T(Pivot1)) < 0 then
        begin
          TFake(A[I]) := TFake(A[pL]);
          TFake(A[pL]) := v;
          Inc(pL);
        end
      else
        if TCmpRel.Compare(T(v), T(Pivot2)) > 0 then
          begin
            while (pR >= I) and (TCmpRel.Compare(A[pR], T(Pivot2)) > 0) do
              Dec(pR);
            if pR < I then
              break;
            if TCmpRel.Compare(A[pR], T(Pivot1)) < 0 then
              begin
                TFake(A[I]) := TFake(A[pL]);
                TFake(A[pL]) := TFake(A[pR]);
                Inc(pL);
              end
            else
              TFake(A[I]) := TFake(A[pR]);
            TFake(A[pR]) := v;
            Dec(pR);
          end;
      Inc(I);
    end;

  TFake(A[0]) := TFake(A[pL - 1]);
  TFake(A[pL - 1]) := Pivot1;
  TFake(A[R]) := TFake(A[pR + 1]);
  TFake(A[pR + 1]) := Pivot2;

  Result.Left := pL - 1;
  Result.Right := pR + 1;
end;

class procedure TGBaseArrayHelper.DoDPQSort(A: PItem; R: SizeInt);
begin
  if R > DPQ_INSERT_CUTOFF then
    with DPQSplit(A, R) do
      begin
        DoDPQSort(A, Left - 1);
        DoDPQSort(@A[Right + 1], R - Right - 1);
        if TCmpRel.Compare(A[Left], A[Right]) <> 0 then
          DoDPQSort(@A[Left + 1], Right - Left - 2);
      end
  else
    if R > 0 then
      InsertionSort(A, R);
end;

class function TGBaseArrayHelper.QSelectR(A: PItem; R, N: SizeInt): T;
var
  v: TFake;
  Pivot: T;
  L, pL, pR: SizeInt;
begin
  L := 0;
  while L < Pred(R) do
    begin
      Pivot := A[L + Random(Succ(R - L))];
      pL := Pred(L);
      pR := Succ(R);
      repeat
        repeat Inc(pL) until TCmpRel.Compare(A[pL], Pivot) >= 0;
        repeat Dec(pR) until TCmpRel.Compare(A[pR], Pivot) <= 0;
        if pL >= pR then break;
        v := TFake(A[pL]);
        TFake(A[pL]) := TFake(A[pR]);
        TFake(A[pR]) := v;
      until False;
      if pL = pR then
        begin
          if pL > L then
            Dec(pR)
          else
            if pL < R then
              Inc(pL);
        end;
      if pR < N then L := pL;
      if pL > N then R := pR;
    end;
  if (L < R) and (TCmpRel.Compare(A[L], A[R]) > 0) then
    begin
      v := TFake(A[L]);
      TFake(A[L]) := TFake(A[R]);
      TFake(A[R]) := v;
    end;
  Result := A[N];
end;

class function TGBaseArrayHelper.SequentSearch(constref A: array of T; constref aValue: T): SizeInt;
begin
  for Result := 0 to System.High(A) do
    if TCmpRel.Compare(aValue, A[Result]) = 0 then
      exit;
  Result := -1;
end;

class function TGBaseArrayHelper.BinarySearch(constref A: array of T; constref aValue: T): SizeInt;
begin
  Result := High(A);
  if Result >= 0 then
    Result := DoBinSearch(@A[0], Result, aValue);
end;

class function TGBaseArrayHelper.BinarySearchPos(constref A: array of T; constref aValue: T): TSearchResult;
var
  hi: SizeInt;
begin
  hi := High(A);
  if hi >= 0 then
    Result := DoBinSearchPos(@A[0], hi, aValue)
  else
    begin
      Result.FoundIndex := hi;
      Result.InsertIndex := hi;
    end;
end;

class function TGBaseArrayHelper.IndexOfMin(constref A: array of T): SizeInt;
var
  R, I: SizeInt;
  m: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      m := A[0];
      for I := 1 to R do
        if TCmpRel.Compare(A[I], m) < 0 then
          begin
            m := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGBaseArrayHelper.IndexOfMax(constref A: array of T): SizeInt;
var
  R, I: SizeInt;
  m: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      m := A[0];
      for I := 1 to R do
        if TCmpRel.Compare(m, A[I]) < 0 then
          begin
            m := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGBaseArrayHelper.GetMin(constref A: array of T): TOptional;
var
  v: T;
begin
  if FindMin(A, v) then
    Result.Assign(v);
end;

class function TGBaseArrayHelper.GetMax(constref A: array of T): TOptional;
var
  v: T;
begin
  if FindMax(A, v) then
    Result.Assign(v);
end;

class function TGBaseArrayHelper.FindMin(constref A: array of T; out aValue: T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if TCmpRel.Compare(A[I], aValue) < 0 then
          aValue := A[I];
    end;
end;

class function TGBaseArrayHelper.FindMax(constref A: array of T; out aValue: T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if TCmpRel.Compare(aValue, A[I]) < 0 then
          aValue := A[I];
    end;
end;

class function TGBaseArrayHelper.FindMinMax(constref A: array of T; out aMin, aMax: T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aMin := A[0];
      aMax := A[0];
      for I := 1 to R do
        if TCmpRel.Compare(aMax, A[I]) < 0 then
          aMax := A[I]
        else
          if TCmpRel.Compare(A[I], aMin) < 0 then
            aMin := A[I];
    end;
end;

class function TGBaseArrayHelper.FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T): Boolean;
var
  R: SizeInt;
begin
  R := System.High(A);
  if R < 0 then
    exit(False);
  if N <= 0 then
    exit(FindMin(A, aValue));
  if N >= R then
    exit(FindMax(A, aValue));
  aValue := QSelectR(@A[0], R, N);
  Result := True;
end;

class function TGBaseArrayHelper.NthSmallest(var A: array of T; N: SizeInt): TOptional;
var
  v: T;
begin
  if FindNthSmallest(A, N, v) then
    Result.Assign(v);
end;

class function TGBaseArrayHelper.FindNthSmallestND(constref A: array of T; N: SizeInt; out aValue: T): Boolean;
begin
  Result := FindNthSmallest(CreateCopy(A), N, aValue);
end;

class function TGBaseArrayHelper.NthSmallestND(constref A: array of T; N: SizeInt): TOptional;
var
  v: T;
begin
  if FindNthSmallestND(A, N, v) then
    Result.Assign(v);
end;

class function TGBaseArrayHelper.NextPermutation2Asc(var A: array of T): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if TCmpRel.Compare(A[I], A[Succ(I)]) > 0 then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if TCmpRel.Compare(A[J], A[I]) > 0 then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGBaseArrayHelper.NextPermutation2Desc(var A: array of T): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if TCmpRel.Compare(A[I], A[Succ(I)]) < 0 then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if TCmpRel.Compare(A[J], A[I]) < 0 then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGBaseArrayHelper.IsNonDescending(constref A: array of T): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if TCmpRel.Compare(A[Succ(I)], A[I]) < 0 then
      exit(False);
  Result := True;
end;

class function TGBaseArrayHelper.IsStrictAscending(constref A: array of T): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 0 to Pred(R) do
        if TCmpRel.Compare(A[Succ(I)], A[I]) <= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseArrayHelper.IsNonAscending(constref A: array of T): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if TCmpRel.Compare(A[I], A[Succ(I)]) < 0 then
      exit(False);
  Result := True;
end;

class function TGBaseArrayHelper.IsStrictDescending(constref A: array of T): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 0 to Pred(R) do
        if TCmpRel.Compare(A[I], A[Succ(I)]) <= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseArrayHelper.Same(constref A, B: array of T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  if System.High(B) <> R then
    exit(False);
  for I := 0 to R do
    if TCmpRel.Compare(A[I], B[I]) <> 0 then
      exit(False);
  Result := True;
end;

class procedure TGBaseArrayHelper.QuickSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R) < R then
        DoQSort(@A[0], R);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGBaseArrayHelper.IntroSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R) < R then
        DoIntroSort(@A[0], R, Pred(LGUtils.NSB(R + 1)) * INTRO_LOG_FACTOR);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGBaseArrayHelper.DualPivotQuickSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R) < R then
        DoDPQSort(@A[0], R);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGBaseArrayHelper.MergeSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if o = soAsc then
      TMergeSort.SortAsc(@A[0], R)
    else
      TMergeSort.SortDesc(@A[0], R);
end;

class procedure TGBaseArrayHelper.Sort(var A: array of T; o: TSortOrder);
begin
  IntroSort(A, o);
end;

class function TGBaseArrayHelper.Sorted(constref A: array of T; o: TSortOrder): TArray;
begin
  Result := CreateCopy(A);
  Sort(Result, o);
end;

class function TGBaseArrayHelper.SelectDistinct(constref A: array of T): TArray;
var
  I, J, Hi: SizeInt;
begin
  Result := Sorted(A);
  Hi := System.High(Result);
  if Hi < 1 then
    exit;
  I := 0;
  for J := 1 to Hi do
    begin
      if TCmpRel.Compare(Result[I], Result[J]) = 0 then
        continue;
      Inc(I);
      if J > I then
        Result[I] := Result[J];
    end;
  System.SetLength(Result, Succ(I));
end;

{ TGComparableArrayHelper.TMergeSort }

procedure TGComparableArrayHelper.TMergeSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGComparableArrayHelper.TMergeSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGComparableArrayHelper.TMergeSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGComparableArrayHelper.TMergeSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGComparableArrayHelper.TMergeSort.MergeAtA(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoA(Base, CountLo, CountHi)
  else
    MergeHiA(Base, CountLo, CountHi);
end;

procedure TGComparableArrayHelper.TMergeSort.MergeAtD(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoD(Base, CountLo, CountHi)
  else
    MergeHiD(Base, CountLo, CountHi);
end;

procedure TGComparableArrayHelper.TMergeSort.MergeLoA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
begin
  LocA := FData;
  if FData[Pred(From + CountLo)] > FData[From + CountLo] then
    begin
      LocB := EnsureBufferCapacity(CountLo);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
      {$ENDIF}
      if LocA[Pred(From + CountLo + CountHi)] >= LocA[From] then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if LocB[pLo] <= LocA[pHi] then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T)); ///
            {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));///
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));   ///
          {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
          {$ENDIF}
        end;
    end;
end;

procedure TGComparableArrayHelper.TMergeSort.MergeLoD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;    // local pointer to data array
  LocB: PItem;    // local pointer to buffer
begin
  LocA := FData;
  if FData[Pred(From + CountLo)] < FData[From + CountLo] then
    begin
      LocB := EnsureBufferCapacity(CountLo);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T)); ///
      {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
      {$ENDIF}
      if LocA[Pred(From + CountLo + CountHi)] <= LocA[From] then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if LocB[pLo] >= LocA[pHi] then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T));///
            {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));///
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));   ///
          {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
          {$ENDIF}
        end;
    end;
end;

procedure TGComparableArrayHelper.TMergeSort.MergeHiA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
begin
  LocA := FData;
  if FData[Pred(From + CountLo)] > FData[From + CountLo] then
    begin
      LocB := EnsureBufferCapacity(CountHi);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T));///
      {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
      {$ENDIF}
      if LocA[Pred(From + CountLo + CountHi)] >= LocA[From] then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if LocA[pLo] > LocB[pHi] then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T)); ///
            {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T)); ///
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));  ///
          {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
          {$ENDIF}
        end;
    end;
end;

procedure TGComparableArrayHelper.TMergeSort.MergeHiD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
begin
  LocA := FData;
  if FData[Pred(From + CountLo)] < FData[From + CountLo] then
    begin
      LocB := EnsureBufferCapacity(CountHi);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T)); ///
      {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
      {$ENDIF}
      if LocA[Pred(From + CountLo + CountHi)] <= LocA[From] then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if LocA[pLo] < LocB[pHi] then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T)); ///
            {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T)); ///
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));              ///
          {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
          {$ENDIF}
        end;
    end;
end;

class procedure TGComparableArrayHelper.TMergeSort.InsertSortA(A: PItem; R, At: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (A[J] > T(v)) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGComparableArrayHelper.TMergeSort.InsertSortD(A: PItem; R, At: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (A[J] < T(v)) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGComparableArrayHelper.TMergeSort.CountRunAsc(A: PItem; R: SizeInt): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if A[0] <= A[1] then  // ascending
        while (Result < R) and (A[Result] <= A[Succ(Result)]) do
          Inc(Result)
      else                 // descending
        begin
          while (Result < R) and (A[Result] > A[Succ(Result)]) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGComparableArrayHelper.TMergeSort.CountRunDesc(A: PItem; R: SizeInt): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if A[0] >= A[1] then  // descending
        while (Result < R) and (A[Result] >= A[Succ(Result)]) do
          Inc(Result)
      else                  // ascending
        begin
          while (Result < R) and (A[Result] < A[Succ(Result)]) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGComparableArrayHelper.TMergeSort.SortAsc(A: PItem; R: SizeInt);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN then
    begin
      ms.Init(A);
      L := 0;
      MinLen := MinRunLen(R - L + 1);
       repeat
         RunLen := Succ(CountRunAsc(@A[L], R - L));
         if RunLen < MinLen then
           begin
             Len := Math.Min(Succ(R - L), MinLen);
             InsertSortA(@A[L], Pred(Len), RunLen);
             RunLen := Len;
           end;
         ms.PushRun(L, RunLen);
         L += RunLen;
         ms.CollapseA;
       until L > R;
       ms.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R)));
end;

class procedure TGComparableArrayHelper.TMergeSort.SortDesc(A: PItem; R: SizeInt);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN then
    begin
      ms.Init(A);
      L := 0;
      MinLen := MinRunLen(R - L + 1);
       repeat
         RunLen := Succ(CountRunDesc(@A[L], R - L));
         if RunLen < MinLen then
           begin
             Len := Math.Min(Succ(R - L), MinLen);
             InsertSortD(@A[L], Pred(Len), RunLen);
             RunLen := Len;
           end;
         ms.PushRun(L, RunLen);
         L += RunLen;
         ms.CollapseD;
       until L > R;
       ms.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R)));
end;


{ TGComparableArrayHelper }

class function TGComparableArrayHelper.CountRun2Asc(A: PItem; R: SizeInt): SizeInt;
begin
  Result := 0;
  while (Result < R) and (A[Result] = A[Succ(Result)]) do
    Inc(Result);
  if Result < R then
    begin
      Inc(Result);
      if A[Pred(Result)] < A[Result] then   // ascending
        while (Result < R) and (A[Result] <= A[Succ(Result)]) do
          Inc(Result)
      else                                  // descending
        begin
          while (Result < R) and (A[Succ(Result)] <= A[Result]) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end;
end;

class procedure TGComparableArrayHelper.InsertionSort(A: PItem; R: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  for I := 1 to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (T(v) < A[J]) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGComparableArrayHelper.DoBinSearch(A: PItem; R: SizeInt; constref aValue: T): SizeInt;
var
  L, M: SizeInt;
begin
  //here R must be >= 0;
  Result := -1;
  L := 0;
  if A[R] > A[L] then  //ascending
    begin
      while L < R do
        begin
          M := L + (R - L) shr 1;
          if A[M] < aValue then
            L := Succ(M)
          else
            begin
              if A[M] = aValue then
                exit(M);
              R := M;
            end;
        end;
      //here L >= R
      if A[R] = aValue then
        Result := R;
    end
  else
    if A[R] < A[L] then  //descending
      begin
        while L < R do
          begin
            M := L + ((R - L) shr 1);
            if A[M] > aValue then
              L := Succ(M)
            else
              begin
                if A[M] = aValue then
                  exit(M);
                R := M;
              end;
          end;
        //here L >= R
        if A[R] = aValue then
          Result := R;
      end
    else              //constant
      if A[L] = aValue then
        Result := L;
end;

class function TGComparableArrayHelper.DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T): TSearchResult;
var
  L, M: SizeInt;
begin
  //here exists at least 2 ascending elements;
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      if A[M] < aValue then
        L := Succ(M)
      else
        begin
          if A[M] = aValue then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  if aValue < A[R] then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if aValue = A[R] then
        Result.FoundIndex := R;
    end;
end;

class function TGComparableArrayHelper.DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T): TSearchResult;
var
  L, M: SizeInt;
begin
  //here exists at least 2 descending elements
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      if A[M] > aValue then
        L := Succ(M)
      else
        begin
          if A[M] = aValue then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  if aValue > A[R] then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if aValue = A[R] then
        Result.FoundIndex := R;
    end;
end;

class function TGComparableArrayHelper.DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T): TSearchResult;
begin
  //here R must be >= 0;
  if A[0] < A[R] then   //ascending
    Result := DoBinSearchPosA(A, R, aValue)
  else
    if A[0] > A[R] then //descending
      Result := DoBinSearchPosD(A, R, aValue)
    else                //constant
      begin
        Result.FoundIndex := -1;
        if A[R] > aValue then
           Result.InsertIndex := 0
        else
          begin
            Result.InsertIndex := Succ(R);
            if A[R] = aValue then
              Result.FoundIndex := 0;
          end;
      end;
end;

class procedure TGComparableArrayHelper.DoHeapSort(A: PItem; R: SizeInt);
var
  I, Curr, Next: SizeInt;
  v: TFake;
begin
  if R > HEAP_INSERT_CUTOFF then
    begin
      for I := Pred(Succ(R) shr 1) downto 0 do
        begin
          Curr := I;
          Next := Succ(I shl 1);
          v := TFake(A[Curr]);
          while Next <= R do
            begin
              if(Succ(Next) <= R) and (A[Next] < A[Succ(Next)])then
                Inc(Next);
              if A[Next] <= T(v) then
                break;
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          TFake(A[Curr]) := v;
        end;
      for I := R downto 1 do
        begin
          Curr := 0;
          Next := 1;
          v := TFake(A[I]);
          TFake(A[I]) := TFake(A[0]);
          while Next < I do
            begin
              if(Succ(Next) < I) and (A[Next] < A[Succ(Next)]) then
                Inc(Next);
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          Next := Pred(Curr) shr 1;
          while (Curr > 0) and (T(v) > A[Next]) do
            begin
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Pred(Next) shr 1;
            end;
          TFake(A[Curr]) := v;
        end;
    end
  else
    InsertionSort(A, R);
end;

class function TGComparableArrayHelper.QSplitR(A: PItem; R: SizeInt): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  Pivot := A[Succ(Random(Pred(R)))]; //shouldn't be first or last
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until A[pL] >= Pivot;
    repeat Dec(pR) until A[pR] <= Pivot;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGComparableArrayHelper.DoQSort(A: PItem; R: SizeInt);
begin
  while R > QUICK_INSERT_CUTOFF do
    with QSplitR(A, R) do
      if Left <= R - Right then
        begin
          DoQSort(A, Left);
          A := @A[Right];
          R -= Right;
        end
      else
        begin
          DoQSort(@A[Right], R - Right);
          R := Left;
        end;
  if R > 0 then
    InsertionSort(A, R);
end;

class function TGComparableArrayHelper.MedianOf3(constref v1, v2, v3: T): T;
begin
  Result := v2;
  if v1 < Result then
    begin
      if v3 < Result then
        begin
          if v1 < v3 then
            Result := v3
          else
            Result := v1;
        end;
    end
  else { v1 >= Result }
    begin
      if v3 > Result then
        begin
          if v1 > v3 then
            Result := v3
          else
            Result := v1;
        end;
    end;
end;

class function TGComparableArrayHelper.QSplitMo9(A: PItem; R: SizeInt): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  if R > MEDIAN_OF9_CUTOFF then
    Pivot := MedianOf3(
      MedianOf3(A[0],
                A[Succ(R) shr 3],
                A[Succ(R) shr 2]),
      MedianOf3(A[Succ(R) shr 1 - Succ(R) shr 3],
                A[Succ(R) shr 1],
                A[Succ(R) shr 1 + Succ(R) shr 3]),
      MedianOf3(A[R - Succ(R) shr 2],
                A[R - Succ(R) shr 3],
                A[R]))
  else
    Pivot := MedianOf3(A[0], A[Succ(R) shr 1], A[R]);
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until A[pL] >= Pivot;
    repeat Dec(pR) until A[pR] <= Pivot;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGComparableArrayHelper.DoIntroSort(A: PItem; R, Ttl: SizeInt);
begin
  if R > QUICK_INSERT_CUTOFF then
    if Ttl > 0 then
      with QSplitMo9(A, R) do
        begin
          DoIntroSort(A, Left, Pred(Ttl));
          DoIntroSort(@A[Right], R - Right, Pred(Ttl));
        end
    else
      DoHeapSort(A, R)
  else
    if R > 0 then
      InsertionSort(A, R);
end;

class function TGComparableArrayHelper.DPQSplit(A: PItem; R: SizeInt): TSortSplit;
var
  v, Pivot1, Pivot2: TFake;
  pL, pR, I: SizeInt;
begin
  pL := Succ(Random(Pred(R shr 1)));
  pR := Pred(R - Random(Pred(R shr 1)));

  if A[pL] <= A[pR] then
    begin
      Pivot1 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[0]);
      Pivot2 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[R]);
    end
  else
    begin
      Pivot2 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[R]);
      Pivot1 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[0]);
    end;

  pL := 1;
  I  := 1;
  pR := Pred(R);
  while I <= pR do
    begin
      v := TFake(A[I]);
      if T(v) < T(Pivot1) then
        begin
          TFake(A[I]) := TFake(A[pL]);
          TFake(A[pL]) := v;
          Inc(pL);
        end
      else
        if T(Pivot2) < T(v) then
          begin
            while (pR >= I) and (T(Pivot2) < A[pR]) do
              Dec(pR);
            if pR < I then
              break;
            if A[pR] < T(Pivot1) then
              begin
                TFake(A[I]) := TFake(A[pL]);
                TFake(A[pL]) := TFake(A[pR]);
                Inc(pL);
              end
            else
              TFake(A[I]) := TFake(A[pR]);
            TFake(A[pR]) := v;
            Dec(pR);
          end;
      Inc(I);
    end;

  TFake(A[0]) := TFake(A[pL - 1]);
  TFake(A[pL - 1]) := Pivot1;
  TFake(A[R]) := TFake(A[pR + 1]);
  TFake(A[pR + 1]) := Pivot2;

  Result.Left := pL - 1;
  Result.Right := pR + 1;
end;

class procedure TGComparableArrayHelper.DoDPQSort(A: PItem; R: SizeInt);
begin
  if R > DPQ_INSERT_CUTOFF then
    with DPQSplit(A, R) do
      begin
        DoDPQSort(A, Left - 1);
        DoDPQSort(@A[Right + 1], R - Right - 1);
        if A[Left] <> A[Right] then
          DoDPQSort(@A[Left + 1], Right - Left - 2);
      end
  else
    if R > 0 then
      InsertionSort(A, R);
end;

class function TGComparableArrayHelper.QSelectR(A: PItem; R, N: SizeInt): T;
var
  v: TFake;
  Pivot: T;
  L, pL, pR: SizeInt;
begin
  L := 0;
  while L < Pred(R) do
    begin
      Pivot := A[L + Random(Succ(R - L))];
      pL := Pred(L);
      pR := Succ(R);
      repeat
        repeat Inc(pL) until A[pL] >= Pivot;
        repeat Dec(pR) until A[pR] <= Pivot;
        if pL >= pR then break;
        v := TFake(A[pL]);
        TFake(A[pL]) := TFake(A[pR]);
        TFake(A[pR]) := v;
      until False;
      if pL = pR then
        begin
          if pL > L then
            Dec(pR)
          else
            if pL < R then
              Inc(pL);
        end;
      if pR < N then L := pL;
      if pL > N then R := pR;
    end;
  if (L < R) and (A[L] > A[R]) then
    begin
      v := TFake(A[L]);
      TFake(A[L]) := TFake(A[R]);
      TFake(A[R]) := v;
    end;
  Result := A[N];
end;

class function TGComparableArrayHelper.SequentSearch(constref A: array of T; constref aValue: T): SizeInt;
begin
  for Result := 0 to System.High(A) do
    if aValue = A[Result] then
      exit;
  Result := -1;
end;

class function TGComparableArrayHelper.BinarySearch(constref A: array of T; constref aValue: T): SizeInt;
begin
  Result := System.High(A);
  if Result >= 0 then
    Result := DoBinSearch(@A[0], Result, aValue);
end;

class function TGComparableArrayHelper.BinarySearchPos(constref A: array of T; constref aValue: T): TSearchResult;
var
  hi: SizeInt;
begin
  hi := High(A);
  if hi >= 0 then
    Result := DoBinSearchPos(@A[0], hi, aValue)
  else
    begin
      Result.FoundIndex := hi;
      Result.InsertIndex := hi;
    end;
end;

class function TGComparableArrayHelper.IndexOfMin(constref A: array of T): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if v > A[I] then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGComparableArrayHelper.IndexOfMax(constref A: array of T): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if v < A[I] then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGComparableArrayHelper.GetMin(constref A: array of T): TOptional;
var
  v: T;
begin
  if FindMin(A, v) then
    Result.Assign(v);
end;

class function TGComparableArrayHelper.GetMax(constref A: array of T): TOptional;
var
  v: T;
begin
  if FindMax(A, v) then
    Result.Assign(v);
end;

class function TGComparableArrayHelper.FindMin(constref A: array of T; out aValue: T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if aValue > A[I] then
          aValue := A[I];
    end;
end;

class function TGComparableArrayHelper.FindMax(constref A: array of T; out aValue: T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if aValue < A[I] then
          aValue := A[I];
    end;
end;

class function TGComparableArrayHelper.FindMinMax(constref A: array of T; out aMin, aMax: T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aMin := A[0];
      aMax := A[0];
      for I := 1 to R do
        if A[I] > aMax then
          aMax := A[I]
        else
          if A[I] < aMin then
            aMin := A[I];
    end;
end;

class function TGComparableArrayHelper.FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T): Boolean;
var
  R: SizeInt;
begin
  R := System.High(A);
  if R < 0 then
    exit(False);
  if N <= 0 then
    exit(FindMin(A, aValue));
  if N >= R then
    exit(FindMax(A, aValue));
  aValue := QSelectR(@A[0], R, N);
  Result := True;
end;

class function TGComparableArrayHelper.NthSmallest(var A: array of T; N: SizeInt): TOptional;
var
  v: T;
begin
  if FindNthSmallest(A, N, v) then
    Result.Assign(v);
end;

class function TGComparableArrayHelper.FindNthSmallestND(constref A: array of T; N: SizeInt;
  out aValue: T): Boolean;
begin
  Result := FindNthSmallest(CreateCopy(A), N, aValue);
end;

class function TGComparableArrayHelper.NthSmallestND(constref A: array of T; N: SizeInt): TOptional;
var
  v: T;
begin
  if FindNthSmallestND(A, N, v) then
    Result.Assign(v);
end;

class function TGComparableArrayHelper.NextPermutation2Asc(var A: array of T): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if A[I] > A[Succ(I)] then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if A[J] > A[I] then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGComparableArrayHelper.NextPermutation2Desc(var A: array of T): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if A[I] < A[Succ(I)] then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if A[J] < A[I] then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGComparableArrayHelper.IsNonDescending(constref A: array of T): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if A[I] > A[Succ(I)] then
      exit(False);
  Result := True;
end;

class function TGComparableArrayHelper.IsStrictAscending(constref A: array of T): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if A[Pred(I)] >= A[I] then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGComparableArrayHelper.IsNonAscending(constref A: array of T): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if A[I] < A[Succ(I)] then
      exit(False);
  Result := True;
end;

class function TGComparableArrayHelper.IsStrictDescending(constref A: array of T): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if A[Pred(I)] <= A[I] then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGComparableArrayHelper.Same(constref A, B: array of T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  if System.High(B) <> R then
    exit(False);
  for I := 0 to R do
    if A[I] <> B[I] then
      exit(False);
  Result := True;
end;

class procedure TGComparableArrayHelper.QuickSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R) < R then
        DoQSort(@A[0], R);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGComparableArrayHelper.IntroSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R) < R then
        DoIntroSort(@A[0], R, Pred(LGUtils.NSB(R + 1)) * INTRO_LOG_FACTOR);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGComparableArrayHelper.DualPivotQuickSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R) < R then
        DoDPQSort(@A[0], R);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGComparableArrayHelper.MergeSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if o = soAsc then
      TMergeSort.SortAsc(@A[0], R)
    else
      TMergeSort.SortDesc(@A[0], R);
end;

class procedure TGComparableArrayHelper.Sort(var A: array of T; o: TSortOrder);
begin
  IntroSort(A, o);
end;

class function TGComparableArrayHelper.Sorted(constref A: array of T; o: TSortOrder): TArray;
begin
  Result := CreateCopy(A);
  Sort(Result, o);
end;

class function TGComparableArrayHelper.SelectDistinct(constref A: array of T): TArray;
var
  I, J, Hi: SizeInt;
begin
  Result := Sorted(A);
  Hi := System.High(Result);
  if Hi < 1 then
    exit;
  I := 0;
  for J := 1 to Hi do
    begin
      if Result[I] = Result[J] then
        continue;
      Inc(I);
      if J > I then
        Result[I] := Result[J];
    end;
  System.SetLength(Result, Succ(I));
end;

{ TGRegularArrayHelper.TMergeSort }

procedure TGRegularArrayHelper.TMergeSort.Init(A: PItem; c: TCompare);
begin
  inherited Init(A);
  FCompare := c;
end;

procedure TGRegularArrayHelper.TMergeSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGRegularArrayHelper.TMergeSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGRegularArrayHelper.TMergeSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGRegularArrayHelper.TMergeSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGRegularArrayHelper.TMergeSort.MergeAtA(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoA(Base, CountLo, CountHi)
  else
    MergeHiA(Base, CountLo, CountHi);
end;

procedure TGRegularArrayHelper.TMergeSort.MergeAtD(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoD(Base, CountLo, CountHi)
  else
    MergeHiD(Base, CountLo, CountHi);
end;

procedure TGRegularArrayHelper.TMergeSort.MergeLoA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) > 0 then
    begin
      LocB := EnsureBufferCapacity(CountLo);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) >= 0 then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if c(LocB[pLo], LocA[pHi]) <= 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T));
            {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
          {$ENDIF}
        end;
    end;
end;

procedure TGRegularArrayHelper.TMergeSort.MergeLoD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) < 0 then
    begin
      LocB := EnsureBufferCapacity(CountLo);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) <= 0 then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if c(LocB[pLo], LocA[pHi]) >= 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T));
            {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
          {$ENDIF}
        end;
    end;
end;

procedure TGRegularArrayHelper.TMergeSort.MergeHiA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) > 0 then
    begin
      LocB := EnsureBufferCapacity(CountHi);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) >= 0 then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if c(LocA[pLo], LocB[pHi]) > 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T));
            {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T));
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
          {$ENDIF}
        end;
    end;
end;

procedure TGRegularArrayHelper.TMergeSort.MergeHiD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) < 0 then
    begin
      LocB := EnsureBufferCapacity(CountHi);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) <= 0 then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if c(LocA[pLo], LocB[pHi]) < 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T));
            {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T));
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
          {$ENDIF}
        end;
    end;
end;

class procedure TGRegularArrayHelper.TMergeSort.InsertSortA(A: PItem; R, At: SizeInt; c: TCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGRegularArrayHelper.TMergeSort.InsertSortD(A: PItem; R, At: SizeInt; c: TCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) < 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGRegularArrayHelper.TMergeSort.CountRunAsc(A: PItem; R: SizeInt; c: TCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) <= 0 then  // ascending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                        // descending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) > 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGRegularArrayHelper.TMergeSort.CountRunDesc(A: PItem; R: SizeInt; c: TCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) >= 0 then  // descending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) >= 0) do
          Inc(Result)
      else                        // ascending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) < 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGRegularArrayHelper.TMergeSort.SortAsc(A: PItem; R: SizeInt; c: TCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ms.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunAsc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortA(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ms.PushRun(L, RunLen);
        L += RunLen;
        ms.CollapseA;
      until L > R;
      ms.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R, c)), c);
end;

class procedure TGRegularArrayHelper.TMergeSort.SortDesc(A: PItem; R: SizeInt; c: TCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ms.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunDesc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortD(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ms.PushRun(L, RunLen);
        L += RunLen;
        ms.CollapseD;
      until L > R;
      ms.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R, c)), c);
end;

{ TGRegularArrayHelper }

class function TGRegularArrayHelper.CountRun2Asc(A: PItem; R: SizeInt; c: TCompare): SizeInt;
begin
  Result := 0;
  while (Result < R) and (c(A[Result], A[Succ(Result)]) = 0) do
    Inc(Result);
  if Result < R then
    begin
      Inc(Result);
      if c(A[Pred(Result)], A[Result]) < 0 then   // ascending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                                        // descending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) >= 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end;
end;

class procedure TGRegularArrayHelper.InsertionSort(A: PItem; R: SizeInt; c: TCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  for I := 1 to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGRegularArrayHelper.DoBinSearch(A: PItem; R: SizeInt; constref aValue: T; c: TCompare): SizeInt;
var
  L, M, Cmp: SizeInt;
begin
  //here R must be >= 0;
  Result := -1;
  L := 0;
  Cmp := c(A[R], A[0]);
  if Cmp > 0 then  //ascending
    begin
      while L < R do
        begin
          M := L + (R - L) shr 1;
          Cmp := c(A[M], aValue);
          if Cmp < 0 then
            L := Succ(M)
          else
            begin
              if Cmp = 0 then
                exit(M);
              R := M;
            end;
        end;
      //here L >= R
      if c(A[R], aValue) = 0 then
        Result := R;
    end
  else
    if Cmp < 0 then  //descending
      begin
        while L < R do
          begin
            M := L + ((R - L) shr 1);
            Cmp := c(A[M], aValue);
            if Cmp > 0 then
              L := Succ(M)
            else
              begin
                if Cmp = 0 then
                  exit(M);
                R := M;
              end;
          end;
        //here L >= R
        if c(A[R], aValue) = 0 then
          Result := R;
      end
    else              //constant
      if c(A[L], aValue) = 0 then
        exit(L);
end;

class function TGRegularArrayHelper.DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T;
  c: TCompare): TSearchResult;
var
  L, M, Cmp: SizeInt;
begin
  //here exists at least 2 ascending elements;
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      Cmp := c(A[M], aValue);
      if Cmp < 0 then
        L := Succ(M)
      else
        begin
          if Cmp = 0 then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  Cmp := c(aValue, A[R]);
  if Cmp < 0 then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if Cmp = 0 then
        Result.FoundIndex := R;
    end;
end;

class function TGRegularArrayHelper.DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T;
  c: TCompare): TSearchResult;
var
  L, M, Cmp: SizeInt;
begin
  //here exists at least 2 descending elements
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      Cmp := c(A[M], aValue);
      if Cmp > 0 then
        L := Succ(M)
      else
        begin
          if Cmp = 0 then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  Cmp := c(aValue, A[R]);
  if Cmp > 0 then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if Cmp = 0 then
        Result.FoundIndex := R;
    end;
end;

class function TGRegularArrayHelper.DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T;
  c: TCompare): TSearchResult;
var
  Cmp: SizeInt;
begin
  //here R must be >= 0;
  Cmp := c(A[R], A[0]);
  if Cmp > 0 then   //ascending
    Result := DoBinSearchPosA(A, R, aValue, c)
  else
    if Cmp < 0 then //descending
      Result := DoBinSearchPosD(A, R, aValue, c)
    else            //constant
      begin
        Cmp := c(aValue, A[R]);
        Result.FoundIndex := -1;
        if Cmp < 0 then
           Result.InsertIndex := 0
        else
          begin
            Result.InsertIndex := Succ(R);
            if Cmp = 0 then
              Result.FoundIndex := 0;
          end;
      end;
end;

class procedure TGRegularArrayHelper.DoHeapSort(A: PItem; R: SizeInt; c: TCompare);
var
  I, Curr, Next: SizeInt;
  v: TFake;
begin
  if R > HEAP_INSERT_CUTOFF then
    begin
      for I := Pred(Succ(R) shr 1) downto 0 do
        begin
          Curr := I;
          Next := Succ(I shl 1);
          v := TFake(A[Curr]);
          while Next <= R do
            begin
              if(Succ(Next) <= R) and (c(A[Next], A[Succ(Next)]) < 0)then
                Inc(Next);
              if c(T(v), A[Next]) >= 0 then
                break;
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          TFake(A[Curr]) := v;
        end;
      for I := R downto 1 do
        begin
          Curr := 0;
          Next := 1;
          v := TFake(A[I]);
          TFake(A[I]) := TFake(A[0]);
          while Next < I do
            begin
              if(Succ(Next) < I) and (c(A[Next], A[Succ(Next)]) < 0) then
                Inc(Next);
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          Next := Pred(Curr) shr 1;
          while (Curr > 0) and (c(T(v), A[Next]) > 0) do
            begin
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Pred(Next) shr 1;
            end;
          TFake(A[Curr]) := v;
        end;
    end
  else
    InsertionSort(A, R, c);
end;

class function TGRegularArrayHelper.QSplitR(A: PItem; R: SizeInt; c: TCompare): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  Pivot := A[Succ(Random(Pred(R)))]; //shouldn't be first or last
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until c(A[pL], Pivot) >= 0;
    repeat Dec(pR) until c(A[pR], Pivot) <= 0;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGRegularArrayHelper.DoQSort(A: PItem; R: SizeInt; c: TCompare);
begin
  while R > QUICK_INSERT_CUTOFF do
    with QSplitR(A, R, c) do
      if Left <= R - Right then
        begin
          DoQSort(A, Left, c);
          A := @A[Right];
          R -= Right;
        end
      else
        begin
          DoQSort(@A[Right], R - Right, c);
          R := Left;
        end;
  if R > 0 then
    InsertionSort(A, R, c);
end;

class function TGRegularArrayHelper.MedianOf3(constref v1, v2, v3: T; c: TCompare): T;
begin
  Result := v2;
  if c(v1, Result) < 0 then
    begin
      if c(v3, Result) < 0 then
        begin
          if c(v1, v3) < 0 then
            Result := v3
          else
            Result := v1;
        end;
    end
  else { v1 >= Result }
    begin
      if c(v3, Result) > 0 then
        begin
          if c(v1, v3) > 0 then
            Result := v3
          else
            Result := v1;
        end;
    end;
end;

class function TGRegularArrayHelper.QSplitMo9(A: PItem; R: SizeInt; c: TCompare): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  if R > MEDIAN_OF9_CUTOFF then
    Pivot := MedianOf3(
      MedianOf3(A[0],
                A[Succ(R) shr 3],
                A[Succ(R) shr 2], c),
      MedianOf3(A[Succ(R) shr 1 - Succ(R) shr 3],
                A[Succ(R) shr 1],
                A[Succ(R) shr 1 + Succ(R) shr 3], c),
      MedianOf3(A[R - Succ(R) shr 2],
                A[R - Succ(R) shr 3],
                A[R], c), c)
  else
    Pivot := MedianOf3(A[0], A[Succ(R) shr 1], A[R], c);
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until c(A[pL], Pivot) >= 0;
    repeat Dec(pR) until c(A[pR], Pivot) <= 0;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGRegularArrayHelper.DoIntroSort(A: PItem; R, Ttl: SizeInt; c: TCompare);
begin
  if R > QUICK_INSERT_CUTOFF then
    if Ttl > 0 then
      with QSplitMo9(A, R, c) do
        begin
          DoIntroSort(A, Left, Pred(Ttl), c);
          DoIntroSort(@A[Right], R - Right, Pred(Ttl), c);
        end
    else
      DoHeapSort(A, R, c)
  else
    if R > 0 then
      InsertionSort(A, R, c);
end;

class function TGRegularArrayHelper.DPQSplit(A: PItem; R: SizeInt; c: TCompare): TSortSplit;
var
  v, Pivot1, Pivot2: TFake;
  pL, pR, I: SizeInt;
begin
  pL := Succ(Random(Pred(R shr 1)));
  pR := Pred(R - Random(Pred(R shr 1)));

  if c(A[pL], A[pR]) <= 0 then
    begin
      Pivot1 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[0]);
      Pivot2 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[R]);
    end
  else
    begin
      Pivot2 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[R]);
      Pivot1 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[0]);
    end;

  pL := 1;
  I  := 1;
  pR := Pred(R);
  while I <= pR do
    begin
      v := TFake(A[I]);
      if c(T(v), T(Pivot1)) < 0 then
        begin
          TFake(A[I]) := TFake(A[pL]);
          TFake(A[pL]) := v;
          Inc(pL);
        end
      else
        if c(T(v), T(Pivot2)) > 0 then
          begin
            while (pR >= I) and (c(A[pR], T(Pivot2)) > 0) do
              Dec(pR);
            if pR < I then
              break;
            if c(A[pR], T(Pivot1)) < 0 then
              begin
                TFake(A[I]) := TFake(A[pL]);
                TFake(A[pL]) := TFake(A[pR]);
                Inc(pL);
              end
            else
              TFake(A[I]) := TFake(A[pR]);
            TFake(A[pR]) := v;
            Dec(pR);
          end;
      Inc(I);
    end;
  TFake(A[0]) := TFake(A[pL - 1]);
  TFake(A[pL - 1]) := Pivot1;
  TFake(A[R]) := TFake(A[pR + 1]);
  TFake(A[pR + 1]) := Pivot2;

  Result.Left := pL - 1;
  Result.Right := pR + 1;
end;

class procedure TGRegularArrayHelper.DoDPQSort(A: PItem; R: SizeInt; c: TCompare);
begin
  if R > DPQ_INSERT_CUTOFF then
    with DPQSplit(A, R, c) do
      begin
        DoDPQSort(A, Left - 1, c);
        DoDPQSort(@A[Right + 1], R - Right - 1, c);
        if c(A[Left], A[Right]) <> 0 then
          DoDPQSort(@A[Left + 1], Right - Left - 2, c);
      end
  else
    if R > 0 then
      InsertionSort(A, R, c);
end;

class function TGRegularArrayHelper.QSelectR(A: PItem; R, N: SizeInt; c: TCompare): T;
var
  v: TFake;
  Pivot: T;
  L, pL, pR: SizeInt;
begin
  L := 0;
  while L < Pred(R) do
    begin
      Pivot := A[L + Random(Succ(R - L))];
      pL := Pred(L);
      pR := Succ(R);
      repeat
        repeat Inc(pL) until c(A[pL], Pivot) >= 0;
        repeat Dec(pR) until c(A[pR], Pivot) <= 0;
        if pL >= pR then break;
        v := TFake(A[pL]);
        TFake(A[pL]) := TFake(A[pR]);
        TFake(A[pR]) := v;
      until False;
      if pL = pR then
        begin
          if pL > L then
            Dec(pR)
          else
            if pL < R then
              Inc(pL);
        end;
      if pR < N then L := pL;
      if pL > N then R := pR;
    end;
  if (L < R) and (c(A[L], A[R]) > 0) then
    begin
      v := TFake(A[L]);
      TFake(A[L]) := TFake(A[R]);
      TFake(A[R]) := v;
    end;
  Result := A[N];
end;

class function TGRegularArrayHelper.SequentSearch(constref A: array of T; constref aValue: T;
  c: TCompare): SizeInt;
begin
  for Result := 0 to System.High(A) do
    if c(aValue, A[Result]) = 0 then
      exit;
  Result := -1;
end;

class function TGRegularArrayHelper.BinarySearch(constref A: array of T; constref aValue: T;
  c: TCompare): SizeInt;
begin
  Result := High(A);
  if Result >= 0 then
    Result := DoBinSearch(@A[0], Result, aValue, c);
end;

class function TGRegularArrayHelper.BinarySearchPos(constref A: array of T; constref aValue: T;
  c: TCompare): TSearchResult;
var
  hi: SizeInt;
begin
  hi := High(A);
  if hi >= 0 then
    Result := DoBinSearchPos(@A[0], hi, aValue, c)
  else
    begin
      Result.FoundIndex := hi;
      Result.InsertIndex := hi;
    end;
end;

class function TGRegularArrayHelper.IndexOfMin(constref A: array of T; c: TCompare): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if c(A[I], v) < 0 then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGRegularArrayHelper.IndexOfMax(constref A: array of T; c: TCompare): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if c(v, A[I]) < 0 then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGRegularArrayHelper.GetMin(constref A: array of T; c: TCompare): TOptional;
var
  v: T;
begin
  if FindMin(A, v, c) then
    Result.Assign(v);
end;

class function TGRegularArrayHelper.GetMax(constref A: array of T; c: TCompare): TOptional;
var
  v: T;
begin
  if FindMax(A, v, c) then
    Result.Assign(v);
end;

class function TGRegularArrayHelper.FindMin(constref A: array of T; out aValue: T; c: TCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if c(A[I], aValue) < 0 then
          aValue := A[I];
    end;
end;

class function TGRegularArrayHelper.FindMax(constref A: array of T; out aValue: T; c: TCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if c(aValue, A[I]) < 0 then
          aValue := A[I];
    end;
end;

class function TGRegularArrayHelper.FindMinMax(constref A: array of T; out aMin, aMax: T; c: TCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aMin := A[0];
      aMax := A[0];
      for I := 1 to R do
        if c(aMax, A[I]) < 0 then
          aMax := A[I]
        else
          if c(A[I], aMin) < 0 then
            aMin := A[I];
    end;
end;

class function TGRegularArrayHelper.FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T;
  c: TCompare): Boolean;
var
  R: SizeInt;
begin
  R := System.High(A);
  if R < 0 then
    exit(False);
  if N <= 0 then
    exit(FindMin(A, aValue, c));
  if N >= R then
    exit(FindMax(A, aValue, c));
  aValue := QSelectR(@A[0], R, N, c);
  Result := True;
end;

class function TGRegularArrayHelper.NthSmallest(var A: array of T; N: SizeInt; c: TCompare): TOptional;
var
  v: T;
begin
  if FindNthSmallest(A, N, v, c) then
    Result.Assign(v);
end;

class function TGRegularArrayHelper.FindNthSmallestND(constref A: array of T; N: SizeInt; out aValue: T;
  c: TCompare): Boolean;
begin
  Result := FindNthSmallest(CreateCopy(A), N, aValue, c);
end;

class function TGRegularArrayHelper.NthSmallestND(constref A: array of T; N: SizeInt; c: TCompare): TOptional;
var
  v: T;
begin
  if FindNthSmallestND(A, N, v, c) then
    Result.Assign(v);
end;

class function TGRegularArrayHelper.NextPermutation2Asc(var A: array of T; c: TCompare): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if c(A[I], A[Succ(I)]) > 0 then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if c(A[J], A[I]) > 0 then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGRegularArrayHelper.NextPermutation2Desc(var A: array of T; c: TCompare): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if c(A[I], A[Succ(I)]) < 0 then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if c(A[J], A[I]) < 0 then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGRegularArrayHelper.IsNonDescending(constref A: array of T; c: TCompare): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if c(A[I], A[Succ(I)]) > 0 then
      exit(False);
  Result := True;
end;

class function TGRegularArrayHelper.IsStrictAscending(constref A: array of T; c: TCompare): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if c(A[Pred(I)], A[I]) >= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGRegularArrayHelper.IsNonAscending(constref A: array of T; c: TCompare): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if c(A[I], A[Succ(I)]) < 0 then
      exit(False);
  Result := True;
end;

class function TGRegularArrayHelper.IsStrictDescending(constref A: array of T; c: TCompare): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if c(A[Pred(I)], A[I]) <= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGRegularArrayHelper.Same(constref A, B: array of T; c: TCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  if System.High(B) <> R then
    exit(False);
  for I := 0 to R do
    if c(A[I], B[I]) <> 0 then
      exit(False);
  Result := True;
end;

class procedure TGRegularArrayHelper.QuickSort(var A: array of T; c: TCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R, c) < R then
        DoQSort(@A[0], R, c);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGRegularArrayHelper.IntroSort(var A: array of T; c: TCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R, c) < R then
        DoIntroSort(@A[0], R, Pred(LGUtils.NSB(R + 1)) * INTRO_LOG_FACTOR, c);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGRegularArrayHelper.DualPivotQuickSort(var A: array of T; c: TCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R, c) < R then
        DoDPQSort(@A[0], R, c);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGRegularArrayHelper.MergeSort(var A: array of T; c: TCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if o = soAsc then
      TMergeSort.SortAsc(@A[0], R, c)
    else
      TMergeSort.SortDesc(@A[0], R, c);
end;

class procedure TGRegularArrayHelper.Sort(var A: array of T; c: TCompare; o: TSortOrder);
begin
  IntroSort(A, c, o);
end;

class function TGRegularArrayHelper.Sorted(constref A: array of T; c: TCompare; o: TSortOrder): TArray;
begin
  Result := CreateCopy(A);
  Sort(Result, c, o);
end;

class function TGRegularArrayHelper.SelectDistinct(constref A: array of T; c: TCompare): TArray;
var
  I, J, Hi: SizeInt;
begin
  Result := Sorted(A, c);
  Hi := System.High(Result);
  if Hi < 1 then
    exit;
  I := 0;
  for J := 1 to Hi do
    begin
      if c(Result[I], Result[J]) = 0 then
        continue;
      Inc(I);
      if J > I then
        Result[I] := Result[J];
    end;
  System.SetLength(Result, Succ(I));
end;

{ TGDelegatedArrayHelper.TMergeSort }

procedure TGDelegatedArrayHelper.TMergeSort.Init(A: PItem; c: TOnCompare);
begin
  inherited Init(A);
  FCompare := c;
end;

procedure TGDelegatedArrayHelper.TMergeSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGDelegatedArrayHelper.TMergeSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGDelegatedArrayHelper.TMergeSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGDelegatedArrayHelper.TMergeSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGDelegatedArrayHelper.TMergeSort.MergeAtA(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoA(Base, CountLo, CountHi)
  else
    MergeHiA(Base, CountLo, CountHi);
end;

procedure TGDelegatedArrayHelper.TMergeSort.MergeAtD(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoD(Base, CountLo, CountHi)
  else
    MergeHiD(Base, CountLo, CountHi);
end;

procedure TGDelegatedArrayHelper.TMergeSort.MergeLoA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TOnCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) > 0 then
    begin
      LocB := EnsureBufferCapacity(CountLo);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) >= 0 then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if c(LocB[pLo], LocA[pHi]) <= 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T));
            {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
          {$ENDIF}
        end;
    end;
end;

procedure TGDelegatedArrayHelper.TMergeSort.MergeLoD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TOnCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) < 0 then
    begin
      LocB := EnsureBufferCapacity(CountLo);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) <= 0 then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if c(LocB[pLo], LocA[pHi]) >= 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T));
            {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
          {$ENDIF}
        end;
    end;
end;

procedure TGDelegatedArrayHelper.TMergeSort.MergeHiA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TOnCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) > 0 then
    begin
      LocB := EnsureBufferCapacity(CountHi);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) >= 0 then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if c(LocA[pLo], LocB[pHi]) > 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T));
            {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T));
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
          {$ENDIF}
        end;
    end;
end;

procedure TGDelegatedArrayHelper.TMergeSort.MergeHiD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TOnCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) < 0 then
    begin
      LocB := EnsureBufferCapacity(CountHi);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) <= 0 then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if c(LocA[pLo], LocB[pHi]) < 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T));
            {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T));
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
          {$ENDIF}
        end;
    end;
end;

class procedure TGDelegatedArrayHelper.TMergeSort.InsertSortA(A: PItem; R, At: SizeInt; c: TOnCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGDelegatedArrayHelper.TMergeSort.InsertSortD(A: PItem; R, At: SizeInt; c: TOnCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) < 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGDelegatedArrayHelper.TMergeSort.CountRunAsc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) <= 0 then  // ascending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                        // descending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) > 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGDelegatedArrayHelper.TMergeSort.CountRunDesc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) >= 0 then  // descending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) >= 0) do
          Inc(Result)
      else                        // ascending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) < 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGDelegatedArrayHelper.TMergeSort.SortAsc(A: PItem; R: SizeInt; c: TOnCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ms.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunAsc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortA(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ms.PushRun(L, RunLen);
        L += RunLen;
        ms.CollapseA;
      until L > R;
      ms.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R, c)), c);
end;

class procedure TGDelegatedArrayHelper.TMergeSort.SortDesc(A: PItem; R: SizeInt; c: TOnCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ms.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunDesc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortD(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ms.PushRun(L, RunLen);
        L += RunLen;
        ms.CollapseD;
      until L > R;
      ms.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R, c)), c);
end;

{ TGDelegatedArrayHelper }

class function TGDelegatedArrayHelper.CountRun2Asc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt;
begin
  Result := 0;
  while (Result < R) and (c(A[Result], A[Succ(Result)]) = 0) do
    Inc(Result);
  if Result < R then
    begin
      Inc(Result);
      if c(A[Pred(Result)], A[Result]) < 0 then   // ascending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                                        // descending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) >= 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end;
end;

class procedure TGDelegatedArrayHelper.InsertionSort(A: PItem; R: SizeInt; c: TOnCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  for I := 1 to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGDelegatedArrayHelper.DoBinSearch(A: PItem; R: SizeInt; constref aValue: T;
  c: TOnCompare): SizeInt;
var
  L, M, Cmp: SizeInt;
begin
  //here R must be >= 0;
  Result := -1;
  L := 0;
  Cmp := c(A[R], A[0]);
  if Cmp > 0 then  //ascending
    begin
      while L < R do
        begin
          M := L + (R - L) shr 1;
          Cmp := c(A[M], aValue);
          if Cmp < 0 then
            L := Succ(M)
          else
            begin
              if Cmp = 0 then
                exit(M);
              R := M;
            end;
        end;
      //here L >= R
      if c(A[R], aValue) = 0 then
        Result := R;
    end
  else
    if Cmp < 0 then  //descending
      begin
        while L < R do
          begin
            M := L + ((R - L) shr 1);
            Cmp := c(A[M], aValue);
            if Cmp > 0 then
              L := Succ(M)
            else
              begin
                if Cmp = 0 then
                  exit(M);
                R := M;
              end;
          end;
        //here L >= R
        if c(A[R], aValue) = 0 then
          Result := R;
      end
    else              //constant
      if c(A[L], aValue) = 0 then
        exit(L);
end;

class function TGDelegatedArrayHelper.DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T;
  c: TOnCompare): TSearchResult;
var
  L, M, Cmp: SizeInt;
begin
  //here exists at least 2 ascending elements;
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      Cmp := c(A[M], aValue);
      if Cmp < 0 then
        L := Succ(M)
      else
        begin
          if Cmp = 0 then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  Cmp := c(aValue, A[R]);
  if Cmp < 0 then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if Cmp = 0 then
        Result.FoundIndex := R;
    end;
end;

class function TGDelegatedArrayHelper.DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T;
  c: TOnCompare): TSearchResult;
var
  L, M, Cmp: SizeInt;
begin
  //here exists at least 2 descending elements
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      Cmp := c(A[M], aValue);
      if Cmp > 0 then
        L := Succ(M)
      else
        begin
          if Cmp = 0 then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  Cmp := c(aValue, A[R]);
  if Cmp > 0 then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if Cmp = 0 then
        Result.FoundIndex := R;
    end;
end;

class function TGDelegatedArrayHelper.DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T;
  c: TOnCompare): TSearchResult;
var
  Cmp: SizeInt;
begin
  //here R must be >= 0;
  Cmp := c(A[R], A[0]);
  if Cmp > 0 then   //ascending
    Result := DoBinSearchPosA(A, R, aValue, c)
  else
    if Cmp < 0 then //descending
      Result := DoBinSearchPosD(A, R, aValue, c)
    else            //constant
      begin
        Cmp := c(aValue, A[R]);
        Result.FoundIndex := -1;
        if Cmp < 0 then
           Result.InsertIndex := 0
        else
          begin
            Result.InsertIndex := Succ(R);
            if Cmp = 0 then
              Result.FoundIndex := 0;
          end;
      end;
end;

class procedure TGDelegatedArrayHelper.DoHeapSort(A: PItem; R: SizeInt; c: TOnCompare);
var
  I, Curr, Next: SizeInt;
  v: TFake;
begin
  if R > HEAP_INSERT_CUTOFF then
    begin
      for I := Pred(Succ(R) shr 1) downto 0 do
        begin
          Curr := I;
          Next := Succ(I shl 1);
          v := TFake(A[Curr]);
          while Next <= R do
            begin
              if(Succ(Next) <= R) and (c(A[Next], A[Succ(Next)]) < 0)then
                Inc(Next);
              if c(T(v), A[Next]) >= 0 then
                break;
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          TFake(A[Curr]) := v;
        end;
      for I := R downto 1 do
        begin
          Curr := 0;
          Next := 1;
          v := TFake(A[I]);
          TFake(A[I]) := TFake(A[0]);
          while Next < I do
            begin
              if(Succ(Next) < I) and (c(A[Next], A[Succ(Next)]) < 0) then
                Inc(Next);
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          Next := Pred(Curr) shr 1;
          while (Curr > 0) and (c(T(v), A[Next]) > 0) do
            begin
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Pred(Next) shr 1;
            end;
          TFake(A[Curr]) := v;
        end;
    end
  else
    InsertionSort(A, R, c);
end;

class function TGDelegatedArrayHelper.QSplitR(A: PItem; R: SizeInt; c: TOnCompare): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  Pivot := A[Succ(Random(Pred(R)))]; //shouldn't be first or last
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until c(A[pL], Pivot) >= 0;
    repeat Dec(pR) until c(A[pR], Pivot) <= 0;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGDelegatedArrayHelper.DoQSort(A: PItem; R: SizeInt; c: TOnCompare);
begin
  while R > QUICK_INSERT_CUTOFF do
    with QSplitR(A, R, c) do
      if Left <= R - Right then
        begin
          DoQSort(A, Left, c);
          A := @A[Right];
          R -= Right;
        end
      else
        begin
          DoQSort(@A[Right], R - Right, c);
          R := Left;
        end;
  if R > 0 then
    InsertionSort(A, R, c);
end;

class function TGDelegatedArrayHelper.MedianOf3(constref v1, v2, v3: T; c: TOnCompare): T;
begin
  Result := v2;
  if c(v1, Result) < 0 then
    begin
      if c(v3, Result) < 0 then
        begin
          if c(v1, v3) < 0 then
            Result := v3
          else
            Result := v1;
        end;
    end
  else { v1 >= Result }
    begin
      if c(v3, Result) > 0 then
        begin
          if c(v1, v3) > 0 then
            Result := v3
          else
            Result := v1;
        end;
    end;
end;

class function TGDelegatedArrayHelper.QSplitMo9(A: PItem; R: SizeInt; c: TOnCompare): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  if R > MEDIAN_OF9_CUTOFF then
    Pivot := MedianOf3(
      MedianOf3(A[0],
                A[Succ(R) shr 3],
                A[Succ(R) shr 2], c),
      MedianOf3(A[Succ(R) shr 1 - Succ(R) shr 3],
                A[Succ(R) shr 1],
                A[Succ(R) shr 1 + Succ(R) shr 3], c),
      MedianOf3(A[R - Succ(R) shr 2],
                A[R - Succ(R) shr 3],
                A[R], c), c)
  else
    Pivot := MedianOf3(A[0], A[Succ(R) shr 1], A[R], c);
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until c(A[pL], Pivot) >= 0;
    repeat Dec(pR) until c(A[pR], Pivot) <= 0;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGDelegatedArrayHelper.DoIntroSort(A: PItem; R, Ttl: SizeInt; c: TOnCompare);
begin
  if R > QUICK_INSERT_CUTOFF then
    if Ttl > 0 then
      with QSplitMo9(A, R, c) do
        begin
          DoIntroSort(A, Left, Pred(Ttl), c);
          DoIntroSort(@A[Right], R - Right, Pred(Ttl), c);
        end
    else
      DoHeapSort(A, R, c)
  else
    if R > 0 then
      InsertionSort(A, R, c);
end;

class function TGDelegatedArrayHelper.DPQSplit(A: PItem; R: SizeInt; c: TOnCompare): TSortSplit;
var
  v, Pivot1, Pivot2: TFake;
  pL, pR, I: SizeInt;
begin
  pL := Succ(Random(Pred(R shr 1)));
  pR := Pred(R - Random(Pred(R shr 1)));

  if c(A[pL], A[pR]) <= 0 then
    begin
      Pivot1 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[0]);
      Pivot2 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[R]);
    end
  else
    begin
      Pivot2 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[R]);
      Pivot1 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[0]);
    end;

  pL := 1;
  I  := 1;
  pR := Pred(R);
  while I <= pR do
    begin
      v := TFake(A[I]);
      if c(T(v), T(Pivot1)) < 0 then
        begin
          TFake(A[I]) := TFake(A[pL]);
          TFake(A[pL]) := v;
          Inc(pL);
        end
      else
        if c(T(v), T(Pivot2)) > 0 then
          begin
            while (pR >= I) and (c(A[pR], T(Pivot2)) > 0) do
              Dec(pR);
            if pR < I then
              break;
            if c(A[pR], T(Pivot1)) < 0 then
              begin
                TFake(A[I]) := TFake(A[pL]);
                TFake(A[pL]) := TFake(A[pR]);
                Inc(pL);
              end
            else
              TFake(A[I]) := TFake(A[pR]);
            TFake(A[pR]) := v;
            Dec(pR);
          end;
      Inc(I);
    end;
  TFake(A[0]) := TFake(A[pL - 1]);
  TFake(A[pL - 1]) := Pivot1;
  TFake(A[R]) := TFake(A[pR + 1]);
  TFake(A[pR + 1]) := Pivot2;

  Result.Left := pL - 1;
  Result.Right := pR + 1;
end;

class procedure TGDelegatedArrayHelper.DoDPQSort(A: PItem; R: SizeInt; c: TOnCompare);
begin
  if R > DPQ_INSERT_CUTOFF then
    with DPQSplit(A, R, c) do
      begin
        DoDPQSort(A, Left - 1, c);
        DoDPQSort(@A[Right + 1], R - Right - 1, c);
        if c(A[Left], A[Right]) <> 0 then
          DoDPQSort(@A[Left + 1], Right - Left - 2, c);
      end
  else
    if R > 0 then
      InsertionSort(A, R, c);
end;

class function TGDelegatedArrayHelper.QSelectR(A: PItem; R, N: SizeInt; c: TOnCompare): T;
var
  v: TFake;
  Pivot: T;
  L, pL, pR: SizeInt;
begin
  L := 0;
  while L < Pred(R) do
    begin
      Pivot := A[L + Random(Succ(R - L))];
      pL := Pred(L);
      pR := Succ(R);
      repeat
        repeat Inc(pL) until c(A[pL], Pivot) >= 0;
        repeat Dec(pR) until c(A[pR], Pivot) <= 0;
        if pL >= pR then break;
        v := TFake(A[pL]);
        TFake(A[pL]) := TFake(A[pR]);
        TFake(A[pR]) := v;
      until False;
      if pL = pR then
        begin
          if pL > L then
            Dec(pR)
          else
            if pL < R then
              Inc(pL);
        end;
      if pR < N then L := pL;
      if pL > N then R := pR;
    end;
  if (L < R) and (c(A[L], A[R]) > 0) then
    begin
      v := TFake(A[L]);
      TFake(A[L]) := TFake(A[R]);
      TFake(A[R]) := v;
    end;
  Result := A[N];
end;

class function TGDelegatedArrayHelper.SequentSearch(constref A: array of T; constref aValue: T;
  c: TOnCompare): SizeInt;
begin
  for Result := 0 to System.High(A) do
    if c(aValue, A[Result]) = 0 then
      exit;
  Result := -1;
end;

class function TGDelegatedArrayHelper.BinarySearch(constref A: array of T; constref aValue: T;
  c: TOnCompare): SizeInt;
begin
  Result := High(A);
  if Result >= 0 then
    Result := DoBinSearch(@A[0], Result, aValue, c);
end;

class function TGDelegatedArrayHelper.BinarySearchPos(constref A: array of T; constref aValue: T;
  c: TOnCompare): TSearchResult;
var
  hi: SizeInt;
begin
  hi := High(A);
  if hi >= 0 then
    Result := DoBinSearchPos(@A[0], hi, aValue, c)
  else
    begin
      Result.FoundIndex := hi;
      Result.InsertIndex := hi;
    end;
end;

class function TGDelegatedArrayHelper.IndexOfMin(constref A: array of T; c: TOnCompare): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if c(A[I], v) < 0 then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGDelegatedArrayHelper.IndexOfMax(constref A: array of T; c: TOnCompare): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if c(v, A[I]) < 0 then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGDelegatedArrayHelper.GetMin(constref A: array of T; c: TOnCompare): TOptional;
var
  v: T;
begin
  if FindMin(A, v, c) then
    Result.Assign(v);
end;

class function TGDelegatedArrayHelper.GetMax(constref A: array of T; c: TOnCompare): TOptional;
var
  v: T;
begin
  if FindMax(A, v, c) then
    Result.Assign(v);
end;

class function TGDelegatedArrayHelper.FindMin(constref A: array of T; out aValue: T; c: TOnCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if c(A[I], aValue) < 0 then
          aValue := A[I];
    end;
end;

class function TGDelegatedArrayHelper.FindMax(constref A: array of T; out aValue: T; c: TOnCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if c(aValue, A[I]) < 0 then
          aValue := A[I];
    end;
end;

class function TGDelegatedArrayHelper.FindMinMax(constref A: array of T; out aMin, aMax: T;
  c: TOnCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aMin := A[0];
      aMax := A[0];
      for I := 1 to R do
        if c(aMax, A[I]) < 0 then
          aMax := A[I]
        else
          if c(A[I], aMin) < 0 then
            aMin := A[I];
    end;
end;

class function TGDelegatedArrayHelper.FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T;
  c: TOnCompare): Boolean;
var
  R: SizeInt;
begin
  R := System.High(A);
  if R < 0 then
    exit(False);
  if N <= 0 then
    exit(FindMin(A, aValue, c));
  if N >= R then
    exit(FindMax(A, aValue, c));
  aValue := QSelectR(@A[0], R, N, c);
  Result := True;
end;

class function TGDelegatedArrayHelper.NthSmallest(var A: array of T; N: SizeInt; c: TOnCompare): TOptional;
var
  v: T;
begin
  if FindNthSmallest(A, N, v, c) then
    Result.Assign(v);
end;

class function TGDelegatedArrayHelper.FindNthSmallestND(constref A: array of T;
  N: SizeInt; out aValue: T; c: TOnCompare): Boolean;
begin
  Result := FindNthSmallest(CreateCopy(A), N, aValue, c);
end;

class function TGDelegatedArrayHelper.NthSmallestND(constref A: array of T;N: SizeInt; c: TOnCompare): TOptional;
var
  v: T;
begin
  if FindNthSmallestND(A, N, v, c) then
    Result.Assign(v);
end;

class function TGDelegatedArrayHelper.NextPermutation2Asc(var A: array of T; c: TOnCompare): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if c(A[I], A[Succ(I)]) > 0 then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if c(A[J], A[I]) > 0 then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGDelegatedArrayHelper.NextPermutation2Desc(var A: array of T; c: TOnCompare): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if c(A[I], A[Succ(I)]) < 0 then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if c(A[J], A[I]) < 0 then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGDelegatedArrayHelper.IsNonDescending(constref A: array of T; c: TOnCompare): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if c(A[I], A[Succ(I)]) > 0 then
      exit(False);
  Result := True;
end;

class function TGDelegatedArrayHelper.IsStrictAscending(constref A: array of T; c: TOnCompare): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if c(A[Pred(I)], A[I]) >= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGDelegatedArrayHelper.IsNonAscending(constref A: array of T; c: TOnCompare): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if c(A[I], A[Succ(I)]) < 0 then
      exit(False);
  Result := True;
end;

class function TGDelegatedArrayHelper.IsStrictDescending(constref A: array of T; c: TOnCompare): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if c(A[Pred(I)], A[I]) <= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGDelegatedArrayHelper.Same(constref A, B: array of T; c: TOnCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  if System.High(B) <> R then
    exit(False);
  for I := 0 to R do
    if c(A[I], B[I]) <> 0 then
      exit(False);
  Result := True;
end;

class procedure TGDelegatedArrayHelper.QuickSort(var A: array of T; c: TOnCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R, c) < R then
        DoQSort(@A[0], R, c);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGDelegatedArrayHelper.IntroSort(var A: array of T; c: TOnCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R, c) < R then
        DoIntroSort(@A[0], R, Pred(LGUtils.NSB(R + 1)) * INTRO_LOG_FACTOR, c);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGDelegatedArrayHelper.DualPivotQuickSort(var A: array of T; c: TOnCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R, c) < R then
        DoDPQSort(@A[0], R, c);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGDelegatedArrayHelper.MergeSort(var A: array of T; c: TOnCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if o = soAsc then
      TMergeSort.SortAsc(@A[0], R, c)
    else
      TMergeSort.SortDesc(@A[0], R, c);
end;

class procedure TGDelegatedArrayHelper.Sort(var A: array of T; c: TOnCompare; o: TSortOrder);
begin
  IntroSort(A, c, o);
end;

class function TGDelegatedArrayHelper.Sorted(constref A: array of T; c: TOnCompare; o: TSortOrder): TArray;
begin
  Result := CreateCopy(A);
  Sort(Result, c, o);
end;

class function TGDelegatedArrayHelper.SelectDistinct(constref A: array of T; c: TOnCompare): TArray;
var
  I, J, Hi: SizeInt;
begin
  Result := Sorted(A, c);
  Hi := System.High(Result);
  if Hi < 1 then
    exit;
  I := 0;
  for J := 1 to Hi do
    begin
      if c(Result[I], Result[J]) = 0 then
        continue;
      Inc(I);
      if J > I then
        Result[I] := Result[J];
    end;
  System.SetLength(Result, Succ(I));
end;

{ TGNestedArrayHelper.TMergeSort }

procedure TGNestedArrayHelper.TMergeSort.Init(A: PItem; c: TNestCompare);
begin
  inherited Init(A);
  FCompare := c;
end;

procedure TGNestedArrayHelper.TMergeSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGNestedArrayHelper.TMergeSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGNestedArrayHelper.TMergeSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGNestedArrayHelper.TMergeSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGNestedArrayHelper.TMergeSort.MergeAtA(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoA(Base, CountLo, CountHi)
  else
    MergeHiA(Base, CountLo, CountHi);
end;

procedure TGNestedArrayHelper.TMergeSort.MergeAtD(aIndex: SizeInt);
var
  Base, CountLo, CountHi: SizeInt;
begin
  Base := FStack[aIndex].Base;
  CountLo := FStack[aIndex].Count;
  CountHi := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := CountLo + CountHi;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if CountLo <= CountHi then
    MergeLoD(Base, CountLo, CountHi)
  else
    MergeHiD(Base, CountLo, CountHi);
end;

procedure TGNestedArrayHelper.TMergeSort.MergeLoA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TNestCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) > 0 then
    begin
      LocB := EnsureBufferCapacity(CountLo);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) >= 0 then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if c(LocB[pLo], LocA[pHi]) <= 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T));
            {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
          {$ENDIF}
        end;
    end;
end;

procedure TGNestedArrayHelper.TMergeSort.MergeLoD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in buffer)
  pHi,           // position in high part  (in data array)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TNestCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) < 0 then
    begin
      LocB := EnsureBufferCapacity(CountLo);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From], LocB[0], CountLo * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From], LocB, CountLo);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) <= 0 then
        begin
          pLo := 0;
          pHi := From + CountLo;
          pDst := From;
          CountHi := Pred(From + CountLo + CountHi);
          repeat
            if c(LocB[pLo], LocA[pHi]) >= 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocB[pLo]);
                Inc(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocA[pHi]);
                Inc(pHi);
              end;
            Inc(pDst);
          until (pLo >= CountLo) or (pHi > CountHi);
          if pLo < CountLo then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[pLo], LocA[pDst], (CountLo - pLo) * SizeOf(T));
            {$ELSE}
            CopyItems(@LocB[pLo], @LocA[pDst], CountLo - pLo);
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From + CountLo], LocA[From], CountHi * SizeOf(T));
          System.Move(LocB[0], LocA[From + CountHi], CountLo * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From + CountLo], @LocA[From], CountHi);
          CopyItems(LocB, @LocA[From + CountHi], CountLo);
          {$ENDIF}
        end;
    end;
end;

procedure TGNestedArrayHelper.TMergeSort.MergeHiA(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TNestCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) > 0 then
    begin
      LocB := EnsureBufferCapacity(CountHi);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) >= 0 then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if c(LocA[pLo], LocB[pHi]) > 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T));
            {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T));
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
          {$ENDIF}
        end;
    end;
end;

procedure TGNestedArrayHelper.TMergeSort.MergeHiD(From, CountLo, CountHi: SizeInt);
var
  pLo,           // position in low part   (in data array)
  pHi,           // position in high part  (in buffer)
  pDst: SizeInt; // current CreateMerge position (in data array)
  LocA: PItem;   // local pointer to data array
  LocB: PItem;   // local pointer to buffer
  c: TNestCompare;
begin
  LocA := FData;
  c := FCompare;
  if c(FData[Pred(From + CountLo)], FData[From + CountLo]) < 0 then
    begin
      LocB := EnsureBufferCapacity(CountHi);
      {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
      System.Move(LocA[From + CountLo], LocB[0], CountHi * SizeOf(T));
      {$ELSE}
      CopyItems(@LocA[From + CountLo], LocB, CountHi);
      {$ENDIF}
      if c(LocA[Pred(From + CountLo + CountHi)], LocA[From]) <= 0 then
        begin
          pLo := Pred(From + CountLo);
          pHi := CountHi - 1;
          pDst := Pred(From + CountLo + CountHi);
          repeat
            if c(LocA[pLo], LocB[pHi]) < 0 then
              begin
                TFake(LocA[pDst]) := TFake(LocA[pLo]);
                Dec(pLo);
              end
            else
              begin
                TFake(LocA[pDst]) := TFake(LocB[pHi]);
                Dec(pHi);
              end;
            Dec(pDst);
          until (pLo < From) or (pHi < 0);
          if pHi >= 0 then
            {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
            System.Move(LocB[0], LocA[From], Succ(pHi) * SizeOf(T));
            {$ELSE}
            CopyItems(LocB, @LocA[From], Succ(pHi));
            {$ENDIF}
        end
      else
        begin
          {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}
          System.Move(LocA[From], LocA[From + CountHi], CountLo * SizeOf(T));
          System.Move(LocB[0], LocA[From], CountHi * SizeOf(T));
          {$ELSE}
          CopyItems(@LocA[From], @LocA[From + CountHi], CountLo);
          CopyItems(LocB, @LocA[From], CountHi);
          {$ENDIF}
        end;
    end;
end;

class procedure TGNestedArrayHelper.TMergeSort.InsertSortA(A: PItem; R, At: SizeInt; c: TNestCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGNestedArrayHelper.TMergeSort.InsertSortD(A: PItem; R, At: SizeInt; c: TNestCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) < 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGNestedArrayHelper.TMergeSort.CountRunAsc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) <= 0 then  // ascending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                        // descending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) > 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGNestedArrayHelper.TMergeSort.CountRunDesc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) >= 0 then  // descending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) >= 0) do
          Inc(Result)
      else                        // ascending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) < 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGNestedArrayHelper.TMergeSort.SortAsc(A: PItem; R: SizeInt; c: TNestCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ms.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunAsc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortA(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ms.PushRun(L, RunLen);
        L += RunLen;
        ms.CollapseA;
      until L > R;
      ms.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R, c)), c);
end;

class procedure TGNestedArrayHelper.TMergeSort.SortDesc(A: PItem; R: SizeInt; c: TNestCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ms: TMergeSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ms.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunDesc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortD(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ms.PushRun(L, RunLen);
        L += RunLen;
        ms.CollapseD;
      until L > R;
      ms.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R, c)), c);
end;

{ TGNestedArrayHelper }

class function TGNestedArrayHelper.CountRun2Asc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt;
begin
  Result := 0;
  while (Result < R) and (c(A[Result], A[Succ(Result)]) = 0) do
    Inc(Result);
  if Result < R then
    begin
      Inc(Result);
      if c(A[Pred(Result)], A[Result]) < 0 then   // ascending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                                        // descending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) >= 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end;
end;

class procedure TGNestedArrayHelper.InsertionSort(A: PItem; R: SizeInt; c: TNestCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  for I := 1 to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGNestedArrayHelper.DoBinSearch(A: PItem; R: SizeInt; constref aValue: T;
  c: TNestCompare): SizeInt;
var
  L, M, Cmp: SizeInt;
begin
  //here R must be >= 0;
  Result := -1;
  L := 0;
  Cmp := c(A[R], A[L]);
  if Cmp > 0 then  //ascending
    begin
      while L < R do
        begin
          M := L + (R - L) shr 1;
          Cmp := c(A[M], aValue);
          if Cmp < 0 then
            L := Succ(M)
          else
            begin
              if Cmp = 0 then
                exit(M);
              R := M;
            end;
        end;
      //here L >= R
      if c(A[R], aValue) = 0 then
        Result := R;
    end
  else
    if Cmp < 0 then  //descending
      begin
        while L < R do
          begin
            M := L + ((R - L) shr 1);
            Cmp := c(A[M], aValue);
            if Cmp > 0 then
              L := Succ(M)
            else
              begin
                if Cmp = 0 then
                  exit(M);
                R := M;
              end;
          end;
        //here L >= R
        if c(A[R], aValue) = 0 then
          Result := R;
      end
    else              //constant
      if c(A[L], aValue) = 0 then
        exit(L);
end;

class function TGNestedArrayHelper.DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T;
  c: TNestCompare): TSearchResult;
var
  L, M, Cmp: SizeInt;
begin
  //here exists at least 2 ascending elements;
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      Cmp := c(A[M], aValue);
      if Cmp < 0 then
        L := Succ(M)
      else
        begin
          if Cmp = 0 then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  Cmp := c(aValue, A[R]);
  if Cmp < 0 then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if Cmp = 0 then
        Result.FoundIndex := R;
    end;
end;

class function TGNestedArrayHelper.DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T;
  c: TNestCompare): TSearchResult;
var
  L, M, Cmp: SizeInt;
begin
  //here exists at least 2 descending elements
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      Cmp := c(A[M], aValue);
      if Cmp > 0 then
        L := Succ(M)
      else
        begin
          if Cmp = 0 then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  Cmp := c(aValue, A[R]);
  if Cmp > 0 then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if Cmp = 0 then
        Result.FoundIndex := R;
    end;
end;

class function TGNestedArrayHelper.DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T;
  c: TNestCompare): TSearchResult;
var
  Cmp: SizeInt;
begin
  //here R must be >= 0;
  Cmp := c(A[R], A[0]);
  if Cmp > 0 then   //ascending
    Result := DoBinSearchPosA(A, R, aValue, c)
  else
    if Cmp < 0 then //descending
      Result := DoBinSearchPosD(A, R, aValue, c)
    else            //constant
      begin
        Cmp := c(aValue, A[R]);
        Result.FoundIndex := -1;
        if Cmp < 0 then
           Result.InsertIndex := 0
        else
          begin
            Result.InsertIndex := Succ(R);
            if Cmp = 0 then
              Result.FoundIndex := 0;
          end;
      end;
end;

class procedure TGNestedArrayHelper.DoHeapSort(A: PItem; R: SizeInt; c: TNestCompare);
var
  I, Curr, Next: SizeInt;
  v: TFake;
begin
  if R > HEAP_INSERT_CUTOFF then
    begin
      for I := Pred(Succ(R) shr 1) downto 0 do
        begin
          Curr := I;
          Next := Succ(I shl 1);
          v := TFake(A[Curr]);
          while Next <= R do
            begin
              if(Succ(Next) <= R) and (c(A[Next], A[Succ(Next)]) < 0)then
                Inc(Next);
              if c(T(v), A[Next]) >= 0 then
                break;
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          TFake(A[Curr]) := v;
        end;
      for I := R downto 1 do
        begin
          Curr := 0;
          Next := 1;
          v := TFake(A[I]);
          TFake(A[I]) := TFake(A[0]);
          while Next < I do
            begin
              if(Succ(Next) < I) and (c(A[Next], A[Succ(Next)]) < 0) then
                Inc(Next);
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          Next := Pred(Curr) shr 1;
          while (Curr > 0) and (c(T(v), A[Next]) > 0) do
            begin
              TFake(A[Curr]) := TFake(A[Next]);
              Curr := Next;
              Next := Pred(Next) shr 1;
            end;
          TFake(A[Curr]) := v;
        end;
    end
  else
    InsertionSort(A, R, c);
end;

class function TGNestedArrayHelper.QSplitR(A: PItem; R: SizeInt; c: TNestCompare): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  Pivot := A[Succ(Random(Pred(R)))]; //shouldn't be first or last
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until c(A[pL], Pivot) >= 0;
    repeat Dec(pR) until c(A[pR], Pivot) <= 0;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGNestedArrayHelper.DoQSort(A: PItem; R: SizeInt; c: TNestCompare);
begin
  while R > QUICK_INSERT_CUTOFF do
    with QSplitR(A, R, c) do
      if Left <= R - Right then
        begin
          DoQSort(A, Left, c);
          A := @A[Right];
          R -= Right;
        end
      else
        begin
          DoQSort(@A[Right], R - Right, c);
          R := Left;
        end;
  if R > 0 then
    InsertionSort(A, R, c);
end;

class function TGNestedArrayHelper.MedianOf3(constref v1, v2, v3: T; c: TNestCompare): T;
begin
  Result := v2;
  if c(v1, Result) < 0 then
    begin
      if c(v3, Result) < 0 then
        begin
          if c(v1, v3) < 0 then
            Result := v3
          else
            Result := v1;
        end;
    end
  else { v1 >= Result }
    begin
      if c(v3, Result) > 0 then
        begin
          if c(v1, v3) > 0 then
            Result := v3
          else
            Result := v1;
        end;
    end;
end;

class function TGNestedArrayHelper.QSplitMo9(A: PItem; R: SizeInt; c: TNestCompare): TSortSplit;
var
  Pivot: T;
  v: TFake;
  pL, pR: SizeInt;
begin
  if R > MEDIAN_OF9_CUTOFF then
    Pivot := MedianOf3(
      MedianOf3(A[0],
                A[Succ(R) shr 3],
                A[Succ(R) shr 2], c),
      MedianOf3(A[Succ(R) shr 1 - Succ(R) shr 3],
                A[Succ(R) shr 1], A[Succ(R) shr 1 + Succ(R) shr 3], c),
      MedianOf3(A[R - Succ(R) shr 2],
                A[R - Succ(R) shr 3],
                A[R], c), c)
  else
    Pivot := MedianOf3(A[0], A[Succ(R) shr 1], A[R], c);
  pL := -1;
  pR := Succ(R);
  repeat
    repeat Inc(pL) until c(A[pL], Pivot) >= 0;
    repeat Dec(pR) until c(A[pR], Pivot) <= 0;
    if pL > pR then break;
    v := TFake(A[pL]);
    TFake(A[pL]) := TFake(A[pR]);
    TFake(A[pR]) := v;
  until False;
  Result.Left := pR;
  Result.Right := pL;
end;

class procedure TGNestedArrayHelper.DoIntroSort(A: PItem; R, Ttl: SizeInt; c: TNestCompare);
begin
  if R > QUICK_INSERT_CUTOFF then
    if Ttl > 0 then
      with QSplitMo9(A, R, c) do
        begin
          DoIntroSort(A, Left, Pred(Ttl), c);
          DoIntroSort(@A[Right], R - Right, Pred(Ttl), c);
        end
    else
      DoHeapSort(A, R, c)
  else
    if R > 0 then
      InsertionSort(A, R, c);
end;

class function TGNestedArrayHelper.DPQSplit(A: PItem; R: SizeInt; c: TNestCompare): TSortSplit;
var
  v, Pivot1, Pivot2: TFake;
  pL, pR, I: SizeInt;
begin
  pL := Succ(Random(Pred(R shr 1)));
  pR := Pred(R - Random(Pred(R shr 1)));

  if c(A[pL], A[pR]) <= 0 then
    begin
      Pivot1 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[0]);
      Pivot2 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[R]);
    end
  else
    begin
      Pivot2 := TFake(A[pL]);
      TFake(A[pL]) := TFake(A[R]);
      Pivot1 := TFake(A[pR]);
      TFake(A[pR]) := TFake(A[0]);
    end;

  pL := 1;
  I  := 1;
  pR := Pred(R);
  while I <= pR do
    begin
      v := TFake(A[I]);
      if c(T(v), T(Pivot1)) < 0 then
        begin
          TFake(A[I]) := TFake(A[pL]);
          TFake(A[pL]) := v;
          Inc(pL);
        end
      else
        if c(T(v), T(Pivot2)) > 0 then
          begin
            while (pR >= I) and (c(A[pR], T(Pivot2)) > 0) do
              Dec(pR);
            if pR < I then
              break;
            if c(A[pR], T(Pivot1)) < 0 then
              begin
                TFake(A[I]) := TFake(A[pL]);
                TFake(A[pL]) := TFake(A[pR]);
                Inc(pL);
              end
            else
              TFake(A[I]) := TFake(A[pR]);
            TFake(A[pR]) := v;
            Dec(pR);
          end;
      Inc(I);
    end;
  TFake(A[0]) := TFake(A[pL - 1]);
  TFake(A[pL - 1]) := Pivot1;
  TFake(A[R]) := TFake(A[pR + 1]);
  TFake(A[pR + 1]) := Pivot2;

  Result.Left := pL - 1;
  Result.Right := pR + 1;
end;

class procedure TGNestedArrayHelper.DoDPQSort(A: PItem; R: SizeInt; c: TNestCompare);
begin
  if R > DPQ_INSERT_CUTOFF then
    with DPQSplit(A, R, c) do
      begin
        DoDPQSort(A, Left - 1, c);
        DoDPQSort(@A[Right + 1], R - Right - 1, c);
        if c(A[Left], A[Right]) <> 0 then
          DoDPQSort(@A[Left + 1], Right - Left - 2, c);
      end
  else
    if R > 0 then
      InsertionSort(A, R, c);
end;

class function TGNestedArrayHelper.QSelectR(A: PItem; R, N: SizeInt; c: TNestCompare): T;
var
  v: TFake;
  Pivot: T;
  L, pL, pR: SizeInt;
begin
  L := 0;
  while L < Pred(R) do
    begin
      Pivot := A[L + Random(Succ(R - L))];
      pL := Pred(L);
      pR := Succ(R);
      repeat
        repeat Inc(pL) until c(A[pL], Pivot) >= 0;
        repeat Dec(pR) until c(A[pR], Pivot) <= 0;
        if pL >= pR then break;
        v := TFake(A[pL]);
        TFake(A[pL]) := TFake(A[pR]);
        TFake(A[pR]) := v;
      until False;
      if pL = pR then
        begin
          if pL > L then
            Dec(pR)
          else
            if pL < R then
              Inc(pL);
        end;
      if pR < N then L := pL;
      if pL > N then R := pR;
    end;
  if (L < R) and (c(A[L], A[R]) > 0) then
    begin
      v := TFake(A[L]);
      TFake(A[L]) := TFake(A[R]);
      TFake(A[R]) := v;
    end;
  Result := A[N];
end;

class function TGNestedArrayHelper.SequentSearch(constref A: array of T; constref aValue: T;
  c: TNestCompare): SizeInt;
begin
  for Result := 0 to System.High(A) do
    if c(aValue, A[Result]) = 0 then
      exit;
  Result := -1;
end;

class function TGNestedArrayHelper.BinarySearch(constref A: array of T; constref aValue: T;
  c: TNestCompare): SizeInt;
begin
  Result := High(A);
  if Result >= 0 then
    Result := DoBinSearch(@A[0], Result, aValue, c);
end;

class function TGNestedArrayHelper.BinarySearchPos(constref A: array of T; constref aValue: T;
  c: TNestCompare): TSearchResult;
var
  hi: SizeInt;
begin
  hi := High(A);
  if hi >= 0 then
    Result := DoBinSearchPos(@A[0], hi, aValue, c)
  else
    begin
      Result.FoundIndex := hi;
      Result.InsertIndex := hi;
    end;
end;

class function TGNestedArrayHelper.IndexOfMin(constref A: array of T; c: TNestCompare): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if c(A[I], v) < 0 then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGNestedArrayHelper.IndexOfMax(constref A: array of T; c: TNestCompare): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if c(v, A[I]) < 0 then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGNestedArrayHelper.GetMin(constref A: array of T; c: TNestCompare): TOptional;
var
  v: T;
begin
  if FindMin(A, v, c) then
    Result.Assign(v);
end;

class function TGNestedArrayHelper.GetMax(constref A: array of T; c: TNestCompare): TOptional;
var
  v: T;
begin
  if FindMax(A, v, c) then
    Result.Assign(v);
end;

class function TGNestedArrayHelper.FindMin(constref A: array of T; out aValue: T; c: TNestCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if c(A[I], aValue) < 0 then
          aValue := A[I];
    end;
end;

class function TGNestedArrayHelper.FindMax(constref A: array of T; out aValue: T; c: TNestCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if c(aValue, A[I]) < 0 then
          aValue := A[I];
    end;
end;

class function TGNestedArrayHelper.FindMinMax(constref A: array of T; out aMin, aMax: T;
  c: TNestCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aMin := A[0];
      aMax := A[0];
      for I := 1 to R do
        if c(aMax, A[I]) < 0 then
          aMax := A[I]
        else
          if c(A[I], aMin) < 0 then
            aMin := A[I];
    end;
end;

class function TGNestedArrayHelper.FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T;
  c: TNestCompare): Boolean;
var
  R: SizeInt;
begin
  R := System.High(A);
  if R < 0 then
    exit(False);
  if N <= 0 then
    exit(FindMin(A, aValue, c));
  if N >= R then
    exit(FindMax(A, aValue, c));
  aValue := QSelectR(@A[0], R, N, c);
  Result := True;
end;

class function TGNestedArrayHelper.NthSmallest(var A: array of T; N: SizeInt; c: TNestCompare): TOptional;
var
  v: T;
begin
  if FindNthSmallest(A, N, v, c) then
    Result.Assign(v);
end;

class function TGNestedArrayHelper.FindNthSmallestND(constref A: array of T;
  N: SizeInt; out aValue: T; c: TNestCompare): Boolean;
begin
  Result := FindNthSmallest(CreateCopy(A), N, aValue, c);
end;

class function TGNestedArrayHelper.NthSmallestND(constref A: array of T;N: SizeInt; c: TNestCompare): TOptional;
var
  v: T;
begin
  if FindNthSmallestND(A, N, v, c) then
    Result.Assign(v);
end;

class function TGNestedArrayHelper.NextPermutation2Asc(var A: array of T; c: TNestCompare): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if c(A[I], A[Succ(I)]) > 0 then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if c(A[J], A[I]) > 0 then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGNestedArrayHelper.NextPermutation2Desc(var A: array of T; c: TNestCompare): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if c(A[I], A[Succ(I)]) < 0 then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if c(A[J], A[I]) < 0 then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(@A[Succ(J)], R - Succ(J));
  Result := True;
end;

class function TGNestedArrayHelper.IsNonDescending(constref A: array of T; c: TNestCompare): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if c(A[I], A[Succ(I)]) > 0 then
      exit(False);
  Result := True;
end;

class function TGNestedArrayHelper.IsStrictAscending(constref A: array of T; c: TNestCompare): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if c(A[Pred(I)], A[I]) >= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGNestedArrayHelper.IsNonAscending(constref A: array of T; c: TNestCompare): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if c(A[I], A[Succ(I)]) < 0 then
      exit(False);
  Result := True;
end;

class function TGNestedArrayHelper.IsStrictDescending(constref A: array of T; c: TNestCompare): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if c(A[Pred(I)], A[I]) <= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGNestedArrayHelper.Same(constref A, B: array of T; c: TNestCompare): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  if System.High(B) <> R then
    exit(False);
  for I := 0 to R do
    if c(A[I], B[I]) <> 0 then
      exit(False);
  Result := True;
end;

class procedure TGNestedArrayHelper.QuickSort(var A: array of T; c: TNestCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R, c) < R then
        DoQSort(@A[0], R, c);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGNestedArrayHelper.IntroSort(var A: array of T; c: TNestCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R, c) < R then
        DoIntroSort(@A[0], R, Pred(LGUtils.NSB(R + 1)) * INTRO_LOG_FACTOR, c);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGNestedArrayHelper.DualPivotQuickSort(var A: array of T; c: TNestCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(@A[0], R, c) < R then
        DoDPQSort(@A[0], R, c);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGNestedArrayHelper.MergeSort(var A: array of T; c: TNestCompare; o: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if o = soAsc then
      TMergeSort.SortAsc(@A[0], R, c)
    else
      TMergeSort.SortDesc(@A[0], R, c);
end;

class procedure TGNestedArrayHelper.Sort(var A: array of T; c: TNestCompare; o: TSortOrder);
begin
  IntroSort(A, c, o);
end;

class function TGNestedArrayHelper.Sorted(constref A: array of T; c: TNestCompare; o: TSortOrder): TArray;
begin
  Result := CreateCopy(A);
  Sort(Result, c, o);
end;

class function TGNestedArrayHelper.SelectDistinct(constref A: array of T; c: TNestCompare): TArray;
var
  I, J, Hi: SizeInt;
begin
  Result := Sorted(A, c);
  Hi := System.High(Result);
  if Hi < 1 then
    exit;
  I := 0;
  for J := 1 to Hi do
    begin
      if c(Result[I], Result[J]) = 0 then
        continue;
      Inc(I);
      if J > I then
        Result[I] := Result[J];
    end;
  System.SetLength(Result, Succ(I));
end;

{ TGNumArrayHelper }

class function TGNumArrayHelper.CountRun2Asc(var A: array of T; L, R: SizeInt): SizeInt;
begin
  Result := L;
  while (Result < R) and (A[Result] = A[Succ(Result)]) do
    Inc(Result);
  if Result < R then
    begin
      Inc(Result);
      if A[Pred(Result)] < A[Result] then  // ascending
        while (Result < R) and (A[Result] <= A[Succ(Result)]) do
          Inc(Result)
      else                                 // descending
        begin
          while (Result < R) and (A[Result] >= A[Succ(Result)]) do
            Inc(Result);
          Reverse(A[0..Result]);
        end;
    end;
end;

class procedure TGNumArrayHelper.InsertionSort(var A: array of T; L, R: SizeInt);
var
  I, J: SizeInt;
  v: T;
begin
  for I := L + 1 to R do
    begin
      v := A[I];
      J := I - 1;
      while (J >= 0) and (A[J] > v) do
        begin
          A[J + 1] := A[J];
          Dec(J);
        end;
      A[J + 1] := v;
    end;
end;

class function TGNumArrayHelper.DoBinSearch(A: PItem; R: SizeInt; constref aValue: T): SizeInt;
var
  L, M: SizeInt;
begin
  //here R must be >= 0;
  Result := -1;
  L := 0;
  if A[R] > A[L] then  //ascending
    begin
      while L < R do
        begin
          M := L + (R - L) shr 1;
          if A[M] < aValue then
            L := Succ(M)
          else
            begin
              if A[M] = aValue then
                exit(M);
              R := M;
            end;
        end;
      //here L >= R
      if A[R] = aValue then
        Result := R;
    end
  else
    if A[R] < A[L] then  //descending
      begin
        while L < R do
          begin
            M := L + ((R - L) shr 1);
            if A[M] > aValue then
              L := Succ(M)
            else
              begin
                if A[M] = aValue then
                  exit(M);
                R := M;
              end;
          end;
        //here L >= R
        if A[R] = aValue then
          Result := R;
      end
    else              //constant
      if A[L] = aValue then
        exit(L);
end;

class function TGNumArrayHelper.DoBinSearchPosA(A: PItem; R: SizeInt; constref aValue: T): TSearchResult;
var
  L, M: SizeInt;
begin
  //here exists at least 2 ascending elements;
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      if A[M] < aValue then
        L := Succ(M)
      else
        begin
          if A[M] = aValue then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  if aValue < A[R] then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if aValue = A[R] then
        Result.FoundIndex := R;
    end;
end;

class function TGNumArrayHelper.DoBinSearchPosD(A: PItem; R: SizeInt; constref aValue: T): TSearchResult;
var
  L, M: SizeInt;
begin
  //here exists at least 2 descending elements
  Result.FoundIndex := -1;
  L := 0;
  while L < R do
    begin
      M := L + (R - L) shr 1;
      if A[M] > aValue then
        L := Succ(M)
      else
        begin
          if A[M] = aValue then
            begin
              Result.FoundIndex := M;
              Result.InsertIndex := Succ(M);
              exit;
            end;
          R := M;
        end;
    end;
  //here L >= R
  if aValue > A[R] then
    Result.InsertIndex := R
  else
    begin
      Result.InsertIndex := Succ(R);
      if aValue = A[R] then
        Result.FoundIndex := R;
    end;
end;

class function TGNumArrayHelper.DoBinSearchPos(A: PItem; R: SizeInt; constref aValue: T): TSearchResult;
begin
  //here R must be >= 0;
  if A[0] < A[R] then   //ascending
    Result := DoBinSearchPosA(A, R, aValue)
  else
    if A[0] > A[R] then //descending
      Result := DoBinSearchPosD(A, R, aValue)
    else                //constant
      begin
        Result.FoundIndex := -1;
        if A[R] > aValue then
           Result.InsertIndex := 0
        else
          begin
            Result.InsertIndex := Succ(R);
            if A[R] = aValue then
              Result.FoundIndex := 0;
          end;
      end;
end;

class procedure TGNumArrayHelper.DoHeapSort(A: PItem; R: SizeInt);
var
  I, Curr, Next: SizeInt;
  v: T;
begin
  if R > 0 then
    begin
      for I := Pred(Succ(R) shr 1) downto 0 do
        begin
          Curr := I;
          Next := Succ(I shl 1);
          v := A[Curr];
          while Next <= R do
            begin
              if(Succ(Next) <= R) and (A[Next] < A[Succ(Next)])then
                Inc(Next);
              if v >= A[Next] then
                break;
              A[Curr] := A[Next];
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          A[Curr] := v;
        end;
      for I := R downto 1 do
        begin
          Curr := 0;
          Next := 1;
          v := A[I];
          A[I] := A[0];
          while Next < I do
            begin
              if(Succ(Next) < I) and (A[Next] < A[Succ(Next)]) then
                Inc(Next);
              A[Curr] := A[Next];
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          Next := Pred(Curr) shr 1;
          while (Curr > 0) and (v > A[Next]) do
            begin
              A[Curr] := A[Next];
              Curr := Next;
              Next := Pred(Next) shr 1;
            end;
          A[Curr] := v;
        end;
    end;
end;

class function TGNumArrayHelper.QSplitR(var A: array of T; L, R: SizeInt): TSortSplit;
var
  v, Pivot: T;
begin
  Pivot := A[Succ(L + Random(Pred(R - L)))]; //shouldn't be first or last
  Dec(L);
  Inc(R);
  repeat
    repeat Inc(L); until A[L] >= Pivot;
    repeat Dec(R); until A[R] <= Pivot;
    //if L > R then
    //  break;
    v := A[L];
    A[L] := A[R];
    A[R] := v;
  //until False;
  until L > R;
  v := A[L];
  A[L] := A[R];
  A[R] := v;

  Result.Left := R;
  Result.Right := L;
end;

class procedure TGNumArrayHelper.DoQSort(var A: array of T; L, R: SizeInt);
begin
  while R - L > QUICK_INSERT_CUTOFF do
    with QSplitR(A, L, R) do
      if Left - L <= R - Right then
        begin
          DoQSort(A, L, Left);
          L := Right;
        end
      else
        begin
          DoQSort(A, Right, R);
          R := Left;
        end;
  if R - L > 0 then
    InsertionSort(A, L, R);
end;

class function TGNumArrayHelper.MedianOf3(const v1, v2, v3: T): T;
begin
  Result := v2;
  if v1 < Result then
    begin
      if v3 < Result then
        begin
          if v1 < v3 then
            Result := v3
          else
            Result := v1;
        end;
    end
  else { v1 >= Result }
    begin
      if v3 > Result then
        begin
          if v1 > v3 then
            Result := v3
          else
            Result := v1;
        end;
    end;
end;

class function TGNumArrayHelper.GetMo9Pivot(constref A: array of T; L, R: SizeInt): T;
begin
  if R - L > MEDIAN_OF9_CUTOFF then
    begin
      Result := MedianOf3(
      MedianOf3(A[L], A[L + Succ(R - L) shr 3], A[L + Succ(R - L) shr 2]),
      MedianOf3(A[L + Succ(R - L) shr 1 - Succ(R - L) shr 3], A[L + Succ(R - L) shr 1],
                A[L + Succ(R - L) shr 1 + Succ(R - L) shr 3]),
      MedianOf3(A[R - Succ(R - L) shr 2], A[R - Succ(R - L) shr 3], A[R]));
    end
  else
    Result := MedianOf3(A[L], A[L + Succ(R - L) shr 1], A[R]);
end;

class function TGNumArrayHelper.QSplitMo9(var A: array of T; L, R: SizeInt): TSortSplit;
var
  v, Pivot: T;
begin
  Pivot := GetMo9Pivot(A, L, R);
  Dec(L);
  Inc(R);
  repeat
    repeat
      Inc(L);
    until A[L] >= Pivot;
    repeat
      Dec(R);
    until A[R] <= Pivot;
    if L > R then
      break;
    v := A[L];
    A[L] := A[R];
    A[R] := v;
  until False;
  Result.Left := R;
  Result.Right := L;
end;

class procedure TGNumArrayHelper.DoIntroSort(var A: array of T; L, R, Ttl: SizeInt);
begin
  if R - L > QUICK_INSERT_CUTOFF then
    if Ttl > 0 then
      with QSplitMo9(A, L, R) do
        begin
          DoIntroSort(A, L, Left, Pred(Ttl));
          DoIntroSort(A, Right, R, Pred(Ttl));
        end
    else
      DoHeapSort(@A[L], R - L)
  else
    if R - L > 0 then
      InsertionSort(A, L, R);
end;

class function TGNumArrayHelper.DPQSplit(var A: array of T; L, R: SizeInt): TSortSplit;
var
  v, Pivot1, Pivot2: T;
  pL, pR, I: SizeInt;
label
  EndLoop;
begin
  pL := Succ(L + Random(Pred((R - L) shr 1)));
  pR := Pred(R - Random(Pred((R - L) shr 1)));

  if A[pL] <= A[pR] then
    begin
      Pivot1 := A[pL];
      A[pL] := A[L];
      Pivot2 := A[pR];
      A[pR] := A[R];
    end
  else
    begin
      Pivot2 := A[pL];
      A[pL] := A[R];
      Pivot1 := A[pR];
      A[pR] := A[L];
    end;

  pL := Succ(L);
  I  := Succ(L);
  pR := Pred(R);
  while I <= pR do
    begin
      v := A[I];
      if v < Pivot1 then
        begin
          A[I] := A[pL];
          A[pL] := v;
          Inc(pL);
        end
      else
        if v > Pivot2 then
          begin
            while A[pR] > Pivot2 do
              begin
                Dec(pR);
                if pR < I then
                  goto EndLoop;
              end;
            if A[pR] < Pivot1 then
              begin
                A[I] := A[pL];
                A[pL] := A[pR];
                Inc(pL);
              end
            else
              A[I] := A[pR];
            A[pR] := v;
            Dec(pR);
          end;
      Inc(I);
    end;

EndLoop:

  A[L] := A[pL - 1];
  A[pL - 1] := Pivot1;
  A[R] := A[pR + 1];
  A[pR + 1] := Pivot2;

  Result.Left := pL - 1;
  Result.Right := pR + 1;
end;

class procedure TGNumArrayHelper.DoDPQSort(var A: array of T; L, R: SizeInt);
begin
  if R - L > DPQ_INSERT_CUTOFF then
    with DPQSplit(A, L, R) do
      begin
        DoDPQSort(A, L, Left - 1);
        DoDPQSort(A, Right + 1, R);
        if A[Left] <> A[Right] then
          DoDPQSort(A, Left + 1, Right - 1);
      end
  else
    if R - L > 0 then
      InsertionSort(A, L, R);
end;

class procedure TGNumArrayHelper.DoSwap(p: PItem; L, R: SizeInt);
var
  v: T;
begin
  v := p[L];
  p[L] := p[R];
  p[R] := v;
end;

class procedure TGNumArrayHelper.DoReverse(var A: array of T; L, R: SizeInt);
var
  v0, v1, v2, v3: T;
begin
  while R - L >= 7 do
    begin
      v0 := A[L    ];
      v1 := A[L + 1];
      v2 := A[L + 2];
      v3 := A[L + 3];
      A[L    ] := A[R    ];
      A[L + 1] := A[R - 1];
      A[L + 2] := A[R - 2];
      A[L + 3] := A[R - 3];
      A[R    ] := v0;
      A[R - 1] := v1;
      A[R - 2] := v2;
      A[R - 3] := v3;
      L += 4;
      R -= 4;
    end;
  case R - L of
    1..2:
      begin
        v0 := A[L];
        A[L] := A[R];
        A[R] := v0;
      end;
    3..4:
      begin
        v0 := A[L    ];
        v1 := A[L + 1];
        A[L    ] := A[R    ];
        A[L + 1] := A[R - 1];
        A[R    ] := v0;
        A[R - 1] := v1;
      end;
    5..6:
      begin
        v0 := A[L    ];
        v1 := A[L + 1];
        v2 := A[L + 2];
        A[L    ] := A[R    ];
        A[L + 1] := A[R - 1];
        A[L + 2] := A[R - 2];
        A[R    ] := v0;
        A[R - 1] := v1;
        A[R - 2] := v2;
      end;
  end;
end;

class function TGNumArrayHelper.QSelectR(var A: array of T; N: SizeInt): T;
var
  L, R, pL, pR: SizeInt;
  v, Pivot: T;
begin
  R := System.High(A);
  L := 0;
  while L < Pred(R) do
    begin
      Pivot := A[L + Random(Succ(R - L))];
      pL := Pred(L);
      pR := Succ(R);
      repeat
        repeat Inc(pL) until A[pL] >= Pivot;
        repeat Dec(pR) until A[pR] <= Pivot;
        if pL >= pR then break;
        v := A[pL];
        A[pL] := A[pR];
        A[pR] := v;
      until False;
      if pL = pR then
        begin
          if pL > L then
            Dec(pR)
          else
            if pL < R then
              Inc(pL);
        end;
      if pR < N then L := pL;
      if pL > N then R := pR;
    end;
  if (L < R) and (A[L] > A[R]) then
    begin
      v := A[L];
      A[L] := A[R];
      A[R] := v;
    end;
  Result := A[N];
end;

class procedure TGNumArrayHelper.Reverse(var A: array of T);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    DoReverse(A, 0, R);
end;

class function TGNumArrayHelper.SequentSearch(constref A: array of T; constref aValue: T): SizeInt;
begin
  for Result := 0 to System.High(A) do
    if aValue = A[Result] then
      exit;
  Result := -1;
end;

class function TGNumArrayHelper.BinarySearch(constref A: array of T; constref aValue: T): SizeInt;
begin
  Result := High(A);
  if Result >= 0 then
    Result := DoBinSearch(@A[0], Result, aValue);
end;

class function TGNumArrayHelper.BinarySearchPos(constref A: array of T; constref aValue: T): TSearchResult;
var
  hi: SizeInt;
begin
  hi := High(A);
  if hi >= 0 then
    Result := DoBinSearchPos(@A[0], hi, aValue)
  else
    begin
      Result.FoundIndex := hi;
      Result.InsertIndex := hi;
    end;
end;

class function TGNumArrayHelper.IndexOfMin(constref A: array of T): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if v > A[I] then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGNumArrayHelper.IndexOfMax(constref A: array of T): SizeInt;
var
  R, I: SizeInt;
  v: T;
begin
  R := System.High(A);
  if R >= 0 then
    begin
      Result := 0;
      v := A[0];
      for I := 1 to R do
        if v < A[I] then
          begin
            v := A[I];
            Result := I;
          end;
    end
  else
    Result := R;
end;

class function TGNumArrayHelper.GetMin(constref A: array of T): TOptional;
var
  v: T;
begin
  if FindMin(A, v) then
    Result.Assign(v);
end;

class function TGNumArrayHelper.GetMax(constref A: array of T): TOptional;
var
  v: T;
begin
  if FindMax(A, v) then
    Result.Assign(v);
end;

class function TGNumArrayHelper.FindMin(constref A: array of T; out aValue: T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if aValue > A[I] then
          aValue := A[I];
    end;
end;

class function TGNumArrayHelper.FindMax(constref A: array of T; out aValue: T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aValue := A[0];
      for I := 1 to R do
        if aValue < A[I] then
          aValue := A[I];
    end;
end;

class function TGNumArrayHelper.FindMinMax(constref A: array of T; out aMin, aMax: T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  Result := R >= 0;
  if Result then
    begin
      aMin := A[0];
      aMax := A[0];
      for I := 1 to R do
        if A[I] > aMax then
          aMax := A[I]
        else
          if A[I] < aMin then
            aMin := A[I];
    end;
end;

class function TGNumArrayHelper.FindNthSmallest(var A: array of T; N: SizeInt; out aValue: T): Boolean;
var
  R: SizeInt;
begin
  R := System.High(A);
  if R < 0 then
    exit(False);
  if N <= 0 then
    exit(FindMin(A, aValue));
  if N >= R then
    exit(FindMax(A, aValue));
  aValue := QSelectR(A, N);
  Result := True;
end;

class function TGNumArrayHelper.NthSmallest(var A: array of T; N: SizeInt): TOptional;
var
  v: T;
begin
  if FindNthSmallest(A, N, v) then
    Result.Assign(v);
end;

class function TGNumArrayHelper.FindNthSmallestND(constref A: array of T; N: SizeInt; out aValue: T): Boolean;
begin
  Result := FindNthSmallest(CreateCopy(A), N, aValue);
end;

class function TGNumArrayHelper.NthSmallestND(constref A: array of T; N: SizeInt): TOptional;
var
  v: T;
begin
  if FindNthSmallestND(A, N, v) then
    Result.Assign(v);
end;

class function TGNumArrayHelper.NextPermutation2Asc(var A: array of T): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if A[I] > A[Succ(I)] then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if A[J] > A[I] then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(A, Succ(J), R);
  Result := True;
end;

class function TGNumArrayHelper.NextPermutation2Desc(var A: array of T): Boolean;
var
  I, J, R: SizeInt;
begin
  R := System.High(A);
  J := -1;
  for I := Pred(R) downto 0 do
    if A[I] < A[Succ(I)] then
      begin
        J := I;
        break;
      end;
  if J < 0 then exit(False);
  for I := R downto 0 do
    if A[J] < A[I] then
      begin
        DoSwap(@A[0], I, J);
        break;
      end;
  DoReverse(A, Succ(J), R);
  Result := True;
end;

class function TGNumArrayHelper.IsNonDescending(constref A: array of T): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if A[I] > A[Succ(I)] then
      exit(False);
  Result := True;
end;

class function TGNumArrayHelper.IsStrictAscending(constref A: array of T): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if A[Pred(I)] >= A[I] then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGNumArrayHelper.IsNonAscending(constref A: array of T): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to Pred(System.High(A)) do
    if A[I] < A[Succ(I)] then
      exit(False);
  Result := True;
end;

class function TGNumArrayHelper.IsStrictDescending(constref A: array of T): Boolean;
var
  I, R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      for I := 1 to R do
        if A[Pred(I)] <= A[I] then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGNumArrayHelper.Same(constref A, B: array of T): Boolean;
var
  R, I: SizeInt;
begin
  R := System.High(A);
  if System.High(B) <> R then
    exit(False);
  for I := 0 to R do
    if A[I] <> B[I] then
      exit(False);
  Result := True;
end;

class procedure TGNumArrayHelper.QuickSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(A, 0, R) < R then
        DoQSort(A, 0, R);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGNumArrayHelper.IntroSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(A, 0, R) < R then
        DoIntroSort(A, 0, R, Pred(LGUtils.NSB(R + 1)) * INTRO_LOG_FACTOR);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGNumArrayHelper.DualPivotQuickSort(var A: array of T; o: TSortOrder);
var
  R: SizeInt;
begin
  R := System.High(A);
  if R > 0 then
    begin
      if CountRun2Asc(A, 0, R) < R then
        DoDPQSort(A, 0, R);
      if o = soDesc then
        Reverse(A);
    end;
end;

class procedure TGNumArrayHelper.Sort(var A: array of T; o: TSortOrder);
begin
  IntroSort(A, o);
end;

class function TGNumArrayHelper.Sorted(constref A: array of T; o: TSortOrder): TArray;
begin
  Result := CreateCopy(A);
  Sort(Result, o);
end;

class function TGNumArrayHelper.SelectDistinct(constref A: array of T): TArray;
var
  I, J, Hi: SizeInt;
begin
  Result := Sorted(A);
  Hi := System.High(Result);
  if Hi < 1 then
    exit;
  I := 0;
  for J := 1 to Hi do
    begin
      if Result[I] = Result[J] then
        continue;
      Inc(I);
      if J > I then
        Result[I] := Result[J];
    end;
  System.SetLength(Result, Succ(I));
end;

{ TGOrdinalArrayHelper }

class function TGOrdinalArrayHelper.TypeInfo: PTypeInfo;
begin
  Result := System.TypeInfo(T);
end;

class function TGOrdinalArrayHelper.TypeData: PTypeData;
var
  p: PTypeInfo;
begin
  p := TypeInfo;
  if p <> nil then
    Result := GetTypeData(p)
  else
    Result := nil;
end;

class function TGOrdinalArrayHelper.TypeKind: TTypeKind;
var
  p: PTypeInfo;
begin
  p := TypeInfo;
  if p <> nil then
    Result := p^.Kind
  else
    Result := tkUnknown;
end;

class function TGOrdinalArrayHelper.CountSortAvailable(out aMinValue, aMaxValue: SizeInt): Boolean;
var
  p: PTypeData;
begin
  if (TypeKind in ORD_TYPES) and (SizeOf(T) <= 2) then
    begin
      p := TypeData;
      if p <> nil then
        begin
          aMinValue := p^.MinValue;
          aMaxValue := p^.MaxValue;
          if LGUtils.NSB(aMaxValue - aMinValue) <= MAX_BITLEN then
            exit(True);
        end;
    end;
  Result := False;
end;

class procedure TGOrdinalArrayHelper.CountSort(var A: array of T; aMinValue, aMaxValue: SizeInt);
var
  I, J: SizeInt;
  v: T;
  Counts: array of SizeInt;
begin
  System.SetLength(Counts, Succ(aMaxValue - aMinValue));
  System.FillChar(Counts[0], Succ(aMaxValue - aMinValue) * SizeOf(SizeInt), 0);

  for J := 0 to System.High(A) do
    Inc(Counts[SizeInt(A[J]) - aMinValue]);

  J := High(A);
  for I := aMaxValue - aMinValue downto 0 do
    if Counts[I] > 0 then
      begin
        v := T(I + aMinValue);
        repeat
          A[J] := v;
          Dec(Counts[I]);
          Dec(J);
        until Counts[I] = 0;
      end;
end;

class procedure TGOrdinalArrayHelper.Sort(var A: array of T; aOrder: TSortOrder);
var
  R, vMin, vMax: SizeInt;
begin
  R := System.High(A);  //todo: also need to test array range
  if R > 0 then
    begin
      if CountRun2Asc(A, 0, R) < R then
        if CountSortAvailable(vMin, vMax) and (Succ(vMax - vMin) <= System.Length(A)) then //todo: <= ???
          CountSort(A, vMin, vMax)
        else
          DoIntroSort(A, 0, R, Pred(LGUtils.NSB(R + 1)) * INTRO_LOG_FACTOR);
      if aOrder = soDesc then
        Reverse(A);
    end;
end;

class function TGOrdinalArrayHelper.Sorted(constref A: array of T; o: TSortOrder): TArray;
begin
  Result := CreateCopy(A);
  Sort(Result, o);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Brief and dirty futures implementation.                                 *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
{
  The futures concept describes an asynchronous single-execution pattern.
  Result is requested at an early stage of execution, but becomes available after it is received.

  This implementation implies that futures are intended for use from the main thread.
}

unit LGAsync;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}
{$MODESWITCH NESTEDPROCVARS}

interface

uses
  Classes,
  SysUtils,
  LGUtils,
  LGDeque,
  LGVector,
  LGFunction,
  LGStrConst;

type

  { TCustomAsyncTask }

  TCustomAsyncTask = class abstract
  strict private
    FException: Exception;
    FExecAwait: PRtlEvent;
    FCancelled: Boolean;
    FStarted: Boolean;
  private
    procedure Cancel; inline;
    function  GetCancelled: Boolean; inline;
    function  GetStarted: Boolean; inline;
  strict protected
    procedure DoExecute; virtual; abstract;
  public
    destructor Destroy; override;
    procedure AfterConstruction; override;
    procedure Execute;
    procedure WaitFor;
    property  Started: Boolean read GetStarted;
    property  Cancelled: Boolean read GetCancelled;
    property  FatalException: Exception read FException;
  end;

  { TGCustomAsyncCall }

  generic TGCustomAsyncCall<T> = class abstract(TCustomAsyncTask)
  strict protected
    FResult: T; //To be setted inside overriden DoExecute
  public
    property Result: T read FResult;
  end;

  TFutureState = (fsPending, fsCancelled, fsResolveError, fsResolved);

  { TGFuture: takes over the management of the inner async task }
  generic TGFuture<T> = record
  public
  type
    TOptional = specialize TGOptional<T>;

  private
  type
    TTask = specialize TGCustomAsyncCall<T>;

  strict private
    FTask: TTask;
    FTaskResult: T;
    FState: TFutureState;
    procedure Resolve;
  private
    procedure Start(aTask: TTask);  inline;
    class operator Finalize(var f: TGFuture); inline;
  public
    function  WaitFor: TFutureState; inline;
  { may be impossible, if task already started }
    function  Cancel: Boolean;
  { will raise exception if resolving failed }
    function  Value: T;
    function  GetValue: TOptional; inline;
    property  State: TFutureState read FState;
  end;

  { TGAsyncProc incapsulates method without arguments(which returns void), True indicates execution success }
  TGAsyncProc = class(specialize TGCustomAsyncCall<Boolean>)
  public
  type
    TProcedure = procedure of object;
    TFuture    = specialize TGFuture<Boolean>;

  strict private
    FProc: TProcedure;
  strict protected
    procedure DoExecute; override;
  public
    class function Call(aProc: TProcedure): TFuture; static;
    constructor Create(aProc: TProcedure);
  end;

  { TAsyncExecutable incapsulates IExecutable, True indicates execution success }
  TAsyncExecutable = class(specialize TGCustomAsyncCall<Boolean>)
  public
  type
    TFuture = specialize TGFuture<Boolean>;

  strict private
    FTask: IExecutable;
  strict protected
    procedure DoExecute; override;
  public
    class function Call(aTask: IExecutable): TFuture; static;
    constructor Create(aTask: IExecutable);
  end;

  { TGAsyncCollable incapsulates IGCallable}
  generic TGAsyncCollable<T> = class(specialize TGCustomAsyncCall<T>)
  public
  type
    ICallable = specialize IGCallable<T>;
    TFuture   = specialize TGFuture<T>;

  strict private
    FTask: ICallable;
  strict protected
    procedure DoExecute; override;
  public
    class function Call(aTask: ICallable): TFuture; static;
    constructor Create(aTask: ICallable);
  end;

  { TGAsyncMethod incapsulates method without arguments(which returns T) }
  generic TGAsyncMethod<T> = class(specialize TGCustomAsyncCall<T>)
  public
  type
    TFunction = function: T of object;
    TFuture   = specialize TGFuture<T>;

  strict private
    FFunc: TFunction;
  strict protected
    procedure DoExecute; override;
  public
    class function Call(aFunc: TFunction): TFuture; static;
    constructor Create(aFunc: TFunction);
  end;

  { TGAsyncNestedFunc incapsulates nested niladic function (without arguments) }
  generic TGAsyncNestedFunc<T> = class(specialize TGCustomAsyncCall<T>)
  public
  type
    TFunction = function: T is nested;
    TFuture   = specialize TGFuture<T>;

  strict private
    FFunc: TFunction;
  strict protected
    procedure DoExecute; override;
  public
    class function Call(aFunc: TFunction): TFuture; static;
    constructor Create(aFunc: TFunction);
  end;

  { TGAsyncNAFunc incapsulates regular niladic function (without arguments) }
  generic TGAsyncNAFunc<T> = class(specialize TGCustomAsyncCall<T>)
  strict protected
  public
  type
    TFunction = function: T;
    TFuture   = specialize TGFuture<T>;

  strict private
    FFunc: TFunction;
  strict protected
    procedure DoExecute; override;
  public
    class function Call(aFunc: TFunction): TFuture; static;
    constructor Create(aFunc: TFunction);
  end;

  { TGAsyncFunc incapsulates regular monadic function (with one argument) }
  generic TGAsyncFunc<T, TResult> = class(specialize TGCustomAsyncCall<TResult>)
  strict protected
  type
    TCall = specialize TGDefferedCall<T, TResult>;

  public
  type
    TFunction = TCall.TFunction;
    TFuture   = specialize TGFuture<TResult>;

  strict private
    FCall: TCall;
  strict protected
    procedure DoExecute; override;
  public
    class function Call(aFunc: TFunction; constref v: T): TFuture; static;
    constructor Create(aFunc: TFunction; constref v: T);
  end;

  { TGAsync2AFunc incapsulates regular dyadic function (with two arguments) }
  generic TGAsync2AFunc<T1, T2, TResult> = class(specialize TGCustomAsyncCall<TResult>)
  strict protected
  type
    TCall = specialize TGDefferedCall2A<T1, T2, TResult>;

  public
  type
    TFunction = TCall.TFunction;
    TFuture   = specialize TGFuture<TResult>;

  strict private
    FCall: TCall;
  strict protected
    procedure DoExecute; override;
  public
    class function Call(aFunc: TFunction; constref v1: T1; constref v2: T2): TFuture; static;
    constructor Create(aFunc: TFunction; constref v1: T1; constref v2: T2);
  end;

  { TGAsync3AFunc incapsulates regular triadic function (with three arguments) }
  generic TGAsync3AFunc<T1, T2, T3, TResult> = class(specialize TGCustomAsyncCall<TResult>)
  strict protected
  type
    TCall = specialize TGDefferedCall3A<T1, T2, T3, TResult>;

  public
  type
    TFunction = TCall.TFunction;
    TFuture   = specialize TGFuture<TResult>;

  strict private
    FCall: TCall;
  strict protected
    procedure DoExecute; override;
  public
    class function Call(aFunc: TFunction; constref v1: T1; constref v2: T2; constref v3: T3): TFuture; static;
    constructor Create(aFunc: TFunction; constref v1: T1; constref v2: T2; constref v3: T3);
  end;

  { TTaskExecutor executes futures in its own thread pool.
    Enqueue procedure is threadsafe, so futures may use other futures.
    Resizing of thread pool is not threadsafe, so MUST be done from main thread. }
  TTaskExecutor = class
  protected
  type

    TTaskQueue = class
    strict private
    type
      TQueue = specialize TGLiteDeque<TCustomAsyncTask>;

    var
      FQueue: TQueue;
      FReadAwait: PRtlEvent;
      FLock: TRtlCriticalSection;
      FClosed: Boolean;
      procedure Lock; inline;
      procedure UnLock; inline;
      procedure Signaled; inline;
      property  Closed: Boolean read FClosed;
    public
      constructor Create;
      destructor Destroy; override;
      procedure AfterConstruction; override;
      procedure Clear;
      procedure Close;
      procedure Open;
      procedure Enqueue(aTask: TCustomAsyncTask);
      function  Dequeue(out aTask: TCustomAsyncTask): Boolean;
      function  Cancel(aTask: TCustomAsyncTask): Boolean;
    end;

    TWorkThread = class(TThread)
    strict private
      FQueue: TTaskQueue;
    public
      constructor Create(aQueue: TTaskQueue);
      procedure Execute; override;
    end;

    TThreadPool = specialize TGLiteVector<TWorkThread>;

  var
    FTaskQueue: TTaskQueue;
    FThreadPool: TThreadPool;
    function  ThreadPoolCount: Integer; inline;
    function  AddThread: TWorkThread;
    procedure PoolGrow(aValue: Integer);
    procedure PoolShrink(aValue: Integer);
    procedure EnqueueTask(aTask: TCustomAsyncTask); inline;
    procedure TerminatePool;
    procedure FinalizePool; inline;
    function  CancelTask(aTask: TCustomAsyncTask): Boolean; inline;
    class constructor InitNil;
    class destructor  DoneQueue;
    class function    GetThreadCount: Integer; static; inline;
    class procedure   SetThreadCount(aValue: Integer); static; inline;
  class var
    CFExecutor: TTaskExecutor; // CF -> Class Field

  public
  const
    DEFAULT_THREAD_COUNT = 4;

    class procedure EnsureThreadCount(aValue: Integer); static;
    class procedure Enqueue(aTask: TCustomAsyncTask); static; inline;
    class function  Cancel(aTask: TCustomAsyncTask): Boolean; inline;
    constructor Create; overload;
    constructor Create(aThreadCount: Integer); overload;
    destructor  Destroy; override;
    class property ThreadCount: Integer read GetThreadCount write SetThreadCount;
  end;

  { TGBlockingChannel }

  generic TGBlockingChannel<T, TSize> = class //todo: replace in unit ???
  strict protected
  type
    TBuffer = array[0..Pred(TSize.Size)] of T;

  var
    FBuffer: TBuffer;
    FLock: TRtlCriticalSection;
    FWriteAwait,
    FReadAwait: PRtlEvent;
    FCount,
    FHead: SizeInt;
    FActive: Boolean;
    function  GetCapacity: SizeInt; inline;
    procedure Lock; inline;
    procedure UnLock; inline;
    procedure SignalRead; inline;
    procedure SignalWrite; inline;
    procedure SendData(constref aValue: T);
    function  ReceiveData: T;
    function  TailIndex: SizeInt; inline;
    procedure Enqueue(constref aValue: T);
    function  Dequeue: T;
    function  CanWrite: Boolean; inline;
    function  CanRead: Boolean; inline;
    procedure Panic; inline;
    procedure CheckCanRead; inline;
    procedure CheckCanWrite; inline;
    procedure CleanupBuffer; virtual;
    property  Head: SizeInt read FHead;
  public
    constructor Create;
    destructor Destroy; override;
    procedure AfterConstruction; override;
    function  Send(constref aValue: T): Boolean;
    function  Receive(out aValue: T): Boolean;
    procedure Close;
    procedure Open;
  { if is not Active then Send and Receive will always return False without blocking }
    property  Active: Boolean read FActive;
    property  Count: SizeInt read FCount;
    property  Capacity: SizeInt read GetCapacity;
  end;

  { TGObjectBlockingChannel }

  generic TGObjectBlockingChannel<T: class; TSize> = class(specialize TGBlockingChannel<T, TSize>)
  strict private
    FOwnsObjects: Boolean;
  strict protected
    procedure CleanupBuffer; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    property OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  TDefaultSize = class sealed
  const
    Size = 256;
  end;

  generic TGDefaultChannel<T> = class(specialize TGBlockingChannel<T, TDefaultSize>);

implementation
{$B-}{$COPERATORS ON}

{ TCustomAsyncTask }

procedure TCustomAsyncTask.Cancel;
begin
  FCancelled := True;
end;

function TCustomAsyncTask.GetCancelled: Boolean;
begin
  WriteBarrier;
  Result := FCancelled;
end;

function TCustomAsyncTask.GetStarted: Boolean;
begin
  WriteBarrier;
  Result := FStarted;
end;

destructor TCustomAsyncTask.Destroy;
begin
  System.RtlEventDestroy(FExecAwait);
  FExecAwait := nil;
  inherited;
end;

procedure TCustomAsyncTask.AfterConstruction;
begin
  inherited;
  FExecAwait := System.RtlEventCreate;
end;

procedure TCustomAsyncTask.Execute;
begin
  if not Cancelled then
    begin
      FStarted := True;
      try
        DoExecute;
      except
        on e: Exception do
           FException := Exception(System.AcquireExceptionObject);
      end;
    end;
  System.RtlEventSetEvent(FExecAwait);
end;

procedure TCustomAsyncTask.WaitFor;
begin
  if Cancelled then
    exit;
  System.RtlEventWaitFor(FExecAwait);
end;

{ TGFuture }

procedure TGFuture.Resolve;
var
  e: Exception;
begin
  if Assigned(FTask) then
    try
      FTask.WaitFor;
      if not FTask.Cancelled then
        begin
          e := FTask.FatalException;
          if Assigned(e) then
            FState := fsResolveError
          else
            begin
              FState := fsResolved;
              FTaskResult := FTask.Result;
            end;
        end
      else
        FState := fsCancelled;
    finally
      FreeAndNil(FTask);
      if Assigned(e) then
        raise e;
    end;
end;

procedure TGFuture.Start(aTask: TTask);
begin
  FTask := aTask;
  FState := fsPending;
  TTaskExecutor.Enqueue(FTask);
end;

class operator TGFuture.Finalize(var f: TGFuture);
begin
  f.WaitFor;
end;

function TGFuture.WaitFor: TFutureState;
begin
  try Resolve except end;
  Result := State;
end;

function TGFuture.Cancel: Boolean;
begin
  if (State = fsPending) and not FTask.Started then
    begin
      Result := TTaskExecutor.Cancel(FTask);
      if Result then
        begin
          FreeAndNil(FTask);
          FState := fsCancelled;
        end;
    end
  else
    Result := False;
end;

function TGFuture.Value: T;
begin
  case State of
    fsPending:      Resolve;
    fsResolveError,
    fsCancelled:    raise ELGFuture.Create(SEResultUnknown);
  end;
  Result := FTaskResult;
end;

function TGFuture.GetValue: TOptional;
begin
  if WaitFor = fsResolved then
    Result.Assign(FTaskResult);
end;

{ TGAsyncProc }

procedure TGAsyncProc.DoExecute;
begin
  FProc;
  FResult := True;
end;

class function TGAsyncProc.Call(aProc: TProcedure): TFuture;
begin
  Result.Start(TGAsyncProc.Create(aProc));
end;

constructor TGAsyncProc.Create(aProc: TProcedure);
begin
  FProc := aProc;
end;

{ TAsyncExecutable }

procedure TAsyncExecutable.DoExecute;
begin
  FTask.Execute;
  FResult := True;
end;

class function TAsyncExecutable.Call(aTask: IExecutable): TFuture;
begin
  Result.Start(TAsyncExecutable.Create(aTask));
end;

constructor TAsyncExecutable.Create(aTask: IExecutable);
begin
  FTask := aTask;
end;

{ TGAsyncCollable }

procedure TGAsyncCollable.DoExecute;
begin
  FResult := FTask.Call;
end;

class function TGAsyncCollable.Call(aTask: ICallable): TFuture;
begin
  Result.Start(TGAsyncCollable.Create(aTask));
end;

constructor TGAsyncCollable.Create(aTask: ICallable);
begin
  FTask := aTask;
end;

{ TGAsyncMethod }

procedure TGAsyncMethod.DoExecute;
begin
  FResult := FFunc();
end;

class function TGAsyncMethod.Call(aFunc: TFunction): TFuture;
begin
  Result.Start(TGAsyncMethod.Create(aFunc));
end;

constructor TGAsyncMethod.Create(aFunc: TFunction);
begin
  FFunc := aFunc;
end;

{ TGAsyncNestedFunc }

procedure TGAsyncNestedFunc.DoExecute;
begin
  FResult := FFunc();
end;

class function TGAsyncNestedFunc.Call(aFunc: TFunction): TFuture;
begin
  Result.Start(TGAsyncNestedFunc.Create(aFunc));
end;

constructor TGAsyncNestedFunc.Create(aFunc: TFunction);
begin
  FFunc := aFunc;
end;

{ TGAsyncNAFunc }

procedure TGAsyncNAFunc.DoExecute;
begin
  FResult := FFunc();
end;

class function TGAsyncNAFunc.Call(aFunc: TFunction): TFuture;
begin
  Result.Start(TGAsyncNAFunc.Create(aFunc));
end;

constructor TGAsyncNAFunc.Create(aFunc: TFunction);
begin
  FFunc := aFunc;
end;

{ TGAsyncFunc }

procedure TGAsyncFunc.DoExecute;
begin
  FResult := FCall.Call;
end;

class function TGAsyncFunc.Call(aFunc: TFunction; constref v: T): TFuture;
begin
  Result.Start(TGAsyncFunc.Create(aFunc, v));
end;

constructor TGAsyncFunc.Create(aFunc: TFunction; constref v: T);
begin
  FCall := TCall.Construct(aFunc, v);
end;

{ TGAsync2AFunc }

procedure TGAsync2AFunc.DoExecute;
begin
  FResult := FCall.Call;
end;

class function TGAsync2AFunc.Call(aFunc: TFunction; constref v1: T1; constref v2: T2): TFuture;
begin
  Result.Start(TGAsync2AFunc.Create(aFunc, v1, v2));
end;

constructor TGAsync2AFunc.Create(aFunc: TFunction; constref v1: T1; constref v2: T2);
begin
  FCall := TCall.Construct(aFunc, v1, v2);
end;

{ TGAsync3AFunc }

procedure TGAsync3AFunc.DoExecute;
begin
  FResult := FCall.Call;
end;

class function TGAsync3AFunc.Call(aFunc: TFunction; constref v1: T1; constref v2: T2;
  constref v3: T3): TFuture;
begin
  Result.Start(TGAsync3AFunc.Create(aFunc, v1, v2, v3));
end;

constructor TGAsync3AFunc.Create(aFunc: TFunction; constref v1: T1; constref v2: T2; constref v3: T3);
begin
  FCall := TCall.Construct(aFunc, v1, v2, v3);
end;

{ TTaskExecutor.TTaskQueue }

procedure TTaskExecutor.TTaskQueue.Lock;
begin
  System.EnterCriticalSection(FLock);
end;

procedure TTaskExecutor.TTaskQueue.UnLock;
begin
  System.LeaveCriticalSection(FLock);
end;

procedure TTaskExecutor.TTaskQueue.Signaled;
begin
  System.RtlEventSetEvent(FReadAwait);
end;

constructor TTaskExecutor.TTaskQueue.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TTaskExecutor.TTaskQueue.Destroy;
begin
  Lock;
  try
    Finalize(FQueue);
    System.RtlEventDestroy(FReadAwait);
    FReadAwait := nil;
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TTaskExecutor.TTaskQueue.AfterConstruction;
begin
  inherited;
  FReadAwait := System.RtlEventCreate;
end;

procedure TTaskExecutor.TTaskQueue.Clear;
var
  Task: TCustomAsyncTask;
begin
  Lock;
  try
    for Task in FQueue do
      Task.Cancel;
    FQueue.Clear;
  finally
    UnLock;
  end;
end;

procedure TTaskExecutor.TTaskQueue.Close;
begin
  Lock;
  try
    FClosed := True;
    Signaled;
  finally
    UnLock;
  end;
end;

procedure TTaskExecutor.TTaskQueue.Open;
begin
  Lock;
  try
    FClosed := False;
  finally
    UnLock;
  end;
end;

procedure TTaskExecutor.TTaskQueue.Enqueue(aTask: TCustomAsyncTask);
begin
  Lock;
  try
    FQueue.PushLast(aTask);
    Signaled;
  finally
    UnLock;
  end;
end;

function TTaskExecutor.TTaskQueue.Dequeue(out aTask: TCustomAsyncTask): Boolean;
begin
  System.RtlEventWaitFor(FReadAwait);
  Lock;
  try
    if not Closed then
      begin
        Result := FQueue.TryPopFirst(aTask);
        if FQueue.NonEmpty then
         Signaled;
      end
    else
      begin
        Result := False;
        Signaled;
      end;
  finally
    UnLock;
  end;
end;

function TTaskExecutor.TTaskQueue.Cancel(aTask: TCustomAsyncTask): Boolean;
var
  I: Integer;
begin
  Lock;
  try
    Result := False;
    for I := 0 to Pred(FQueue.Count) do
      if FQueue[I] = aTask then
        begin
          aTask.Cancel;
          FQueue.Delete(I);
          Result := True;
          break;
        end;
    Signaled; // ???
  finally
    UnLock;
  end;
end;

{ TTaskExecutor.TWorkThread }

constructor TTaskExecutor.TWorkThread.Create(aQueue: TTaskQueue);
begin
  inherited Create(True);
  FQueue := aQueue;
end;

procedure TTaskExecutor.TWorkThread.Execute;
var
  CurrTask: TCustomAsyncTask;
begin
  while not Terminated do
    if FQueue.Dequeue(CurrTask) then
      CurrTask.Execute;
end;

{ TTaskExecutor }

function TTaskExecutor.ThreadPoolCount: Integer;
begin
  Result := FThreadPool.Count;
end;

function TTaskExecutor.AddThread: TWorkThread;
begin
  Result := TWorkThread.Create(FTaskQueue);
  FThreadPool.Add(Result);
  Result.Start;
end;

procedure TTaskExecutor.PoolGrow(aValue: Integer);
begin
  while FThreadPool.Count < aValue do
    AddThread;
end;

procedure TTaskExecutor.PoolShrink(aValue: Integer);
begin
  if aValue < 1 then
    aValue := 1;
  TerminatePool;
  FTaskQueue.Open;
  PoolGrow(aValue);
end;

procedure TTaskExecutor.EnqueueTask(aTask: TCustomAsyncTask);
begin
  FTaskQueue.Enqueue(aTask);
end;

procedure TTaskExecutor.TerminatePool;
var
  Thread: TWorkThread;
begin
  for Thread in FThreadPool.Reverse do
    Thread.Terminate;
  FTaskQueue.Close;
  while FThreadPool.Count > 0 do
    begin
      Thread := FThreadPool.Delete(Pred(FThreadPool.Count));
      Thread.WaitFor;
      Thread.Free;
    end;
end;

procedure TTaskExecutor.FinalizePool;
begin
  TerminatePool;
  FThreadPool.Clear;
end;

function TTaskExecutor.CancelTask(aTask: TCustomAsyncTask): Boolean;
begin
  Result := FTaskQueue.Cancel(aTask);
end;

class constructor TTaskExecutor.InitNil;
begin
  CFExecutor := nil;
end;

class destructor TTaskExecutor.DoneQueue;
begin
  FreeAndNil(CFExecutor);
end;

class function TTaskExecutor.GetThreadCount: Integer; static;
begin
  if Assigned(CFExecutor) then
    Result := CFExecutor.ThreadPoolCount
  else
    Result := 0;
end;

class procedure TTaskExecutor.SetThreadCount(aValue: Integer);
begin
  if aValue > ThreadCount then
    EnsureThreadCount(aValue)
  else
    if Assigned(CFExecutor) then
      CFExecutor.PoolShrink(aValue);
end;

class procedure TTaskExecutor.EnsureThreadCount(aValue: Integer);
begin
  if aValue > ThreadCount then
    if not Assigned(CFExecutor) then
      CFExecutor := TTaskExecutor.Create(aValue)
    else
      CFExecutor.PoolGrow(aValue);
end;

class procedure TTaskExecutor.Enqueue(aTask: TCustomAsyncTask);
begin
  if not Assigned(CFExecutor) then
    CFExecutor := TTaskExecutor.Create;
  CFExecutor.EnqueueTask(aTask);
end;

class function TTaskExecutor.Cancel(aTask: TCustomAsyncTask): Boolean;
begin
  if Assigned(CFExecutor) then
    Result := CFExecutor.CancelTask(aTask)
  else
    Result := False;
end;

constructor TTaskExecutor.Create;
begin
  if TThread.ProcessorCount > DEFAULT_THREAD_COUNT then
    Create(TThread.ProcessorCount)
  else
    Create(DEFAULT_THREAD_COUNT);
end;

constructor TTaskExecutor.Create(aThreadCount: Integer);
begin
  FTaskQueue := TTaskQueue.Create;
  if aThreadCount > 0 then
    PoolGrow(aThreadCount)
  else
    PoolGrow(1);
end;

destructor TTaskExecutor.Destroy;
begin
  FTaskQueue.Clear;
  FinalizePool;
  FTaskQueue.Free;
  inherited;
end;

{ TGBlockingChannel }

function TGBlockingChannel.GetCapacity: SizeInt;
begin
  Result := TSize.Size;
end;

procedure TGBlockingChannel.Lock;
begin
  System.EnterCriticalSection(FLock);
end;

procedure TGBlockingChannel.UnLock;
begin
  System.LeaveCriticalSection(FLock);
end;

procedure TGBlockingChannel.SignalRead;
begin
  System.RtlEventSetEvent(FReadAwait);
end;

procedure TGBlockingChannel.SignalWrite;
begin
  System.RtlEventSetEvent(FWriteAwait);
end;

procedure TGBlockingChannel.SendData(constref aValue: T);
begin
  Enqueue(aValue);
  SignalRead;
  if CanWrite then
    SignalWrite;
end;

function TGBlockingChannel.ReceiveData: T;
begin
  Result := Dequeue;
  SignalWrite;
  if CanRead then
    SignalRead;
end;

function TGBlockingChannel.TailIndex: SizeInt;
begin
  Result := Head + Count;
  if Result >= Capacity then
    Result -= Capacity;
end;

procedure TGBlockingChannel.Enqueue(constref aValue: T);
begin
  CheckCanWrite;
  FBuffer[TailIndex] := aValue;
  Inc(FCount);
end;

function TGBlockingChannel.Dequeue: T;
begin
  CheckCanRead;
  Result := FBuffer[Head];
  FBuffer[Head] := Default(T);
  Inc(FHead);
  Dec(FCount);
  if Head = Capacity then
    FHead := 0;
end;

function TGBlockingChannel.CanWrite: Boolean;
begin
  Result := Count < Capacity;
end;

function TGBlockingChannel.CanRead: Boolean;
begin
  Result := Count > 0;
end;

procedure TGBlockingChannel.Panic;
begin
  raise ELGPanic.Create(SEInternalDataInconsist);
end;

procedure TGBlockingChannel.CheckCanRead;
begin
  if Count = 0 then
    Panic;
end;

procedure TGBlockingChannel.CheckCanWrite;
begin
  if Count >= Capacity then
    Panic;
end;

procedure TGBlockingChannel.CleanupBuffer;
var
  I: SizeInt;
begin
  for I := 0 to Pred(Count) do
    FBuffer[I] := Default(T);
end;

constructor TGBlockingChannel.Create;
begin
  System.FillChar(FBuffer, SizeOf(FBuffer), 0);
  System.InitCriticalSection(FLock);
  FActive := True;
end;

destructor TGBlockingChannel.Destroy;
begin
  Close;
  Lock;
  try
    CleanupBuffer;
    System.RtlEventDestroy(FWriteAwait);
    FWriteAwait := nil;
    System.RtlEventDestroy(FReadAwait);
    FReadAwait := nil;
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGBlockingChannel.AfterConstruction;
begin
  inherited;
  FWriteAwait := System.RtlEventCreate;
  FReadAwait  := System.RtlEventCreate;
  SignalWrite;
end;

function TGBlockingChannel.Send(constref aValue: T): Boolean;
begin
  System.RtlEventWaitFor(FWriteAwait);
  Lock;
  try
    if Active then
      begin
        Result := CanWrite;
        if Result then
          SendData(aValue);
      end
    else
      begin
        Result := False;
        SignalWrite;
      end;
  finally
    UnLock;
  end;
end;

function TGBlockingChannel.Receive(out aValue: T): Boolean;
begin
  System.RtlEventWaitFor(FReadAwait);
  Lock;
  try
    if Active then
      begin
        Result := CanRead;
        if Result then
          aValue := ReceiveData;
      end
    else
      begin
        Result := False;
        SignalRead;
      end;
  finally
    UnLock;
  end;
end;

procedure TGBlockingChannel.Close;
begin
  Lock;
  try
    if Active then
      begin
        FActive := False;
        SignalRead;
        SignalWrite;
      end;
  finally
    UnLock;
  end;
end;

procedure TGBlockingChannel.Open;
begin
  Lock;
  try
    if not Active then
      begin
        FActive := True;
        if Count > 0 then
          SignalRead;
        if Count < Capacity then
          SignalWrite;
      end;
  finally
    UnLock;
  end;
end;

{ TGObjectBlockingChannel }

procedure TGObjectBlockingChannel.CleanupBuffer;
var
  I: Integer;
begin
  if OwnsObjects then
    for I := 0 to Pred(Count) do
      FBuffer[I].Free;
end;

constructor TGObjectBlockingChannel.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  FOwnsObjects := aOwnsObjects;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic AVL tree implementations for internal use.                      *
*   (see https://en.wikipedia.org/wiki/AVL_tree)                            *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGAvlTree;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}
{$MODESWITCH NESTEDPROCVARS}
{$PACKRECORDS DEFAULT}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers;

{.$DEFINE AVLTREE_ENABLE_PAGEDNODEMANAGER}//if uncomment define, will use TGPageNodeManager
type

  { TGCustomAvlTree }

  generic TGCustomAvlTree<TKey, TEntry> = class abstract
  public
  type
    PNode = ^TNode;

    TNode = record
    private
    {$IFNDEF CPU16}
      Left,
      Right: PNode;
      FParent: SizeInt;
      function  GetBalance: SizeInt; inline;
      function  GetParent: PNode; inline;
      procedure SetBalance(aValue: SizeInt); inline;
      procedure SetParent(aValue: PNode); inline;
      procedure SwapBalance(aNode: PNode); inline;
      property  Parent: PNode read GetParent write SetParent;
      property  Balance: SizeInt read GetBalance write SetBalance;
    {$ELSE !CPU16}
      Left,
      Right,
      Parent: PNode;
      Balance: SizeInt;
      procedure SwapBalance(aNode: PNode); inline;
    {$ENDIF !CPU16}
      //for node manager
      property  NextLink: PNode read Left write Left;
    public
      Data: TEntry;
      function Successor: PNode;
      function Predecessor: PNode;
    end;
{$IFDEF AVLTREE_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGPageNodeManager<TNode>;
{$ELSE AVLTREE_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGNodeManager<TNode>;
{$ENDIF AVLTREE_ENABLE_PAGEDNODEMANAGER}
    PEntry      = ^TEntry;
    TTest       = specialize TGTest<TKey>;
    TOnTest     = specialize TGOnTest<TKey>;
    TNestTest   = specialize TGNestTest<TKey>;
    TEntryTest  = function(p: PEntry): Boolean of object;
    TEntryEvent = procedure(p: PEntry) of object;

    TEnumerator = class
    protected
      FCurrNode: PNode;
      FInCycle: Boolean;
      FTree: TGCustomAvlTree;
    public
      constructor Create(aTree: TGCustomAvlTree);
      function  MoveNext: Boolean; virtual;
      procedure Reset;
      property  Current: PNode read FCurrNode;
    end;

  protected
  type
    TReverseEnumerator = class(TEnumerator)
      function  MoveNext: Boolean; override;
    end;

    TEnumeratorAt = class(TEnumerator)
    public
      FRootNode: PNode;
      constructor Create(aRootNode: PNode);
      function  MoveNext: Boolean; override;
    end;

  var
    FNodeManager: TNodeManager;
    FRoot: PNode;
    FCount: SizeInt;
    function  NewNode: PNode;
    procedure DisposeNode(aNode: PNode); inline;
    function  GetCapacity: SizeInt; inline;
    procedure ClearTree;
    function  GetHighest: PNode;
    function  GetLowest: PNode;
    function  FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode; virtual; abstract;
    function  FindInsertPos(constref aKey: TKey): PNode; virtual; abstract;
    procedure InsertNode(aNode: PNode); virtual; abstract;
    procedure InsertNodeAt(aNode, aParent: PNode); virtual; abstract;
    procedure ReplaceWithSuccessor(aNode: PNode);
    procedure DoRemoveNode(aNode: PNode);
    procedure BalanceAfterInsert(aNode: PNode);
    procedure BalanceAfterRemove(aNode: PNode; aNodeBalance: SizeInt);
    procedure RotateLeft(aNode: PNode);
    procedure RotateRight(aNode: PNode);
    procedure RemoveNodeWithChilds(aNode: PNode);
  public
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    destructor Destroy; override;
    procedure Clear; inline;
    procedure EnsureCapacity(aValue: SizeInt);
    procedure TrimToFit; inline;
    function  FindOrAdd(constref aKey: TKey; out aNode: PNode): Boolean;
    function  Add(constref aData: TEntry): PNode; inline;
    function  Remove(constref aKey: TKey): Boolean;
    procedure RemoveNode(aNode: PNode); inline;
    function  GetEnumerator: TEnumerator; inline;
    function  GetReverseEnumerator: TEnumerator; inline;
    function  GetEnumeratorAt(constref aKey: TKey; aInclusive: Boolean): TEnumeratorAt; inline;
    function  RemoveIf(aTest: TTest; aOnRemove: TEntryEvent = nil): SizeInt;
    function  RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent = nil): SizeInt;
    function  RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent = nil): SizeInt;
    function  RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent = nil): SizeInt;
    function  Find(constref aKey: TKey): PNode; virtual; abstract;
    function  FindLess(constref aKey: TKey): PNode; virtual; abstract;
    function  FindLessOrEqual(constref aKey: TKey): PNode; virtual; abstract;
    function  FindGreater(constref aKey: TKey): PNode; virtual; abstract;
    function  FindGreaterOrEqual(constref aKey: TKey): PNode; virtual; abstract;
    property  Count: SizeInt read FCount;
    property  Capacity: SizeInt read GetCapacity;
    property  Lowest: PNode read GetLowest;
    property  Highest: PNode read GetHighest;
  end;

  { TGAvlTree
      functor TKeyCmpRel (key comparision relation) must provide:
        class function Compare([const[ref]] L, R: TKey): SizeInt;  }
  generic TGAvlTree<TKey, TEntry, TKeyCmpRel> = class(specialize TGCustomAvlTree<TKey, TEntry>)
  protected
    function  FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode; override;
    function  FindInsertPos(constref aKey: TKey): PNode; override;
    procedure InsertNode(aNode: PNode); override;
    procedure InsertNodeAt(aNode, aParent: PNode); override;
  public
    function  Clone: TGAvlTree;
    function  Find(constref aKey: TKey): PNode; override;
    function  FindLess(constref aKey: TKey): PNode; override;
    function  FindLessOrEqual(constref aKey: TKey): PNode; override;
    function  FindGreater(constref aKey: TKey): PNode; override;
    function  FindGreaterOrEqual(constref aKey: TKey): PNode; override;
  end;

  { TGComparableAvlTree assumes that type TKey has defined comparision operators }
  generic TGComparableAvlTree<TKey, TEntry> = class(specialize TGCustomAvlTree<TKey, TEntry>)
  protected
    function  FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode; override;
    function  FindInsertPos(constref aKey: TKey): PNode; override;
    procedure InsertNode(aNode: PNode); override;
    procedure InsertNodeAt(aNode, aParent: PNode); override;
  public
    function  Clone: TGComparableAvlTree;
    function  Find(constref aKey: TKey): PNode; override;
    function  FindLess(constref aKey: TKey): PNode; override;
    function  FindLessOrEqual(constref aKey: TKey): PNode; override;
    function  FindGreater(constref aKey: TKey): PNode; override;
    function  FindGreaterOrEqual(constref aKey: TKey): PNode; override;
  end;

  { TGRegularAvlTree is avl tree with regular comparator }
  generic TGRegularAvlTree<TKey, TEntry> = class(specialize TGCustomAvlTree<TKey, TEntry>)
  public
  type
    TCompare = specialize TGCompare<TKey>;
  private
    FCompare: TCompare;
  protected
    function  FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode; override;
    function  FindInsertPos(constref aKey: TKey): PNode; override;
    procedure InsertNode(aNode: PNode); override;
    procedure InsertNodeAt(aNode, aParent: PNode); override;
  public
    constructor Create(aCompare: TCompare);
    constructor Create(aCapacity: SizeInt; aCompare: TCompare);
    function  Clone: TGRegularAvlTree;
    function  Find(constref aKey: TKey): PNode; override;
    function  FindLess(constref aKey: TKey): PNode; override;
    function  FindLessOrEqual(constref aKey: TKey): PNode; override;
    function  FindGreater(constref aKey: TKey): PNode; override;
    function  FindGreaterOrEqual(constref aKey: TKey): PNode; override;
    property  Comparator: TCompare read FCompare;
  end;

  { TGDelegatedAvlTree is avl tree with delegated comparator }
  generic TGDelegatedAvlTree<TKey, TEntry> = class(specialize TGCustomAvlTree<TKey, TEntry>)
  public
  type
    TOnCompare = specialize TGOnCompare<TKey>;
  private
    FCompare: TOnCompare;
  protected
    function  FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode; override;
    function  FindInsertPos(constref aKey: TKey): PNode; override;
    procedure InsertNode(aNode: PNode); override;
    procedure InsertNodeAt(aNode, aParent: PNode); override;
  public
    constructor Create(aCompare: TOnCompare);
    constructor Create(aCapacity: SizeInt; aCompare: TOnCompare);
    function  Clone: TGDelegatedAvlTree;
    function  Find(constref aKey: TKey): PNode; override;
    function  FindLess(constref aKey: TKey): PNode; override;
    function  FindLessOrEqual(constref aKey: TKey): PNode; override;
    function  FindGreater(constref aKey: TKey): PNode; override;
    function  FindGreaterOrEqual(constref aKey: TKey): PNode; override;
    property  Comparator: TOnCompare read FCompare;
  end;

  generic TGAvlTreeNode<T> = record
  private
  type
    TAvlTreeNode = specialize TGAvlTreeNode<T>;
  public
  type
    PNode = ^TAvlTreeNode;
  private
  {$IFNDEF CPU16}
    Left,
    Right: PNode;
    FParent: SizeInt;
    function  GetBalance: SizeInt; inline;
    function  GetParent: PNode; inline;
    procedure SetBalance(aValue: SizeInt); inline;
    procedure SetParent(aValue: PNode); inline;
    procedure SwapBalance(aNode: PNode); inline;
  {$ELSE !CPU16}
    Left,
    Right,
    Parent: PNode;
    Balance: SizeInt;
    procedure SwapBalance(aNode: PNode); inline;
  {$ENDIF !CPU16}
  public
    Data: T;
    function Successor: PNode;
    function Predecessor: PNode;
    property Parent: PNode read GetParent write SetParent;
    property Balance: SizeInt read GetBalance write SetBalance;
    //for node manager
    property NextLink: PNode read Left write Left;
  end;

  { TGAvlTree2: simplified version TGAvlTree }
  generic TGAvlTree2<TKey, TEntry, TNodeManager, TKeyCmpRel> = class
  public
  type
    TNode  = specialize TGAvlTreeNode<TEntry>;
    PNode  = ^TNode;
    PEntry = ^TEntry;

    TEnumerator = record
    private
      FCurrNode: PNode;
      FInCycle: Boolean;
      FTree: TGAvlTree2;
      function GetCurrent: PEntry; inline;
    public
      procedure Init(aTree: TGAvlTree2);
      function  MoveNext: Boolean;
      procedure Reset; inline;
      property  Current: PEntry read GetCurrent;
    end;

  strict protected
  type
    PNodeManager = ^TNodeManager;

  var
    FRoot: PNode;
    FCount: SizeInt;
    FNodeManager: TNodeManager;
    function  NewNode: PNode;
    procedure DisposeNode(aNode: PNode); inline;
    procedure ClearTree; inline;
    function  GetHighest: PNode;
    function  GetLowest: PNode;
    function  FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode;
    function  FindInsertPos(constref aKey: TKey): PNode;
    procedure InsertNode(aNode: PNode);
    procedure InsertNodeAt(aNode, aParent: PNode);
    procedure ReplaceWithSuccessor(aNode: PNode);
    procedure DoRemoveNode(aNode: PNode);
    procedure BalanceAfterInsert(aNode: PNode);
    procedure BalanceAfterRemove(aNode: PNode; aNodeBalance: SizeInt);
    procedure RotateLeft(aNode: PNode);
    procedure RotateRight(aNode: PNode);
    procedure RemoveNodeWithChilds(aNode: PNode);
  public
    constructor Create(aNodeManager: TNodeManager);
    destructor Destroy; override;
    function  GetEnumerator: TEnumerator; inline;
    procedure Clear; inline;
    function  FindOrAdd(constref aKey: TKey; out aNode: PNode): Boolean;
    function  Find(constref aKey: TKey): PNode;
    function  Remove(constref aKey: TKey): Boolean;
    procedure RemoveNode(aNode: PNode); inline;
    property  Count: SizeInt read FCount;
    property  Lowest: PNode read GetLowest;
    property  Highest: PNode read GetHighest;
  end;

implementation
{$B-}{$COPERATORS ON}

{$PUSH}{$Q-}
{$IFNDEF CPU16}
function TGCustomAvlTree.TNode.GetBalance: SizeInt;
begin
  Assert((FParent and 3) <> 0, Format('Inconsistent internal Balance value(%d)', [FParent and 3]));
  Result := (FParent and 3) - 2;
end;

function TGCustomAvlTree.TNode.GetParent: PNode;
begin
  Result := {%H-}Pointer(FParent and not SizeInt(3));
end;

procedure TGCustomAvlTree.TNode.SetBalance(aValue: SizeInt);
begin
  Assert((aValue + 2) in [1..3],
    Format('Inconsistent input Balance value(%d) in '+{$I %CURRENTROUTINE%}, [aValue]));
  FParent := (FParent and not SizeInt(3)) or ((aValue + 2) and 3);
end;

procedure TGCustomAvlTree.TNode.SetParent(aValue: PNode);
begin
  Assert({%H-}SizeUint(aValue) and 3 = 0,
    Format('Unaligned input Parent value($%x) in '+{$I %CURRENTROUTINE%}, [aValue]));
  FParent := {%H-}SizeInt(aValue) or (FParent and 3);
end;

procedure TGCustomAvlTree.TNode.SwapBalance(aNode: PNode);
var
  b: SizeInt;
begin
  b := FParent and 3;
  FParent := (FParent and not SizeInt(3)) or (aNode^.FParent and 3);
  aNode^.FParent := (aNode^.FParent and not SizeInt(3)) or b;
end;
{$ELSE !CPU16}
procedure TGCustomAvlTree.TNode.SwapBalance(aNode: PNode);
var
  b: SizeInt;
begin
  b := Balance;
  Balance := aNode^.Balance;
  aNode^.Balance := b;
end;
{$ENDIF !CPU16}
{$POP}

function TGCustomAvlTree.TNode.Successor: PNode;
begin
  Result := Right;
  if Result <> nil then
    while Result^.Left <> nil do
      Result := Result^.Left
  else
    begin
      Result := @Self;
      while (Result^.Parent <> nil) and (Result^.Parent^.Right = Result) do
        Result := Result^.Parent;
      Result := Result^.Parent;
    end;
end;

function TGCustomAvlTree.TNode.Predecessor: PNode;
begin
  Result := Left;
  if Result <> nil then
    while Result^.Right <> nil do
      Result := Result^.Right
  else
    begin
      Result := @Self;
      while (Result^.Parent <> nil) and (Result^.Parent^.Left = Result) do
        Result := Result^.Parent;
      Result := Result^.Parent;
    end;
end;

{ TGCustomAvlTree.TEnumerator }

constructor TGCustomAvlTree.TEnumerator.Create(aTree: TGCustomAvlTree);
begin
  FTree := aTree;
end;

function TGCustomAvlTree.TEnumerator.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Successor
  else
    if not FInCycle then
      begin
        NextNode := FTree.Lowest;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

procedure TGCustomAvlTree.TEnumerator.Reset;
begin
  FCurrNode := nil;
  FInCycle := False;
end;

{ TGCustomAvlTree.TReverseEnumerator }

function TGCustomAvlTree.TReverseEnumerator.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Predecessor
  else
    if not FInCycle then
      begin
        NextNode := FTree.Highest;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

{ TGCustomAvlTree.TEnumeratorAt }

constructor TGCustomAvlTree.TEnumeratorAt.Create(aRootNode: PNode);
begin
  FRootNode := aRootNode;
end;

function TGCustomAvlTree.TEnumeratorAt.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Successor
  else
    if not FInCycle then
      begin
        NextNode := FRootNode;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

{ TGCustomAvlTree }

function TGCustomAvlTree.NewNode: PNode;
begin
  Result := FNodeManager.NewNode;
  Result^.Balance := 0;
  Inc(FCount);
end;

procedure TGCustomAvlTree.DisposeNode(aNode: PNode);
begin
  if aNode <> nil then
    begin
      aNode^ := Default(TNode);
      FNodeManager.FreeNode(aNode);
      Dec(FCount);
    end;
end;

function TGCustomAvlTree.GetCapacity: SizeInt;
begin
  Result := Count + FNodeManager.FreeCount;
end;

procedure TGCustomAvlTree.ClearTree;
begin
  RemoveNodeWithChilds(FRoot);
  FRoot := nil;
  Assert(Count = 0, Format('Inconsistent Count value(%d) after '+{$I %CURRENTROUTINE%}, [Count]));
end;

function TGCustomAvlTree.GetHighest: PNode;
begin
  Result := FRoot;
  if Result <> nil then
    while Result^.Right <> nil do
      Result := Result^.Right;
end;

function TGCustomAvlTree.GetLowest: PNode;
begin
  Result := FRoot;
  if Result <> nil then
    while Result^.Left <> nil do
      Result := Result^.Left;
end;

procedure TGCustomAvlTree.ReplaceWithSuccessor(aNode: PNode);
var
  SuccNode, OldParent, OldLeft, OldRight,
  OldSuccParent, OldSuccLeft, OldSuccRight: PNode;
begin
  SuccNode := aNode^.Successor;
  aNode^.SwapBalance(SuccNode);

  OldParent := aNode^.Parent;
  OldLeft := aNode^.Left;
  OldRight := aNode^.Right;
  OldSuccParent := SuccNode^.Parent;
  OldSuccLeft := SuccNode^.Left;
  OldSuccRight := SuccNode^.Right;

  if OldParent <> nil then
    begin
      if OldParent^.Left = aNode then
        OldParent^.Left := SuccNode
      else
        OldParent^.Right := SuccNode;
    end
  else
    FRoot := SuccNode;

  SuccNode^.Parent := OldParent;

  if OldSuccParent <> aNode then
    begin
      if OldSuccParent^.Left = SuccNode then
        OldSuccParent^.Left := aNode
      else
        OldSuccParent^.Right := aNode;
      SuccNode^.Right := OldRight;
      aNode^.Parent := OldSuccParent;
      if OldRight <> nil then
        OldRight^.Parent := SuccNode;
    end
  else
    begin
      SuccNode^.Right := aNode;
      aNode^.Parent := SuccNode;
    end;

  aNode^.Left := OldSuccLeft;
  if OldSuccLeft <> nil then
    OldSuccLeft^.Parent := aNode;
  aNode^.Right := OldSuccRight;
  if OldSuccRight <> nil then
    OldSuccRight^.Parent := aNode;
  SuccNode^.Left := OldLeft;
  if OldLeft <> nil then
    OldLeft^.Parent := SuccNode;
end;

procedure TGCustomAvlTree.DoRemoveNode(aNode: PNode);
var
  OldParent, Child: PNode;
begin
  if (aNode^.Left <> nil) and (aNode^.Right <> nil) then
    ReplaceWithSuccessor(aNode);
  OldParent := aNode^.Parent;
  aNode^.Parent := nil;
  if aNode^.Left <> nil then
    Child := aNode^.Left
  else
    Child := aNode^.Right;
  if Child <> nil then
    Child^.Parent := OldParent;
  if OldParent <> nil then
    begin
      if OldParent^.Left = aNode then
        begin
          OldParent^.Left := Child;
          BalanceAfterRemove(OldParent, Succ(OldParent^.Balance));
        end
      else
        begin
          OldParent^.Right := Child;
          BalanceAfterRemove(OldParent, Pred(OldParent^.Balance));
        end;
    end
  else
    FRoot := Child;
  DisposeNode(aNode);
end;

procedure TGCustomAvlTree.BalanceAfterInsert(aNode: PNode);
var
  OldParent, OldChild: PNode;
begin
  OldParent := aNode^.Parent;
  while OldParent <> nil do
    if OldParent^.Left = aNode then //aNode is left child => we need decrease OldParent^.Balance
      case OldParent^.Balance of
        -1:
          begin
            if aNode^.Balance = -1 then
              begin
                RotateRight(OldParent);
                aNode^.Balance := 0;
                OldParent^.Balance := 0;
              end
            else
              begin
                OldChild := aNode^.Right;
                RotateLeft(aNode);
                RotateRight(OldParent);
                case OldChild^.Balance of
                  -1:
                    begin
                      aNode^.Balance := 0;
                      OldParent^.Balance := 1;
                    end;
                  0:
                    begin
                      aNode^.Balance := 0;
                      OldParent^.Balance := 0
                    end;
                else //1
                  aNode^.Balance := -1;
                  OldParent^.Balance := 0;
                end;
                OldChild^.Balance := 0;
              end;
            break;
          end;
         0:
          begin
            OldParent^.Balance := -1;
            aNode := OldParent;
            OldParent := aNode^.Parent;
          end;
      else //1
        OldParent^.Balance := 0;
        break;
      end
    else  // aNode is right child => we need increase OldParent^.Balance
      case OldParent^.Balance of
       -1:
         begin
           OldParent^.Balance := 0;
           break;
         end;
        0:
          begin
            OldParent^.Balance := 1;
            aNode := OldParent;
            OldParent := aNode^.Parent;
          end;
      else // 1
        if aNode^.Balance = 1 then
          begin
            RotateLeft(OldParent);
            aNode^.Balance := 0;
            OldParent^.Balance := 0;
          end
        else
          begin
            OldChild := aNode^.Left;
            RotateRight(aNode);
            RotateLeft(OldParent);
            case OldChild^.Balance of
              -1:
                begin
                  aNode^.Balance := 1;
                  OldParent^.Balance := 0;
                end;
              0:
                begin
                  aNode^.Balance := 0;
                  OldParent^.Balance := 0;
                end;
            else  //1
              aNode^.Balance := 0;
              OldParent^.Balance := -1
            end;
            OldChild^.Balance := 0;
          end;
        break;
      end;
end;

procedure TGCustomAvlTree.BalanceAfterRemove(aNode: PNode; aNodeBalance: SizeInt);
var
  OldParent, Child, ChildOfChild: PNode;
begin
  while aNode <> nil do
    begin
      OldParent := aNode^.Parent;
      case aNodeBalance of
        -2:
          begin
            Child := aNode^.Left;
            if Child^.Balance <= 0 then
              begin
                RotateRight(aNode);
                aNode^.Balance := -Succ(Child^.Balance);
                aNodeBalance := Succ(Child^.Balance);
                aNode := Child;
                Child^.Balance := aNodeBalance;
              end
            else
              begin
                ChildOfChild := Child^.Right;
                RotateLeft(Child);
                RotateRight(aNode);
                case ChildOfChild^.Balance of
                  -1:
                    begin
                      aNode^.Balance := 1;
                      Child^.Balance := 0;
                    end;
                   0:
                     begin
                       aNode^.Balance := 0;
                       Child^.Balance := 0;
                     end;
                else // 1
                  aNode^.Balance := 0;
                  Child^.Balance := -1;
                end;
                aNode := ChildOfChild;
                aNodeBalance := 0;
                ChildOfChild^.Balance := 0;
              end;
          end;
        -1:
          begin
            aNode^.Balance := aNodeBalance;
            break;
          end;
         0:
           begin
             aNode^.Balance := aNodeBalance;
             if OldParent <> nil then
               begin
                 if OldParent^.Left = aNode then
                   aNodeBalance := Succ(OldParent^.Balance)
                 else
                   aNodeBalance := Pred(OldParent^.Balance);
                 aNode := OldParent;
               end
             else
               break;
           end;
         1:
           begin
             aNode^.Balance := aNodeBalance;
             break;
           end;
         2:
           begin
             Child := aNode^.Right;
             if Child^.Balance >= 0 then
               begin
                 RotateLeft(aNode);
                 aNode^.Balance := SizeInt(1) - Child^.Balance;
                 aNodeBalance := Pred(Child^.Balance);
                 aNode := Child;
                 Child^.Balance := aNodeBalance;
               end
             else
               begin
                 ChildOfChild := Child^.Left;
                 RotateRight(Child);
                 RotateLeft(aNode);
                 case ChildOfChild^.Balance of
                   -1:
                     begin
                       aNode^.Balance := 0;
                       Child^.Balance := 1;
                     end;
                    0:
                      begin
                        aNode^.Balance := 0;
                        Child^.Balance := 0;
                      end;
                 else // 1
                   aNode^.Balance := -1;
                   Child^.Balance := 0;
                 end;
                 ChildOfChild^.Balance := 0;
                 aNode := ChildOfChild;
                 aNodeBalance := 0;
               end;
           end;
      end;
    end;
end;

procedure TGCustomAvlTree.RotateLeft(aNode: PNode);
var
  OldParent, OldRight, OldRightLeft: PNode;
begin
  OldRight := aNode^.Right;
  OldRightLeft := OldRight^.Left;
  OldParent := aNode^.Parent;
  if OldParent <> nil then
    begin
      if OldParent^.Left = aNode then
        OldParent^.Left := OldRight
      else
        OldParent^.Right := OldRight;
    end
  else
    FRoot := OldRight;
  OldRight^.Parent := OldParent;
  aNode^.Parent := OldRight;
  aNode^.Right := OldRightLeft;
  if OldRightLeft <> nil then
    OldRightLeft^.Parent := aNode;
  OldRight^.Left := aNode;
end;

procedure TGCustomAvlTree.RotateRight(aNode: PNode);
var
  OldParent, OldLeft, OldLeftRight: PNode;
begin
  OldLeft := aNode^.Left;
  OldLeftRight := OldLeft^.Right;
  OldParent := aNode^.Parent;
  if OldParent <> nil then
    begin
      if OldParent^.Left = aNode then
        OldParent^.Left := OldLeft
      else
        OldParent^.Right := OldLeft;
    end
  else
    FRoot := OldLeft;
  OldLeft^.Parent := OldParent;
  aNode^.Parent := OldLeft;
  aNode^.Left := OldLeftRight;
  if OldLeftRight <> nil then
    OldLeftRight^.Parent := aNode;
  OldLeft^.Right := aNode;
end;

procedure TGCustomAvlTree.RemoveNodeWithChilds(aNode: PNode);
begin
  if aNode <> nil then
    begin
      RemoveNodeWithChilds(aNode^.Left);
      RemoveNodeWithChilds(aNode^.Right);
      aNode^.Data := Default(TEntry);
      FNodeManager.DisposeNode(aNode);
      Dec(FCount);
    end;
end;

constructor TGCustomAvlTree.Create;
begin
  FNodeManager := TNodeManager.Create;
  FNodeManager.EnsureFreeCount(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGCustomAvlTree.Create(aCapacity: SizeInt);
begin
  FNodeManager := TNodeManager.Create;
  if aCapacity > 0 then
    FNodeManager.EnsureFreeCount(aCapacity);
end;

destructor TGCustomAvlTree.Destroy;
begin
  ClearTree;
  FNodeManager.Free;
  inherited;
end;

procedure TGCustomAvlTree.Clear;
begin
  ClearTree;
  FNodeManager.Clear;
end;

procedure TGCustomAvlTree.EnsureCapacity(aValue: SizeInt);
begin
  if aValue > Capacity then
    FNodeManager.EnsureFreeCount(aValue - Count);
end;

procedure TGCustomAvlTree.TrimToFit;
begin
  if Count > 0 then
    FNodeManager.ClearFreeList
  else
    FNodeManager.Clear;
end;

function TGCustomAvlTree.FindOrAdd(constref aKey: TKey; out aNode: PNode): Boolean;
var
  ParentNode: PNode;
begin
  aNode := FindNode(aKey, ParentNode);
  Result := aNode <> nil;
  if not Result then
    begin
      aNode := NewNode;
      aNode^.Data.Key := aKey;
      InsertNodeAt(aNode, ParentNode);
    end;
end;

function TGCustomAvlTree.Add(constref aData: TEntry): PNode;
begin
  Result := NewNode;
  Result^.Data := aData;
  InsertNode(Result);
end;

function TGCustomAvlTree.Remove(constref aKey: TKey): Boolean;
var
  Node: PNode;
begin
  Node := Find(aKey);
  Result := Node <> nil;
  if Result then
    DoRemoveNode(Node);
end;

procedure TGCustomAvlTree.RemoveNode(aNode: PNode);
begin
  if aNode <> nil then
    DoRemoveNode(aNode);
end;

function TGCustomAvlTree.GetEnumerator: TEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

function TGCustomAvlTree.GetReverseEnumerator: TEnumerator;
begin
  Result := TReverseEnumerator.Create(Self);
end;

function TGCustomAvlTree.GetEnumeratorAt(constref aKey: TKey; aInclusive: Boolean): TEnumeratorAt;
begin
  if aInclusive then
    Result := TEnumeratorAt.Create(FindGreaterOrEqual(aKey))
  else
    Result := TEnumeratorAt.Create(FindGreater(aKey))
end;

function TGCustomAvlTree.RemoveIf(aTest: TTest; aOnRemove: TEntryEvent): SizeInt;
var
  CurrNode, NextNode: PNode;
begin
  CurrNode := Lowest;
  Result := 0;
  while CurrNode <> nil do
    begin
      NextNode := CurrNode^.Successor;
      if aTest(CurrNode^.Data.Key) then
        begin
          if aOnRemove <> nil then
            aOnRemove(@CurrNode^.Data);
          DoRemoveNode(CurrNode);
          Inc(Result);
        end;
      CurrNode := NextNode;
    end;
end;

function TGCustomAvlTree.RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent): SizeInt;
var
  CurrNode, NextNode: PNode;
begin
  CurrNode := Lowest;
  Result := 0;
  while CurrNode <> nil do
    begin
      NextNode := CurrNode^.Successor;
      if aTest(CurrNode^.Data.Key) then
        begin
          if aOnRemove <> nil then
            aOnRemove(@CurrNode^.Data);
          DoRemoveNode(CurrNode);
          Inc(Result);
        end;
      CurrNode := NextNode;
    end;
end;

function TGCustomAvlTree.RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent): SizeInt;
var
  CurrNode, NextNode: PNode;
begin
  CurrNode := Lowest;
  Result := 0;
  while CurrNode <> nil do
    begin
      NextNode := CurrNode^.Successor;
      if aTest(CurrNode^.Data.Key) then
        begin
          if aOnRemove <> nil then
            aOnRemove(@CurrNode^.Data);
          DoRemoveNode(CurrNode);
          Inc(Result);
        end;
      CurrNode := NextNode;
    end;
end;

function TGCustomAvlTree.RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent): SizeInt;
var
  CurrNode, NextNode: PNode;
begin
  CurrNode := Lowest;
  Result := 0;
  while CurrNode <> nil do
    begin
      NextNode := CurrNode^.Successor;
      if aTest(@CurrNode^.Data) then
        begin
          if aOnRemove <> nil then
            aOnRemove(@CurrNode^.Data);
          DoRemoveNode(CurrNode);
          Inc(Result);
        end;
      CurrNode := NextNode;
    end;
end;

{ TGAvlTree }

function TGAvlTree.FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode;
var
  c: SizeInt;
begin
  Result := FRoot;
  aInsertPos := nil;
  while Result <> nil do
    begin
      c := TKeyCmpRel.Compare(aKey, Result^.Data.Key);
      aInsertPos := Result;
      if c < 0 then
        Result := Result^.Left
      else
        if c > 0 then
          Result := Result^.Right
        else
          break;
    end;
end;

function TGAvlTree.FindInsertPos(constref aKey: TKey): PNode;
begin
  Result := FRoot;
  while Result <> nil do
    if TKeyCmpRel.Compare(aKey, Result^.Data.Key) < 0 then
      begin
        if Result^.Left <> nil then
          Result := Result^.Left
        else
          break;
      end
    else
      begin
        if Result^.Right <> nil then
          Result := Result^.Right
        else
          break;
      end;
end;

procedure TGAvlTree.InsertNode(aNode: PNode);
var
  ParentNode: PNode;
begin
  if FRoot <> nil then
    begin
      ParentNode := FindInsertPos(aNode^.Data.Key);
      aNode^.Parent := ParentNode;
      if TKeyCmpRel.Compare(aNode^.Data.Key, ParentNode^.Data.Key) < 0 then
        ParentNode^.Left := aNode
      else
        ParentNode^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

procedure TGAvlTree.InsertNodeAt(aNode, aParent: PNode);
begin
  if aParent <> nil then
    begin
      aNode^.Parent := aParent;
      if TKeyCmpRel.Compare(aNode^.Data.Key, aParent^.Data.Key) < 0 then
        aParent^.Left := aNode
      else
        aParent^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

function TGAvlTree.Clone: TGAvlTree;
var
  p: PNode;
begin
  Result := TGAvlTree.Create(Count);
  for p in Self do
    Result.Add(p^.Data);
end;

function TGAvlTree.Find(constref aKey: TKey): PNode;
var
  c: SizeInt;
begin
  Result := FRoot;
  while Result <> nil do
    begin
      c := TKeyCmpRel.Compare(aKey, Result^.Data.Key);
      if c < 0 then
        Result := Result^.Left
      else
        if c > 0 then
          Result := Result^.Right
        else
          break;
    end;
end;

function TGAvlTree.FindLess(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if TKeyCmpRel.Compare(aKey, Node^.Data.Key) > 0 then
      begin
        Result := Node;
        Node := Node^.Right;
      end
    else
      Node := Node^.Left;
end;

function TGAvlTree.FindLessOrEqual(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if TKeyCmpRel.Compare(aKey, Node^.Data.Key) >= 0 then
      begin
        Result := Node;
        Node := Node^.Right;
      end
    else
      Node := Node^.Left;
end;

function TGAvlTree.FindGreater(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if TKeyCmpRel.Compare(aKey, Node^.Data.Key) < 0 then
      begin
        Result := Node;
        Node := Node^.Left;
      end
    else
      Node := Node^.Right;
end;

function TGAvlTree.FindGreaterOrEqual(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if TKeyCmpRel.Compare(aKey, Node^.Data.Key) <= 0 then
      begin
        Result := Node;
        Node := Node^.Left;
      end
    else
      Node := Node^.Right;
end;

{ TGComparableAvlTree }

function TGComparableAvlTree.FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode;
begin
  Result := FRoot;
  aInsertPos := nil;
  while Result <> nil do
    begin
      aInsertPos := Result;
      if aKey < Result^.Data.Key then
        Result := Result^.Left
      else
        if aKey > Result^.Data.Key then
          Result := Result^.Right
        else
          break;
    end;
end;

function TGComparableAvlTree.FindInsertPos(constref aKey: TKey): PNode;
begin
  Result := FRoot;
  while Result <> nil do
    if aKey < Result^.Data.Key then
      begin
        if Result^.Left <> nil then
          Result := Result^.Left
        else
          break;
      end
    else
      begin
        if Result^.Right <> nil then
          Result := Result^.Right
        else
          break;
      end;
end;

procedure TGComparableAvlTree.InsertNode(aNode: PNode);
// If there are already exist nodes with the same value it will be inserted rightmost
var
  ParentNode: PNode;
begin
  if FRoot <> nil then
    begin
      ParentNode := FindInsertPos(aNode^.Data.Key);
      aNode^.Parent := ParentNode;
      if aNode^.Data.Key < ParentNode^.Data.Key then
        ParentNode^.Left := aNode
      else
        ParentNode^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

procedure TGComparableAvlTree.InsertNodeAt(aNode, aParent: PNode);
begin
  if aParent <> nil then
    begin
      aNode^.Parent := aParent;
      if aNode^.Data.Key < aParent^.Data.Key then
        aParent^.Left := aNode
      else
        aParent^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

function TGComparableAvlTree.Clone: TGComparableAvlTree;
var
  p: PNode;
begin
  Result := TGComparableAvlTree.Create(Count);
  for p in Self do
    Result.Add(p^.Data);
end;

function TGComparableAvlTree.Find(constref aKey: TKey): PNode;
begin
  Result := FRoot;
  while Result <> nil do
    if aKey < Result^.Data.Key then
      Result := Result^.Left
    else
      if aKey > Result^.Data.Key then
        Result := Result^.Right
      else
        break;
end;

function TGComparableAvlTree.FindLess(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if aKey > Node^.Data.Key then
      begin
        Result := Node;
        Node := Node^.Right;
      end
    else
      Node := Node^.Left;
end;

function TGComparableAvlTree.FindLessOrEqual(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if aKey >= Node^.Data.Key then
      begin
        Result := Node;
        Node := Node^.Right;
      end
    else
      Node := Node^.Left;
end;

function TGComparableAvlTree.FindGreater(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if aKey < Node^.Data.Key then
      begin
        Result := Node;
        Node := Node^.Left;
      end
    else
      Node := Node^.Right;
end;

function TGComparableAvlTree.FindGreaterOrEqual(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if aKey <= Node^.Data.Key then
      begin
        Result := Node;
        Node := Node^.Left;
      end
    else
      Node := Node^.Right;
end;

{ TGRegularAvlTree }

function TGRegularAvlTree.FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode;
var
  c: SizeInt;
begin
  Result := FRoot;
  aInsertPos := nil;
  while Result <> nil do
    begin
      c := FCompare(aKey, Result^.Data.Key);
      aInsertPos := Result;
      if c < 0 then
        Result := Result^.Left
      else
        if c > 0 then
          Result := Result^.Right
        else
          break;
    end;
end;

function TGRegularAvlTree.FindInsertPos(constref aKey: TKey): PNode;
begin
  Result := FRoot;
  while Result <> nil do
    if FCompare(aKey, Result^.Data.Key) < 0 then
      begin
        if Result^.Left <> nil then
          Result := Result^.Left
        else
          break;
      end
    else
      begin
        if Result^.Right <> nil then
          Result := Result^.Right
        else
          break;
      end;
end;

procedure TGRegularAvlTree.InsertNode(aNode: PNode);
// If there are already exist nodes with the same value it will be inserted rightmost
var
  ParentNode: PNode;
begin
  if FRoot <> nil then
    begin
      ParentNode := FindInsertPos(aNode^.Data.Key);
      aNode^.Parent := ParentNode;
      if FCompare(aNode^.Data.Key, ParentNode^.Data.Key) < 0 then
        ParentNode^.Left := aNode
      else
        ParentNode^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

procedure TGRegularAvlTree.InsertNodeAt(aNode, aParent: PNode);
begin
  if aParent <> nil then
    begin
      aNode^.Parent := aParent;
      if FCompare(aNode^.Data.Key, aParent^.Data.Key) < 0 then
        aParent^.Left := aNode
      else
        aParent^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

constructor TGRegularAvlTree.Create(aCompare: TCompare);
begin
  inherited Create;
  FCompare := aCompare;
end;

constructor TGRegularAvlTree.Create(aCapacity: SizeInt; aCompare: TCompare);
begin
  inherited Create(aCapacity);
  FCompare := aCompare;
end;

function TGRegularAvlTree.Clone: TGRegularAvlTree;
var
  p: PNode;
begin
  Result := TGRegularAvlTree.Create(Count, FCompare);
  for p in Self do
    Result.Add(p^.Data);
end;

function TGRegularAvlTree.Find(constref aKey: TKey): PNode;
var
  c: SizeInt;
begin
  Result := FRoot;
  while Result <> nil do
    begin
      c := FCompare(aKey, Result^.Data.Key);
      if c < 0 then
        Result := Result^.Left
      else
        if c > 0 then
          Result := Result^.Right
        else
          exit;
    end;
end;

function TGRegularAvlTree.FindLess(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if FCompare(aKey, Node^.Data.Key) > 0 then
      begin
        Result := Node;
        Node := Node^.Right;
      end
    else
      Node := Node^.Left;
end;

function TGRegularAvlTree.FindLessOrEqual(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if FCompare(aKey, Node^.Data.Key) >= 0 then
      begin
        Result := Node;
        Node := Node^.Right;
      end
    else
      Node := Node^.Left;
end;

function TGRegularAvlTree.FindGreater(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if FCompare(aKey, Node^.Data.Key) < 0 then
      begin
        Result := Node;
        Node := Node^.Left;
      end
    else
      Node := Node^.Right;
end;

function TGRegularAvlTree.FindGreaterOrEqual(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if FCompare(aKey, Node^.Data.Key) <= 0 then
      begin
        Result := Node;
        Node := Node^.Left;
      end
    else
      Node := Node^.Right;
end;

{ TGDelegatedAvlTree }

function TGDelegatedAvlTree.FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode;
var
  c: SizeInt;
begin
  Result := FRoot;
  aInsertPos := nil;
  while Result <> nil do
    begin
      c := FCompare(aKey, Result^.Data.Key);
      aInsertPos := Result;
      if c < 0 then
        Result := Result^.Left
      else
        if c > 0 then
          Result := Result^.Right
        else
          break;
    end;
end;

function TGDelegatedAvlTree.FindInsertPos(constref aKey: TKey): PNode;
begin
  Result := FRoot;
  while Result <> nil do
    if FCompare(aKey, Result^.Data.Key) < 0 then
      begin
        if Result^.Left <> nil then
          Result := Result^.Left
        else
          break;
      end
    else
      begin
        if Result^.Right <> nil then
          Result := Result^.Right
        else
          break;
      end;
end;

procedure TGDelegatedAvlTree.InsertNode(aNode: PNode);
// If there are already exist nodes with the same value it will be inserted rightmost
var
  ParentNode: PNode;
begin
  if FRoot <> nil then
    begin
      ParentNode := FindInsertPos(aNode^.Data.Key);
      aNode^.Parent := ParentNode;
      if FCompare(aNode^.Data.Key, ParentNode^.Data.Key) < 0 then
        ParentNode^.Left := aNode
      else
        ParentNode^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

procedure TGDelegatedAvlTree.InsertNodeAt(aNode, aParent: PNode);
begin
  if aParent <> nil then
    begin
      aNode^.Parent := aParent;
      if FCompare(aNode^.Data.Key, aParent^.Data.Key) < 0 then
        aParent^.Left := aNode
      else
        aParent^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

constructor TGDelegatedAvlTree.Create(aCompare: TOnCompare);
begin
  inherited Create;
  FCompare := aCompare;
end;

constructor TGDelegatedAvlTree.Create(aCapacity: SizeInt; aCompare: TOnCompare);
begin
  inherited Create(aCapacity);
  FCompare := aCompare;
end;

function TGDelegatedAvlTree.Clone: TGDelegatedAvlTree;
var
  p: PNode;
begin
  Result := TGDelegatedAvlTree.Create(Count, FCompare);
  for p in Self do
    Result.Add(p^.Data);
end;

function TGDelegatedAvlTree.Find(constref aKey: TKey): PNode;
var
  c: SizeInt;
begin
  Result := FRoot;
  while Result <> nil do
    begin
      c := FCompare(aKey, Result^.Data.Key);
      if c < 0 then
        Result := Result^.Left
      else
        if c > 0 then
          Result := Result^.Right
        else
          exit;
    end;
end;

function TGDelegatedAvlTree.FindLess(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if FCompare(aKey, Node^.Data.Key) > 0 then
      begin
        Result := Node;
        Node := Node^.Right;
      end
    else
      Node := Node^.Left;
end;

function TGDelegatedAvlTree.FindLessOrEqual(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if FCompare(aKey, Node^.Data.Key) >= 0 then
      begin
        Result := Node;
        Node := Node^.Right;
      end
    else
      Node := Node^.Left;
end;

function TGDelegatedAvlTree.FindGreater(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if FCompare(aKey, Node^.Data.Key) < 0 then
      begin
        Result := Node;
        Node := Node^.Left;
      end
    else
      Node := Node^.Right;
end;

function TGDelegatedAvlTree.FindGreaterOrEqual(constref aKey: TKey): PNode;
var
  Node: PNode;
begin
  Node := FRoot;
  Result := nil;
  while Node <> nil do
    if FCompare(aKey, Node^.Data.Key) <= 0 then
      begin
        Result := Node;
        Node := Node^.Left;
      end
    else
      Node := Node^.Right;
end;

{$IFNDEF CPU16}
function TGAvlTreeNode.GetBalance: SizeInt;
begin
  Assert((FParent and 3) <> 0, Format('Inconsistent internal Balance value(%d)', [FParent and 3]));
  Result := (FParent and 3) - 2;
end;

function TGAvlTreeNode.GetParent: PNode;
begin
  Result := {%H-}Pointer(FParent and not SizeInt(3));
end;

procedure TGAvlTreeNode.SetBalance(aValue: SizeInt);
begin
  Assert((aValue + 2) in [1..3],
    Format('Inconsistent input Balance value(%d) in '+{$I %CURRENTROUTINE%}, [aValue]));
  FParent := (FParent and not SizeInt(3)) or ((aValue + 2) and 3);
end;

procedure TGAvlTreeNode.SetParent(aValue: PNode);
begin
  Assert({%H-}SizeUint(aValue) and 3 = 0,
    Format('Unaligned input Parent value($%x) in '+{$I %CURRENTROUTINE%}, [aValue]));
  FParent := {%H-}SizeInt(aValue) or (FParent and 3);
end;

procedure TGAvlTreeNode.SwapBalance(aNode: PNode);
var
  b: SizeInt;
begin
  b := FParent and 3;
  FParent := (FParent and not SizeInt(3)) or (aNode^.FParent and 3);
  aNode^.FParent := (aNode^.FParent and not SizeInt(3)) or b;
end;
{$ELSE !CPU16}
procedure TGAvlTreeNode.SwapBalance(aNode: PNode);
var
  b: SizeInt;
begin
  b := Balance;
  Balance := aNode^.Balance;
  aNode^.Balance := b;
end;
{$ENDIF !CPU16}

function TGAvlTreeNode.Successor: PNode;
begin
  Result := Right;
  if Result <> nil then
    while Result^.Left <> nil do
      Result := Result^.Left
  else
    begin
      Result := @Self;
      while (Result^.Parent <> nil) and (Result^.Parent^.Right = Result) do
        Result := Result^.Parent;
      Result := Result^.Parent;
    end;
end;

function TGAvlTreeNode.Predecessor: PNode;
begin
  Result := Left;
  if Result <> nil then
    while Result^.Right <> nil do
      Result := Result^.Right
  else
    begin
      Result := @Self;
      while (Result^.Parent <> nil) and (Result^.Parent^.Left = Result) do
        Result := Result^.Parent;
      Result := Result^.Parent;
    end;
end;

{ TGAvlTree2.TEnumerator }

function TGAvlTree2.TEnumerator.GetCurrent: PEntry;
begin
  Result := @FCurrNode^.Data;
end;

procedure TGAvlTree2.TEnumerator.Init(aTree: TGAvlTree2);
begin
  FTree := aTree;
  Reset;
end;

function TGAvlTree2.TEnumerator.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Successor
  else
    if not FInCycle then
      begin
        NextNode := FTree.Lowest;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

procedure TGAvlTree2.TEnumerator.Reset;
begin
  FCurrNode := nil;
  FInCycle := False;
end;

{ TGAvlTree2 }

function TGAvlTree2.NewNode: PNode;
begin
  Result := FNodeManager.NewNode;
  Result^.Balance := 0;
  Inc(FCount);
end;

procedure TGAvlTree2.DisposeNode(aNode: PNode);
begin
  if aNode <> nil then
    begin
      aNode^ := Default(TNode);
      FNodeManager.FreeNode(aNode);
      Dec(FCount);
    end;
end;

procedure TGAvlTree2.ClearTree;
begin
  RemoveNodeWithChilds(FRoot);
  FRoot := nil;
end;

function TGAvlTree2.GetHighest: PNode;
begin
  Result := FRoot;
  if Result <> nil then
    while Result^.Right <> nil do
      Result := Result^.Right;
end;

function TGAvlTree2.GetLowest: PNode;
begin
  Result := FRoot;
  if Result <> nil then
    while Result^.Left <> nil do
      Result := Result^.Left;
end;

function TGAvlTree2.FindNode(constref aKey: TKey; out aInsertPos: PNode): PNode;
var
  c: SizeInt;
begin
  Result := FRoot;
  aInsertPos := nil;
  while Result <> nil do
    begin
      c := TKeyCmpRel.Compare(aKey, Result^.Data.Key);
      aInsertPos := Result;
      if c < 0 then
        Result := Result^.Left
      else
        if c > 0 then
          Result := Result^.Right
        else
          break;
    end;
end;

function TGAvlTree2.FindInsertPos(constref aKey: TKey): PNode;
begin
  Result := FRoot;
  while Result <> nil do
    if TKeyCmpRel.Compare(aKey, Result^.Data.Key) < 0 then
      begin
        if Result^.Left <> nil then
          Result := Result^.Left
        else
          break;
      end
    else
      begin
        if Result^.Right <> nil then
          Result := Result^.Right
        else
          break;
      end;
end;

procedure TGAvlTree2.InsertNode(aNode: PNode);
var
  ParentNode: PNode;
begin
  if FRoot <> nil then
    begin
      ParentNode := FindInsertPos(aNode^.Data.Key);
      aNode^.Parent := ParentNode;
      if TKeyCmpRel.Compare(aNode^.Data.Key, ParentNode^.Data.Key) < 0 then
        ParentNode^.Left := aNode
      else
        ParentNode^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

procedure TGAvlTree2.InsertNodeAt(aNode, aParent: PNode);
begin
  if aParent <> nil then
    begin
      aNode^.Parent := aParent;
      if TKeyCmpRel.Compare(aNode^.Data.Key, aParent^.Data.Key) < 0 then
        aParent^.Left := aNode
      else
        aParent^.Right := aNode;
      BalanceAfterInsert(aNode);
    end
  else
    begin
      FRoot := aNode;
      aNode^.Parent := nil;
    end;
end;

procedure TGAvlTree2.ReplaceWithSuccessor(aNode: PNode);
var
  SuccNode, OldParent, OldLeft, OldRight,
  OldSuccParent, OldSuccLeft, OldSuccRight: PNode;
begin
  SuccNode := aNode^.Successor;
  aNode^.SwapBalance(SuccNode);

  OldParent := aNode^.Parent;
  OldLeft := aNode^.Left;
  OldRight := aNode^.Right;
  OldSuccParent := SuccNode^.Parent;
  OldSuccLeft := SuccNode^.Left;
  OldSuccRight := SuccNode^.Right;

  if OldParent <> nil then
    begin
      if OldParent^.Left = aNode then
        OldParent^.Left := SuccNode
      else
        OldParent^.Right := SuccNode;
    end
  else
    FRoot := SuccNode;

  SuccNode^.Parent := OldParent;

  if OldSuccParent <> aNode then
    begin
      if OldSuccParent^.Left = SuccNode then
        OldSuccParent^.Left := aNode
      else
        OldSuccParent^.Right := aNode;
      SuccNode^.Right := OldRight;
      aNode^.Parent := OldSuccParent;
      if OldRight <> nil then
        OldRight^.Parent := SuccNode;
    end
  else
    begin
      SuccNode^.Right := aNode;
      aNode^.Parent := SuccNode;
    end;

  aNode^.Left := OldSuccLeft;
  if OldSuccLeft <> nil then
    OldSuccLeft^.Parent := aNode;
  aNode^.Right := OldSuccRight;
  if OldSuccRight <> nil then
    OldSuccRight^.Parent := aNode;
  SuccNode^.Left := OldLeft;
  if OldLeft <> nil then
    OldLeft^.Parent := SuccNode;
end;

procedure TGAvlTree2.DoRemoveNode(aNode: PNode);
var
  OldParent, Child: PNode;
begin
  if (aNode^.Left <> nil) and (aNode^.Right <> nil) then
    ReplaceWithSuccessor(aNode);
  OldParent := aNode^.Parent;
  aNode^.Parent := nil;
  if aNode^.Left <> nil then
    Child := aNode^.Left
  else
    Child := aNode^.Right;
  if Child <> nil then
    Child^.Parent := OldParent;
  if OldParent <> nil then
    begin
      if OldParent^.Left = aNode then
        begin
          OldParent^.Left := Child;
          BalanceAfterRemove(OldParent, Succ(OldParent^.Balance));
        end
      else
        begin
          OldParent^.Right := Child;
          BalanceAfterRemove(OldParent, Pred(OldParent^.Balance));
        end;
    end
  else
    FRoot := Child;
  DisposeNode(aNode);
end;

procedure TGAvlTree2.BalanceAfterInsert(aNode: PNode);
var
  OldParent, OldChild: PNode;
begin
  OldParent := aNode^.Parent;
  while OldParent <> nil do
    if OldParent^.Left = aNode then //aNode is left child => we need decrease OldParent^.Balance
      case OldParent^.Balance of
        -1:
          begin
            if aNode^.Balance = -1 then
              begin
                RotateRight(OldParent);
                aNode^.Balance := 0;
                OldParent^.Balance := 0;
              end
            else
              begin
                OldChild := aNode^.Right;
                RotateLeft(aNode);
                RotateRight(OldParent);
                case OldChild^.Balance of
                  -1:
                    begin
                      aNode^.Balance := 0;
                      OldParent^.Balance := 1;
                    end;
                  0:
                    begin
                      aNode^.Balance := 0;
                      OldParent^.Balance := 0
                    end;
                else //1
                  aNode^.Balance := -1;
                  OldParent^.Balance := 0;
                end;
                OldChild^.Balance := 0;
              end;
            break;
          end;
         0:
          begin
            OldParent^.Balance := -1;
            aNode := OldParent;
            OldParent := aNode^.Parent;
          end;
      else //1
        OldParent^.Balance := 0;
        break;
      end
    else  // aNode is right child => we need increase OldParent^.Balance
      case OldParent^.Balance of
       -1:
         begin
           OldParent^.Balance := 0;
           break;
         end;
        0:
          begin
            OldParent^.Balance := 1;
            aNode := OldParent;
            OldParent := aNode^.Parent;
          end;
      else // 1
        if aNode^.Balance = 1 then
          begin
            RotateLeft(OldParent);
            aNode^.Balance := 0;
            OldParent^.Balance := 0;
          end
        else
          begin
            OldChild := aNode^.Left;
            RotateRight(aNode);
            RotateLeft(OldParent);
            case OldChild^.Balance of
              -1:
                begin
                  aNode^.Balance := 1;
                  OldParent^.Balance := 0;
                end;
              0:
                begin
                  aNode^.Balance := 0;
                  OldParent^.Balance := 0;
                end;
            else  //1
              aNode^.Balance := 0;
              OldParent^.Balance := -1
            end;
            OldChild^.Balance := 0;
          end;
        break;
      end;
end;

procedure TGAvlTree2.BalanceAfterRemove(aNode: PNode; aNodeBalance: SizeInt);
var
  OldParent, Child, ChildOfChild: PNode;
begin
  while aNode <> nil do
    begin
      OldParent := aNode^.Parent;
      case aNodeBalance of
        -2:
          begin
            Child := aNode^.Left;
            if Child^.Balance <= 0 then
              begin
                RotateRight(aNode);
                aNode^.Balance := -Succ(Child^.Balance);
                aNodeBalance := Succ(Child^.Balance);
                aNode := Child;
                Child^.Balance := aNodeBalance;
              end
            else
              begin
                ChildOfChild := Child^.Right;
                RotateLeft(Child);
                RotateRight(aNode);
                case ChildOfChild^.Balance of
                  -1:
                    begin
                      aNode^.Balance := 1;
                      Child^.Balance := 0;
                    end;
                   0:
                     begin
                       aNode^.Balance := 0;
                       Child^.Balance := 0;
                     end;
                else // 1
                  aNode^.Balance := 0;
                  Child^.Balance := -1;
                end;
                aNode := ChildOfChild;
                aNodeBalance := 0;
                ChildOfChild^.Balance := 0;
              end;
          end;
        -1:
          begin
            aNode^.Balance := aNodeBalance;
            break;
          end;
         0:
           begin
             aNode^.Balance := aNodeBalance;
             if OldParent <> nil then
               begin
                 if OldParent^.Left = aNode then
                   aNodeBalance := Succ(OldParent^.Balance)
                 else
                   aNodeBalance := Pred(OldParent^.Balance);
                 aNode := OldParent;
               end
             else
               break;
           end;
         1:
           begin
             aNode^.Balance := aNodeBalance;
             break;
           end;
         2:
           begin
             Child := aNode^.Right;
             if Child^.Balance >= 0 then
               begin
                 RotateLeft(aNode);
                 aNode^.Balance := SizeInt(1) - Child^.Balance;
                 aNodeBalance := Pred(Child^.Balance);
                 aNode := Child;
                 Child^.Balance := aNodeBalance;
               end
             else
               begin
                 ChildOfChild := Child^.Left;
                 RotateRight(Child);
                 RotateLeft(aNode);
                 case ChildOfChild^.Balance of
                   -1:
                     begin
                       aNode^.Balance := 0;
                       Child^.Balance := 1;
                     end;
                    0:
                      begin
                        aNode^.Balance := 0;
                        Child^.Balance := 0;
                      end;
                 else // 1
                   aNode^.Balance := -1;
                   Child^.Balance := 0;
                 end;
                 ChildOfChild^.Balance := 0;
                 aNode := ChildOfChild;
                 aNodeBalance := 0;
               end;
           end;
      end;
    end;
end;

procedure TGAvlTree2.RotateLeft(aNode: PNode);
var
  OldParent, OldRight, OldRightLeft: PNode;
begin
  OldRight := aNode^.Right;
  OldRightLeft := OldRight^.Left;
  OldParent := aNode^.Parent;
  if OldParent <> nil then
    begin
      if OldParent^.Left = aNode then
        OldParent^.Left := OldRight
      else
        OldParent^.Right := OldRight;
    end
  else
    FRoot := OldRight;
  OldRight^.Parent := OldParent;
  aNode^.Parent := OldRight;
  aNode^.Right := OldRightLeft;
  if OldRightLeft <> nil then
    OldRightLeft^.Parent := aNode;
  OldRight^.Left := aNode;
end;

procedure TGAvlTree2.RotateRight(aNode: PNode);
var
  OldParent, OldLeft, OldLeftRight: PNode;
begin
  OldLeft := aNode^.Left;
  OldLeftRight := OldLeft^.Right;
  OldParent := aNode^.Parent;
  if OldParent <> nil then
    begin
      if OldParent^.Left = aNode then
        OldParent^.Left := OldLeft
      else
        OldParent^.Right := OldLeft;
    end
  else
    FRoot := OldLeft;
  OldLeft^.Parent := OldParent;
  aNode^.Parent := OldLeft;
  aNode^.Left := OldLeftRight;
  if OldLeftRight <> nil then
    OldLeftRight^.Parent := aNode;
  OldLeft^.Right := aNode;
end;

procedure TGAvlTree2.RemoveNodeWithChilds(aNode: PNode);
begin
  if aNode <> nil then
    begin
      RemoveNodeWithChilds(aNode^.Left);
      RemoveNodeWithChilds(aNode^.Right);
      aNode^.Data := Default(TEntry);
      DisposeNode(aNode);
    end;
end;

constructor TGAvlTree2.Create(aNodeManager: TNodeManager);
begin
  FNodeManager := aNodeManager;
end;

destructor TGAvlTree2.Destroy;
begin
  ClearTree;
  inherited;
end;

function TGAvlTree2.GetEnumerator: TEnumerator;
begin
  Result.Init(Self);
end;

procedure TGAvlTree2.Clear;
begin
  ClearTree;
end;

function TGAvlTree2.FindOrAdd(constref aKey: TKey; out aNode: PNode): Boolean;
var
  ParentNode: PNode;
begin
  aNode := FindNode(aKey, ParentNode);
  Result := aNode <> nil;
  if not Result then
    begin
      aNode := NewNode;
      aNode^.Data.Key := aKey;
      InsertNodeAt(aNode, ParentNode);
    end;
end;

function TGAvlTree2.Find(constref aKey: TKey): PNode;
var
  c: SizeInt;
begin
  Result := FRoot;
  while Result <> nil do
    begin
      c := TKeyCmpRel.Compare(aKey, Result^.Data.Key);
      if c < 0 then
        Result := Result^.Left
      else
        if c > 0 then
          Result := Result^.Right
        else
          break;
    end;
end;

function TGAvlTree2.Remove(constref aKey: TKey): Boolean;
var
  Node: PNode;
begin
  Node := Find(aKey);
  Result := Node <> nil;
  if Result then
    DoRemoveNode(Node);
end;

procedure TGAvlTree2.RemoveNode(aNode: PNode);
begin
  if aNode <> nil then
    DoRemoveNode(aNode);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic bijective map implementation on top of hash table.              *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGBiMap;

{$mode objfpc}{$H+}
{$INLINE ON}

interface

uses
  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGHashTable,
  LGStrConst;

type

{$PUSH}{$INTERFACES CORBA}
  generic IGInverseMap<TKey, TValue> = interface
  ['{12C18769-51E6-4FA8-8AC7-904B46B86D9F}']
    function  _GetRef: TObject;
    function  GetCount: SizeInt;
    function  GetCapacity: SizeInt;
    function  GetValue(const aKey: TValue): TKey;
    function  IsEmpty: Boolean;
    function  NonEmpty: Boolean;
    procedure Clear;
    procedure EnsureCapacity(aValue: SizeInt);
  { free unused memory if possible }
    procedure TrimToFit;
  { returns True and add TEntry(aKey, aValue) only if not contains aKey }
    function  Add(constref aKey: TValue; constref aValue: TKey): Boolean; overload;
    procedure AddOrSetValue(const aKey: TValue; const aValue: TKey); overload;
    function  TryGetValue(constref aKey: TValue; out aValue: TKey): Boolean;
    function  GetValueDef(constref aKey: TValue; constref aDefault: TKey = Default(TKey)): TKey;
  { returns True and map aNewValue to aKey only if contains aKey, False otherwise }
    function  Replace(constref aKey: TValue; constref aNewValue: TKey): Boolean;
    function  Contains(constref aKey: TValue): Boolean;
    function  Extract(constref aKey: TValue; out v: TKey): Boolean;
    function  Remove(constref aKey: TValue): Boolean;
    procedure RetainAll(c: specialize IGCollection<TValue>);
    function  Keys: specialize IGEnumerable<TValue>;
    function  Values: specialize IGEnumerable<TKey>;
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
  { reading will raise ELGMapError if an aKey is not present in map }
    property  Items[const aKey: TValue]: TKey read GetValue write AddOrSetValue; default;
  end;
{$POP}

  { TGHashBiMap implements bijective map(i.e. a one-to-one correspondence between keys and values)
     on top of hashtable;

      functor TKeyEqRel(key equality relation) must provide:
        class function HashCode([const[ref]] k: TKey): SizeInt;
        class function Equal([const[ref]] L, R: TKey): Boolean;

      functor TValueEqRel(value equality relation) must provide:
        class function HashCode([const[ref]] v: TValue): SizeInt;
        class function Equal([const[ref]] L, R: TValue): Boolean;  }
  generic TGHashBiMap<TKey, TValue, TKeyEqRel, TValueEqRel> = class(TCustomIterable,
    specialize IGMap<TKey, TValue>, specialize IGInverseMap<TKey, TValue>)
  {must be  generic TGHashBiMap<TKey, TValue> = class abstract(
              specialize TGContainer<specialize TGMapEntry<TKey, TValue>>), but :( ... }
  public
  type
    THashBiMap       = specialize TGHashBiMap<TKey, TValue, TKeyEqRel, TValueEqRel>;
    TEntry           = specialize TGMapEntry<TKey, TValue>;
    TInverseEntry    = specialize TGMapEntry<TValue, TKey>;
    IKeyEnumerable   = specialize IGEnumerable<TKey>;
    IValueEnumerable = specialize IGEnumerable<TValue>;
    IEntryEnumerable = specialize IGEnumerable<TEntry>;
    TEntryArray      = specialize TGArray<TEntry>;
    TKeyCollection   = specialize TGCustomCollection<TKey>;
    TValueCollection = specialize TGCustomCollection<TValue>;
    IKeyCollection   = specialize IGCollection<TKey>;
    IValueCollection = specialize IGCollection<TValue>;
    IInverseMap      = specialize IGInverseMap<TKey, TValue>;
    EBiMapError      = class(Exception);

  protected
  type
    PKeyNode   = ^TKeyNode;
    PValueNode = ^TValueNode;

    TKeyEntry  = record
      Key: TKey;
      ValueNode: PValueNode;
    end;
    PKeyEntry = ^TKeyEntry;

    TValEntry = record
      Key: TValue;
      KeyNode: PKeyNode;
    end;
    PValEntry = ^TValEntry;

    TKeySet            = specialize TGChainHashTable<TKey, TKeyEntry, TKeyEqRel>;
    TKeySearchResult   = TKeySet.TSearchResult;
    TKeyNode           = TKeySet.TNode;
    TValueSet          = specialize TGChainHashTable<TValue, TValEntry, TValueEqRel>;
    TValueSearchResult = TValueSet.TSearchResult;
    TValueNode         = TValueSet.TNode;

    TKeyEnumerable = class(specialize TGAutoEnumerable<TKey>)
    protected
      FOwner: TGHashBiMap;
      FEnum:  TKeySet.TEntryEnumerator;
      function GetCurrent: TKey; override;
    public
      constructor Create(aMap: TGHashBiMap);
      destructor Destroy; override;
      function MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TValueEnumerable = class(specialize TGAutoEnumerable<TValue>)
    protected
      FOwner: TGHashBiMap;
      FEnum:  TValueSet.TEntryEnumerator;
      function GetCurrent: TValue; override;
    public
      constructor Create(aMap: TGHashBiMap);
      destructor Destroy; override;
      function MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TEntryEnumerable = class(specialize TGAutoEnumerable<TEntry>)
    protected
      FOwner: TGHashBiMap;
      FEnum:  TKeySet.TEntryEnumerator;
      function GetCurrent: TEntry; override;
    public
      constructor Create(aMap: TGHashBiMap);
      destructor Destroy; override;
      function MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FKeySet: TKeySet;
    FValueSet: TValueSet;
    function  _GetRef: TObject;
    function  GetCount: SizeInt; inline;
    function  GetCapacity: SizeInt; inline;
    function  GetFillRatio: Single; inline;
    function  GetLoadFactor: Single; inline;
    function  GetTableSize: SizeInt; inline;
    procedure SetLoadFactor(aValue: Single);
    procedure KeyRemoving(p: PKeyEntry);
    procedure ValueRemoving(p: PValEntry);
    procedure DoClear; virtual;
    procedure DoEnsureCapacity(aValue: SizeInt);
    procedure DoTrimToFit;
    function  DoAdd(constref aKey: TKey; constref aValue: TValue): Boolean;
    function  DoAddAll(constref a: array of TEntry): SizeInt;
    function  DoAddAll(e: IEntryEnumerable): SizeInt;
    function  TryAddOrSetValue(constref aKey: TKey; constref aValue: TValue): Boolean;
    function  TryAddOrSetKey(constref aValue: TValue; constref aKey: TKey): Boolean;
    procedure DoAddOrSetValue(constref aKey: TKey; constref aValue: TValue);
    procedure DoAddOrSetKey(constref aValue: TValue; constref aKey: TKey);
    function  DoExtractKey(constref aKey: TKey; out v: TValue): Boolean;
    function  DoRemoveKey(constref aKey: TKey): Boolean; virtual;
    function  DoRemoveKeys(constref a: array of TKey): SizeInt;
    function  DoRemoveKeys(e: IKeyEnumerable): SizeInt;
    function  DoExtractValue(constref aValue: TValue; out k: TKey): Boolean; virtual;
    function  DoRemoveValue(constref aValue: TValue): Boolean; virtual;
    function  DoRemoveValues(constref a: array of TValue): SizeInt;
    function  DoRemoveValues(e: IValueEnumerable): SizeInt;
    function  DoReplaceValue(constref aKey: TKey; constref aNewValue: TValue): Boolean; virtual;
    function  DoReplaceKey(constref aValue: TValue; constref aNewKey: TKey): Boolean; virtual;
    procedure DoRetainAll({%H-}c: IKeyCollection); virtual;
    procedure DoRetainAllVal({%H-}c: IValueCollection); virtual;
    function  GetKeys: IKeyEnumerable;
    function  GetValues: IValueEnumerable;
    function  GetEntries: IEntryEnumerable;
    function  AddInverse(constref aValue: TValue; constref aKey: TKey): Boolean;
  { returns True and add e only if keys do not contain e.Key and values do not contain e.Value }
  public
    class function DefaultLoadFactor: Single; static; inline;
    class function MaxLoadFactor: Single; static; inline;
    class function MinLoadFactor: Single; static; inline;
    constructor Create;
    constructor Create(constref a: array of TEntry);
    constructor Create(e: IEntryEnumerable);
    constructor Create(aCapacity: SizeInt);
    constructor Create(aCapacity: SizeInt; constref a: array of TEntry);
    constructor Create(aCapacity: SizeInt; e: IEntryEnumerable);
    constructor CreateCopy(aMap: TGHashBiMap);
    destructor  Destroy; override;
    function  IsEmpty: Boolean;
    function  NonEmpty: Boolean;
    procedure Clear;
    procedure EnsureCapacity(aValue: SizeInt);
    procedure TrimToFit;
    function  Contains(constref aKey: TKey): Boolean; inline;
    function  NonContains(constref aKey: TKey): Boolean; inline;
    function  ContainsValue(constref aValue: TValue): Boolean; inline;
    function  NonContainsValue(constref aValue: TValue): Boolean; inline;
  { will raise ELGMapError if not contains aKey }
    function  GetValue(const aKey: TKey): TValue; inline;
  { will raise ELGMapError if not contains aKey }
    function  GetKey(const aValue: TValue): TKey; inline;
    function  TryGetValue(constref aKey: TKey; out aValue: TValue): Boolean;
    function  TryGetKey(constref aValue: TValue; out aKey: TKey): Boolean;
    function  GetValueDef(constref aKey: TKey; constref aDefault: TValue = Default(TValue)): TValue; inline;
    function  GetKeyDef(constref aValue: TValue; constref aDefault: TKey = Default(TKey)): TKey; inline;
  { returns True and add TEntry(aKey, aValue) only if keys do not contain aKey and
    values do not contain aValue }
    function  Add(constref aKey: TKey; constref aValue: TValue): Boolean;
  { returns True and add e only if keys do not contain e.Key and values do not contain e.Value }
    function  Add(constref e: TEntry): Boolean;
  { will raise ELGMapError if contains aValue }
    procedure AddOrSetValue(const aKey: TKey; const aValue: TValue);
  { will return False if contains aValue }
    function  AddOrSetValue(constref e: TEntry): Boolean;
  { will raise ELGMapError if contains aValue }
    procedure AddOrSetKey(const aValue: TValue; const aKey: TKey);
  { will return False if contains aValue }
    function  AddOrSetKey(constref e: TInverseEntry): Boolean;
  { will add only entries which keys and values are not contained in the map }
    function  AddAll(constref a: array of TEntry): SizeInt;
    function  AddAll(e: IEntryEnumerable): SizeInt;
  { returns True if contains aKey and not contains aNewValue }
    function  Replace(constref aKey: TKey; constref aNewValue: TValue): Boolean;
  { returns True if contains aValue and not contains aNewKey }
    function  ReplaceKey(constref aValue: TValue; constref aNewKey: TKey): Boolean;
    function  Extract(constref aKey: TKey; out v: TValue): Boolean;
    function  ExtractValue(constref aValue: TValue; out k: TKey): Boolean;
  { returns True if aKey contained in the map and removes an aKey from the map }
    function  Remove(constref aKey: TKey): Boolean;
    function  RemoveAll(constref a: array of TKey): SizeInt;
    function  RemoveAll(e: IKeyEnumerable): SizeInt;
  { returns True if aValue contained in the map and removes an aValue from the map }
    function  RemoveValue(constref aValue: TValue): Boolean;
    function  RemoveValues(constref a: array of TValue): SizeInt;
    function  RemoveValues(e: IValueEnumerable): SizeInt;
    procedure RetainAll(c: IKeyCollection);
    procedure RetainAll(c: IValueCollection);
    function  Clone: THashBiMap; virtual;
    function  Keys: IKeyEnumerable;
    function  Values: IValueEnumerable;
    function  Entries: IEntryEnumerable;
  private
    function  IInverseMap.Contains      = ContainsValue;
    function  IInverseMap.NonContains   = NonContainsValue;
    function  IInverseMap.GetValue      = GetKey;
    function  IInverseMap.TryGetValue   = TryGetKey;
    function  IInverseMap.GetValueDef   = GetKeyDef;
    function  IInverseMap.Add           = AddInverse;
    procedure IInverseMap.AddOrSetValue = AddOrSetKey;
    function  IInverseMap.Replace       = ReplaceKey;
    function  IInverseMap.Extract       = ExtractValue;
    function  IInverseMap.Remove        = RemoveValue;
    function  IInverseMap.RetainAll     = RetainAll;
    function  IInverseMap.Keys          = Values;
    function  IInverseMap.Values        = Keys;
  public
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
    property  LoadFactor: Single read GetLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  { will raise ELGMapError if not contains aKey or contains aValue }
    property  Items[const aKey: TKey]: TValue read GetValue write AddOrSetValue; default;
  end;

  { TGHashBiMapK assumes that TKey implements TKeyEqRel }
  generic TGHashBiMapK<TKey, TValue, TValueEqRel> = class(
    specialize TGHashBiMap<TKey, TValue, TKey, TValueEqRel>);

  { TGHashBiMapV assumes that TValue implements TValueEqRel }
  generic TGHashBiMapV<TKey, TValue, TKeyEqRel> = class(
    specialize TGHashBiMap<TKey, TValue, TKeyEqRel, TValue>);

  { TGHashBiMap2 assumes that TKey implements TKeyEqRel and TValue implements TValueEqRel }
  generic TGHashBiMap2<TKey, TValue> = class(specialize TGHashBiMap<TKey, TValue, TKey, TValue>);

  { TGObjectHashBiMap }

  generic TGObjectHashBiMap<TKey, TValue, TKeyEqRel, TValueEqRel> = class(specialize
    TGHashBiMap<TKey, TValue, TKeyEqRel, TValueEqRel>)
  private
    FOwnsKeys: Boolean;
    FOwnsValues: Boolean;
  protected
    procedure SetOwnership(aOwns: TMapObjOwnership); inline;
    procedure KeyRemoving(p: PKeyEntry);
    procedure ValueRemoving(p: PValEntry);
    procedure DoClear; override;
    function  DoRemoveKey(constref aKey: TKey): Boolean; override;
    function  DoRemoveValue(constref aValue: TValue): Boolean; override;
    function  DoReplaceValue(constref aKey: TKey; constref aNewValue: TValue): Boolean; override;
    function  DoReplaceKey(constref aValue: TValue; constref aNewKey: TKey): Boolean; override;
    procedure DoRetainAll({%H-}c: IKeyCollection); override;
    procedure DoRetainAllVal({%H-}c: IValueCollection); override;
  public
    constructor Create(aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(constref a: array of TEntry; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(e: IEntryEnumerable; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; constref a: array of TEntry; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; e: IEntryEnumerable; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor CreateCopy(aMap: TGObjectHashBiMap);
    function  Clone: TGObjectHashBiMap; override;
    property  OwnsKeys: Boolean read FOwnsKeys write FOwnsKeys;
    property  OwnsValues: Boolean read FOwnsValues write FOwnsValues;
  end;

  { TGObjHashBiMapK assumes that TKey implements TKeyEqRel }
  generic TGObjHashBiMapK<TKey, TValue, TValueEqRel> = class(specialize
    TGObjectHashBiMap<TKey, TValue, TKey, TValueEqRel>);

  { TGObjHashBiMapV assumes that TValue implements TValueEqRel }
  generic TGObjHashBiMapV<TKey, TValue, TKeyEqRel> = class(specialize
    TGObjectHashBiMap<TKey, TValue, TKeyEqRel, TValue>);

  { TGObjHashBiMap2 assumes that TKey implements TKeyEqRel and TValue implements TValueEqRel }
  generic TGObjHashBiMap2<TKey, TValue> = class(specialize TGObjectHashBiMap<TKey, TValue, TKey, TValue>);

implementation
{$B-}{$COPERATORS ON}

{ TGHashBiMap.TKeyEnumerable }

function TGHashBiMap.TKeyEnumerable.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Key;
end;

constructor TGHashBiMap.TKeyEnumerable.Create(aMap: TGHashBiMap);
begin
  inherited Create;
  FOwner := aMap;
  FEnum := aMap.FKeySet.GetEnumerator;
end;

destructor TGHashBiMap.TKeyEnumerable.Destroy;
begin
  FOwner.EndIteration;
  FEnum.Free;
  inherited;
end;

function TGHashBiMap.TKeyEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGHashBiMap.TKeyEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGHashBiMap.TValueEnumerable }

function TGHashBiMap.TValueEnumerable.GetCurrent: TValue;
begin
  Result := FEnum.Current^.Key;
end;

constructor TGHashBiMap.TValueEnumerable.Create(aMap: TGHashBiMap);
begin
  inherited Create;
  FOwner := aMap;
  FEnum := aMap.FValueSet.GetEnumerator;
end;

destructor TGHashBiMap.TValueEnumerable.Destroy;
begin
  FOwner.EndIteration;
  FEnum.Free;
  inherited;
end;

function TGHashBiMap.TValueEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGHashBiMap.TValueEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGHashBiMap.TEntryEnumerable }

function TGHashBiMap.TEntryEnumerable.GetCurrent: TEntry;
var
  p: PKeyEntry;
begin
  p := FEnum.Current;
  Result.Key := p^.Key;
  Result.Value := p^.ValueNode^.Data.Key;
end;

constructor TGHashBiMap.TEntryEnumerable.Create(aMap: TGHashBiMap);
begin
  inherited Create;
  FOwner := aMap;
  FEnum := aMap.FKeySet.GetEnumerator;
end;

destructor TGHashBiMap.TEntryEnumerable.Destroy;
begin
  FOwner.EndIteration;
  FEnum.Free;
  inherited;
end;

function TGHashBiMap.TEntryEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGHashBiMap.TEntryEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGBiMap }

function TGHashBiMap._GetRef: TObject;
begin
  Result := Self;
end;

function TGHashBiMap.GetCount: SizeInt;
begin
  Result := FKeySet.Count;
end;

procedure TGHashBiMap.DoClear;
begin
  FKeySet.Clear;
  FValueSet.Clear;
end;

function TGHashBiMap.GetCapacity: SizeInt;
begin
  Result := FKeySet.Capacity;
end;

function TGHashBiMap.GetFillRatio: Single;
begin
  Result := FKeySet.FillRatio;
end;

function TGHashBiMap.GetLoadFactor: Single;
begin
  Result := FKeySet.LoadFactor;
end;

function TGHashBiMap.GetTableSize: SizeInt;
begin
  Result := FKeySet.TableSize;
end;

procedure TGHashBiMap.SetLoadFactor(aValue: Single);
begin
  FKeySet.LoadFactor := aValue;
  FValueSet.LoadFactor := aValue;
end;

procedure TGHashBiMap.KeyRemoving(p: PKeyEntry);
begin
  FValueSet.Remove(p^.ValueNode^.Data.Key);
end;

procedure TGHashBiMap.ValueRemoving(p: PValEntry);
begin
  FKeySet.Remove(p^.KeyNode^.Data.Key);
end;

procedure TGHashBiMap.DoEnsureCapacity(aValue: SizeInt);
begin
  FKeySet.EnsureCapacity(aValue);
  FValueSet.EnsureCapacity(aValue);
end;

procedure TGHashBiMap.DoTrimToFit;
begin
  FKeySet.TrimToFit;
  FValueSet.TrimToFit;
end;

function TGHashBiMap.DoAdd(constref aKey: TKey; constref aValue: TValue): Boolean;
var
  pk: PKeyNode;
  pv: PValueNode;
begin
  if Contains(aKey) or ContainsValue(aValue) then
    exit(False);

  pk := FKeySet.Add(aKey);
  pv := FValueSet.Add(aValue);

  pk^.Data.Key := aKey;
  pk^.Data.ValueNode := pv;
  pv^.Data.Key := aValue;
  pv^.Data.KeyNode := pk;
  Result := True;
end;

function TGHashBiMap.DoAddAll(constref a: array of TEntry): SizeInt;
var
  e: TEntry;
begin
  Result := Count;
  for e in a do
    DoAdd(e.Key, e.Value);
  Result := Count - Result;
end;

function TGHashBiMap.DoAddAll(e: IEntryEnumerable): SizeInt;
var
  Entry: TEntry;
begin
  Result := Count;
  for Entry in e do
    DoAdd(Entry.Key, Entry.Value);
  Result := Count - Result;
end;

function TGHashBiMap.TryAddOrSetValue(constref aKey: TKey; constref aValue: TValue): Boolean;
begin
  Result := not ContainsValue(aValue);
  if Result then
    if Contains(aKey) then
      DoReplaceValue(aKey, aValue)
    else
      DoAdd(aKey, aValue);
end;

function TGHashBiMap.TryAddOrSetKey(constref aValue: TValue; constref aKey: TKey): Boolean;
begin
  Result := not Contains(aKey);
  if Result then
    if ContainsValue(aValue) then
      DoReplaceKey(aValue, aKey)
    else
      DoAdd(aKey, aValue);
end;

procedure TGHashBiMap.DoAddOrSetValue(constref aKey: TKey; constref aValue: TValue);
begin
  if not TryAddOrSetValue(aKey, aValue) then
    raise ELGMapError.Create(SEValueAlreadyExist);
end;

procedure TGHashBiMap.DoAddOrSetKey(constref aValue: TValue; constref aKey: TKey);
begin
  if not TryAddOrSetKey(aValue, aKey) then
    raise ELGMapError.Create(SEKeyAlreadyExist);
end;

function TGHashBiMap.DoExtractKey(constref aKey: TKey; out v: TValue): Boolean;
var
  srk: TKeySearchResult;
  pk: PKeyEntry;
begin
  pk := FKeySet.Find(aKey, srk);
  Result := pk <> nil;
  if Result then
    begin
      v := pk^.ValueNode^.Data.Key;
      if not FValueSet.Remove(pk^.ValueNode^.Data.Key) then
        raise EBiMapError.Create(SEInternalDataInconsist);
      FKeySet.RemoveAt(srk);
    end;
end;

function TGHashBiMap.DoRemoveKey(constref aKey: TKey): Boolean;
var
  v: TValue;
begin
  Result := DoExtractKey(aKey, v);
end;

function TGHashBiMap.DoRemoveKeys(constref a: array of TKey): SizeInt;
var
  k: TKey;
begin
  Result := Count;
  for k in a do
    DoRemoveKey(k);
  Result := Result - Count;
end;

function TGHashBiMap.DoRemoveKeys(e: IKeyEnumerable): SizeInt;
var
  k: TKey;
begin
  Result := Count;
  for k in e do
    DoRemoveKey(k);
  Result := Result - Count;
end;

function TGHashBiMap.DoExtractValue(constref aValue: TValue; out k: TKey): Boolean;
var
  srv: TValueSearchResult;
  pv: PValEntry;
begin
  pv := FValueSet.Find(aValue, srv);
  Result := pv <> nil;
  if Result then
    begin
      k := pv^.KeyNode^.Data.Key;
      if not FKeySet.Remove(pv^.KeyNode^.Data.Key) then
        raise EBiMapError.Create(SEInternalDataInconsist);
      FValueSet.RemoveAt(srv);
    end;
end;

function TGHashBiMap.DoRemoveValue(constref aValue: TValue): Boolean;
var
  k: TKey;
begin
  Result := DoExtractValue(aValue, k);
end;

function TGHashBiMap.DoRemoveValues(constref a: array of TValue): SizeInt;
var
  v: TValue;
begin
  Result := Count;
  for v in a do
    DoRemoveValue(v);
  Result := Result - Count;
end;

function TGHashBiMap.DoRemoveValues(e: IValueEnumerable): SizeInt;
var
  v: TValue;
begin
  Result := Count;
  for v in e do
    DoRemoveValue(v);
  Result := Result - Count;
end;

function TGHashBiMap.DoReplaceValue(constref aKey: TKey; constref aNewValue: TValue): Boolean;
var
  srk: TKeySearchResult;
  srv: TValueSearchResult;
  pk: PKeyEntry;
  pv: PValEntry;
begin
  pk := FKeySet.Find(aKey, srk);
  Result := pk <> nil;
  if Result then
    begin
      Result := not TValueEqRel.Equal(pk^.ValueNode^.Data.Key, aNewValue);
      if Result then
        begin
          Result := not FValueSet.FindOrAdd(aNewValue, pv, srv);
          if Result then
            begin
              if not FValueSet.Remove(pk^.ValueNode^.Data.Key) then
                raise EBiMapError.Create(SEInternalDataInconsist);
              pk^.ValueNode := srv.Node;
            end;
        end;
    end;
end;

function TGHashBiMap.DoReplaceKey(constref aValue: TValue; constref aNewKey: TKey): Boolean;
var
  srk: TKeySearchResult;
  srv: TValueSearchResult;
  pk: PKeyEntry;
  pv: PValEntry;
begin
  pv := FValueSet.Find(aValue, srv);
  Result := pv <> nil;
  if Result then
    begin
      Result := not TKeyEqRel.Equal(pv^.KeyNode^.Data.Key, aNewKey);
      if Result then
        begin
          Result := not FKeySet.FindOrAdd(aNewKey, pk, srk);
          if Result then
            begin
              if not FKeySet.Remove(pv^.KeyNode^.Data.Key) then
                raise EBiMapError.Create(SEInternalDataInconsist);
              pv^.KeyNode := srk.Node;
            end;
        end;
    end;
end;

procedure TGHashBiMap.DoRetainAll(c: IKeyCollection);
begin
  FKeySet.RemoveIf(@c.NonContains, @KeyRemoving);
end;

procedure TGHashBiMap.DoRetainAllVal(c: IValueCollection);
begin
  FValueSet.RemoveIf(@c.NonContains, @ValueRemoving);
end;

function TGHashBiMap.GetKeys: IKeyEnumerable;
begin
  Result := TKeyEnumerable.Create(Self);
end;

function TGHashBiMap.GetValues: IValueEnumerable;
begin
  Result := TValueEnumerable.Create(Self);
end;

function TGHashBiMap.GetEntries: IEntryEnumerable;
begin
  Result := TEntryEnumerable.Create(Self);
end;

function TGHashBiMap.AddInverse(constref aValue: TValue; constref aKey: TKey): Boolean;
begin
  CheckInIteration;
  Result := DoAdd(aKey, aValue);
end;

class function TGHashBiMap.DefaultLoadFactor: Single;
begin
  Result := TKeySet.DefaultLoadFactor;
end;

class function TGHashBiMap.MaxLoadFactor: Single;
begin
  Result := TKeySet.MaxLoadFactor;
end;

class function TGHashBiMap.MinLoadFactor: Single;
begin
  Result := TKeySet.MinLoadFactor;
end;

constructor TGHashBiMap.Create;
begin
  FKeySet := TKeySet.Create;
  FValueSet := TValueSet.Create;
end;

constructor TGHashBiMap.Create(constref a: array of TEntry);
begin
  Create;
  DoAddAll(a);
end;

constructor TGHashBiMap.Create(e: IEntryEnumerable);
begin
  Create;
  DoAddAll(e);
end;

constructor TGHashBiMap.Create(aCapacity: SizeInt);
begin
  FKeySet := TKeySet.Create(aCapacity);
  FValueSet := TValueSet.Create(aCapacity);
end;

constructor TGHashBiMap.Create(aCapacity: SizeInt; constref a: array of TEntry);
begin
  Create(aCapacity);
  DoAddAll(a);
end;

constructor TGHashBiMap.Create(aCapacity: SizeInt; e: IEntryEnumerable);
begin
  Create(aCapacity);
  DoAddAll(e);
end;

constructor TGHashBiMap.CreateCopy(aMap: TGHashBiMap);
begin
  Create(aMap.Count);
  DoAddAll(aMap.Entries);
end;

destructor TGHashBiMap.Destroy;
begin
  DoClear;
  FKeySet.Free;
  FValueSet.Free;
  inherited;
end;

function TGHashBiMap.IsEmpty: Boolean;
begin
  Result := Count = 0;
end;

function TGHashBiMap.NonEmpty: Boolean;
begin
  Result := Count > 0;
end;

procedure TGHashBiMap.Clear;
begin
  CheckInIteration;
  DoClear;
end;

procedure TGHashBiMap.EnsureCapacity(aValue: SizeInt);
begin
  CheckInIteration;
  DoEnsureCapacity(aValue);
end;

procedure TGHashBiMap.TrimToFit;
begin
  CheckInIteration;
  DoTrimToFit;
end;

function TGHashBiMap.Contains(constref aKey: TKey): Boolean;
var
  p: TKeySearchResult;
begin
  Result := FKeySet.Find(aKey, p) <> nil;
end;

function TGHashBiMap.NonContains(constref aKey: TKey): Boolean;
begin
  Result := not Contains(aKey);
end;

function TGHashBiMap.ContainsValue(constref aValue: TValue): Boolean;
var
  p: TValueSearchResult;
begin
  Result := FValueSet.Find(aValue, p) <> nil;
end;

function TGHashBiMap.NonContainsValue(constref aValue: TValue): Boolean;
begin
  Result := not ContainsValue(aValue);
end;

function TGHashBiMap.GetValue(const aKey: TKey): TValue;
begin
  if not TryGetValue(aKey, Result) then
    raise ELGMapError.Create(SEKeyNotFound);
end;

function TGHashBiMap.GetKey(const aValue: TValue): TKey;
begin
  if not TryGetKey(aValue, Result) then
    raise ELGMapError.Create(SEValueNotFound);
end;

function TGHashBiMap.TryGetValue(constref aKey: TKey; out aValue: TValue): Boolean;
var
  p: PKeyEntry;
  sr: TKeySearchResult;
begin
  p := FKeySet.Find(aKey, sr);
  Result := p <> nil;
  if Result then
    aValue := p^.ValueNode^.Data.Key;
end;

function TGHashBiMap.TryGetKey(constref aValue: TValue; out aKey: TKey): Boolean;
var
  p: PValEntry;
  sr: TValueSearchResult;
begin
  p := FValueSet.Find(aValue, sr);
  Result := p <> nil;
  if Result then
    aKey := p^.KeyNode^.Data.Key;
end;

function TGHashBiMap.GetValueDef(constref aKey: TKey; constref aDefault: TValue): TValue;
begin
  if not TryGetValue(aKey, Result) then
    Result := aDefault;
end;

function TGHashBiMap.GetKeyDef(constref aValue: TValue; constref aDefault: TKey): TKey;
begin
  if not TryGetKey(aValue, Result) then
    Result := aDefault;
end;

function TGHashBiMap.Add(constref aKey: TKey; constref aValue: TValue): Boolean;
begin
  CheckInIteration;
  Result := DoAdd(aKey, aValue);
end;

function TGHashBiMap.Add(constref e: TEntry): Boolean;
begin
  CheckInIteration;
  Result := DoAdd(e.Key, e.Value);
end;

procedure TGHashBiMap.AddOrSetValue(const aKey: TKey; const aValue: TValue);
begin
  CheckInIteration;
  DoAddOrSetValue(aKey, aValue);
end;

function TGHashBiMap.AddOrSetValue(constref e: TEntry): Boolean;
begin
  CheckInIteration;
  Result := TryAddOrSetValue(e.Key, e.Value);
end;

procedure TGHashBiMap.AddOrSetKey(const aValue: TValue; const aKey: TKey);
begin
  CheckInIteration;
  DoAddOrSetKey(aValue, aKey);
end;

function TGHashBiMap.AddOrSetKey(constref e: TInverseEntry): Boolean;
begin
  CheckInIteration;
  Result := TryAddOrSetKey(e.Key, e.Value);
end;

function TGHashBiMap.AddAll(constref a: array of TEntry): SizeInt;
begin
  CheckInIteration;
  Result := DoAddAll(a);
end;

function TGHashBiMap.AddAll(e: IEntryEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoAddAll(e);
end;

function TGHashBiMap.Remove(constref aKey: TKey): Boolean;
begin
  CheckInIteration;
  Result := DoRemoveKey(aKey);
end;

function TGHashBiMap.RemoveAll(constref a: array of TKey): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveKeys(a);
end;

function TGHashBiMap.RemoveAll(e: IKeyEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveKeys(e);
end;

function TGHashBiMap.RemoveValue(constref aValue: TValue): Boolean;
begin
  CheckInIteration;
  Result := DoRemoveValue(aValue);
end;

function TGHashBiMap.RemoveValues(constref a: array of TValue): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveValues(a);
end;

function TGHashBiMap.RemoveValues(e: IValueEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveValues(e);
end;

function TGHashBiMap.Replace(constref aKey: TKey; constref aNewValue: TValue): Boolean;
begin
  CheckInIteration;
  Result := DoReplaceValue(aKey, aNewValue);
end;

function TGHashBiMap.ReplaceKey(constref aValue: TValue; constref aNewKey: TKey): Boolean;
begin
  CheckInIteration;
  Result := DoReplaceKey(aValue, aNewKey);
end;

function TGHashBiMap.Extract(constref aKey: TKey; out v: TValue): Boolean;
begin
  CheckInIteration;
  Result := DoExtractKey(aKey, v);
end;

function TGHashBiMap.ExtractValue(constref aValue: TValue; out k: TKey): Boolean;
begin
  CheckInIteration;
  Result := DoExtractValue(aValue, k);
end;

procedure TGHashBiMap.RetainAll(c: IKeyCollection);
begin
  CheckInIteration;
  DoRetainAll(c);
end;

procedure TGHashBiMap.RetainAll(c: IValueCollection);
begin
  CheckInIteration;
  DoRetainAllVal(c);
end;

function TGHashBiMap.Clone: THashBiMap;
begin
  Result := THashBiMap.CreateCopy(Self);
end;

function TGHashBiMap.Keys: IKeyEnumerable;
begin
  BeginIteration;
  Result := GetKeys;
end;

function TGHashBiMap.Values: IValueEnumerable;
begin
  BeginIteration;
  Result := GetValues;
end;

function TGHashBiMap.Entries: IEntryEnumerable;
begin
  BeginIteration;
  Result := GetEntries;
end;

{ TGObjectHashBiMap }

procedure TGObjectHashBiMap.SetOwnership(aOwns: TMapObjOwnership);
begin
  OwnsKeys := moOwnsKeys in aOwns;
  OwnsValues := moOwnsValues in aOwns;
end;

procedure TGObjectHashBiMap.KeyRemoving(p: PKeyEntry);
var
  v: TValue;
begin
  v := p^.ValueNode^.Data.Key;
  if OwnsKeys then
    TObject(p^.Key).Free;
  FValueSet.Remove(v);
  if OwnsValues then
    TObject(v).Free;
end;

procedure TGObjectHashBiMap.ValueRemoving(p: PValEntry);
var
  k: TKey;
begin
  k := p^.KeyNode^.Data.Key;
  if OwnsKeys then
    TObject(p^.Key).Free;
  FKeySet.Remove(k);
  if OwnsValues then
    TObject(k).Free;
end;

procedure TGObjectHashBiMap.DoClear;
var
  e: PKeyEntry;
begin
  if OwnsKeys or OwnsValues then
    for e in FKeySet do
      begin
        if OwnsKeys then
          TObject(e^.Key).Free;
        if OwnsValues then
          TObject(e^.ValueNode^.Data.Key).Free;
      end;
  inherited;
end;

function TGObjectHashBiMap.DoRemoveKey(constref aKey: TKey): Boolean;
var
  v: TValue;
begin
  Result := DoExtractKey(aKey, v);
  if Result then
    begin
      if OwnsKeys then
        TObject(aKey).Free;
      if OwnsValues then
        TObject(v).Free;
    end;
end;

function TGObjectHashBiMap.DoRemoveValue(constref aValue: TValue): Boolean;
var
  k: TKey;
begin
  Result := DoExtractValue(aValue, k);
  if Result then
    begin
      if OwnsKeys then
        TObject(k).Free;
      if OwnsValues then
        TObject(aValue).Free;
    end;
end;

function TGObjectHashBiMap.DoReplaceValue(constref aKey: TKey; constref aNewValue: TValue): Boolean;
var
  srk: TKeySearchResult;
  srv: TValueSearchResult;
  pk: PKeyEntry;
  pv: PValEntry;
  v: TValue;
begin
  pk := FKeySet.Find(aKey, srk);
  Result := pk <> nil;
  if Result then
    begin
      Result := not TValueEqRel.Equal(pk^.ValueNode^.Data.Key, aNewValue);
      if Result then
        begin
          Result := not FValueSet.FindOrAdd(aNewValue, pv, srv);
          if Result then
            begin
              v := pk^.ValueNode^.Data.Key;
              if not FValueSet.Remove(v) then
                raise EBiMapError.Create(SEInternalDataInconsist);
              pk^.ValueNode := srv.Node;
              if OwnsValues then
                TObject(v).Free;
            end;
        end;
    end;
end;

function TGObjectHashBiMap.DoReplaceKey(constref aValue: TValue; constref aNewKey: TKey): Boolean;
var
  srk: TKeySearchResult;
  srv: TValueSearchResult;
  pk: PKeyEntry;
  pv: PValEntry;
  k: TKey;
begin
  pv := FValueSet.Find(aValue, srv);
  Result := pv <> nil;
  if Result then
    begin
      Result := not TKeyEqRel.Equal(pv^.KeyNode^.Data.Key, aNewKey);
      if Result then
        begin
          Result := not FKeySet.FindOrAdd(aNewKey, pk, srk);
          if Result then
            begin
              k := pv^.KeyNode^.Data.Key;
              if not FKeySet.Remove(k) then
                raise EBiMapError.Create(SEInternalDataInconsist);
              pv^.KeyNode := srk.Node;
              if OwnsKeys then
                TObject(k).Free;
            end;
        end;
    end;
end;

procedure TGObjectHashBiMap.DoRetainAll(c: IKeyCollection);
begin
  FKeySet.RemoveIf(@c.NonContains, @KeyRemoving);
end;

procedure TGObjectHashBiMap.DoRetainAllVal(c: IValueCollection);
begin
  FValueSet.RemoveIf(@c.NonContains, @ValueRemoving);
end;

constructor TGObjectHashBiMap.Create(aOwns: TMapObjOwnership);
begin
  inherited Create;
  SetOwnership(aOwns);
end;

constructor TGObjectHashBiMap.Create(constref a: array of TEntry; aOwns: TMapObjOwnership);
begin
  inherited Create(a);
  SetOwnership(aOwns);
end;

constructor TGObjectHashBiMap.Create(e: IEntryEnumerable; aOwns: TMapObjOwnership);
begin
  inherited Create(e);
  SetOwnership(aOwns);
end;

constructor TGObjectHashBiMap.Create(aCapacity: SizeInt; aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity);
  SetOwnership(aOwns);
end;

constructor TGObjectHashBiMap.Create(aCapacity: SizeInt; constref a: array of TEntry; aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity, a);
  SetOwnership(aOwns);
end;

constructor TGObjectHashBiMap.Create(aCapacity: SizeInt; e: IEntryEnumerable; aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity, e);
  SetOwnership(aOwns);
end;

constructor TGObjectHashBiMap.CreateCopy(aMap: TGObjectHashBiMap);
begin
  inherited CreateCopy(aMap);
  OwnsKeys := aMap.OwnsKeys;
  OwnsValues := aMap.OwnsValues;
end;

function TGObjectHashBiMap.Clone: TGObjectHashBiMap;
begin
  Result := TGObjectHashBiMap.CreateCopy(Self);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Common abstact container classes.                                       *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGCustomContainer;

{$MODE OBJFPC}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  math,
  LGUtils,
  {%H-}LGHelpers,
  LGArrayHelpers,
  LGStrConst;

type

  { TGEnumerable }

  generic TGEnumerable<T> = class abstract(TObject, specialize IGEnumerable<T>, IObjInstance)
  public
  type
    TCustomEnumerable = specialize TGEnumerable<T>;
    TCustomEnumerator = specialize TGCustomEnumerator<T>;
    IEnumerable       = specialize IGEnumerable<T>;
    TOptional         = specialize TGOptional<T>;
    TArray            = specialize TGArray<T>;
    TCompare          = specialize TGCompare<T>;
    TOnCompare        = specialize TGOnCompare<T>;
    TNestCompare      = specialize TGNestCompare<T>;
    TTest             = specialize TGTest<T>;
    TOnTest           = specialize TGOnTest<T>;
    TNestTest         = specialize TGNestTest<T>;
    TMapFunc          = specialize TGMapFunc<T, T>;
    TOnMap            = specialize TGOnMap<T, T>;
    TNestMap          = specialize TGNestMap<T, T>;
    TFold             = specialize TGFold<T, T>;
    TOnFold           = specialize TGOnFold<T, T>;
    TNestFold         = specialize TGNestFold<T, T>;
    TDefaults         = specialize TGDefaults<T>;
    TItem             = T;

  protected
  type
    PItem = ^T;

    function  _GetRef: TObject; inline;
  public
    function GetEnumerator: TCustomEnumerator;  virtual; abstract;
  { enumerates elements in reverse order }
    function Reverse: IEnumerable; virtual;
    function ToArray: TArray; virtual;
    function Any: Boolean;
    function None: Boolean;
    function Total: SizeInt;
    function FindFirst(out aValue: T): Boolean;
    function First: TOptional;
    function FindLast(out aValue: T): Boolean;
    function Last: TOptional;
    function FindMin(out aValue: T; c: TCompare): Boolean;
    function FindMin(out aValue: T; c: TOnCompare): Boolean;
    function FindMin(out aValue: T; c: TNestCompare): Boolean;
    function Min(c: TCompare): TOptional;
    function Min(c: TOnCompare): TOptional;
    function Min(c: TNestCompare): TOptional;
    function FindMax(out aValue: T; c: TCompare): Boolean;
    function FindMax(out aValue: T; c: TOnCompare): Boolean;
    function FindMax(out aValue: T; c: TNestCompare): Boolean;
    function Max(c: TCompare): TOptional;
    function Max(c: TOnCompare): TOptional;
    function Max(c: TNestCompare): TOptional;
    function Skip(aCount: SizeInt): IEnumerable; inline;
    function Limit(aCount: SizeInt): IEnumerable; inline;
    function Sorted(c: TCompare): IEnumerable;
    function Sorted(c: TOnCompare): IEnumerable;
    function Sorted(c: TNestCompare): IEnumerable;
    function Select(aTest: TTest): IEnumerable; inline;
    function Select(aTest: TOnTest): IEnumerable; inline;
    function Select(aTest: TNestTest): IEnumerable; inline;
    function Any(aTest: TTest): Boolean;
    function Any(aTest: TOnTest): Boolean;
    function Any(aTest: TNestTest): Boolean;
    function None(aTest: TTest): Boolean; inline;
    function None(aTest: TOnTest): Boolean; inline;
    function None(aTest: TNestTest): Boolean; inline;
    function All(aTest: TTest): Boolean;
    function All(aTest: TOnTest): Boolean;
    function All(aTest: TNestTest): Boolean;
    function Total(aTest: TTest): SizeInt;
    function Total(aTest: TOnTest): SizeInt;
    function Total(aTest: TNestTest): SizeInt;
    function Distinct(c: TCompare): IEnumerable;
    function Distinct(c: TOnCompare): IEnumerable;
    function Distinct(c: TNestCompare): IEnumerable;
    function Map(aMap: TMapFunc): IEnumerable; inline;
    function Map(aMap: TOnMap): IEnumerable; inline;
    function Map(aMap: TNestMap): IEnumerable; inline;
  { left-associative linear fold }
    function Fold(aFold: TFold; constref v0: T): T;
    function Fold(aFold: TFold): TOptional;
    function Fold(aFold: TOnFold; constref v0: T): T;
    function Fold(aFold: TOnFold): TOptional;
    function Fold(aFold: TNestFold; constref v0: T): T;
    function Fold(aFold: TNestFold): TOptional;
  end;

{$I LGEnumsH.inc}

  { TGCustomContainer }

  generic TGCustomContainer<T> = class abstract(specialize TGEnumerable<T>, specialize IGContainer<T>)
  public
  type
    TCustomContainer = specialize TGCustomContainer<T>;

  protected
  type
    //to supress unnecessary refcounting
    TFake = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(SizeOf(T))] of Byte{$ELSE}T{$ENDIF};
    TFakeArray = array of TFake;

    TContainerEnumerator = class(specialize TGCustomEnumerator<T>)
    strict protected
      FOwner: TCustomContainer;
    public
      constructor Create(c: TCustomContainer);
      destructor Destroy; override;
    end;

    TContainerEnumerable = class(specialize TGAutoEnumerable<T>)
    strict protected
      FOwner: TCustomContainer;
    public
      constructor Create(c: TCustomContainer);
      destructor Destroy; override;
    end;

  strict private
    FIterationCount: LongInt;
    function  GetInIteration: Boolean; inline;
  protected
    procedure CapacityExceedError(aValue: SizeInt); inline;
    procedure AccessEmptyError; inline;
    procedure IndexOutOfBoundError(aIndex: SizeInt); inline;
    procedure CheckInIteration; inline;
    procedure BeginIteration; inline;
    procedure EndIteration; inline;
    function  GetCount: SizeInt; virtual; abstract;
    function  GetCapacity: SizeInt; virtual; abstract;
    function  DoGetEnumerator: TCustomEnumerator;  virtual; abstract;
    procedure DoClear; virtual; abstract;
    procedure DoTrimToFit; virtual; abstract;
    procedure DoEnsureCapacity(aValue: SizeInt); virtual; abstract;
    procedure CopyItems(aBuffer: PItem); virtual;
    property  InIteration: Boolean read GetInIteration;
  public
    function  GetEnumerator: TCustomEnumerator; override;
    function  ToArray: TArray; override;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure Clear;
    procedure TrimToFit;
    procedure EnsureCapacity(aValue: SizeInt);
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
  end;

{$I LGDynBuffersH.inc}

  { TGCustomCollection: collection abstract ancestor class}
  generic TGCustomCollection<T> = class abstract(specialize TGCustomContainer<T>, specialize IGCollection<T>)
  public
  type
    TCustomCollection = specialize TGCustomCollection<T>;
    ICollection       = specialize IGCollection<T>;

  protected
    function  DoAdd(constref aValue: T): Boolean; virtual; abstract;
    function  DoExtract(constref aValue: T): Boolean; virtual; abstract;
    function  DoRemoveIf(aTest: TTest): SizeInt; virtual; abstract;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; virtual; abstract;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; virtual; abstract;
    function  DoExtractIf(aTest: TTest): TArray; virtual; abstract;
    function  DoExtractIf(aTest: TOnTest): TArray; virtual; abstract;
    function  DoExtractIf(aTest: TNestTest): TArray; virtual; abstract;

    function  DoRemove(constref aValue: T): Boolean; virtual;
    function  DoAddAll(constref a: array of T): SizeInt; virtual; overload;
    function  DoAddAll(e: IEnumerable): SizeInt; virtual; abstract; overload;
    function  DoRemoveAll(constref a: array of T): SizeInt;
    function  DoRemoveAll(e: IEnumerable): SizeInt; virtual;
  public
  { returns True if element added }
    function  Add(constref aValue: T): Boolean;
  { returns count of added elements }
    function  AddAll(constref a: array of T): SizeInt;
  { returns count of added elements }
    function  AddAll(e: IEnumerable): SizeInt;
    function  Contains(constref aValue: T): Boolean; virtual; abstract;
    function  NonContains(constref aValue: T): Boolean;
    function  ContainsAny(constref a: array of T): Boolean;
    function  ContainsAny(e: IEnumerable): Boolean;
    function  ContainsAll(constref a: array of T): Boolean;
    function  ContainsAll(e: IEnumerable): Boolean;
  { returns True if element removed }
    function  Remove(constref aValue: T): Boolean;
  { returns count of removed elements }
    function  RemoveAll(constref a: array of T): SizeInt;
  { returns count of removed elements }
    function  RemoveAll(e: IEnumerable): SizeInt;
  { returns count of removed elements }
    function  RemoveIf(aTest: TTest): SizeInt;
    function  RemoveIf(aTest: TOnTest): SizeInt;
    function  RemoveIf(aTest: TNestTest): SizeInt;
  { returns True if element extracted }
    function  Extract(constref aValue: T): Boolean;
    function  ExtractIf(aTest: TTest): TArray;
    function  ExtractIf(aTest: TOnTest): TArray;
    function  ExtractIf(aTest: TNestTest): TArray;
  { will contain only those elements that are simultaneously contained in self and aCollection }
    procedure RetainAll(aCollection: ICollection);
    function  Clone: TCustomCollection; virtual; abstract;
  end;

  { TGThreadCollection }

  generic TGThreadCollection<T> = class
  public
  type
    ICollection = specialize IGCollection<T>;

  private
    FCollection: ICollection;
    FLock: TRTLCriticalSection;
    procedure Lock; inline;
  public
    constructor Create(aCollection: ICollection);
    destructor Destroy; override;
    function  LockCollection: ICollection;
    procedure Unlock; inline;
    procedure Clear;
    function  Contains(constref aValue: T): Boolean;
    function  NonContains(constref aValue: T): Boolean;
    function  Add(constref aValue: T): Boolean;
    function  Remove(constref aValue: T): Boolean;
  end;

  { TGCustomSet: set abstract ancestor class }
  generic TGCustomSet<T> = class abstract(specialize TGCustomCollection<T>)
  public
  type
    TCustomSet = specialize TGCustomSet<T>;

  protected
  type
    TEntry = record
      Key: T;
    end;
    PEntry = ^TEntry;

    TExtractHelper = object
    private
      FCurrIndex: SizeInt;
      FExtracted: TArray;
    public
      procedure OnExtract(p: PEntry);
      procedure Init;
      function  Final: TArray;
    end;

    function  DoAddAll(e: IEnumerable): SizeInt; override; overload;
    procedure DoSymmetricSubtract(aSet: TCustomSet);
  public
    function  IsSuperset(aSet: TCustomSet): Boolean;
    function  IsSubset(aSet: TCustomSet): Boolean; inline;
    function  IsEqual(aSet: TCustomSet): Boolean;
    function  Intersecting(aSet: TCustomSet): Boolean; inline;
    procedure Intersect(aSet: TCustomSet);
    procedure Join(aSet: TCustomSet);
    procedure Subtract(aSet: TCustomSet);
    procedure SymmetricSubtract(aSet: TCustomSet);
  end;

  generic TGMultiSetEntry<T> = record
    Key: T;
    Count: SizeInt; //multiplicity(count of occurrences)
  end;

  { TGCustomMultiSet: multiSet abstract ancestor class  }
  generic TGCustomMultiSet<T> = class abstract(specialize TGCustomCollection<T>)
  public
  type
    TEntry           = specialize TGMultiSetEntry<T>;
    TCustomMultiSet  = specialize TGCustomMultiSet<T>;
    IEntryEnumerable = specialize IGEnumerable<TEntry>;

  protected
  type
    PEntry = ^TEntry;

    TExtractHelper = object
    private
      FCurrIndex: SizeInt;
      FExtracted: TArray;
    public
      procedure OnExtract(p: PEntry);
      procedure Init;
      function  Final: TArray;
    end;

    TIntersectHelper = object
      FSet,
      FOtherSet: TCustomMultiSet;
      function OnIntersect(p: PEntry): Boolean;
    end;

  var
    FCount: SizeInt;
    function  FindEntry(constref aKey: T): PEntry; virtual; abstract;
    //return True if aKey found, otherwise inserts entry (garbage) and return False;
    function  FindOrAdd(constref aKey: T; out p: PEntry): Boolean; virtual; abstract;
    //returns True only if e removed
    function  DoSubEntry(constref e: TEntry): Boolean; virtual; abstract;
    //returns True only if e removed
    function  DoSymmSubEntry(constref e: TEntry): Boolean; virtual; abstract;
    function  GetEntryCount: SizeInt; virtual; abstract;
    function  DoDoubleEntryCounters: SizeInt; virtual; abstract;
    function  GetDistinct: IEnumerable; virtual; abstract;  // distinct keys
    function  GetEntries: IEntryEnumerable; virtual; abstract;
    procedure DoIntersect(aSet: TCustomMultiSet); virtual; abstract;

    function  GetCount: SizeInt; override;
    procedure DoJoinEntry(constref e: TEntry);
    procedure DoAddEntry(constref e: TEntry);
    function  GetKeyCount(const aKey: T): SizeInt;
    procedure SetKeyCount(const aKey: T; aValue: SizeInt);
    procedure DoArithAdd(aSet: TCustomMultiSet);
    procedure DoArithSubtract(aSet: TCustomMultiSet);
    procedure DoSymmSubtract(aSet: TCustomMultiSet);

    function  DoAdd(constref aKey: T): Boolean; override;
    function  DoAddAll(e: IEnumerable): SizeInt; override; overload;
    function  DoRemoveAll(e: IEnumerable): SizeInt; override;
    property  ElemCount: SizeInt read FCount;
  public
    function  Contains(constref aValue: T): Boolean; override;
  { returns True if multiplicity of an any key in self is greater then or equal to
    the multiplicity of that key in aSet }
    function  IsSuperMultiSet(aSet: TCustomMultiSet): Boolean;
  { returns True if multiplicity of an any key in aSet is greater then or equal to
    the multiplicity of that key in self }
    function  IsSubMultiSet(aSet: TCustomMultiSet): Boolean;
  { returns True if the multiplicity of an any key in self is equal to the multiplicity of that key in aSet }
    function  IsEqual(aSet: TCustomMultiSet): Boolean;
    function  Intersecting(aSet: TCustomMultiSet): Boolean;
  { will contain only those keys that are simultaneously contained in self and in aSet;
    the multiplicity of a key becomes equal to the MINIMUM of the multiplicities of a key in self and aSet }
    procedure Intersect(aSet: TCustomMultiSet);
  { will contain all keys that are contained in self and in aSet;
    the multiplicity of a key will become equal to the MAXIMUM of the multiplicities of
    a key in self and aSet }
    procedure Join(aSet: TCustomMultiSet);
  { will contain all keys that are contained in self or in aSet;
    the multiplicity of a key will become equal to the SUM of the multiplicities of a key in self and aSet }
    procedure ArithmeticAdd(aSet: TCustomMultiSet);
  { will contain only those keys whose multiplicity is greater then the multiplicity
    of that key in aSet; the multiplicity of a key will become equal to the difference of multiplicities
    of a key in self and aSet }
    procedure ArithmeticSubtract(aSet: TCustomMultiSet);
  { will contain only those keys whose multiplicity is not equal to the multiplicity
    of that key in aSet; the multiplicity of a key will become equal to absolute value of difference
    of the multiplicities of a key in self and aSet }
    procedure SymmetricSubtract(aSet: TCustomMultiSet);
  { enumerates underlying set - distinct keys only }
    function  Distinct: IEnumerable;
    function  Entries: IEntryEnumerable;
  { returs number of distinct keys }
    property  EntryCount: SizeInt read GetEntryCount; //dimension, Count - cardinality
  { will return 0 if not contains an element aValue;
    will raise EArgumentException if one try to set negative multiplicity of a aValue }
    property  Counts[const aValue: T]: SizeInt read GetKeyCount write SetKeyCount; default;
  end;

  { TCustomIterable }

  TCustomIterable = class
  private
    FIterationCount: LongInt;
    function  GetInIteration: Boolean; inline;
  protected
    procedure CapacityExceedError(aValue: SizeInt); inline;
    procedure CheckInIteration; inline;
    procedure BeginIteration; inline;
    procedure EndIteration; inline;
    property  InIteration: Boolean read GetInIteration;
  end;

  TMapObjectOwns   = (moOwnsKeys, moOwnsValues);
  TMapObjOwnership = set of TMapObjectOwns;

  const
    OWNS_BOTH = [moOwnsKeys, moOwnsValues];

  type
  { TGCustomMap: map abstract ancestor class  }
  generic TGCustomMap<TKey, TValue> = class abstract(TCustomIterable, specialize IGMap<TKey, TValue>)
  {must be  generic TGCustomMap<TKey, TValue> = class abstract(
              specialize TGContainer<specialize TGMapEntry<TKey, TValue>>), but :( ... }
  public
  type
    TCustomMap       = specialize TGCustomMap<TKey, TValue>;
    TEntry           = specialize TGMapEntry<TKey, TValue>;
    IKeyEnumerable   = specialize IGEnumerable<TKey>;
    IValueEnumerable = specialize IGEnumerable<TValue>;
    IEntryEnumerable = specialize IGEnumerable<TEntry>;
    TEntryArray      = specialize TGArray<TEntry>;
    TKeyArray        = specialize TGArray<TKey>;
    TKeyTest         = specialize TGTest<TKey>;
    TOnKeyTest       = specialize TGOnTest<TKey>;
    TNestKeyTest     = specialize TGNestTest<TKey>;
    TKeyOptional     = specialize TGOptional<TKey>;
    TValueOptional   = specialize TGOptional<TValue>;
    TKeyCollection   = specialize TGCustomCollection<TKey>;
    IKeyCollection   = specialize IGCollection<TKey>;

  protected
  type
    PEntry          = ^TEntry;

    TExtractHelper = object
    private
      FCurrIndex: SizeInt;
      FExtracted: TEntryArray;
    public
      procedure OnExtract(p: PEntry);
      procedure Init;
      function  Final: TEntryArray;
    end;

    TCustomKeyEnumerable = class(specialize TGAutoEnumerable<TKey>)
    protected
      FOwner: TCustomMap;
    public
      constructor Create(aMap: TCustomMap);
      destructor Destroy; override;
    end;

    TCustomValueEnumerable = class(specialize TGAutoEnumerable<TValue>)
    protected
      FOwner: TCustomMap;
    public
      constructor Create(aMap: TCustomMap);
      destructor Destroy; override;
    end;

    TCustomEntryEnumerable = class(specialize TGAutoEnumerable<TEntry>)
    protected
      FOwner: TCustomMap;
    public
      constructor Create(aMap: TCustomMap);
      destructor Destroy; override;
    end;

    function  _GetRef: TObject;
    function  GetCount: SizeInt;  virtual; abstract;
    function  GetCapacity: SizeInt; virtual; abstract;
    function  Find(constref aKey: TKey): PEntry; virtual; abstract;
    //returns True if aKey found, otherwise inserts (garbage) entry and returns False;
    function  FindOrAdd(constref aKey: TKey; out p: PEntry): Boolean; virtual; abstract;
    function  DoExtract(constref aKey: TKey; out v: TValue): Boolean; virtual; abstract;
    function  DoRemoveIf(aTest: TKeyTest): SizeInt; virtual; abstract;
    function  DoRemoveIf(aTest: TOnKeyTest): SizeInt; virtual; abstract;
    function  DoRemoveIf(aTest: TNestKeyTest): SizeInt; virtual; abstract;
    function  DoExtractIf(aTest: TKeyTest): TEntryArray; virtual; abstract;
    function  DoExtractIf(aTest: TOnKeyTest): TEntryArray; virtual; abstract;
    function  DoExtractIf(aTest: TNestKeyTest): TEntryArray; virtual; abstract;

    function  DoRemove(constref aKey: TKey): Boolean; virtual;
    procedure DoClear; virtual; abstract;
    procedure DoEnsureCapacity(aValue: SizeInt); virtual; abstract;
    procedure DoTrimToFit; virtual; abstract;
    function  GetKeys: IKeyEnumerable; virtual; abstract;
    function  GetValues: IValueEnumerable; virtual; abstract;
    function  GetEntries: IEntryEnumerable; virtual; abstract;

    function  GetValue(const aKey: TKey): TValue; inline;
    function  DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean; virtual;
    function  DoAdd(constref aKey: TKey; constref aValue: TValue): Boolean;
    function  DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean; virtual;
    function  DoAddAll(constref a: array of TEntry): SizeInt;
    function  DoAddAll(e: IEntryEnumerable): SizeInt;
    function  DoRemoveAll(constref a: array of TKey): SizeInt;
    function  DoRemoveAll(e: IKeyEnumerable): SizeInt;
  public
    function  ToArray: TEntryArray;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure Clear;
    procedure EnsureCapacity(aValue: SizeInt);
  { free unused memory if possible }
    procedure TrimToFit;
  { returns True and aValue mapped to aKey if contains aKey, False otherwise }
    function  TryGetValue(constref aKey: TKey; out aValue: TValue): Boolean;
  { returns Value mapped to aKey or aDefault }
    function  GetValueDef(constref aKey: TKey; constref aDefault: TValue = Default(TValue)): TValue; inline;
  { returns True and add TEntry(aKey, aValue) only if not contains aKey }
    function  Add(constref aKey: TKey; constref aValue: TValue): Boolean;
  { returns True and add e only if not contains e.Key }
    function  Add(constref e: TEntry): Boolean; inline;
    procedure AddOrSetValue(const aKey: TKey; const aValue: TValue);
  { returns True if e.Key added, False otherwise }
    function  AddOrSetValue(constref e: TEntry): Boolean;
  { will add only entries which keys are absent in map }
    function  AddAll(constref a: array of TEntry): SizeInt;
    function  AddAll(e: IEntryEnumerable): SizeInt;
  { returns True and map aNewValue to aKey only if contains aKey, False otherwise }
    function  Replace(constref aKey: TKey; constref aNewValue: TValue): Boolean;
    function  Contains(constref aKey: TKey): Boolean; inline;
    function  ContainsAny(constref a: array of TKey): Boolean;
    function  ContainsAny(e: IKeyEnumerable): Boolean;
    function  ContainsAll(constref a: array of TKey): Boolean;
    function  ContainsAll(e: IKeyEnumerable): Boolean;
    function  Remove(constref aKey: TKey): Boolean;
    function  RemoveAll(constref a: array of TKey): SizeInt;
    function  RemoveAll(e: IKeyEnumerable): SizeInt;
    function  RemoveIf(aTest: TKeyTest): SizeInt;
    function  RemoveIf(aTest: TOnKeyTest): SizeInt;
    function  RemoveIf(aTest: TNestKeyTest): SizeInt;
    function  Extract(constref aKey: TKey; out v: TValue): Boolean;
    function  ExtractIf(aTest: TKeyTest): TEntryArray;
    function  ExtractIf(aTest: TOnKeyTest): TEntryArray;
    function  ExtractIf(aTest: TNestKeyTest): TEntryArray;
    procedure RetainAll({%H-}c: IKeyCollection);
    function  Clone: TCustomMap; virtual; abstract;
    function  Keys: IKeyEnumerable;
    function  Values: IValueEnumerable;
    function  Entries: IEntryEnumerable;
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
  { reading will raise ELGMapError if an aKey is not present in map }
    property  Items[const aKey: TKey]: TValue read GetValue write AddOrSetValue; default;
  end;

  { TGCustomMultiMap: multimap abstract ancestor class }
  generic TGCustomMultiMap<TKey, TValue> = class abstract(TCustomIterable)
  {must be  generic TGCustomMultiMap<TKey, TValue> = class abstract(
              specialize TGContainer<specialize TGMapEntry<TKey, TValue>>), but :( ... }
  public
  type
    TCustomMultiMap  = specialize TGCustomMultiMap<TKey, TValue>;
    TEntry           = specialize TGMapEntry<TKey, TValue>;
    IKeyEnumerable   = specialize IGEnumerable<TKey>;
    IValueEnumerable = specialize IGEnumerable<TValue>;
    IEntryEnumerable = specialize IGEnumerable<TEntry>;
    TValueArray      = specialize TGArray<TKey>;

  protected
  type
    TCustomValueEnumerator = specialize TGCustomEnumerator<TValue>;

    TCustomValueSet = class
    protected
      function GetCount: SizeInt; virtual; abstract;
    public
      function  GetEnumerator: TCustomValueEnumerator; virtual; abstract;
      function  ToArray: TValueArray;
      function  Contains(constref aValue: TValue): Boolean; virtual; abstract;
      function  Add(constref aValue: TValue): Boolean; virtual; abstract;
      function  Remove(constref aValue: TValue): Boolean; virtual; abstract;
      property  Count: SizeInt read GetCount;
    end;

    TMMEntry = record
      Key: TKey;
      Values: TCustomValueSet;
    end;
    PMMEntry = ^TMMEntry;

    TCustomKeyEnumerable = class(specialize TGAutoEnumerable<TKey>)
    protected
      FOwner: TCustomMultiMap;
    public
      constructor Create(aMap: TCustomMultiMap);
      destructor Destroy; override;
    end;

    TCustomValueEnumerable = class(specialize TGAutoEnumerable<TValue>)
    protected
      FOwner: TCustomMultiMap;
    public
      constructor Create(aMap: TCustomMultiMap);
      destructor Destroy; override;
    end;

    TCustomEntryEnumerable = class(specialize TGAutoEnumerable<TEntry>)
    protected
      FOwner: TCustomMultiMap;
    public
      constructor Create(aMap: TCustomMultiMap);
      destructor Destroy; override;
    end;

    TCustomValueCursor = class(specialize TGEnumCursor<TValue>)
    protected
      FOwner: TCustomMultiMap;
    public
      constructor Create(e: TCustomEnumerator; aMap: TCustomMultiMap);
      destructor Destroy; override;
    end;

  var
    FCount: SizeInt;
    function  GetKeyCount: SizeInt; virtual; abstract;
    function  GetCapacity: SizeInt; virtual; abstract;
    function  GetUniqueKeyValues: Boolean; virtual; abstract;
    procedure DoClear; virtual; abstract;
    procedure DoEnsureCapacity(aValue: SizeInt); virtual; abstract;
    procedure DoTrimToFit; virtual; abstract;
    function  Find(constref aKey: TKey): PMMEntry; virtual; abstract;
    function  FindOrAdd(constref aKey: TKey): PMMEntry; virtual; abstract;
    function  DoRemoveKey(constref aKey: TKey): SizeInt; virtual; abstract;
    function  GetKeys: IKeyEnumerable; virtual; abstract;
    function  GetValues: IValueEnumerable; virtual; abstract;
    function  GetEntries: IEntryEnumerable; virtual; abstract;

    function  DoAdd(constref aKey: TKey; constref aValue: TValue): Boolean;
    function  DoAddAll(constref a: array of TEntry): SizeInt;
    function  DoAddAll(e: IEntryEnumerable): SizeInt;
    function  DoAddValues(constref aKey: TKey; constref a: array of TValue): SizeInt;
    function  DoAddValues(constref aKey: TKey; e: IValueEnumerable): SizeInt;
    function  DoRemove(constref aKey: TKey; constref aValue: TValue): Boolean;
    function  DoRemoveAll(constref a: array of TEntry): SizeInt;
    function  DoRemoveAll(e: IEntryEnumerable): SizeInt;
    function  DoRemoveValues(constref aKey: TKey; constref a: array of TValue): SizeInt;
    function  DoRemoveValues(constref aKey: TKey; e: IValueEnumerable): SizeInt;
    function  DoRemoveKeys(constref a: array of TKey): SizeInt;
    function  DoRemoveKeys(e: IKeyEnumerable): SizeInt;
  public
    function  IsEmpty: Boolean;
    function  NonEmpty: Boolean;
    procedure Clear;
    procedure EnsureCapacity(aValue: SizeInt);
    procedure TrimToFit;

    function  Contains(constref aKey: TKey): Boolean; inline;
    function  ContainsValue(constref aKey: TKey; constref aValue: TValue): Boolean;
  { returns True and add TEntry(aKey, aValue) only if value-collection of an aKey does not contains aValue }
    function  Add(constref aKey: TKey; constref aValue: TValue): Boolean;
  { returns True and add e only if value-collection of an e.Key does not contains e.Value }
    function  Add(constref e: TEntry): Boolean;
  { returns count of added values }
    function  AddAll(constref a: array of TEntry): SizeInt;
    function  AddAll(e: IEntryEnumerable): SizeInt;
    function  AddValues(constref aKey: TKey; constref a: array of TValue): SizeInt;
    function  AddValues(constref aKey: TKey; e: IValueEnumerable): SizeInt;
  { returns True if aKey exists and mapped to aValue; aValue will be removed(and aKey if no more mapped values) }
    function  Remove(constref aKey: TKey; constref aValue: TValue): Boolean;
    function  Remove(constref e: TEntry): Boolean;
    function  RemoveAll(constref a: array of TEntry): SizeInt;
    function  RemoveAll(e: IEntryEnumerable): SizeInt;
    function  RemoveValues(constref aKey: TKey; constref a: array of TValue): SizeInt;
    function  RemoveValues(constref aKey: TKey; e: IValueEnumerable): SizeInt;
  { if aKey exists then removes if with mapped values; returns count of removed values }
    function  RemoveKey(constref aKey: TKey): SizeInt;
  { returns count of removed values }
    function  RemoveKeys(constref a: array of TKey): SizeInt;
  { returns count of removed values }
    function  RemoveKeys(e: IKeyEnumerable): SizeInt;
  { returns copy of values mapped to aKey(empty if aKey is missing) }
    function  CopyValues(const aKey: TKey): TValueArray;
  { enumerates values mapped to aKey(empty if aKey is missing) }
    function  ViewValues(const aKey: TKey): IValueEnumerable;
    function  Keys: IKeyEnumerable;
    function  Values: IValueEnumerable;
    function  Entries: IEntryEnumerable;
  { returns count of values mapped to aKey (similar as multiset)}
    function  ValueCount(constref aKey: TKey): SizeInt;
    property  UniqueKeyValues: Boolean read GetUniqueKeyValues;
    property  Count: SizeInt read FCount;
    property  KeyCount: SizeInt read GetKeyCount;
    property  Capacity: SizeInt read GetCapacity;
    property  Items[const aKey: TKey]: IValueEnumerable read ViewValues; default;
  end;

  { TGCustomTable2D: abstract ancestor class }
  generic TGCustomTable2D<TRow, TCol, TValue> = class abstract
  public
  type
    TCellData = record
      Row:    TRow;
      Column: TCol;
      Value:  TValue;
    end;

    TColData = record
      Row:   TRow;
      Value: TValue;
    end;

    TRowData = record
      Column: TCol;
      Value:  TValue;
    end;

    TCustomTable2D      = TGCustomTable2D;
    TValueArray         = array of TValue;
    IValueEnumerable    = specialize IGEnumerable<TValue>;
    IColEnumerable      = specialize IGEnumerable<TCol>;
    IRowEnumerable      = specialize IGEnumerable<TRow>;
    IRowDataEnumerable  = specialize IGEnumerable<TRowData>;
    IColDataEnumerable  = specialize IGEnumerable<TColData>;
    ICellDataEnumerable = specialize IGEnumerable<TCellData>;
    TRowDataEnumerator  = class abstract(specialize TGCustomEnumerator<TRowData>);

{$PUSH}{$INTERFACES CORBA}
    IRowMap = interface
      function  GetCount: SizeInt;
      function  GetEnumerator: TRowDataEnumerator;
      function  IsEmpty: Boolean;
      function  Contains(constref aCol: TCol): Boolean;
      function  TryGetValue(constref aCol: TCol; out aValue: TValue): Boolean;
      function  GetValueOrDefault(const aCol: TCol): TValue;
    { returns True if not contains aCol was added, False otherwise }
      function  Add(constref aCol: TCol; constref aValue: TValue): Boolean;
      procedure AddOrSetValue(const aCol: TCol; const aValue: TValue);
      function  Remove(constref aCol: TCol): Boolean;
      property  Count: SizeInt read GetCount;
      property  Cells[const aCol: TCol]: TValue read GetValueOrDefault write AddOrSetValue; default;
    end;
{$POP}

   IRowMapEnumerable = specialize IGEnumerable<IRowMap>;

  protected
  type
    TCustomRowMap = class(IRowMap)
    protected
      function  GetCount: SizeInt; virtual; abstract;
    public
      function  GetEnumerator: TRowDataEnumerator; virtual; abstract;
      function  IsEmpty: Boolean;
      function  Contains(constref aCol: TCol): Boolean; virtual; abstract;
      function  TryGetValue(constref aCol: TCol; out aValue: TValue): Boolean; virtual; abstract;
      function  GetValueOrDefault(const aCol: TCol): TValue; inline;
    { returns True if not contains aCol was added, False otherwise }
      function  Add(constref aCol: TCol; constref aValue: TValue): Boolean; virtual; abstract;
      procedure AddOrSetValue(const aCol: TCol; const aValue: TValue); virtual; abstract;
      function  Remove(constref aCol: TCol): Boolean; virtual; abstract;
      property  Count: SizeInt read GetCount;
      property  Cells[const aCol: TCol]: TValue read GetValueOrDefault write AddOrSetValue; default;
    end;

    TRowEntry = record
      Key: TRow;
      Columns: TCustomRowMap;
    end;
    PRowEntry = ^TRowEntry;

    TCustomValueEnumerable    = class abstract(specialize TGAutoEnumerable<TValue>);
    TCustomRowDataEnumerable  = class abstract(specialize TGAutoEnumerable<TRowData>);
    TCustomColDataEnumerable  = class abstract(specialize TGAutoEnumerable<TColData>);
    TCustomCellDataEnumerable = class abstract(specialize TGAutoEnumerable<TCellData>);

  var
    FCellCount: SizeInt;
    function  GetRowCount: SizeInt; virtual; abstract;
    function  DoFindRow(constref aRow: TRow): PRowEntry; virtual; abstract;
  { returns True if row found, False otherwise }
    function  DoFindOrAddRow(constref aRow: TRow; out p: PRowEntry): Boolean; virtual; abstract;
    function  DoRemoveRow(constref aRow: TRow): SizeInt; virtual; abstract;
    function  GetColumn(const aCol: TCol): IColDataEnumerable; virtual; abstract;
    function  GetCellData: ICellDataEnumerable; virtual; abstract;
    function  GetColCount(const aRow: TRow): SizeInt;
  { aRow will be added if it is missed }
    function  GetRow(const aRow: TRow): IRowMap;
  public
    function  IsEmpty: Boolean;
    function  NonEmpty: Boolean;
    procedure Clear; virtual; abstract;
    procedure TrimToFit; virtual; abstract;
    procedure EnsureRowCapacity(aValue: SizeInt); virtual; abstract;
    function  ContainsRow(constref aRow: TRow): Boolean; inline;
    function  FindRow(constref aRow: TRow; out aMap: IRowMap): Boolean;
  { returns True if row found, False otherwise }
    function  FindOrAddRow(constref aRow: TRow; out aMap: IRowMap): Boolean;
  { if not contains aRow then add aRow and returns True, False otherwise }
    function  AddRow(constref aRow: TRow): Boolean; inline;
  { returns count of columns in removed row }
    function  RemoveRow(constref aRow: TRow): SizeInt; inline;
    function  ContainsCell(constref aRow: TRow; constref aCol: TCol): Boolean;
  { will raise exception if cell is missing }
    function  GetCell(constref aRow: TRow; constref aCol: TCol): TValue;
    function  TryGetCell(constref aRow: TRow; constref aCol: TCol; out aValue: TValue): Boolean;
    function  TryGetCellDef(constref aRow: TRow; constref aCol: TCol; aDef: TValue = Default(TValue)): TValue;
              inline;
    function  GetCellOrDefault(const aRow: TRow; const aCol: TCol): TValue;
    procedure AddOrSetCell(const aRow: TRow; const aCol: TCol; const aValue: TValue);
    function  AddCell(constref aRow: TRow; constref aCol: TCol; constref aValue: TValue): Boolean;
    function  AddCell(constref e: TCellData): Boolean; inline;
    function  AddAll(constref a: array of TCellData): SizeInt;
    function  RemoveCell(const aRow: TRow; const aCol: TCol): Boolean;

    function  RowEnum: IRowEnumerable; virtual; abstract;
    function  RowMapEnum: IRowMapEnumerable; virtual; abstract;
    property  RowCount: SizeInt read GetRowCount;
    property  ColCount[const aRow: TRow]: SizeInt read GetColCount;
    property  CellCount: SizeInt read FCellCount;
    property  Rows[const aRow: TRow]: IRowMap read GetRow;
    property  Columns[const aCol: TCol]: IColDataEnumerable read GetColumn;
    property  Cells: ICellDataEnumerable read GetCellData;
    property  Items[const aRow: TRow; const aCol: TCol]: TValue read GetCellOrDefault write AddOrSetCell; default;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGEnumerable }

function TGEnumerable._GetRef: TObject;
begin
  Result := Self;
end;

function TGEnumerable.Reverse: IEnumerable;
begin
  Result := specialize TGArrayReverse<T>.Create(ToArray);
end;

function TGEnumerable.ToArray: TArray;
var
  I, Len: SizeInt;
begin
  Len := ARRAY_INITIAL_SIZE;
  SetLength(Result, ARRAY_INITIAL_SIZE);
  I := 0;
  with GetEnumerator do
    try
      while MoveNext do
        begin
          if I = Len then
            begin
              Len += Len;
              SetLength(Result, Len);
            end;
          Result[I] := Current;
          Inc(I);
        end;
    finally
      Free;
    end;
  SetLength(Result, I);
end;

function TGEnumerable.Any: Boolean;
begin
  with GetEnumerator do
    try
      Result :=  MoveNext;
    finally
      Free;
    end;
end;

function TGEnumerable.None: Boolean;
begin
  Result := not Any;
end;

function TGEnumerable.Total: SizeInt;
begin
  Result := 0;
  with GetEnumerator do
    try
      while MoveNext do
        Inc(Result);
    finally
      Free;
    end;
end;

function TGEnumerable.FindFirst(out aValue: T): Boolean;
var
  e: TCustomEnumerator;
begin
  e := GetEnumerator;
  try
    Result := e.MoveNext;
    if Result then
      aValue := e.Current;
  finally
    e.Free;
  end;
end;

function TGEnumerable.First: TOptional;
var
  v: T;
begin
  if FindFirst(v) then
    Result.Assign(v);
end;

function TGEnumerable.FindLast(out aValue: T): Boolean;
var
  e: TCustomEnumerator;
begin
  e := GetEnumerator;
  try
    Result := e.MoveNext;
    if Result then
      begin
        while e.MoveNext do;
        aValue := e.Current;
      end;
  finally
    e.Free;
  end;
end;

function TGEnumerable.Last: TOptional;
var
  v: T;
begin
  if FindLast(v) then
    Result.Assign(v);
end;

function TGEnumerable.FindMin(out aValue: T; c: TCompare): Boolean;
var
  v: T;
begin
  with GetEnumerator do
    try
      Result := MoveNext;
      if Result then
        begin
          aValue := Current;
          while MoveNext do
            begin
              v := Current;
              if c(v, aValue) < 0 then
                aValue := v;
            end;
        end;
    finally
      Free;
    end;
end;

function TGEnumerable.FindMin(out aValue: T; c: TOnCompare): Boolean;
var
  v: T;
begin
  with GetEnumerator do
    try
      Result := MoveNext;
      if Result then
        begin
          aValue := Current;
          while MoveNext do
            begin
              v := Current;
              if c(v, aValue) < 0 then
                aValue := v;
            end;
        end;
    finally
      Free;
    end;
end;

function TGEnumerable.FindMin(out aValue: T; c: TNestCompare): Boolean;
var
  v: T;
begin
  with GetEnumerator do
    try
      Result := MoveNext;
      if Result then
        begin
          aValue := Current;
          while MoveNext do
            begin
              v := Current;
              if c(v, aValue) < 0 then
                aValue := v;
            end;
        end;
    finally
      Free;
    end;
end;

function TGEnumerable.Min(c: TCompare): TOptional;
var
  v: T;
begin
  if FindMin(v, c) then
    Result.Assign(v);
end;

function TGEnumerable.Min(c: TOnCompare): TOptional;
var
  v: T;
begin
  if FindMin(v, c) then
    Result.Assign(v);
end;

function TGEnumerable.Min(c: TNestCompare): TOptional;
var
  v: T;
begin
  if FindMin(v, c) then
    Result.Assign(v);
end;

function TGEnumerable.FindMax(out aValue: T; c: TCompare): Boolean;
var
  v: T;
begin
  with GetEnumerator do
    try
      Result := MoveNext;
      if Result then
        begin
          aValue := Current;
          while MoveNext do
            begin
              v := Current;
              if c(aValue, v) < 0 then
                aValue := v;
            end;
        end;
    finally
      Free;
    end;
end;

function TGEnumerable.FindMax(out aValue: T; c: TOnCompare): Boolean;
var
  v: T;
begin
  with GetEnumerator do
    try
      Result := MoveNext;
      if Result then
        begin
          aValue := Current;
          while MoveNext do
            begin
              v := Current;
              if c(aValue, v) < 0 then
                aValue := v;
            end;
        end;
    finally
      Free;
    end;
end;

function TGEnumerable.FindMax(out aValue: T; c: TNestCompare): Boolean;
var
  v: T;
begin
  with GetEnumerator do
    try
      Result := MoveNext;
      if Result then
        begin
          aValue := Current;
          while MoveNext do
            begin
              v := Current;
              if c(aValue, v) < 0 then
                aValue := v;
            end;
        end;
    finally
      Free;
    end;
end;

function TGEnumerable.Max(c: TCompare): TOptional;
var
  v: T;
begin
  if FindMax(v, c) then
    Result.Assign(v);
end;

function TGEnumerable.Max(c: TOnCompare): TOptional;
var
  v: T;
begin
  if FindMax(v, c) then
    Result.Assign(v);
end;

function TGEnumerable.Max(c: TNestCompare): TOptional;
var
  v: T;
begin
  if FindMax(v, c) then
    Result.Assign(v);
end;

function TGEnumerable.Skip(aCount: SizeInt): IEnumerable;
begin
  Result := specialize TGSkipEnumerable<T>.Create(GetEnumerator, aCount);
end;

function TGEnumerable.Limit(aCount: SizeInt): IEnumerable;
begin
  Result := specialize TGLimitEnumerable<T>.Create(GetEnumerator, aCount);
end;

function TGEnumerable.Sorted(c: TCompare): IEnumerable;
var
  a: TArray;
begin
  a := ToArray;
  specialize TGRegularArrayHelper<T>.Sort(a, c);
  Result := specialize TGArrayCursor<T>.Create(a);
end;

function TGEnumerable.Sorted(c: TOnCompare): IEnumerable;
var
  a: TArray;
begin
  a := ToArray;
  specialize TGDelegatedArrayHelper<T>.Sort(a, c);
  Result := specialize TGArrayCursor<T>.Create(a);
end;

function TGEnumerable.Sorted(c: TNestCompare): IEnumerable;
var
  a: TArray;
begin
  a := ToArray;
  specialize TGNestedArrayHelper<T>.Sort(a, c);
  Result := specialize TGArrayCursor<T>.Create(a);
end;

function TGEnumerable.Select(aTest: TTest): IEnumerable;
begin
  Result := specialize TGEnumRegularFilter<T>.Create(GetEnumerator, aTest);
end;

function TGEnumerable.Select(aTest: TOnTest): IEnumerable;
begin
  Result := specialize TGEnumDelegatedFilter<T>.Create(GetEnumerator, aTest);
end;

function TGEnumerable.Select(aTest: TNestTest): IEnumerable;
begin
  Result := specialize TGEnumNestedFilter<T>.Create(GetEnumerator, aTest);
end;

function TGEnumerable.Any(aTest: TTest): Boolean;
begin
  with GetEnumerator do
    try
      while MoveNext do
        if aTest(Current) then
          exit(True);
    finally
      Free;
    end;
  Result := False;
end;

function TGEnumerable.Any(aTest: TOnTest): Boolean;
begin
  with GetEnumerator do
    try
      while MoveNext do
        if aTest(Current) then
          exit(True);
    finally
      Free;
    end;
  Result := False;
end;

function TGEnumerable.Any(aTest: TNestTest): Boolean;
begin
  with GetEnumerator do
    try
      while MoveNext do
        if aTest(Current) then
          exit(True);
    finally
      Free;
    end;
  Result := False;
end;

function TGEnumerable.None(aTest: TTest): Boolean;
begin
  Result := not Any(aTest);
end;

function TGEnumerable.None(aTest: TOnTest): Boolean;
begin
  Result := not Any(aTest);
end;

function TGEnumerable.None(aTest: TNestTest): Boolean;
begin
  Result := not Any(aTest);
end;

function TGEnumerable.All(aTest: TTest): Boolean;
begin
  with GetEnumerator do
    try
      while MoveNext do
        if not aTest(Current) then
          exit(False);
    finally
      Free;
    end;
  Result := True;
end;

function TGEnumerable.All(aTest: TOnTest): Boolean;
begin
  with GetEnumerator do
    try
      while MoveNext do
        if not aTest(Current) then
          exit(False);
    finally
      Free;
    end;
  Result := True;
end;

function TGEnumerable.All(aTest: TNestTest): Boolean;
begin
  with GetEnumerator do
    try
      while MoveNext do
        if not aTest(Current) then
          exit(False);
    finally
      Free;
    end;
  Result := True;
end;

function TGEnumerable.Total(aTest: TTest): SizeInt;
begin
  Result := 0;
  with GetEnumerator do
    try
      while MoveNext do
        Result += Ord(aTest(Current));
    finally
      Free;
    end;
end;

function TGEnumerable.Total(aTest: TOnTest): SizeInt;
begin
  Result := 0;
  with GetEnumerator do
    try
      while MoveNext do
        Result += Ord(aTest(Current));
    finally
      Free;
    end;
end;

function TGEnumerable.Total(aTest: TNestTest): SizeInt;
begin
  Result := 0;
  with GetEnumerator do
    try
      while MoveNext do
        Result += Ord(aTest(Current));
    finally
      Free;
    end;
end;

function TGEnumerable.Distinct(c: TCompare): IEnumerable;
begin
  Result := specialize TGArrayCursor<T>.Create(
    specialize TGRegularArrayHelper<T>.SelectDistinct(ToArray, c));
end;

function TGEnumerable.Distinct(c: TOnCompare): IEnumerable;
begin
  Result := specialize TGArrayCursor<T>.Create(
    specialize TGDelegatedArrayHelper<T>.SelectDistinct(ToArray, c));
end;

function TGEnumerable.Distinct(c: TNestCompare): IEnumerable;
begin
  Result := specialize TGArrayCursor<T>.Create(
    specialize TGNestedArrayHelper<T>.SelectDistinct(ToArray, c));
end;

function TGEnumerable.Map(aMap: TMapFunc): IEnumerable;
begin
  Result := specialize TGEnumRegularMap<T>.Create(GetEnumerator, aMap);
end;

function TGEnumerable.Map(aMap: TOnMap): IEnumerable;
begin
  Result := specialize TGEnumDelegatedMap<T>.Create(GetEnumerator, aMap);
end;

function TGEnumerable.Map(aMap: TNestMap): IEnumerable;
begin
  Result := specialize TGEnumNestedMap<T>.Create(GetEnumerator, aMap);
end;

function TGEnumerable.Fold(aFold: TFold; constref v0: T): T;
begin
  Result := v0;
  with GetEnumerator do
    try
      while MoveNext do
        Result := aFold(Current, Result);
    finally
      Free;
    end;
end;

function TGEnumerable.Fold(aFold: TFold): TOptional;
var
  v: T;
begin
  with GetEnumerator do
    try
      if MoveNext then
        begin
          v := Current;
          while MoveNext do
            v := aFold(Current, v);
          Result.Assign(v);
        end;
    finally
      Free;
    end;
end;

function TGEnumerable.Fold(aFold: TOnFold; constref v0: T): T;
begin
  Result := v0;
  with GetEnumerator do
    try
      while MoveNext do
        Result := aFold(Current, Result);
    finally
      Free;
    end;
end;

function TGEnumerable.Fold(aFold: TOnFold): TOptional;
var
  v: T;
begin
  with GetEnumerator do
    try
      if MoveNext then
        begin
          v := Current;
          while MoveNext do
            v := aFold(Current, v);
          Result.Assign(v);
        end;
    finally
      Free;
    end;
end;

function TGEnumerable.Fold(aFold: TNestFold; constref v0: T): T;
begin
  Result := v0;
  with GetEnumerator do
    try
      while MoveNext do
        Result := aFold(Current, Result);
    finally
      Free;
    end;
end;

function TGEnumerable.Fold(aFold: TNestFold): TOptional;
var
  v: T;
begin
  with GetEnumerator do
    try
      if MoveNext then
        begin
          v := Current;
          while MoveNext do
            v := aFold(Current, v);
          Result.Assign(v);
        end;
    finally
      Free;
    end;
end;

{$I LGEnumsImpl.inc}

{ TGCustomContainer.TGContainerEnumerator }

constructor TGCustomContainer.TContainerEnumerator.Create(c: TCustomContainer);
begin
  FOwner := c;
end;

destructor TGCustomContainer.TContainerEnumerator.Destroy;
begin
  FOwner.EndIteration;
  inherited;
end;

{ TGCustomContainer.TContainerEnumerable }

constructor TGCustomContainer.TContainerEnumerable.Create(c: TCustomContainer);
begin
  inherited Create;
  FOwner := c;
end;

destructor TGCustomContainer.TContainerEnumerable.Destroy;
begin
  FOwner.EndIteration;
  inherited;
end;

{ TGCustomContainer }

function TGCustomContainer.GetInIteration: Boolean;
begin
  Result := Boolean(LongBool(FIterationCount));
end;

procedure TGCustomContainer.CapacityExceedError(aValue: SizeInt);
begin
  raise ELGCapacityExceed.CreateFmt(SEClassCapacityExceedFmt, [ClassName, aValue]);
end;

procedure TGCustomContainer.AccessEmptyError;
begin
  raise ELGAccessEmpty.CreateFmt(SEClassAccessEmptyFmt, [ClassName]);
end;

procedure TGCustomContainer.IndexOutOfBoundError(aIndex: SizeInt);
begin
  raise ELGListError.CreateFmt(SEClassIdxOutOfBoundsFmt, [ClassName, aIndex]);
end;

procedure TGCustomContainer.CheckInIteration;
begin
  if InIteration then
    raise ELGUpdateLock.CreateFmt(SECantUpdDuringIterFmt, [ClassName]);
end;

procedure TGCustomContainer.BeginIteration;
begin
  InterlockedIncrement(FIterationCount);
end;

procedure TGCustomContainer.EndIteration;
begin
  InterlockedDecrement(FIterationCount);
end;

procedure TGCustomContainer.CopyItems(aBuffer: PItem);
begin
  with GetEnumerator do
    try
      while MoveNext do
        begin
          aBuffer^ := Current;
          Inc(aBuffer);
        end;
    finally
      Free;
    end;
end;

function TGCustomContainer.GetEnumerator: TCustomEnumerator;
begin
  BeginIteration;
  Result := DoGetEnumerator;
end;

function TGCustomContainer.ToArray: TArray;
var
  c: SizeInt;
begin
  c := Count;
  System.SetLength(Result, c);
  if c > 0 then
    CopyItems(@Result[0]);
end;

function TGCustomContainer.IsEmpty: Boolean;
begin
  Result := GetCount = 0;
end;

function TGCustomContainer.NonEmpty: Boolean;
begin
  Result := GetCount <> 0;
end;

procedure TGCustomContainer.Clear;
begin
  CheckInIteration;
  DoClear;
end;

procedure TGCustomContainer.TrimToFit;
begin
  CheckInIteration;
  DoTrimToFit;
end;

procedure TGCustomContainer.EnsureCapacity(aValue: SizeInt);
begin
  CheckInIteration;
  DoEnsureCapacity(aValue);
end;

{$I LGDynBuffersImpl.inc}

{ TGCustomCollection }

function TGCustomCollection.DoRemove(constref aValue: T): Boolean;
begin
  Result := DoExtract(aValue);
end;

function TGCustomCollection.DoAddAll(constref a: array of T): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in a do
    Result += Ord(DoAdd(v));
end;

function TGCustomCollection.DoRemoveAll(constref a: array of T): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in a do
    Result += Ord(DoRemove(v));
end;

function TGCustomCollection.DoRemoveAll(e: IEnumerable): SizeInt;
var
  o: TObject;
  v: T;
begin
  o := e._GetRef;
  if o <> Self then
    begin
      Result := 0;
      for v in e do
        Result += Ord(DoRemove(v));
    end
  else
    begin
      Result := Count;
      DoClear;
    end;
end;

function TGCustomCollection.Add(constref aValue: T): Boolean;
begin
  CheckInIteration;
  Result := DoAdd(aValue);
end;

function TGCustomCollection.AddAll(constref a: array of T): SizeInt;
begin
  CheckInIteration;
  Result := DoAddAll(a);
end;

function TGCustomCollection.AddAll(e: IEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoAddAll(e);
end;

function TGCustomCollection.NonContains(constref aValue: T): Boolean;
begin
  Result := not Contains(aValue);
end;

function TGCustomCollection.ContainsAny(constref a: array of T): Boolean;
var
  v: T;
begin
  for v in a do
    if Contains(v) then
      exit(True);
  Result := False;
end;

function TGCustomCollection.ContainsAny(e: IEnumerable): Boolean;
var
  v: T;
begin
  if e._GetRef <> Self then
    begin
      for v in e do
        if Contains(v) then
          exit(True);
      Result := False;
    end
  else
    Result := not IsEmpty;
end;

function TGCustomCollection.ContainsAll(constref a: array of T): Boolean;
var
  v: T;
begin
  for v in a do
    if NonContains(v) then
      exit(False);
  Result := True;
end;

function TGCustomCollection.ContainsAll(e: IEnumerable): Boolean;
var
  v: T;
begin
  if e._GetRef <> Self then
    for v in e do
      if NonContains(v) then
        exit(False);
  Result := True;
end;

function TGCustomCollection.Remove(constref aValue: T): Boolean;
begin
  CheckInIteration;
  Result := DoRemove(aValue);
end;

function TGCustomCollection.RemoveAll(constref a: array of T): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveAll(a);
end;

function TGCustomCollection.RemoveAll(e: IEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveAll(e);
end;

function TGCustomCollection.RemoveIf(aTest: TTest): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveIf(aTest);
end;

function TGCustomCollection.RemoveIf(aTest: TOnTest): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveIf(aTest);
end;

function TGCustomCollection.RemoveIf(aTest: TNestTest): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveIf(aTest);
end;

function TGCustomCollection.Extract(constref aValue: T): Boolean;
begin
  CheckInIteration;
  Result := DoExtract(aValue);
end;

function TGCustomCollection.ExtractIf(aTest: TTest): TArray;
begin
  CheckInIteration;
  Result := DoExtractIf(aTest);
end;

function TGCustomCollection.ExtractIf(aTest: TOnTest): TArray;
begin
  CheckInIteration;
  Result := DoExtractIf(aTest);
end;

function TGCustomCollection.ExtractIf(aTest: TNestTest): TArray;
begin
  CheckInIteration;
  Result := DoExtractIf(aTest);
end;

procedure TGCustomCollection.RetainAll(aCollection: ICollection);
begin
  if aCollection._GetRef <> Self then
    begin
      CheckInIteration;
      DoRemoveIf(@aCollection.NonContains);
    end;
end;

{ TGThreadCollection }

procedure TGThreadCollection.Lock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGThreadCollection.Create(aCollection: ICollection);
begin
  System.InitCriticalSection(FLock);
  FCollection := aCollection;
end;

destructor TGThreadCollection.Destroy;
begin
  Lock;
  try
    FCollection._GetRef.Free;
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

function TGThreadCollection.LockCollection: ICollection;
begin
  Result := FCollection;
  Lock;
end;

procedure TGThreadCollection.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

procedure TGThreadCollection.Clear;
begin
  Lock;
  try
    FCollection.Clear;
  finally
    UnLock;
  end;
end;

function TGThreadCollection.Contains(constref aValue: T): Boolean;
begin
  Lock;
  try
    Result := FCollection.Contains(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadCollection.NonContains(constref aValue: T): Boolean;
begin
  Lock;
  try
    Result := FCollection.NonContains(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadCollection.Add(constref aValue: T): Boolean;
begin
  Lock;
  try
    Result := FCollection.Add(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadCollection.Remove(constref aValue: T): Boolean;
begin
  Lock;
  try
    Result := FCollection.Remove(aValue);
  finally
    UnLock;
  end;
end;

{ TGCustomSet.TExtractHelper }

procedure TGCustomSet.TExtractHelper.OnExtract(p: PEntry);
var
  c: SizeInt;
begin
  c := System.Length(FExtracted);
  if FCurrIndex = c then
    System.SetLength(FExtracted, c shl 1);
  FExtracted[FCurrIndex] := p^.Key;
  Inc(FCurrIndex);
end;

procedure TGCustomSet.TExtractHelper.Init;
begin
  FCurrIndex := 0;
  System.SetLength(FExtracted, ARRAY_INITIAL_SIZE);
end;

function TGCustomSet.TExtractHelper.Final: TArray;
begin
  System.SetLength(FExtracted, FCurrIndex);
  Result := FExtracted;
end;

{ TGCustomSet }

function TGCustomSet.DoAddAll(e: IEnumerable): SizeInt;
var
  v: T;
begin
  if e._GetRef <> Self then
    begin
      Result := 0;
      for v in e do
        Result += Ord(DoAdd(v));
    end
  else
    Result := 0;
end;

procedure TGCustomSet.DoSymmetricSubtract(aSet: TCustomSet);
var
  v: T;
begin
  if aSet <> Self then
    begin
      for v in aSet do
        if not DoRemove(v) then
          DoAdd(v);
    end
  else
    Clear;
end;

function TGCustomSet.IsSuperset(aSet: TCustomSet): Boolean;
begin
  if aSet <> Self then
    begin
      if Count >= aSet.Count then
        Result := ContainsAll(aSet)
      else
        Result := False;
    end
  else
    Result := True;
end;

function TGCustomSet.IsSubset(aSet: TCustomSet): Boolean;
begin
  Result := aSet.IsSuperset(Self);
end;

function TGCustomSet.IsEqual(aSet: TCustomSet): Boolean;
begin
  if aSet <> Self then
    Result := (Count = aSet.Count) and ContainsAll(aSet)
  else
    Result := True;
end;

function TGCustomSet.Intersecting(aSet: TCustomSet): Boolean;
begin
  Result := ContainsAny(aSet);
end;

procedure TGCustomSet.Intersect(aSet: TCustomSet);
begin
  RetainAll(aSet);
end;

procedure TGCustomSet.Join(aSet: TCustomSet);
begin
  AddAll(aSet);
end;

procedure TGCustomSet.Subtract(aSet: TCustomSet);
begin
  RemoveAll(aSet);
end;

procedure TGCustomSet.SymmetricSubtract(aSet: TCustomSet);
begin
  CheckInIteration;
  DoSymmetricSubtract(aSet);
end;

{ TGCustomMultiSet.TExtractor }

procedure TGCustomMultiSet.TExtractHelper.OnExtract(p: PEntry);
var
  I, LastKey: SizeInt;
  Key: T;
begin
  LastKey := Pred(FCurrIndex + p^.Count);
  Key := p^.Key;
  if LastKey >= System.Length(FExtracted) then
      System.SetLength(FExtracted, RoundUpTwoPower(Succ(LastKey)));
  for I := FCurrIndex to LastKey do
    FExtracted[I] := Key;
  FCurrIndex := Succ(LastKey);
end;

procedure TGCustomMultiSet.TExtractHelper.Init;
begin
  FCurrIndex := 0;
  System.SetLength(FExtracted, ARRAY_INITIAL_SIZE);
end;

function TGCustomMultiSet.TExtractHelper.Final: TArray;
begin
  System.SetLength(FExtracted, FCurrIndex);
  Result := FExtracted;
end;

{ TGCustomMultiSet.TIntersectHelper }

function TGCustomMultiSet.TIntersectHelper.OnIntersect(p: PEntry): Boolean;
var
  c, SetCount: SizeInt;
begin
  SetCount := FOtherSet[p^.Key];
  c := p^.Count;
  if SetCount > 0 then
    begin
      Result := False;
      if SetCount < c then
        begin
          FSet.FCount -= c - SetCount;
          p^.Count := SetCount;
        end;
    end
  else
    Result := True;
end;

{ TGCustomMultiSet }

function TGCustomMultiSet.GetCount: SizeInt;
begin
  Result := FCount;
end;

procedure TGCustomMultiSet.DoJoinEntry(constref e: TEntry);
var
  p: PEntry;
begin
{$PUSH}{$Q+}
  if not FindOrAdd(e.Key, p) then
    begin
      p^.Count := e.Count;
      FCount += e.Count;
    end
  else
    if e.Count > p^.Count then
      begin
        FCount += e.Count - p^.Count;
        p^.Count := e.Count;
      end;
{$POP}
end;

procedure TGCustomMultiSet.DoAddEntry(constref e: TEntry);
var
  p: PEntry;
begin
{$PUSH}{$Q+}
  FCount += e.Count;
{$POP}
  if not FindOrAdd(e.Key, p) then
    p^.Count := e.Count
  else
    p^.Count += e.Count;
end;

function TGCustomMultiSet.GetKeyCount(const aKey: T): SizeInt;
var
  p: PEntry;
begin
  p := FindEntry(aKey);
  if p <> nil then
    Result := p^.Count
  else
    Result := 0;
end;

procedure TGCustomMultiSet.SetKeyCount(const aKey: T; aValue: SizeInt);
var
  p: PEntry;
  e: TEntry;
begin
  if aValue < 0 then
    raise EArgumentException.CreateFmt(SECantAcceptNegCountFmt, [ClassName]);
  CheckInIteration;
  if aValue > 0 then
    begin
{$PUSH}{$Q+}
      if FindOrAdd(aKey, p) then
        begin
          FCount += aValue - p^.Count;
          p^.Count := aValue;
        end
      else
        begin
          FCount += aValue;
          p^.Count := aValue;
        end;
{$POP}
    end
  else
    begin  // aValue = 0;
      e.Key := aKey;
      e.Count := High(SizeInt);
      DoSubEntry(e);
    end;
end;

procedure TGCustomMultiSet.DoArithAdd(aSet: TCustomMultiSet);
var
  e: TEntry;
begin
  if aSet <> Self then
    for e in aSet.Entries do
      DoAddEntry(e)
  else
    DoDoubleEntryCounters;
end;

procedure TGCustomMultiSet.DoArithSubtract(aSet: TCustomMultiSet);
var
  e: TEntry;
begin
  if aSet <> Self then
    for e in aSet.Entries do
      DoSubEntry(e)
  else
    Clear;
end;

procedure TGCustomMultiSet.DoSymmSubtract(aSet: TCustomMultiSet);
var
  e: TEntry;
begin
  if aSet <> Self then
    for e in aSet.Entries do
      DoSymmSubEntry(e)
  else
    Clear;
end;

function TGCustomMultiSet.DoAdd(constref aKey: T): Boolean;
var
  p: PEntry;
begin
{$PUSH}{$Q+}
  Inc(FCount);
{$POP}
  if FindOrAdd(aKey, p) then
    Inc(p^.Count);
  Result := True;
end;
function TGCustomMultiSet.DoAddAll(e: IEnumerable): SizeInt;
var
  v: T;
  o: TObject;
begin
  o := e._GetRef;
  if o is TCustomMultiSet then
    begin
      Result := ElemCount;
      DoArithAdd(TCustomMultiSet(o));
      Result := ElemCount - Result;
    end
  else
    begin
      Result := 0;
      for v in e do
        Result += Ord(DoAdd(v));
    end;
end;

function TGCustomMultiSet.DoRemoveAll(e: IEnumerable): SizeInt;
var
  o: TObject;
  v: T;
begin
  o := e._GetRef;
  if o is TCustomMultiSet then
    begin
      Result := ElemCount;
      DoArithSubtract(TCustomMultiSet(o));
      Result -= ElemCount;
    end
  else
    begin
      Result := 0;
      for v in e do
        Result += Ord(DoRemove(v));
    end;
end;

function TGCustomMultiSet.Contains(constref aValue: T): Boolean;
begin
  Result := FindEntry(aValue) <> nil;
end;

function TGCustomMultiSet.IsSuperMultiSet(aSet: TCustomMultiSet): Boolean;
var
  e: TEntry;
begin
  if aSet <> Self then
    begin
      if (Count >= aSet.Count) and (EntryCount >= aSet.EntryCount) then
        begin
          for e in aSet.Entries do
            if GetKeyCount(e.Key) < e.Count then
              exit(False);
          Result := True;
        end
      else
        Result := False;
    end
  else
    Result := True;
end;

function TGCustomMultiSet.IsSubMultiSet(aSet: TCustomMultiSet): Boolean;
var
  e: TEntry;
begin
  if aSet <> Self then
    begin
      if (aSet.Count >= Count) and (aSet.EntryCount >= EntryCount) then
        begin
          for e in Entries do
            if aSet[e.Key] < e.Count then
              exit(False);
          Result := True;
        end
      else
        Result := False;
    end
  else
    Result := True;
end;

function TGCustomMultiSet.IsEqual(aSet: TCustomMultiSet): Boolean;
var
  e: TEntry;
begin
  if aSet <> Self then
    begin
      if (aSet.Count = Count) and (aSet.EntryCount = EntryCount) then
        begin
          for e in Entries do
            if aSet[e.Key] <> e.Count then
              exit(False);
          Result := True;
        end
      else
        Result := False;
    end
  else
    Result := True;
end;

function TGCustomMultiSet.Intersecting(aSet: TCustomMultiSet): Boolean;
begin
  Result := ContainsAny(aSet.Distinct);
end;

procedure TGCustomMultiSet.Intersect(aSet: TCustomMultiSet);
begin
  if aSet <> Self then
    begin
      CheckInIteration;
      DoIntersect(aSet);
    end;
end;

procedure TGCustomMultiSet.Join(aSet: TCustomMultiSet);
var
  e: TEntry;
begin
  if aSet <> Self then
    begin
      CheckInIteration;
      for e in aSet.Entries do
        DoJoinEntry(e);
    end;
end;

procedure TGCustomMultiSet.ArithmeticAdd(aSet: TCustomMultiSet);
begin
  CheckInIteration;
  DoArithAdd(aSet);
end;

procedure TGCustomMultiSet.ArithmeticSubtract(aSet: TCustomMultiSet);
begin
  CheckInIteration;
  DoArithSubtract(aSet);
end;

procedure TGCustomMultiSet.SymmetricSubtract(aSet: TCustomMultiSet);
begin
  CheckInIteration;
  DoSymmSubtract(aSet);
end;

function TGCustomMultiSet.Distinct: IEnumerable;
begin
  BeginIteration;
  Result := GetDistinct;
end;

function TGCustomMultiSet.Entries: IEntryEnumerable;
begin
  BeginIteration;
  Result := GetEntries;
end;

{ TCustomIterable }

function TCustomIterable.GetInIteration: Boolean;
begin
  Result := Boolean(LongBool(FIterationCount));
end;

procedure TCustomIterable.CapacityExceedError(aValue: SizeInt);
begin
  raise ELGCapacityExceed.CreateFmt(SEClassCapacityExceedFmt, [ClassName, aValue]);
end;

procedure TCustomIterable.CheckInIteration;
begin
  if InIteration then
    raise ELGUpdateLock.CreateFmt(SECantUpdDuringIterFmt, [ClassName]);
end;

procedure TCustomIterable.BeginIteration;
begin
  InterlockedIncrement(FIterationCount);
end;

procedure TCustomIterable.EndIteration;
begin
  InterlockedDecrement(FIterationCount);
end;

{ TGCustomMap.TExtractHelper }

procedure TGCustomMap.TExtractHelper.OnExtract(p: PEntry);
var
  c: SizeInt;
begin
  c := System.Length(FExtracted);
  if FCurrIndex = c then
    System.SetLength(FExtracted, c shl 1);
  FExtracted[FCurrIndex] := p^;
  Inc(FCurrIndex);
end;

procedure TGCustomMap.TExtractHelper.Init;
begin
  FCurrIndex := 0;
  System.SetLength(FExtracted, ARRAY_INITIAL_SIZE);
end;

function TGCustomMap.TExtractHelper.Final: TEntryArray;
begin
  System.SetLength(FExtracted, FCurrIndex);
  Result := FExtracted;
end;

{ TGCustomMap.TCustomKeyEnumerable }

constructor TGCustomMap.TCustomKeyEnumerable.Create(aMap: TCustomMap);
begin
  inherited Create;
  FOwner := aMap;
end;

destructor TGCustomMap.TCustomKeyEnumerable.Destroy;
begin
  FOwner.EndIteration;
  inherited;
end;

{ TGCustomMap.TCustomValueEnumerable }

constructor TGCustomMap.TCustomValueEnumerable.Create(aMap: TCustomMap);
begin
  inherited Create;
  FOwner := aMap;
end;

destructor TGCustomMap.TCustomValueEnumerable.Destroy;
begin
  FOwner.EndIteration;
  inherited;
end;

{ TGCustomMap.TCustomEntryEnumerable }

constructor TGCustomMap.TCustomEntryEnumerable.Create(aMap: TCustomMap);
begin
  inherited Create;
  FOwner := aMap;
end;

destructor TGCustomMap.TCustomEntryEnumerable.Destroy;
begin
  FOwner.EndIteration;
  inherited;
end;

{ TGCustomMap }

function TGCustomMap._GetRef: TObject;
begin
  Result := Self;
end;

function TGCustomMap.DoRemove(constref aKey: TKey): Boolean;
var
  v: TValue;
begin
  Result := DoExtract(aKey, v);
end;

function TGCustomMap.GetValue(const aKey: TKey): TValue;
begin
  if not TryGetValue(aKey, Result) then
    raise ELGMapError.Create(SEKeyNotFound);
end;

function TGCustomMap.DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean;
var
  p: PEntry;
begin
  p := Find(aKey);
  Result := p <> nil;
  if Result then
    p^.Value := aNewValue;
end;

function TGCustomMap.DoAdd(constref aKey: TKey; constref aValue: TValue): Boolean;
var
  p: PEntry;
begin
  Result := not FindOrAdd(aKey, p);
  if Result then
    p^.Value := aValue;
end;

function TGCustomMap.DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean;
var
  p: PEntry;
begin
  Result := not FindOrAdd(aKey, p);
  p^.Value := aValue;
end;

function TGCustomMap.DoAddAll(constref a: array of TEntry): SizeInt;
var
  e: TEntry;
begin
  Result := 0;
  for e in a do
    Result += Ord(DoAdd(e.Key, e.Value));
end;

function TGCustomMap.DoAddAll(e: IEntryEnumerable): SizeInt;
var
  Entry: TEntry;
begin
  Result := 0;
  if e._GetRef <> Self then
    for Entry in e do
      Result += Ord(DoAdd(Entry.Key, Entry.Value));
end;

function TGCustomMap.DoRemoveAll(constref a: array of TKey): SizeInt;
var
  k: TKey;
begin
  Result := 0;
  for k in a do
    Result += Ord(DoRemove(k));
end;

function TGCustomMap.DoRemoveAll(e: IKeyEnumerable): SizeInt;
var
  k: TKey;
begin
  Result := 0;
  for k in e do
    Result += Ord(DoRemove(k));
end;

function TGCustomMap.ToArray: TEntryArray;
var
  I: Integer = 0;
  e: TEntry;
begin
  System.SetLength(Result, Count);
  for e in Entries do
    begin
      Result[I] := e;
      Inc(I);
    end;
end;

function TGCustomMap.IsEmpty: Boolean;
begin
  Result := Count = 0;
end;

function TGCustomMap.NonEmpty: Boolean;
begin
  Result := Count <> 0;
end;

procedure TGCustomMap.Clear;
begin
  CheckInIteration;
  DoClear;
end;

procedure TGCustomMap.EnsureCapacity(aValue: SizeInt);
begin
  CheckInIteration;
  DoEnsureCapacity(aValue);
end;

procedure TGCustomMap.TrimToFit;
begin
  CheckInIteration;
  DoTrimToFit;
end;

function TGCustomMap.TryGetValue(constref aKey: TKey; out aValue: TValue): Boolean;
var
  p: PEntry;
begin
  p := Find(aKey);
  Result := p <> nil;
  if Result then
    aValue := p^.Value;
end;

function TGCustomMap.GetValueDef(constref aKey: TKey; constref aDefault: TValue): TValue;
begin
  if not TryGetValue(aKey, Result) then
    Result := aDefault;
end;

function TGCustomMap.Add(constref aKey: TKey; constref aValue: TValue): Boolean;
begin
  CheckInIteration;
  Result := DoAdd(aKey, aValue);
end;

function TGCustomMap.Add(constref e: TEntry): Boolean;
begin
  Result := Add(e.Key, e.Value);
end;

procedure TGCustomMap.AddOrSetValue(const aKey: TKey; const aValue: TValue);
begin
  CheckInIteration;
  DoAddOrSetValue(aKey, aValue);
end;

function TGCustomMap.AddOrSetValue(constref e: TEntry): Boolean;
begin
  CheckInIteration;
  Result := DoAddOrSetValue(e.Key, e.Value);
end;

function TGCustomMap.AddAll(constref a: array of TEntry): SizeInt;
begin
  CheckInIteration;
  Result := DoAddAll(a);
end;

function TGCustomMap.AddAll(e: IEntryEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoAddAll(e);
end;

function TGCustomMap.Replace(constref aKey: TKey; constref aNewValue: TValue): Boolean;
begin
  CheckInIteration;
  Result := DoSetValue(aKey, aNewValue);
end;

function TGCustomMap.Contains(constref aKey: TKey): Boolean;
begin
  Result := Find(aKey) <> nil;
end;

function TGCustomMap.ContainsAny(constref a: array of TKey): Boolean;
var
  k: TKey;
begin
  for k in a do
  if Contains(k) then
    exit(True);
  Result := False;
end;

function TGCustomMap.ContainsAny(e: IKeyEnumerable): Boolean;
var
  k: TKey;
begin
  for k in e do
  if Contains(k) then
    exit(True);
  Result := False;
end;

function TGCustomMap.ContainsAll(constref a: array of TKey): Boolean;
var
  k: TKey;
begin
  for k in a do
  if not Contains(k) then
    exit(False);
  Result := True;
end;

function TGCustomMap.ContainsAll(e: IKeyEnumerable): Boolean;
var
  k: TKey;
begin
  for k in e do
  if not Contains(k) then
    exit(False);
  Result := True;
end;

function TGCustomMap.Remove(constref aKey: TKey): Boolean;
begin
  CheckInIteration;
  Result := DoRemove(aKey);
end;

function TGCustomMap.RemoveAll(constref a: array of TKey): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveAll(a);
end;

function TGCustomMap.RemoveAll(e: IKeyEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveAll(e);
end;

function TGCustomMap.RemoveIf(aTest: TKeyTest): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveIf(aTest);
end;

function TGCustomMap.RemoveIf(aTest: TOnKeyTest): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveIf(aTest);
end;

function TGCustomMap.RemoveIf(aTest: TNestKeyTest): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveIf(aTest);
end;

function TGCustomMap.Extract(constref aKey: TKey; out v: TValue): Boolean;
begin
  CheckInIteration;
  Result := DoExtract(aKey, v);
end;

function TGCustomMap.ExtractIf(aTest: TKeyTest): TEntryArray;
begin
  CheckInIteration;
  Result := DoExtractIf(aTest);
end;

function TGCustomMap.ExtractIf(aTest: TOnKeyTest): TEntryArray;
begin
  CheckInIteration;
  Result := DoExtractIf(aTest);
end;

function TGCustomMap.ExtractIf(aTest: TNestKeyTest): TEntryArray;
begin
  CheckInIteration;
  Result := DoExtractIf(aTest);
end;

procedure TGCustomMap.RetainAll(c: IKeyCollection);
begin
  CheckInIteration;
  DoRemoveIf(@c.NonContains);
end;


function TGCustomMap.Keys: IKeyEnumerable;
begin
  BeginIteration;
  Result := GetKeys;
end;

function TGCustomMap.Values: IValueEnumerable;
begin
  BeginIteration;
  Result := GetValues;
end;

function TGCustomMap.Entries: IEntryEnumerable;
begin
  BeginIteration;
  Result := GetEntries;
end;

{ TGCustomMultiMap.TCustomValueSet }

function TGCustomMultiMap.TCustomValueSet.ToArray: TValueArray;
var
  I, Len: SizeInt;
begin
  Len := ARRAY_INITIAL_SIZE;
  SetLength(Result, ARRAY_INITIAL_SIZE);
  I := 0;
  with GetEnumerator do
    try
      while MoveNext do
        begin
          if I = Len then
            begin
              Len += Len;
              SetLength(Result, Len);
            end;
          Result[I] := Current;
          Inc(I);
        end;
    finally
      Free;
    end;
  SetLength(Result, I);
end;

{ TGCustomMultiMap.TCustomKeyEnumerable }

constructor TGCustomMultiMap.TCustomKeyEnumerable.Create(aMap: TCustomMultiMap);
begin
  inherited Create;
  FOwner := aMap;
end;

destructor TGCustomMultiMap.TCustomKeyEnumerable.Destroy;
begin
  FOwner.EndIteration;
  inherited;
end;

{ TGCustomMultiMap.TCustomValueEnumerable }

constructor TGCustomMultiMap.TCustomValueEnumerable.Create(aMap: TCustomMultiMap);
begin
  inherited Create;
  FOwner := aMap;
end;

destructor TGCustomMultiMap.TCustomValueEnumerable.Destroy;
begin
  FOwner.EndIteration;
  inherited;
end;

{ TGCustomMultiMap.TCustomEntryEnumerable }

constructor TGCustomMultiMap.TCustomEntryEnumerable.Create(aMap: TCustomMultiMap);
begin
  inherited Create;
  FOwner := aMap;
end;

destructor TGCustomMultiMap.TCustomEntryEnumerable.Destroy;
begin
  FOwner.EndIteration;
  inherited;
end;

{ TGCustomMultiMap.TCustomValueCursor }

constructor TGCustomMultiMap.TCustomValueCursor.Create(e: TCustomEnumerator; aMap: TCustomMultiMap);
begin
  inherited Create(e);
  FOwner := aMap;
end;

destructor TGCustomMultiMap.TCustomValueCursor.Destroy;
begin
  FOwner.EndIteration;
  inherited;
end;

{ TGCustomMultiMap }

function TGCustomMultiMap.DoAdd(constref aKey: TKey; constref aValue: TValue): Boolean;
var
  p: PMMEntry;
begin
  p := FindOrAdd(aKey);
  Result := p^.Values.Add(aValue);
  FCount += Ord(Result);
end;

function TGCustomMultiMap.DoAddAll(constref a: array of TEntry): SizeInt;
var
  e: TEntry;
begin
  Result := 0;
  for e in a do
    Result += Ord(DoAdd(e.Key, e.Value));
end;

function TGCustomMultiMap.DoAddAll(e: IEntryEnumerable): SizeInt;
var
  Entry: TEntry;
begin
  Result := 0;
  for Entry in e do
    Result += Ord(DoAdd(Entry.Key, Entry.Value));
end;

function TGCustomMultiMap.DoAddValues(constref aKey: TKey; constref a: array of TValue): SizeInt;
var
  p: PMMEntry;
  v: TValue;
begin
  Result := 0;
  if System.Length(a) > 0 then
    begin
      p := FindOrAdd(aKey);
      for v in a do
        Result += Ord(p^.Values.Add(v));
      FCount += Result;
    end;
end;

function TGCustomMultiMap.DoAddValues(constref aKey: TKey; e: IValueEnumerable): SizeInt;
var
  p: PMMEntry = nil;
  v: TValue;
begin
  Result := 0;
  for v in e do
    begin
      if p = nil then
        p := FindOrAdd(aKey);
      Result += Ord(p^.Values.Add(v));
    end;
  FCount += Result;
end;

function TGCustomMultiMap.DoRemove(constref aKey: TKey; constref aValue: TValue): Boolean;
var
  p: PMMEntry;
begin
  p := Find(aKey);
  if p <> nil then
    begin
      Result := p^.Values.Remove(aValue);
      FCount -= Ord(Result);
      if p^.Values.Count = 0 then
        DoRemoveKey(aKey);
    end
  else
    Result := False;
end;

function TGCustomMultiMap.DoRemoveAll(constref a: array of TEntry): SizeInt;
var
  e: TEntry;
begin
  Result := 0;
  for e in a do
    Result += Ord(DoRemove(e.Key, e.Value));
end;

function TGCustomMultiMap.DoRemoveAll(e: IEntryEnumerable): SizeInt;
var
  Entry: TEntry;
begin
  Result := 0;
  for Entry in e do
    Result += Ord(DoRemove(Entry.Key, Entry.Value));
end;

function TGCustomMultiMap.DoRemoveValues(constref aKey: TKey; constref a: array of TValue): SizeInt;
var
  p: PMMEntry;
  v: TValue;
begin
  p := Find(aKey);
  Result := 0;
  if p <> nil then
    begin
      for v in a do
        Result += Ord( p^.Values.Remove(v));
      FCount -= Result;
      if p^.Values.Count = 0 then
        DoRemoveKey(aKey);
    end;
end;

function TGCustomMultiMap.DoRemoveValues(constref aKey: TKey; e: IValueEnumerable): SizeInt;
var
  p: PMMEntry;
  v: TValue;
begin
  p := Find(aKey);
  Result := 0;
  if p <> nil then
    begin
      for v in e do
        Result += Ord( p^.Values.Remove(v));
      FCount -= Result;
      if p^.Values.Count = 0 then
        DoRemoveKey(aKey);
    end;
end;

function TGCustomMultiMap.DoRemoveKeys(constref a: array of TKey): SizeInt;
var
  k: TKey;
begin
  Result := 0;
  for k in a do
    Result += DoRemoveKey(k);
  FCount -= Result;
end;

function TGCustomMultiMap.DoRemoveKeys(e: IKeyEnumerable): SizeInt;
var
  k: TKey;
begin
  Result := 0;
  for k in e do
    Result += DoRemoveKey(k);
  FCount -= Result;
end;

function TGCustomMultiMap.IsEmpty: Boolean;
begin
  Result := Count = 0;
end;

function TGCustomMultiMap.NonEmpty: Boolean;
begin
  Result := Count <> 0;
end;

procedure TGCustomMultiMap.Clear;
begin
  CheckInIteration;
  DoClear;
  FCount := 0;
end;

procedure TGCustomMultiMap.EnsureCapacity(aValue: SizeInt);
begin
  CheckInIteration;
  DoEnsureCapacity(aValue);
end;

procedure TGCustomMultiMap.TrimToFit;
begin
  CheckInIteration;
  DoTrimToFit;
end;

function TGCustomMultiMap.Contains(constref aKey: TKey): Boolean;
begin
  Result := Find(aKey) <> nil;
end;

function TGCustomMultiMap.ContainsValue(constref aKey: TKey; constref aValue: TValue): Boolean;
var
  p: PMMEntry;
begin
  p := Find(aKey);
  if p <> nil then
    Result := p^.Values.Contains(aValue)
  else
    Result := False;
end;

function TGCustomMultiMap.Add(constref aKey: TKey; constref aValue: TValue): Boolean;
begin
  CheckInIteration;
  Result := DoAdd(aKey, aValue);
end;

function TGCustomMultiMap.Add(constref e: TEntry): Boolean;
begin
  Result := Add(e.Key, e.Value);
end;

function TGCustomMultiMap.AddAll(constref a: array of TEntry): SizeInt;
begin
  CheckInIteration;
  Result := DoAddAll(a);
end;

function TGCustomMultiMap.AddAll(e: IEntryEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoAddAll(e);
end;

function TGCustomMultiMap.AddValues(constref aKey: TKey; constref a: array of TValue): SizeInt;
begin
  CheckInIteration;
  Result := DoAddValues(aKey, a);
end;

function TGCustomMultiMap.AddValues(constref aKey: TKey; e: IValueEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoAddValues(aKey, e);
end;

function TGCustomMultiMap.Remove(constref aKey: TKey; constref aValue: TValue): Boolean;
begin
  CheckInIteration;
  Result := DoRemove(aKey, aValue);
end;

function TGCustomMultiMap.Remove(constref e: TEntry): Boolean;
begin
  Result := Remove(e.Key, e.Value);
end;

function TGCustomMultiMap.RemoveAll(constref a: array of TEntry): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveAll(a);
end;

function TGCustomMultiMap.RemoveAll(e: IEntryEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveAll(e);
end;

function TGCustomMultiMap.RemoveValues(constref aKey: TKey; constref a: array of TValue): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveValues(aKey, a);
end;

function TGCustomMultiMap.RemoveValues(constref aKey: TKey; e: IValueEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveValues(aKey, e);
end;

function TGCustomMultiMap.RemoveKey(constref aKey: TKey): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveKey(aKey);
  FCount -= Result;
end;

function TGCustomMultiMap.RemoveKeys(constref a: array of TKey): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveKeys(a);
end;

function TGCustomMultiMap.RemoveKeys(e: IKeyEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := DoRemoveKeys(e);
end;

function TGCustomMultiMap.CopyValues(const aKey: TKey): TValueArray;
var
  p: PMMEntry;
begin
  p := Find(aKey);
  if p <> nil then
    Result := p^.Values.ToArray
  else
    Result := nil;
end;

function TGCustomMultiMap.ViewValues(const aKey: TKey): IValueEnumerable;
var
  p: PMMEntry;
begin
  p := Find(aKey);
  if p <> nil then
    begin
      BeginIteration;
      Result := TCustomValueCursor.Create(p^.Values.GetEnumerator, Self);
    end
  else
    Result := specialize TGArrayCursor<TValue>.Create(nil);
end;

function TGCustomMultiMap.Keys: IKeyEnumerable;
begin
  BeginIteration;
  Result := GetKeys;
end;

function TGCustomMultiMap.Values: IValueEnumerable;
begin
  BeginIteration;
  Result := GetValues;
end;

function TGCustomMultiMap.Entries: IEntryEnumerable;
begin
  BeginIteration;
  Result := GetEntries;
end;

function TGCustomMultiMap.ValueCount(constref aKey: TKey): SizeInt;
var
  p: PMMEntry;
begin
  p := Find(aKey);
  if p <> nil then
    Result := p^.Values.Count
  else
    Result := 0;
end;

{ TGCustomTable2D.TCustomRowMap }

function TGCustomTable2D.TCustomRowMap.IsEmpty: Boolean;
begin
  Result := Count = 0;
end;

function TGCustomTable2D.TCustomRowMap.GetValueOrDefault(const aCol: TCol): TValue;
begin
  if not TryGetValue(aCol, Result) then
    Result := Default(TValue);
end;

{ TGCustomTable2D }

function TGCustomTable2D.GetColCount(const aRow: TRow): SizeInt;
var
  p: PRowEntry;
begin
  p := DoFindRow(aRow);
  if p <> nil then
    Result := p^.Columns.Count
  else
    Result := 0;
end;

function TGCustomTable2D.GetRow(const aRow: TRow): IRowMap;
var
  p: PRowEntry;
begin
  DoFindOrAddRow(aRow, p);
  Result := p^.Columns;
end;

function TGCustomTable2D.IsEmpty: Boolean;
begin
  Result := CellCount = 0;
end;

function TGCustomTable2D.NonEmpty: Boolean;
begin
  Result := CellCount <> 0;
end;

function TGCustomTable2D.ContainsRow(constref aRow: TRow): Boolean;
begin
  Result := DoFindRow(aRow) <> nil;
end;

function TGCustomTable2D.FindRow(constref aRow: TRow; out aMap: IRowMap): Boolean;
var
  p: PRowEntry;
begin
  p := DoFindRow(aRow);
  Result := p <> nil;
  if Result then
    aMap := p^.Columns;
end;

function TGCustomTable2D.FindOrAddRow(constref aRow: TRow; out aMap: IRowMap): Boolean;
var
  p: PRowEntry;
begin
  Result := DoFindOrAddRow(aRow, p);
  aMap := p^.Columns;
end;

function TGCustomTable2D.AddRow(constref aRow: TRow): Boolean;
var
  p: PRowEntry;
begin
  Result := not DoFindOrAddRow(aRow, p);
end;

function TGCustomTable2D.RemoveRow(constref aRow: TRow): SizeInt;
begin
  Result := DoRemoveRow(aRow);
end;

function TGCustomTable2D.ContainsCell(constref aRow: TRow; constref aCol: TCol): Boolean;
var
  p: PRowEntry;
begin
  p := DoFindRow(aRow);
  if p <> nil then
    Result := p^.Columns.Contains(aCol)
  else
    Result := False;
end;

function TGCustomTable2D.GetCell(constref aRow: TRow; constref aCol: TCol): TValue;
begin
  if not TryGetCell(aRow, aCol, Result) then
    raise ELGTableError.CreateFmt(SECellNotFoundFmt, [ClassName]);
end;

function TGCustomTable2D.TryGetCell(constref aRow: TRow; constref aCol: TCol; out aValue: TValue): Boolean;
var
  p: PRowEntry;
begin
  p := DoFindRow(aRow);
  if p <> nil then
    Result := p^.Columns.TryGetValue(aCol, aValue)
  else
    Result := False;
end;

function TGCustomTable2D.GetCellOrDefault(const aRow: TRow; const aCol: TCol): TValue;
begin
  if not TryGetCell(aRow, aCol, Result) then
    Result := Default(TValue);
end;

function TGCustomTable2D.TryGetCellDef(constref aRow: TRow; constref aCol: TCol; aDef: TValue): TValue;
begin
  if not TryGetCell(aRow, aCol, Result) then
    Result := aDef;
end;

procedure TGCustomTable2D.AddOrSetCell(const aRow: TRow; const aCol: TCol; const aValue: TValue);
var
  p: PRowEntry;
begin
  DoFindOrAddRow(aRow, p);
  p^.Columns[aCol] := aValue;
end;

function TGCustomTable2D.AddCell(constref aRow: TRow; constref aCol: TCol; constref aValue: TValue): Boolean;
begin
  Result := not ContainsCell(aRow, aCol);
  if Result then
    AddOrSetCell(aRow, aCol, aValue);
end;

function TGCustomTable2D.AddCell(constref e: TCellData): Boolean;
begin
  Result := AddCell(e.Row, e.Column, e.Value);
end;

function TGCustomTable2D.AddAll(constref a: array of TCellData): SizeInt;
var
  e: TCellData;
begin
  Result := 0;
  for e in a do
    Result += Ord(AddCell(e));
end;

function TGCustomTable2D.RemoveCell(const aRow: TRow; const aCol: TCol): Boolean;
var
  p: PRowEntry;
begin
  p := DoFindRow(aRow);
  if p <> nil then
    begin
      Result := p^.Columns.Remove(aCol);
      if Result and p^.Columns.IsEmpty then
        DoRemoveRow(aRow);
    end
  else
    Result := False;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic deque(double ended queue) implementation.                       *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGDeque;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGArrayHelpers,
  LGStrConst;

type

  { TGDeque }

  generic TGDeque<T> = class(specialize TGCustomRingArrayBuffer<T>, specialize IGDeque<T>)
  protected
  const
    SIZE_CUTOFF = 64;

    procedure DoPushFirst(constref aValue: T);
    function  TailIndex: SizeInt; inline;
    function  PeekTail: T; inline;
    function  ExtractTail: T;
    function  AddArray2Head(constref a: array of T): SizeInt;
    function  AddContainer2Head(aContainer: TCustomContainer): SizeInt;
    function  AddEnum2Head(e: IEnumerable): SizeInt;
    function  InternalIndex(aIndex: SizeInt): SizeInt; inline;
    function  FastGetItem(aIndex: SizeInt): T; inline;
    procedure FastSetItem(aIndex: SizeInt; aValue: T); inline;
    procedure FastSwap(L, R: SizeInt);
    function  GetItem(aIndex: SizeInt): T; inline;
    procedure SetItem(aIndex: SizeInt; const aValue: T); virtual;
    procedure ShiftHeadRight(aToIndex: SizeInt);
    procedure ShiftHeadLeft(aFromIndex: SizeInt);
    procedure ShiftTailRight(aFromIndex: SizeInt);
    procedure ShiftTailLeft(aToIndex: SizeInt);
    procedure InsertItem(aIndex: SizeInt; aValue: T);
    function  ExtractItem(aIndex: SizeInt): T;
    function  DeleteItem(aIndex: SizeInt): T; virtual;
  public
    procedure PushFirst(constref aValue: T); inline;
    function  PushAllFirst(constref a: array of T): SizeInt;
    function  PushAllFirst(e: IEnumerable): SizeInt; inline;
    procedure PushLast(constref aValue: T); inline;
    function  PushAllLast(constref a: array of T): SizeInt;
    function  PushAllLast(e: IEnumerable): SizeInt; inline;
  { EXTRACTS element from the head of deque; will raise ELGAccessEmpty if inctance is empty;
    will raise ELGUpdateLock if instance in iteration }
    function  PopFirst: T;
    function  TryPopFirst(out aValue: T): Boolean;
  { EXTRACTS element from the tail of deque; will raise ELGAccessEmpty if inctance is empty;
    will raise ELGUpdateLock if instance in iteration }
    function  PopLast: T;
    function  TryPopLast(out aValue: T): Boolean;
  { examines element in the head of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PeekFirst: T;
    function  TryPeekFirst(out aValue: T): Boolean;
  { examines element in the tail of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PeekLast: T;
    function  TryPeekLast(out aValue: T): Boolean;
  { inserts aValue into position aIndex;
    will raise ELGListError if aIndex out of bounds(aIndex = Count  is allowed);
    will raise ELGUpdateLock if instance in iteration }
    procedure Insert(aIndex: SizeInt; constref aValue: T);
  { will return False if aIndex out of bounds or instance in iteration }
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
  { extracts value from position aIndex;
    will raise ELGListError if aIndex out of bounds;
    will raise ELGUpdateLock if instance in iteration }
    function  Extract(aIndex: SizeInt): T;
  { will return False if aIndex out of bounds or instance in iteration }
    function  TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
  { deletes value in position aIndex;
    will raise ELGListError if aIndex out of bounds;
    will raise ELGUpdateLock if instance in iteration }
    procedure Delete(aIndex: SizeInt);
  { will return False if aIndex out of bounds or instance in iteration }
    function  TryDelete(aIndex: SizeInt): Boolean;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
  end;

  { TGObjectDeque notes:
    TGObjectDeque.PopFirst(or TGObjectDeque.TryPopFirst) and
    TGObjectDeque.PopLast(or TGObjectDeque.TryPopLast) EXTRACTS object from deque:
    one must to free this object yourself;
    for equality comparision of items uses TObjectHelper from LGHelpers  }
  generic TGObjectDeque<T: class> = class(specialize TGDeque<T>)
  private
    FOwnsObjects: Boolean;
  protected
    procedure DoClear; override;
    procedure SetItem(aIndex: SizeInt; const aValue: T); override;
    function  DeleteItem(aIndex: SizeInt): T; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(constref A: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGThreadDeque }

  generic TGThreadDeque<T> = class
  public
  type
    IDeque = specialize IGDeque<T>;
  private
    FDeque: IDeque;
    FLock: TRtlCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create(aDeque: IDeque);
    destructor Destroy; override;
    procedure Clear;
    procedure PushFirst(constref aValue: T); inline;
    procedure PushLast(constref aValue: T); inline;
    function  TryPopFirst(out aValue: T): Boolean;
    function  TryPopLast(out aValue: T): Boolean;
    function  TryPeekFirst(out aValue: T): Boolean;
    function  TryPeekLast(out aValue: T): Boolean;
    function  Lock: IDeque;
    procedure Unlock; inline;
  end;

  { TGLiteDeque }

  generic TGLiteDeque<T> = record
  public
  type
    TBuffer     = specialize TGLiteRingDynBuffer<T>;
    TEnumerator = TBuffer.TEnumerator;
    TMutable    = TBuffer.TMutable;
    TReverse    = TBuffer.TReverse;
    TArray      = TBuffer.TArray;

  private
  const
    SIZE_CUTOFF = 64;

  type
    TFake = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(SizeOf(T))] of Byte{$ELSE}T{$ENDIF};

  var
    FBuffer: TBuffer;
    function  GetCapacity: SizeInt; inline;
    function  InternalIndex(aIndex: SizeInt): SizeInt; inline;
    function  FastGetItem(aIndex: SizeInt): T; inline;
    procedure FastSetItem(aIndex: SizeInt; constref aValue: T); inline;
    procedure FastSwap(L, R: SizeInt); inline;
    function  GetItem(aIndex: SizeInt): T; inline;
    procedure SetItem(aIndex: SizeInt; const aValue: T); inline;
    procedure ShiftHeadRight(aToIndex: SizeInt);
    procedure ShiftHeadLeft(aFromIndex: SizeInt);
    procedure ShiftTailRight(aFromIndex: SizeInt);
    procedure ShiftTailLeft(aToIndex: SizeInt);
    procedure InsertItem(aIndex: SizeInt; aValue: T);
    function  DeleteItem(aIndex: SizeInt): T; inline;
    procedure IndexOutOfBoundError(aIndex: SizeInt); inline;
    function  IndexInRange(aIndex: SizeInt): Boolean; inline;
    function  IndexInInsertRange(aIndex: SizeInt): Boolean; inline;
    procedure CheckIndexRange(aIndex: SizeInt); inline;
    procedure CheckInsertIndexRange(aIndex: SizeInt); inline;
  public
    function  GetEnumerator: TEnumerator; inline;
    function  Mutable: TMutable; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    procedure PushFirst(constref aValue: T); inline;
    procedure PushLast(constref aValue: T); inline;
  { EXTRACTS element from the head of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PopFirst: T; inline;
    function  TryPopFirst(out aValue: T): Boolean; inline;
  { EXTRACTS element from the tail of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PopLast: T; inline;
    function  TryPopLast(out aValue: T): Boolean; inline;
  { examines element in the head of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PeekFirst: T; inline;
    function  TryPeekFirst(out aValue: T): Boolean;
  { examines element in the tail of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PeekLast: T; inline;
    function  TryPeekLast(out aValue: T): Boolean; inline;
  { inserts aValue into position aIndex;
    will raise ELGListError if aIndex out of bounds(aIndex = Count  is allowed) }
    procedure Insert(aIndex: SizeInt; constref aValue: T);
  { will return False if aIndex out of bounds }
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
  { deletes and returns value from position aIndex;
    will raise ELGListError if aIndex out of bounds }
    function  Delete(aIndex: SizeInt): T;
  { will return False if aIndex out of bounds }
    function  TryDelete(aIndex: SizeInt; out aValue: T): Boolean;
    property  Count: SizeInt read FBuffer.FCount;
    property  Capacity: SizeInt read GetCapacity;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
  end;

  { TGLiteThreadDeque }

  generic TGLiteThreadDeque<T> = class
  public
  type
    TDeque = specialize TGLiteDeque<T>;
    PDeque = ^TDeque;

  private
    FDeque: TDeque;
    FLock: TRtlCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    procedure PushFirst(constref aValue: T); inline;
    procedure PushLast(constref aValue: T); inline;
    function  TryPopFirst(out aValue: T): Boolean;
    function  TryPopLast(out aValue: T): Boolean;
    function  TryPeekFirst(out aValue: T): Boolean;
    function  TryPeekLast(out aValue: T): Boolean;
    function  Lock: PDeque;
    procedure Unlock; inline;
  end;

  { TGLiteObjectDeque notes:
    TGLiteObjectDeque.PopFirst(or TGLiteObjectDeque.TryPopFirst) and
    TGLiteObjectDeque.PopLast(or TGLiteObjectDeque.TryPopLast) EXTRACTS object from deque:
    one must to free this object yourself;
    for equality comparision of items uses TObjectHelper from LGHelpers }
  generic TGLiteObjectDeque<T: class> = record
  public
  type
    TDeque      = specialize TGLiteDeque<T>;
    PDeque      = ^TDeque;
    TEnumerator = TDeque.TEnumerator;
    TReverse    = TDeque.TReverse;
    TArray      = TDeque.TArray;

  private
    FDeque: TDeque;
    FOwnsObjects: Boolean;
    procedure CheckFreeItems;
    function  GetCapacity: SizeInt; inline;
    function  GetCount: SizeInt; inline;
    function  GetItem(aIndex: SizeInt): T; inline;
    procedure SetItem(aIndex: SizeInt; const aValue: T);
    class operator Initialize(var d: TGLiteObjectDeque);
    class operator Finalize(var d: TGLiteObjectDeque);
  public
    function  InnerDeque: PDeque;
    function  GetEnumerator: TEnumerator; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    procedure PushFirst(constref aValue: T); inline;
    procedure PushLast(constref aValue: T); inline;
  { EXTRACTS element from the head of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PopFirst: T; inline;
    function  TryPopFirst(out aValue: T): Boolean; inline;
  { EXTRACTS element from the tail of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PopLast: T; inline;
    function  TryPopLast(out aValue: T): Boolean;
  { examines element in the head of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PeekFirst: T; inline;
    function  TryPeekFirst(out aValue: T): Boolean;
  { examines element in the tail of deque; will raise ELGAccessEmpty if inctance is empty }
    function  PeekLast: T; inline;
    function  TryPeekLast(out aValue: T): Boolean; inline;
  { inserts aValue into position aIndex;
    will raise ELGListError if aIndex out of bounds(aIndex = Count  is allowed) }
    procedure Insert(aIndex: SizeInt; constref aValue: T); inline;
  { will return False if aIndex out of bounds }
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean; inline;
  { extracts value from position aIndex;
    will raise ELGListError if aIndex out of bounds }
    function  Extract(aIndex: SizeInt): T; inline;
  { will return False if aIndex out of bounds }
    function  TryExtract(aIndex: SizeInt; out aValue: T): Boolean; inline;
  { deletes value in position aIndex;
    will raise ELGListError if aIndex out of bounds }
    procedure Delete(aIndex: SizeInt); inline;
  { will return False if aIndex out of bounds }
    function  TryDelete(aIndex: SizeInt): Boolean; inline;
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGLiteThreadObjectDeque }

  generic TGLiteThreadObjectDeque<T: class> = class
  public
  type
    TDeque = specialize TGLiteObjectDeque<T>;
    PDeque = ^TDeque;

  private
    FDeque: TDeque;
    FLock: TRtlCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    procedure PushFirst(constref aValue: T); inline;
    procedure PushLast(constref aValue: T); inline;
    function  TryPopFirst(out aValue: T): Boolean;
    function  TryPopLast(out aValue: T): Boolean;
    function  TryPeekFirst(out aValue: T): Boolean;
    function  TryPeekLast(out aValue: T): Boolean;
    function  Lock: PDeque;
    procedure Unlock; inline;
  end;

  { TGDequeHelpUtil }

  generic TGDequeHelpUtil<T> = class
  public
  type
    TDeque           = class(specialize TGDeque<T>);
    TLiteDeque       = specialize TGLiteDeque<T>;
    TEqualityCompare = specialize TGEqualCompare<T>;
  protected
    class procedure DoReverse(d: TDeque; L, R: SizeInt); static; inline;
    class procedure DoReverse(var d: TLiteDeque; L, R: SizeInt); static; inline;
  public
    class procedure Reverse(d: TDeque); static;
    class procedure Reverse(var d: TLiteDeque); static; inline;
    class procedure RandomShuffle(d: TDeque); static;
    class procedure RandomShuffle(var d: TLiteDeque); static;
    class function  SequentSearch(d: TDeque; constref aValue: T; c: TEqualityCompare): SizeInt; static;
    class function  SequentSearch(constref d: TLiteDeque; constref aValue: T; c: TEqualityCompare): SizeInt; static;
    class function  Same(d1, d2: TDeque; c: TEqualityCompare): Boolean; static;
    class function  Same(constref d1, d2: TLiteDeque; c: TEqualityCompare): Boolean; static;
  end;

  { TGBaseDequeHelper }

  generic TGBaseDequeHelper<T, TCmpRel> = class(specialize TGDequeHelpUtil<T>)
  protected
  type
    THelper    = class(specialize TGBaseArrayHelper<T, TCmpRel>);
    TFake      = THelper.TFake;
    TSortSplit = THelper.TSortSplit;
    class function  DoBinSearch(d: TDeque; constref aValue: T): SizeInt; static;
    class function  DoBinSearch(constref d: TLiteDeque; constref aValue: T): SizeInt; static;
    class function  CountRun2Asc(d: TDeque; R: SizeInt): SizeInt;
    class function  CountRun2Asc(var d: TLiteDeque; R: SizeInt): SizeInt;
    class procedure InsertionSort(d: TDeque; L, R: SizeInt); static;
    class procedure InsertionSort(var d: TLiteDeque; L, R: SizeInt); static;
    class procedure DoHeapSort(d: TDeque; L, R: SizeInt); static;
    class procedure DoHeapSort(var d: TLiteDeque; L, R: SizeInt); static;
    class function  QSplitR(d: TDeque; L, R: SizeInt): TSortSplit; static;
    class function  QSplitR(var d: TLiteDeque; L, R: SizeInt): TSortSplit; static;
    class procedure DoQSort(d: TDeque; L, R: SizeInt); static;
    class procedure DoQSort(var d: TLiteDeque; L, R: SizeInt); static;
    class function  GetMo9Pivot(d: TDeque; L, R: SizeInt): T; static;
    class function  GetMo9Pivot(constref d: TLiteDeque; L, R: SizeInt): T; static;
    class function  QSplitMo9(d: TDeque; L, R: SizeInt): TSortSplit; static;
    class function  QSplitMo9(var d: TLiteDeque; L, R: SizeInt): TSortSplit; static;
    class procedure DoIntroSort(d: TDeque; L, R, Ttl: SizeInt); static;
    class procedure DoIntroSort(var d: TLiteDeque; L, R, Ttl: SizeInt); static;
  public
  type
    TOptional = specialize TGOptional<T>;
    class function  SequentSearch(d: TDeque; constref aValue: T): SizeInt; static;
    class function  SequentSearch(constref d: TLiteDeque; constref aValue: T): SizeInt; static;
    class function  BinarySearch(d: TDeque; constref aValue: T): SizeInt; static; inline;
    class function  BinarySearch(constref d: TLiteDeque; constref aValue: T): SizeInt; static; inline;
    class function  IndexOfMin(d: TDeque): SizeInt; static;
    class function  IndexOfMin(constref d: TLiteDeque): SizeInt; static;
    class function  IndexOfMax(d: TDeque): SizeInt; static;
    class function  IndexOfMax(constref d: TLiteDeque): SizeInt; static;
    class function  GetMin(d: TDeque): TOptional; static;
    class function  GetMin(constref d: TLiteDeque): TOptional; static;
    class function  GetMax(d: TDeque): TOptional; static;
    class function  GetMax(constref d: TLiteDeque): TOptional; static;
    class function  FindMin(d: TDeque; out aValue: T): Boolean; static;
    class function  FindMin(constref d: TLiteDeque; out aValue: T): Boolean; static;
    class function  FindMax(d: TDeque; out aValue: T): Boolean; static;
    class function  FindMax(constref d: TLiteDeque; out aValue: T): Boolean; static;
    class function  FindMinMax(d: TDeque; out aMin, aMax: T): Boolean; static;
    class function  FindMinMax(constref d: TLiteDeque; out aMin, aMax: T): Boolean; static;
    class function  FindNthSmallest(d: TDeque; N: SizeInt; out aValue: T): Boolean; static;
    class function  FindNthSmallest(constref d: TLiteDeque; N: SizeInt; out aValue: T): Boolean; static;
    class function  NthSmallest(d: TDeque; N: SizeInt): TOptional; static;
    class function  NthSmallest(constref d: TLiteDeque; N: SizeInt): TOptional; static;
    class function  NextPermutation2Asc(d: TDeque): Boolean; static;
    class function  NextPermutation2Asc(var d: TLiteDeque): Boolean; static;
    class function  NextPermutation2Desc(d: TDeque): Boolean; static;
    class function  NextPermutation2Desc(var d: TLiteDeque): Boolean; static;
    class function  IsNonDescending(d: TDeque): Boolean; static;
    class function  IsNonDescending(constref d: TLiteDeque): Boolean; static;
    class function  IsStrictAscending(d: TDeque): Boolean; static;
    class function  IsStrictAscending(constref d: TLiteDeque): Boolean; static;
    class function  IsNonAscending(d: TDeque): Boolean; static;
    class function  IsNonAscending(constref d: TLiteDeque): Boolean; static;
    class function  IsStrictDescending(d: TDeque): Boolean; static;
    class function  IsStrictDescending(constref d: TLiteDeque): Boolean; static;
    class function  Same(d1, d2: TDeque): Boolean; static;
    class function  Same(constref d1, d2: TLiteDeque): Boolean; static;
    class procedure QuickSort(d: TDeque; o: TSortOrder = soAsc); static;
    class procedure QuickSort(var d: TLiteDeque; o: TSortOrder = soAsc); static;
    class procedure IntroSort(d: TDeque; o: TSortOrder = soAsc); static;
    class procedure IntroSort(var d: TLiteDeque; o: TSortOrder = soAsc); static;
    class procedure Sort(d: TDeque; o: TSortOrder = soAsc); static; inline;
    class procedure Sort(var d: TLiteDeque; o: TSortOrder = soAsc); static; inline;
  { copies only distinct values from v }
    class function  SelectDistinct(d: TDeque): TDeque.TArray; static; inline;
    class function  SelectDistinct(constref d: TLiteDeque): TDeque.TArray; static; inline;
  end;

  { TGDequeHelper assumes that type T implements TCmpRel }
  generic TGDequeHelper<T> = class(specialize TGBaseDequeHelper<T, T>);

implementation
{$B-}{$COPERATORS ON}

{ TGDeque }

procedure TGDeque.DoPushFirst(constref aValue: T);
begin
  ItemAdding;
  Dec(FHead);
  if Head < 0 then
    FHead += System.Length(FItems);
  Inc(FCount);
  FItems[Head] := aValue;
end;

function TGDeque.TailIndex: SizeInt;
begin
  Result := InternalIndex(Pred(ElemCount));
end;

function TGDeque.PeekTail: T;
begin
  Result := FItems[TailIndex];
end;

function TGDeque.ExtractTail: T;
var
  TailPos: SizeInt;
begin
  TailPos := TailIndex;
  Dec(FCount);
  Result := FItems[TailPos];
  FItems[TailPos] := Default(T);
end;

function TGDeque.AddArray2Head(constref a: array of T): SizeInt;
var
  HeadPos, I, c: SizeInt;
begin
  Result := System.Length(a);
  if Result > 0 then
    begin
      DoEnsureCapacity(ElemCount + Result);
      c := System.Length(FItems);
      HeadPos := Head;
      for I := 0 to System.High(a) do
        begin
          Dec(HeadPos);
          if HeadPos < 0 then
            HeadPos += c;
          FItems[HeadPos] := a[I];
        end;
      FCount += Result;
      FHead := HeadPos;
    end;
end;

function TGDeque.AddContainer2Head(aContainer: TCustomContainer): SizeInt;
var
  HeadPos, c: SizeInt;
  v: T;
begin
  if aContainer <> Self then
    begin
      Result := aContainer.Count;
      if Result > 0 then
        begin
          DoEnsureCapacity(ElemCount + Result);
          c := System.Length(FItems);
          HeadPos := Head;
          for v in aContainer do
            begin
              Dec(HeadPos);
              if HeadPos < 0 then
                HeadPos += c;
              FItems[HeadPos] := v;
            end;
          FCount += Result;
          FHead := HeadPos;
        end;
    end
  else
    Result := AddArray2Head(aContainer.ToArray);
end;

function TGDeque.AddEnum2Head(e: IEnumerable): SizeInt;
var
  v: T;
begin
  Result := ElemCount;
  for v in e do
    begin
      ItemAdding;
      Dec(FHead);
      if Head < 0 then
        FHead += System.Length(FItems);
      Inc(FCount);
      FItems[Head] := v;
    end;
  Result := ElemCount - Result;
end;

function TGDeque.InternalIndex(aIndex: SizeInt): SizeInt;
begin
  Result := aIndex + Head;
  if Result >= System.Length(FItems) then
    Result -= System.Length(FItems);
end;

function TGDeque.FastGetItem(aIndex: SizeInt): T;
begin
  Result := FItems[InternalIndex(aIndex)];
end;

procedure TGDeque.FastSetItem(aIndex: SizeInt; aValue: T);
begin
  FItems[InternalIndex(aIndex)] := aValue;
end;

procedure TGDeque.FastSwap(L, R: SizeInt);
var
  c: SizeInt;
  v: TFake;
begin
  c := System.Length(FItems);
  L += Head;
  R += Head;
  if L >= c then
    L -= c;
  if R >= c then
    R -= c;
  v := TFake(FItems[L]);
  TFake(FItems[L]) := TFake(FItems[R]);
  TFake(FItems[R]) := v;
end;

function TGDeque.GetItem(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := FastGetItem(aIndex);
end;

procedure TGDeque.SetItem(aIndex: SizeInt; const aValue: T);
begin
  //CheckInIteration;  ???
  CheckIndexRange(aIndex);
  FastSetItem(aIndex, aValue);
end;

procedure TGDeque.ShiftHeadRight(aToIndex: SizeInt);
var
  I, Curr, Prev, c: SizeInt;
begin
  c := System.Length(FItems);
  Curr := InternalIndex(aToIndex);
  for I := aToIndex downto 1 do
    begin
      Prev := Pred(Curr);
      if Prev < 0 then
        Prev += c;
      TFake(FItems[Curr]) := TFake(FItems[Prev]);
      Curr := Prev;
    end;
  TFake(FItems[Curr]) := Default(TFake); //clear old head slot
  Inc(FHead);
  if FHead >= c then
    FHead -= c;
end;

procedure TGDeque.ShiftHeadLeft(aFromIndex: SizeInt);
var
  I, Curr, Next, c: SizeInt;
begin
  c := System.Length(FItems);
  Dec(FHead);
  if FHead < 0 then
    FHead += c;
  Curr := Head;
  for I := 0 to Pred(aFromIndex) do
    begin
      Next := Succ(Curr);
      if Next >= c then
        Next -= c;
      TFake(FItems[Curr]) := TFake(FItems[Next]);
      Curr := Next;
    end;
  TFake(FItems[Curr]) := Default(TFake); //clear last slot
end;

procedure TGDeque.ShiftTailRight(aFromIndex: SizeInt);
var
  I, Curr, Prev, c: SizeInt;
begin
  c := System.Length(FItems);
  Curr := InternalIndex(Pred(ElemCount));  //here FCount already increased
  for I := Pred(ElemCount) downto Succ(aFromIndex) do
    begin
      Prev := Pred(Curr);
      if Prev < 0 then
        Prev += c;
      TFake(FItems[Curr]) := TFake(FItems[Prev]);
      Curr := Prev;
    end;
  TFake(FItems[Curr]) := Default(TFake); //clear old aFromIndex slot
end;

procedure TGDeque.ShiftTailLeft(aToIndex: SizeInt);
var
  I, Curr, Next, c: SizeInt;
begin
  c := System.Length(FItems);
  Curr := InternalIndex(aToIndex);
  for I := aToIndex to Pred(ElemCount) do //here FCount already decreased
    begin
      Next := Succ(Curr);
      if Next >= c then
        Next -= c;
      TFake(FItems[Curr]) := TFake(FItems[Next]);
      Curr := Next;
    end;
  TFake(FItems[Curr]) := Default(TFake); //clear last slot
end;

procedure TGDeque.InsertItem(aIndex: SizeInt; aValue: T);
begin
  if aIndex = 0 then
    DoPushFirst(aValue)
  else
    if aIndex = ElemCount then
      Append(aValue)
    else
      begin
        ItemAdding;
        Inc(FCount); ////
        if ElemCount <= SIZE_CUTOFF then
          ShiftTailRight(aIndex)
        else
          if aIndex >= Pred(ElemCount shr 1) then
            ShiftTailRight(aIndex)
          else
            ShiftHeadLeft(aIndex);
        FItems[InternalIndex(aIndex)] := aValue;
      end;
end;

function TGDeque.ExtractItem(aIndex: SizeInt): T;
var
  I: SizeInt;
begin
  if aIndex = 0 then
    Result := ExtractHead
  else
    if aIndex = Pred(ElemCount) then
      Result := ExtractTail
    else
      begin
        I := InternalIndex(aIndex);
        Result := FItems[I];
        FItems[I] := Default(T);
        Dec(FCount);  ///////
        if ElemCount <= SIZE_CUTOFF then
            ShiftTailLeft(aIndex)
        else
          if aIndex >= Pred(ElemCount shr 1) then
            ShiftTailLeft(aIndex)
          else
            ShiftHeadRight(aIndex);
      end;
end;

function TGDeque.DeleteItem(aIndex: SizeInt): T;
begin
  Result := ExtractItem(aIndex);
end;

procedure TGDeque.PushFirst(constref aValue: T);
begin
  CheckInIteration;
  DoPushFirst(aValue);
end;

function TGDeque.PushAllFirst(constref a: array of T): SizeInt;
begin
  CheckInIteration;
  Result := AddArray2Head(a);
end;

function TGDeque.PushAllFirst(e: IEnumerable): SizeInt;
var
  o: TObject;
begin
  CheckInIteration;
  o := e._GetRef;
  if o is TCustomContainer then
    Result := AddContainer2Head(TCustomContainer(o))
  else
    Result := AddEnum2Head(e);
end;

procedure TGDeque.PushLast(constref aValue: T);
begin
  CheckInIteration;
  Append(aValue);
end;

function TGDeque.PushAllLast(constref a: array of T): SizeInt;
begin
  CheckInIteration;
  Result := AppendArray(a);
end;

function TGDeque.PushAllLast(e: IEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := AppendEnumerable(e);
end;

function TGDeque.PopFirst: T;
begin
  CheckInIteration;
  CheckEmpty;
  Result := ExtractHead;
end;

function TGDeque.TryPopFirst(out aValue: T): Boolean;
begin
  Result := not InIteration and (ElemCount > 0);
  if Result then
    aValue := ExtractHead;
end;

function TGDeque.PopLast: T;
begin
  CheckInIteration;
  CheckEmpty;
  Result := ExtractTail;
end;

function TGDeque.TryPopLast(out aValue: T): Boolean;
begin
  Result := not InIteration and (ElemCount > 0);
  if Result then
    aValue := ExtractTail;
end;

function TGDeque.PeekFirst: T;
begin
  CheckEmpty;
  Result := Items[Head];
end;

function TGDeque.TryPeekFirst(out aValue: T): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aValue := FItems[Head];
end;

function TGDeque.PeekLast: T;
begin
  CheckEmpty;
  Result := PeekTail;
end;

function TGDeque.TryPeekLast(out aValue: T): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aValue := PeekTail;
end;

procedure TGDeque.Insert(aIndex: SizeInt; constref aValue: T);
begin
  CheckInIteration;
  CheckInsertIndexRange(aIndex);
  InsertItem(aIndex, aValue);
end;

function TGDeque.TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
begin
  Result := not InIteration and IndexInInsertRange(aIndex);
  if Result then
    InsertItem(aIndex, aValue);
end;

function TGDeque.Extract(aIndex: SizeInt): T;
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  Result := ExtractItem(aIndex);
end;

function TGDeque.TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
begin
  Result := not InIteration and IndexInRange(aIndex);
  if Result then
    aValue := ExtractItem(aIndex);
end;

procedure TGDeque.Delete(aIndex: SizeInt);
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  DeleteItem(aIndex);
end;

function TGDeque.TryDelete(aIndex: SizeInt): Boolean;
begin
  Result := not InIteration and IndexInRange(aIndex);
  if Result then
    DeleteItem(aIndex);
end;

{ TGObjectDeque }

procedure TGObjectDeque.DoClear;
var
  I, CurrIdx, c: SizeInt;
begin
  if OwnsObjects and (ElemCount > 0) then
    begin
      CurrIdx := FHead;
      c := Capacity;
      for I := 1 to ElemCount do
        begin
          FItems[CurrIdx].Free;
          Inc(CurrIdx);
          if CurrIdx = c then
            CurrIdx := 0;
        end;
    end;
  inherited;
end;

procedure TGObjectDeque.SetItem(aIndex: SizeInt; const aValue: T);
var
  v: T;
begin
  //CheckInIteration;
  CheckIndexRange(aIndex);
  if OwnsObjects then
    begin
      v := FastGetItem(aIndex);
      if not TObject.Equal(v, aValue) then
        v.Free;
    end;
  FastSetItem(aIndex, aValue);
end;

function TGObjectDeque.DeleteItem(aIndex: SizeInt): T;
begin
  Result := inherited DeleteItem(aIndex);
  if OwnsObjects then
    Result.Free;
end;

constructor TGObjectDeque.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectDeque.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectDeque.Create(constref A: array of T; aOwnsObjects: Boolean = True);
begin
  inherited Create(A);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectDeque.Create(e: IEnumerable; aOwnsObjects: Boolean = True);
begin
  inherited Create(e);
  FOwnsObjects := aOwnsObjects;
end;

procedure TGThreadDeque.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGThreadDeque.Create(aDeque: IDeque);
begin
  System.InitCriticalSection(FLock);
  FDeque := aDeque;
end;

destructor TGThreadDeque.Destroy;
begin
  DoLock;
  try
    FDeque._GetRef.Free;
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGThreadDeque.Clear;
begin
  DoLock;
  try
    FDeque.Clear;
  finally
    UnLock;
  end;
end;

procedure TGThreadDeque.PushFirst(constref aValue: T);
begin
  DoLock;
  try
    FDeque.PushFirst(aValue);
  finally
    UnLock;
  end;
end;

procedure TGThreadDeque.PushLast(constref aValue: T);
begin
  DoLock;
  try
    FDeque.PushLast(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadDeque.TryPopFirst(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPopFirst(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadDeque.TryPopLast(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPopLast(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadDeque.TryPeekFirst(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPeekFirst(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadDeque.TryPeekLast(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPeekLast(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadDeque.Lock: IDeque;
begin
  Result := FDeque;
  DoLock;
end;

procedure TGThreadDeque.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

{ TGLiteDeque }

function TGLiteDeque.GetCapacity: SizeInt;
begin
  Result := FBuffer.Capacity;
end;

function TGLiteDeque.InternalIndex(aIndex: SizeInt): SizeInt;
begin
  Result := FBuffer.InternalIndex(aIndex);
end;

function TGLiteDeque.FastGetItem(aIndex: SizeInt): T;
begin
  Result := FBuffer.FastGetItem(aIndex);
end;

procedure TGLiteDeque.FastSetItem(aIndex: SizeInt; constref aValue: T);
begin
  FBuffer.FastSetItem(aIndex, aValue);
end;

procedure TGLiteDeque.FastSwap(L, R: SizeInt);
var
  c: SizeInt;
  v: TFake;
begin
  c := FBuffer.Capacity;
  L += FBuffer.Head;
  R += FBuffer.Head;
  if L >= c then
    L -= c;
  if R >= c then
    R -= c;
  v := TFake(FBuffer.FItems[L]);
  TFake(FBuffer.FItems[L]) := TFake(FBuffer.FItems[R]);
  TFake(FBuffer.FItems[R]) := v;
end;

function TGLiteDeque.GetItem(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := FastGetItem(aIndex);
end;

procedure TGLiteDeque.SetItem(aIndex: SizeInt; const aValue: T);
begin
  CheckIndexRange(aIndex);
  FastSetItem(aIndex, aValue);
end;

procedure TGLiteDeque.ShiftHeadRight(aToIndex: SizeInt);
var
  I, Curr, Prev, c: SizeInt;
begin
  c := FBuffer.Capacity;
  Curr := InternalIndex(aToIndex);
  for I := aToIndex downto 1 do
    begin
      Prev := Pred(Curr);
      if Prev < 0 then
        Prev += c;
      TFake(FBuffer.FItems[Curr]) := TFake(FBuffer.FItems[Prev]);
      Curr := Prev;
    end;
  TFake(FBuffer.FItems[Curr]) := Default(TFake); //clear old head slot
  Inc(FBuffer.FHead);
  if FBuffer.Head >= c then
    FBuffer.FHead -= c;
end;

procedure TGLiteDeque.ShiftHeadLeft(aFromIndex: SizeInt);
var
  I, Curr, Next, c: SizeInt;
begin
  c := FBuffer.Capacity;
  Dec(FBuffer.FHead);
  if FBuffer.Head < 0 then
    FBuffer.FHead += c;
  Curr := FBuffer.Head;
  for I := 0 to Pred(aFromIndex) do
    begin
      Next := Succ(Curr);
      if Next >= c then
        Next -= c;
      TFake(FBuffer.FItems[Curr]) := TFake(FBuffer.FItems[Next]);
      Curr := Next;
    end;
  TFake(FBuffer.FItems[Curr]) := Default(TFake); //clear last slot
end;

procedure TGLiteDeque.ShiftTailRight(aFromIndex: SizeInt);
var
  I, Curr, Prev, c: SizeInt;
begin
  c := FBuffer.Capacity;
  Curr := InternalIndex(Pred(Count));  //here FBuffer.FCount already increased
  for I := Pred(Count) downto Succ(aFromIndex) do
    begin
      Prev := Pred(Curr);
      if Prev < 0 then
        Prev += c;
      TFake(FBuffer.FItems[Curr]) := TFake(FBuffer.FItems[Prev]);
      Curr := Prev;
    end;
  TFake(FBuffer.FItems[Curr]) := Default(TFake); //clear old aFromIndex slot
end;

procedure TGLiteDeque.ShiftTailLeft(aToIndex: SizeInt);
var
  I, Curr, Next, c: SizeInt;
begin
  c := FBuffer.Capacity;
  Curr := InternalIndex(aToIndex);
  for I := aToIndex to Pred(Count) do //here FBuffer.FCount already decreased
    begin
      Next := Succ(Curr);
      if Next >= c then
        Next -= c;
      TFake(FBuffer.FItems[Curr]) := TFake(FBuffer.FItems[Next]);
      Curr := Next;
    end;
  TFake(FBuffer.FItems[Curr]) := Default(TFake); //clear last slot
end;

procedure TGLiteDeque.InsertItem(aIndex: SizeInt; aValue: T);
begin
  if aIndex = 0 then
    PushFirst(aValue)
  else
    if aIndex = Count then
      FBuffer.PushLast(aValue)
    else
      begin
        FBuffer.ItemAdding;
        Inc(FBuffer.FCount); ////
        if Count <= SIZE_CUTOFF then
          ShiftTailRight(aIndex)
        else
          if aIndex >= Pred(Count shr 1) then
            ShiftTailRight(aIndex)
          else
            ShiftHeadLeft(aIndex);
        FBuffer.FItems[InternalIndex(aIndex)] := aValue;
      end;
end;

function TGLiteDeque.DeleteItem(aIndex: SizeInt): T;
var
  I: SizeInt;
begin
  if aIndex = 0 then
    Result := FBuffer.PopHead
  else
    if aIndex = Pred(Count) then
      Result := FBuffer.PopTail
    else
      begin
        I := InternalIndex(aIndex);
        Result := FBuffer.FItems[I];
        FBuffer.FItems[I] := Default(T);
        Dec(FBuffer.FCount);  ///////
        if Count <= SIZE_CUTOFF then
            ShiftTailLeft(aIndex)
        else
          if aIndex >= Pred(Count shr 1) then
            ShiftTailLeft(aIndex)
          else
            ShiftHeadRight(aIndex);
      end;
end;

procedure TGLiteDeque.IndexOutOfBoundError(aIndex: SizeInt);
begin
  raise ELGListError.CreateFmt(SEIndexOutOfBoundsFmt, [aIndex]);
end;

function TGLiteDeque.IndexInRange(aIndex: SizeInt): Boolean;
begin
  Result := (aIndex >= 0) and (aIndex < FBuffer.Count);
end;

function TGLiteDeque.IndexInInsertRange(aIndex: SizeInt): Boolean;
begin
  Result := (aIndex >= 0) and (aIndex <= FBuffer.Count);
end;

procedure TGLiteDeque.CheckIndexRange(aIndex: SizeInt);
begin
  if not IndexInRange(aIndex) then
    IndexOutOfBoundError(aIndex);
end;

procedure TGLiteDeque.CheckInsertIndexRange(aIndex: SizeInt);
begin
  if not IndexInInsertRange(aIndex) then
    IndexOutOfBoundError(aIndex);
end;

function TGLiteDeque.GetEnumerator: TEnumerator;
begin
  Result := FBuffer.GetEnumerator;
end;

function TGLiteDeque.Mutable: TMutable;
begin
  Result := FBuffer.Mutable;
end;

function TGLiteDeque.Reverse: TReverse;
begin
  Result := FBuffer.Reverse;
end;

function TGLiteDeque.ToArray: TArray;
begin
  Result := FBuffer.ToArray;
end;

procedure TGLiteDeque.Clear;
begin
  FBuffer.Clear;
end;

function TGLiteDeque.IsEmpty: Boolean;
begin
  Result := FBuffer.Count = 0;
end;

function TGLiteDeque.NonEmpty: Boolean;
begin
  Result := FBuffer.Count <> 0;
end;

procedure TGLiteDeque.EnsureCapacity(aValue: SizeInt);
begin
  FBuffer.EnsureCapacity(aValue);
end;

procedure TGLiteDeque.TrimToFit;
begin
  FBuffer.TrimToFit;
end;

procedure TGLiteDeque.PushFirst(constref aValue: T);
begin
  FBuffer.PushFirst(aValue);
end;

procedure TGLiteDeque.PushLast(constref aValue: T);
begin
  FBuffer.PushLast(aValue);
end;

function TGLiteDeque.PopFirst: T;
begin
  Result := FBuffer.PopFirst;
end;

function TGLiteDeque.TryPopFirst(out aValue: T): Boolean;
begin
  Result := FBuffer.TryPopFirst(aValue);
end;

function TGLiteDeque.PopLast: T;
begin
  Result := FBuffer.PopLast;
end;

function TGLiteDeque.TryPopLast(out aValue: T): Boolean;
begin
  Result := FBuffer.TryPopLast(aValue);
end;

function TGLiteDeque.PeekFirst: T;
begin
  Result := FBuffer.PeekFirst;
end;

function TGLiteDeque.TryPeekFirst(out aValue: T): Boolean;
begin
  Result := FBuffer.TryPeekFirst(aValue);
end;

function TGLiteDeque.PeekLast: T;
begin
  Result := FBuffer.PeekLast;
end;

function TGLiteDeque.TryPeekLast(out aValue: T): Boolean;
begin
  Result := FBuffer.TryPeekLast(aValue);
end;

procedure TGLiteDeque.Insert(aIndex: SizeInt; constref aValue: T);
begin
  CheckInsertIndexRange(aIndex);
  InsertItem(aIndex, aValue);
end;

function TGLiteDeque.TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
begin
  Result := IndexInInsertRange(aIndex);
  if Result then
    InsertItem(aIndex, aValue);
end;

function TGLiteDeque.Delete(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := DeleteItem(aIndex);
end;

function TGLiteDeque.TryDelete(aIndex: SizeInt; out aValue: T): Boolean;
begin
  Result := IndexInRange(aIndex);
  if Result then
    aValue := DeleteItem(aIndex);
end;

{ TGLiteThreadDeque }

procedure TGLiteThreadDeque.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGLiteThreadDeque.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteThreadDeque.Destroy;
begin
  DoLock;
  try
    Finalize(FDeque);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGLiteThreadDeque.Clear;
begin
  DoLock;
  try
    FDeque.Clear;
  finally
    UnLock;
  end;
end;

procedure TGLiteThreadDeque.PushFirst(constref aValue: T);
begin
  DoLock;
  try
    FDeque.PushFirst(aValue);
  finally
    UnLock;
  end;
end;

procedure TGLiteThreadDeque.PushLast(constref aValue: T);
begin
  DoLock;
  try
    FDeque.PushLast(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadDeque.TryPopFirst(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPopFirst(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadDeque.TryPopLast(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPopLast(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadDeque.TryPeekFirst(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPeekFirst(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadDeque.TryPeekLast(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPeekLast(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadDeque.Lock: PDeque;
begin
  Result := @FDeque;
  DoLock;
end;

procedure TGLiteThreadDeque.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

{ TGLiteObjectDeque }

procedure TGLiteObjectDeque.CheckFreeItems;
var
  v: T;
begin
  if OwnsObjects then
    for v in FDeque do
      v.Free;
end;

function TGLiteObjectDeque.GetCapacity: SizeInt;
begin
  Result := FDeque.Capacity;
end;

function TGLiteObjectDeque.GetCount: SizeInt;
begin
  Result := FDeque.Count;
end;

function TGLiteObjectDeque.GetItem(aIndex: SizeInt): T;
begin
  Result := FDeque.GetItem(aIndex)
end;

procedure TGLiteObjectDeque.SetItem(aIndex: SizeInt; const aValue: T);
var
  v: T;
begin
  if OwnsObjects then
    begin
      FDeque.CheckIndexRange(aIndex);
      v := FDeque.FastGetItem(aIndex);
      if not TObject.Equal(v, aValue) then
        v.Free;
      FDeque.FastSetItem(aIndex, aValue);
    end
  else
    FDeque.SetItem(aIndex, aValue);
end;

class operator TGLiteObjectDeque.Initialize(var d: TGLiteObjectDeque);
begin
  d.OwnsObjects := True;
end;

class operator TGLiteObjectDeque.Finalize(var d: TGLiteObjectDeque);
begin
  d.Clear;
end;

function TGLiteObjectDeque.InnerDeque: PDeque;
begin
  Result := @FDeque;
end;

function TGLiteObjectDeque.GetEnumerator: TEnumerator;
begin
  Result := FDeque.GetEnumerator;
end;

function TGLiteObjectDeque.Reverse: TReverse;
begin
  Result := FDeque.Reverse;
end;

function TGLiteObjectDeque.ToArray: TArray;
begin
  Result := FDeque.ToArray;
end;

procedure TGLiteObjectDeque.Clear;
begin
  CheckFreeItems;
  FDeque.Clear;
end;

function TGLiteObjectDeque.IsEmpty: Boolean;
begin
  Result := FDeque.IsEmpty;
end;

function TGLiteObjectDeque.NonEmpty: Boolean;
begin
  Result := FDeque.NonEmpty;
end;

procedure TGLiteObjectDeque.EnsureCapacity(aValue: SizeInt);
begin
  FDeque.EnsureCapacity(aValue);
end;

procedure TGLiteObjectDeque.TrimToFit;
begin
  FDeque.TrimToFit;
end;

procedure TGLiteObjectDeque.PushFirst(constref aValue: T);
begin
  FDeque.PushFirst(aValue);
end;

procedure TGLiteObjectDeque.PushLast(constref aValue: T);
begin
  FDeque.PushLast(aValue);
end;

function TGLiteObjectDeque.PopFirst: T;
begin
  Result := FDeque.PopFirst;
end;

function TGLiteObjectDeque.TryPopFirst(out aValue: T): Boolean;
begin
  Result := FDeque.TryPopFirst(aValue);
end;

function TGLiteObjectDeque.PopLast: T;
begin
  Result := FDeque.PopLast;
end;

function TGLiteObjectDeque.TryPopLast(out aValue: T): Boolean;
begin
  Result := FDeque.TryPopLast(aValue);
end;

function TGLiteObjectDeque.PeekFirst: T;
begin
  Result := FDeque.PeekFirst;
end;

function TGLiteObjectDeque.TryPeekFirst(out aValue: T): Boolean;
begin
  Result := FDeque.TryPeekFirst(aValue);
end;

function TGLiteObjectDeque.PeekLast: T;
begin
  Result := FDeque.PeekLast;
end;

function TGLiteObjectDeque.TryPeekLast(out aValue: T): Boolean;
begin
  Result := FDeque.TryPeekLast(aValue);
end;

procedure TGLiteObjectDeque.Insert(aIndex: SizeInt; constref aValue: T);
begin
  FDeque.Insert(aIndex, aValue);
end;

function TGLiteObjectDeque.TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
begin
  Result := FDeque.TryInsert(aIndex, aValue);
end;

function TGLiteObjectDeque.Extract(aIndex: SizeInt): T;
begin
  Result := FDeque.Delete(aIndex);
end;

function TGLiteObjectDeque.TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
begin
  Result := FDeque.TryDelete(aIndex, aValue);
end;

procedure TGLiteObjectDeque.Delete(aIndex: SizeInt);
var
  v: T;
begin
  v := FDeque.Delete(aIndex);
  if OwnsObjects then
    v.Free;
end;

function TGLiteObjectDeque.TryDelete(aIndex: SizeInt): Boolean;
var
  v: T;
begin
  Result := FDeque.TryDelete(aIndex, v);
  if Result and OwnsObjects then
    v.Free;
end;

{ TGLiteThreadObjectDeque }

procedure TGLiteThreadObjectDeque.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGLiteThreadObjectDeque.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteThreadObjectDeque.Destroy;
begin
  DoLock;
  try
    Finalize(FDeque);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGLiteThreadObjectDeque.Clear;
begin
  DoLock;
  try
    FDeque.Clear;
  finally
    UnLock;
  end;
end;

procedure TGLiteThreadObjectDeque.PushFirst(constref aValue: T);
begin
  DoLock;
  try
    FDeque.PushFirst(aValue);
  finally
    UnLock;
  end;
end;

procedure TGLiteThreadObjectDeque.PushLast(constref aValue: T);
begin
  DoLock;
  try
    FDeque.PushLast(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectDeque.TryPopFirst(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPopFirst(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectDeque.TryPopLast(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPopLast(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectDeque.TryPeekFirst(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPeekFirst(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectDeque.TryPeekLast(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FDeque.TryPeekLast(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectDeque.Lock: PDeque;
begin
  Result := @FDeque;
  DoLock;
end;

procedure TGLiteThreadObjectDeque.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

{ TGDequeHelpUtil }

class procedure TGDequeHelpUtil.DoReverse(d: TDeque; L, R: SizeInt);
begin
  while L < R do
    begin
      d.FastSwap(L, R);
      Inc(L);
      Dec(R);
    end;
end;

class procedure TGDequeHelpUtil.DoReverse(var d: TLiteDeque; L, R: SizeInt);
begin
  while L < R do
    begin
      d.FastSwap(L, R);
      Inc(L);
      Dec(R);
    end;
end;

class procedure TGDequeHelpUtil.Reverse(d: TDeque);
var
  R: SizeInt;
begin
  R := Pred(d.ElemCount);
  if R > 0 then
    begin
      d.CheckInIteration;
      DoReverse(d, 0, R);
    end;
end;

class procedure TGDequeHelpUtil.Reverse(var d: TLiteDeque);
begin
   DoReverse(d, 0, Pred(d.Count));
end;

class procedure TGDequeHelpUtil.RandomShuffle(d: TDeque);
var
  I, J: SizeInt;
begin
  I := Pred(d.ElemCount);
  if I > 0 then
    begin
      d.CheckInIteration;
      for I := I downto 1 do
        begin
          J := Random(I);
          d.FastSwap(I, J);
        end;
    end;
end;

class procedure TGDequeHelpUtil.RandomShuffle(var d: TLiteDeque);
var
  I, J: SizeInt;
begin
  for I := Pred(d.Count) downto 1 do
    begin
      J := Random(I);
      d.FastSwap(I, J);
    end;
end;

class function TGDequeHelpUtil.SequentSearch(d: TDeque; constref aValue: T; c: TEqualityCompare): SizeInt;
begin
  for Result := 0 to Pred(d.ElemCount) do
    if c(aValue, d.FastGetItem(Result)) then
      exit;
  Result := -1;
end;

class function TGDequeHelpUtil.SequentSearch(constref d: TLiteDeque; constref aValue: T;
  c: TEqualityCompare): SizeInt;
begin
  for Result := 0 to Pred(d.Count) do
    if c(aValue, d.FastGetItem(Result)) then
      exit;
  Result := -1;
end;

class function TGDequeHelpUtil.Same(d1, d2: TDeque; c: TEqualityCompare): Boolean;
var
  I, Count: SizeInt;
begin
  Count := d1.ElemCount;
  if d2.ElemCount <> Count then
    exit(False);
  for I := 0 to Pred(Count) do
    if not c(d1.FastGetItem(I), d2.FastGetItem(I)) then
      exit(False);
  Result := True;
end;

class function TGDequeHelpUtil.Same(constref d1, d2: TLiteDeque; c: TEqualityCompare): Boolean;
var
  I, Count: SizeInt;
begin
  Count := d1.Count;
  if d2.Count <> Count then
    exit(False);
  for I := 0 to Pred(Count) do
    if not c(d1.FastGetItem(I), d2.FastGetItem(I)) then
      exit(False);
  Result := True;
end;

{ TGBaseDequeHelper }

class function TGBaseDequeHelper.DoBinSearch(d: TDeque; constref aValue: T): SizeInt;
var
  R, L, M, c: SizeInt;
begin
  //here R must be >= 0;
  R := Pred(d.ElemCount);
  Result := -1;
  L := 0;
  c := TCmpRel.Compare(d.FastGetItem(R), d.FastGetItem(0));
  if c > 0 then  //ascending
    begin
      while L < R do
        begin
          M := L + (R - L) shr 1;
          c := TCmpRel.Compare(d.FastGetItem(M), aValue);
          if c < 0 then
            L := Succ(M)
          else
            begin
              if c = 0 then
                exit(M);
              R := M;
            end;
        end;
      //here L >= R
      if TCmpRel.Compare(d.FastGetItem(R), aValue) = 0 then
        Result := R;
    end
  else
    if c < 0 then  //descending
      begin
        while L < R do
          begin
            M := L + ((R - L) shr 1);
            c := TCmpRel.Compare(d.FastGetItem(M), aValue);
            if c > 0 then
              L := Succ(M)
            else
              begin
                if c = 0 then
                  exit(M);
                R := M;
              end;
          end;
        //here L >= R
        if TCmpRel.Compare(d.FastGetItem(R), aValue) = 0 then
          Result := R;
      end
    else           //constant
      if TCmpRel.Compare(d.FastGetItem(L), aValue) = 0 then
        exit(L);
end;

class function TGBaseDequeHelper.DoBinSearch(constref d: TLiteDeque; constref aValue: T): SizeInt;
var
  R, L, M, c: SizeInt;
begin
  //here R must be >= 0;
  R := Pred(d.Count);
  Result := -1;
  L := 0;
  c := TCmpRel.Compare(d.FastGetItem(R), d.FastGetItem(0));
  if c > 0 then  //ascending
    begin
      while L < R do
        begin
          M := L + (R - L) shr 1;
          c := TCmpRel.Compare(d.FastGetItem(M), aValue);
          if c < 0 then
            L := Succ(M)
          else
            begin
              if c = 0 then
                exit(M);
              R := M;
            end;
        end;
      //here L >= R
      if TCmpRel.Compare(d.FastGetItem(R), aValue) = 0 then
        Result := R;
    end
  else
    if c < 0 then  //descending
      begin
        while L < R do
          begin
            M := L + ((R - L) shr 1);
            c := TCmpRel.Compare(d.FastGetItem(M), aValue);
            if c > 0 then
              L := Succ(M)
            else
              begin
                if c = 0 then
                  exit(M);
                R := M;
              end;
          end;
        //here L >= R
        if TCmpRel.Compare(d.FastGetItem(R), aValue) = 0 then
          Result := R;
      end
    else           //constant
      if TCmpRel.Compare(d.FastGetItem(L), aValue) = 0 then
        exit(L);
end;

class function TGBaseDequeHelper.CountRun2Asc(d: TDeque; R: SizeInt): SizeInt;
begin
  Result := 0;
  while (Result < R) and (TCmpRel.Compare(d.FastGetItem(Result), d.FastGetItem(Succ(Result))) = 0) do
    Inc(Result);
  if Result < R then
    begin
      Inc(Result);
      if TCmpRel.Compare(d.FastGetItem(Pred(Result)), d.FastGetItem(Result)) < 0 then   // ascending
        while (Result < R) and
              (TCmpRel.Compare(d.FastGetItem(Result), d.FastGetItem(Succ(Result))) <= 0) do
          Inc(Result)
      else                                                      // descending
        begin
          while (Result < R) and
                (TCmpRel.Compare(d.FastGetItem(Succ(Result)), d.FastGetItem(Result)) <= 0) do
            Inc(Result);
          DoReverse(d, 0, Result);
        end;
    end;
end;

class function TGBaseDequeHelper.CountRun2Asc(var d: TLiteDeque; R: SizeInt): SizeInt;
begin
  Result := 0;
  while (Result < R) and (TCmpRel.Compare(d.FastGetItem(Result), d.FastGetItem(Succ(Result))) = 0) do
    Inc(Result);
  if Result < R then
    begin
      Inc(Result);
      if TCmpRel.Compare(d.FastGetItem(Pred(Result)), d.FastGetItem(Result)) < 0 then   // ascending
        while (Result < R) and
              (TCmpRel.Compare(d.FastGetItem(Result), d.FastGetItem(Succ(Result))) <= 0) do
          Inc(Result)
      else                                                      // descending
        begin
          while (Result < R) and
                (TCmpRel.Compare(d.FastGetItem(Succ(Result)), d.FastGetItem(Result)) <= 0) do
            Inc(Result);
          DoReverse(d, 0, Result);
        end;
    end;
end;

class procedure TGBaseDequeHelper.InsertionSort(d: TDeque; L, R: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  for I := L + 1 to R do
    begin
      v := TFake(d.FItems[d.InternalIndex(I)]);
      J := I - 1;
      while (J >= 0) and (TCmpRel.Compare(T(v), d.FItems[d.InternalIndex(J)]) < 0) do
        begin
          TFake(d.FItems[d.InternalIndex(J + 1)]) := TFake(d.FItems[d.InternalIndex(J)]);
          Dec(J);
        end;
      TFake(d.FItems[d.InternalIndex(J + 1)]) := v;
    end;
end;

class procedure TGBaseDequeHelper.InsertionSort(var d: TLiteDeque; L, R: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  for I := L + 1 to R do
    begin
      v := TFake(d.FBuffer.FItems[d.InternalIndex(I)]);
      J := I - 1;
      while (J >= 0) and (TCmpRel.Compare(T(v), d.FBuffer.FItems[d.InternalIndex(J)]) < 0) do
        begin
          TFake(d.FBuffer.FItems[d.InternalIndex(J + 1)]) := TFake(d.FBuffer.FItems[d.InternalIndex(J)]);
          Dec(J);
        end;
      TFake(d.FBuffer.FItems[d.InternalIndex(J + 1)]) := v;
    end;
end;

class procedure TGBaseDequeHelper.DoHeapSort(d: TDeque; L, R: SizeInt);
var
  I, Curr, Next: SizeInt;
  v: TFake;
begin
  if R - L > THelper.HEAP_INSERT_CUTOFF then
    begin
      for I := Pred(Succ(R - L) shr 1) downto L do
        begin
          Curr := I;
          Next := Succ(I shl 1);
          v := TFake(d.FItems[d.InternalIndex(Curr)]);
          while Next <= R do
            begin
              if (Succ(Next) <= R) and (TCmpRel.Compare(
                  d.FItems[d.InternalIndex(Next)], d.FItems[d.InternalIndex(Succ(Next))]) < 0)then
                Inc(Next);
              if TCmpRel.Compare(T(v), d.FItems[d.InternalIndex(Next)]) >= 0 then
                break;
              TFake(d.FItems[d.InternalIndex(Curr)]) := TFake(d.FItems[d.InternalIndex(Next)]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          TFake(d.FItems[d.InternalIndex(Curr)]) := v;
        end;
      for I := R downto L + 1 do
        begin
          Curr := L;
          Next := Succ(L);
          v := TFake(d.FItems[d.InternalIndex(I)]);
          TFake(d.FItems[d.InternalIndex(I)]) := TFake(d.FItems[d.InternalIndex(L)]);
          while Next < I do
            begin
              if(Succ(Next) < I) and (TCmpRel.Compare(
                 d.FItems[d.InternalIndex(Next)], d.FItems[d.InternalIndex(Succ(Next))]) < 0) then
                Inc(Next);
              TFake(d.FItems[d.InternalIndex(Curr)]) := TFake(d.FItems[d.InternalIndex(Next)]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          Next := Pred(Curr) shr 1;
          while (Curr > 0) and (TCmpRel.Compare(T(v), d.FItems[d.InternalIndex(Next)]) > 0) do
            begin
              TFake(d.FItems[d.InternalIndex(Curr)]) := TFake(d.FItems[d.InternalIndex(Next)]);
              Curr := Next;
              Next := Pred(Next) shr 1;
            end;
          TFake(d.FItems[d.InternalIndex(Curr)]) := v;
        end;
    end
  else
    InsertionSort(d, L, R);
end;

class procedure TGBaseDequeHelper.DoHeapSort(var d: TLiteDeque; L, R: SizeInt);
var
  I, Curr, Next: SizeInt;
  v: TFake;
begin
  if R - L > THelper.HEAP_INSERT_CUTOFF then
    begin
      for I := Pred(Succ(R - L) shr 1) downto L do
        begin
          Curr := I;
          Next := Succ(I shl 1);
          v := TFake(d.FBuffer.FItems[d.InternalIndex(Curr)]);
          while Next <= R do
            begin
              if (Succ(Next) <= R) and (TCmpRel.Compare(
                  d.FBuffer.FItems[d.InternalIndex(Next)], d.FBuffer.FItems[d.InternalIndex(Succ(Next))]) < 0)then
                Inc(Next);
              if TCmpRel.Compare(T(v), d.FBuffer.FItems[d.InternalIndex(Next)]) >= 0 then
                break;
              TFake(d.FBuffer.FItems[d.InternalIndex(Curr)]) := TFake(d.FBuffer.FItems[d.InternalIndex(Next)]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          TFake(d.FBuffer.FItems[d.InternalIndex(Curr)]) := v;
        end;
      for I := R downto L + 1 do
        begin
          Curr := L;
          Next := Succ(L);
          v := TFake(d.FBuffer.FItems[d.InternalIndex(I)]);
          TFake(d.FBuffer.FItems[d.InternalIndex(I)]) := TFake(d.FBuffer.FItems[d.InternalIndex(L)]);
          while Next < I do
            begin
              if(Succ(Next) < I) and (TCmpRel.Compare(
                 d.FBuffer.FItems[d.InternalIndex(Next)], d.FBuffer.FItems[d.InternalIndex(Succ(Next))]) < 0) then
                Inc(Next);
              TFake(d.FBuffer.FItems[d.InternalIndex(Curr)]) := TFake(d.FBuffer.FItems[d.InternalIndex(Next)]);
              Curr := Next;
              Next := Succ(Next shl 1);
            end;
          Next := Pred(Curr) shr 1;
          while (Curr > 0) and (TCmpRel.Compare(T(v), d.FBuffer.FItems[d.InternalIndex(Next)]) > 0) do
            begin
              TFake(d.FBuffer.FItems[d.InternalIndex(Curr)]) := TFake(d.FBuffer.FItems[d.InternalIndex(Next)]);
              Curr := Next;
              Next := Pred(Next) shr 1;
            end;
          TFake(d.FBuffer.FItems[d.InternalIndex(Curr)]) := v;
        end;
    end
  else
    InsertionSort(d, L, R);
end;

class function TGBaseDequeHelper.QSplitR(d: TDeque; L, R: SizeInt): TSortSplit;
var
  Pivot: T;
begin
  Pivot := d.FItems[d.InternalIndex(Succ(L + Random(Pred(R - L))))];
  Dec(L);
  Inc(R);
  repeat
    repeat Inc(L) until TCmpRel.Compare(Pivot, d.FItems[d.InternalIndex(L)]) <= 0;
    repeat Dec(R) until TCmpRel.Compare(d.FItems[d.InternalIndex(R)], Pivot) <= 0;
    if L > R then break;
    d.FastSwap(L, R);
  until False;
  Result.Left := R;
  Result.Right := L;
end;

class function TGBaseDequeHelper.QSplitR(var d: TLiteDeque; L, R: SizeInt): TSortSplit;
var
  Pivot: T;
begin
  Pivot := d.FBuffer.FItems[d.InternalIndex(Succ(L + Random(Pred(R - L))))];
  Dec(L);
  Inc(R);
  repeat
    repeat Inc(L) until TCmpRel.Compare(Pivot, d.FBuffer.FItems[d.InternalIndex(L)]) <= 0;
    repeat Dec(R) until TCmpRel.Compare(d.FBuffer.FItems[d.InternalIndex(R)], Pivot) <= 0;
    if L > R then break;
    d.FastSwap(L, R);
  until False;
  Result.Left := R;
  Result.Right := L;
end;

class procedure TGBaseDequeHelper.DoQSort(d: TDeque; L, R: SizeInt);
begin
  while R - L > THelper.QUICK_INSERT_CUTOFF do
    with QSplitR(d, L, R) do
      if Left - L <= R - Right then
        begin
          DoQSort(d, L, Left);
          L := Right;
        end
      else
        begin
          DoQSort(d, Right, R);
          R := Left;
        end;
  if R - L > 0 then
    InsertionSort(d, L, R);
end;

class procedure TGBaseDequeHelper.DoQSort(var d: TLiteDeque; L, R: SizeInt);
begin
  while R - L > THelper.QUICK_INSERT_CUTOFF do
    with QSplitR(d, L, R) do
      if Left - L <= R - Right then
        begin
          DoQSort(d, L, Left);
          L := Right;
        end
      else
        begin
          DoQSort(d, Right, R);
          R := Left;
        end;
  if R - L > 0 then
    InsertionSort(d, L, R);
end;

class function TGBaseDequeHelper.GetMo9Pivot(d: TDeque; L, R: SizeInt): T;
begin
  if R - L > THelper.MEDIAN_OF9_CUTOFF then
    begin
      Result := THelper.MedianOf3(
        THelper.MedianOf3(
          d.FItems[d.InternalIndex(L)],
          d.FItems[d.InternalIndex(L + Succ(R - L) shr 3)],
          d.FItems[d.InternalIndex(L + Succ(R - L) shr 2)]),
        THelper.MedianOf3(
          d.FItems[d.InternalIndex(L + Succ(R - L) shr 1 - Succ(R - L) shr 3)],
          d.FItems[d.InternalIndex(L + Succ(R - L) shr 1)],
          d.FItems[d.InternalIndex(L + Succ(R - L) shr 1 + Succ(R - L) shr 3)]),
        THelper.MedianOf3(
          d.FItems[d.InternalIndex(R - Succ(R - L) shr 2)],
          d.FItems[d.InternalIndex(R - Succ(R - L) shr 3)],
          d.FItems[d.InternalIndex(R)]));
    end
  else
    Result := THelper.MedianOf3(
          d.FItems[d.InternalIndex(L)],
          d.FItems[d.InternalIndex(L + Succ(R - L) shr 1)],
          d.FItems[d.InternalIndex(R)]);
end;

class function TGBaseDequeHelper.GetMo9Pivot(constref d: TLiteDeque; L, R: SizeInt): T;
begin
  if R - L > THelper.MEDIAN_OF9_CUTOFF then
    begin
      Result := THelper.MedianOf3(
        THelper.MedianOf3(
          d.FBuffer.FItems[d.InternalIndex(L)],
          d.FBuffer.FItems[d.InternalIndex(L + Succ(R - L) shr 3)],
          d.FBuffer.FItems[d.InternalIndex(L + Succ(R - L) shr 2)]),
        THelper.MedianOf3(
          d.FBuffer.FItems[d.InternalIndex(L + Succ(R - L) shr 1 - Succ(R - L) shr 3)],
          d.FBuffer.FItems[d.InternalIndex(L + Succ(R - L) shr 1)],
          d.FBuffer.FItems[d.InternalIndex(L + Succ(R - L) shr 1 + Succ(R - L) shr 3)]),
        THelper.MedianOf3(
          d.FBuffer.FItems[d.InternalIndex(R - Succ(R - L) shr 2)],
          d.FBuffer.FItems[d.InternalIndex(R - Succ(R - L) shr 3)],
          d.FBuffer.FItems[d.InternalIndex(R)]));
    end
  else
    Result := THelper.MedianOf3(
          d.FBuffer.FItems[d.InternalIndex(L)],
          d.FBuffer.FItems[d.InternalIndex(L + Succ(R - L) shr 1)],
          d.FBuffer.FItems[d.InternalIndex(R)]);
end;

class function TGBaseDequeHelper.QSplitMo9(d: TDeque; L, R: SizeInt): TSortSplit;
var
  Pivot: T;
begin
  Pivot := GetMo9Pivot(d, L, R);
  Dec(L);
  Inc(R);
  repeat
    repeat Inc(L) until TCmpRel.Compare(Pivot, d.FItems[d.InternalIndex(L)]) <= 0;
    repeat Dec(R) until TCmpRel.Compare(d.FItems[d.InternalIndex(R)], Pivot) <= 0;
    if L > R then break;
    d.FastSwap(L, R);
  until False;
  Result.Left := R;
  Result.Right := L;
end;

class function TGBaseDequeHelper.QSplitMo9(var d: TLiteDeque; L, R: SizeInt): TSortSplit;
var
  Pivot: T;
begin
  Pivot := GetMo9Pivot(d, L, R);
  Dec(L);
  Inc(R);
  repeat
    repeat Inc(L) until TCmpRel.Compare(Pivot, d.FBuffer.FItems[d.InternalIndex(L)]) <= 0;
    repeat Dec(R) until TCmpRel.Compare(d.FBuffer.FItems[d.InternalIndex(R)], Pivot) <= 0;
    if L > R then break;
    d.FastSwap(L, R);
  until False;
  Result.Left := R;
  Result.Right := L;
end;

class procedure TGBaseDequeHelper.DoIntroSort(d: TDeque; L, R, Ttl: SizeInt);
begin
  if R - L > THelper.QUICK_INSERT_CUTOFF then
    if Ttl > 0 then
      with QSplitMo9(d, L, R) do
        begin
          DoIntroSort(d, L, Left, Pred(Ttl));
          DoIntroSort(d, Right, R, Pred(Ttl));
        end
    else
      DoHeapSort(d, L, R)
  else
    if R - L > 0 then
      InsertionSort(d, L, R);
end;

class procedure TGBaseDequeHelper.DoIntroSort(var d: TLiteDeque; L, R, Ttl: SizeInt);
begin
  if R - L > THelper.QUICK_INSERT_CUTOFF then
    if Ttl > 0 then
      with QSplitMo9(d, L, R) do
        begin
          DoIntroSort(d, L, Left, Pred(Ttl));
          DoIntroSort(d, Right, R, Pred(Ttl));
        end
    else
      DoHeapSort(d, L, R)
  else
    if R - L > 0 then
      InsertionSort(d, L, R);
end;

class function TGBaseDequeHelper.SequentSearch(d: TDeque; constref aValue: T): SizeInt;
begin
  for Result := 0 to Pred(d.ElemCount) do
    if TCmpRel.Compare(aValue, d.FastGetItem(Result)) = 0 then
      exit;
  Result := -1;
end;

class function TGBaseDequeHelper.SequentSearch(constref d: TLiteDeque; constref aValue: T): SizeInt;
begin
  for Result := 0 to Pred(d.Count) do
    if TCmpRel.Compare(aValue, d.FastGetItem(Result)) = 0 then
      exit;
  Result := -1;
end;

class function TGBaseDequeHelper.BinarySearch(d: TDeque; constref aValue: T): SizeInt;
begin
  if d.ElemCount > 0 then
    Result := DoBinSearch(d, aValue)
  else
    Result := -1;
end;

class function TGBaseDequeHelper.BinarySearch(constref d: TLiteDeque; constref aValue: T): SizeInt;
begin
  if d.Count > 0 then
    Result := DoBinSearch(d, aValue)
  else
    Result := -1;
end;

class function TGBaseDequeHelper.IndexOfMin(d: TDeque): SizeInt;
var
  R, I: SizeInt;
  m, v: T;
begin
  R := Pred(d.ElemCount);
  if R >= 0 then
    begin
      Result := 0;
      m := d.FastGetItem(0);
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(v, m) < 0 then
            begin
              m := v;
              Result := I;
            end;
        end;
    end
  else
    Result := R;
end;

class function TGBaseDequeHelper.IndexOfMin(constref d: TLiteDeque): SizeInt;
var
  R, I: SizeInt;
  m, v: T;
begin
  R := Pred(d.Count);
  if R >= 0 then
    begin
      Result := 0;
      m := d.FastGetItem(0);
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(v, m) < 0 then
            begin
              m := v;
              Result := I;
            end;
        end;
    end
  else
    Result := R;
end;

class function TGBaseDequeHelper.IndexOfMax(d: TDeque): SizeInt;
var
  R, I: SizeInt;
  m, v: T;
begin
  R := Pred(d.ElemCount);
  if R >= 0 then
    begin
      Result := 0;
      m := d.FastGetItem(0);
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(m, v) < 0 then
            begin
              m := v;
              Result := I;
            end;
        end;
    end
  else
    Result := R;
end;

class function TGBaseDequeHelper.IndexOfMax(constref d: TLiteDeque): SizeInt;
var
  R, I: SizeInt;
  m, v: T;
begin
  R := Pred(d.Count);
  if R >= 0 then
    begin
      Result := 0;
      m := d.FastGetItem(0);
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(m, v) < 0 then
            begin
              m := v;
              Result := I;
            end;
        end;
    end
  else
    Result := R;
end;

class function TGBaseDequeHelper.GetMin(d: TDeque): TOptional;
var
  v: T;
begin
  if FindMin(d, v) then
    Result.Assign(v);
end;

class function TGBaseDequeHelper.GetMin(constref d: TLiteDeque): TOptional;
var
  v: T;
begin
  if FindMin(d, v) then
    Result.Assign(v);
end;

class function TGBaseDequeHelper.GetMax(d: TDeque): TOptional;
var
  v: T;
begin
  if FindMax(d, v) then
    Result.Assign(v);
end;

class function TGBaseDequeHelper.GetMax(constref d: TLiteDeque): TOptional;
var
  v: T;
begin
  if FindMax(d, v) then
    Result.Assign(v);
end;

class function TGBaseDequeHelper.FindMin(d: TDeque; out aValue: T): Boolean;
var
  R, I: SizeInt;
  v: T;
begin
  R := Pred(d.ElemCount);
  Result := R >= 0;
  if Result then
    begin
      aValue := d.FastGetItem(0);
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(v, aValue) < 0 then
            aValue := v;
        end;
    end;
end;

class function TGBaseDequeHelper.FindMin(constref d: TLiteDeque; out aValue: T): Boolean;
var
  R, I: SizeInt;
  v: T;
begin
  R := Pred(d.Count);
  Result := R >= 0;
  if Result then
    begin
      aValue := d.FastGetItem(0);
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(v, aValue) < 0 then
            aValue := v;
        end;
    end;
end;

class function TGBaseDequeHelper.FindMax(d: TDeque; out aValue: T): Boolean;
var
  R, I: SizeInt;
  v: T;
begin
  R := Pred(d.ElemCount);
  Result := R >= 0;
  if Result then
    begin
      aValue := d.FastGetItem(0);
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(aValue, v) < 0 then
            aValue := v;
        end;
    end;
end;

class function TGBaseDequeHelper.FindMax(constref d: TLiteDeque; out aValue: T): Boolean;
var
  R, I: SizeInt;
  v: T;
begin
  R := Pred(d.Count);
  Result := R >= 0;
  if Result then
    begin
      aValue := d.FastGetItem(0);
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(aValue, v) < 0 then
            aValue := v;
        end;
    end;
end;

class function TGBaseDequeHelper.FindMinMax(d: TDeque; out aMin, aMax: T): Boolean;
var
  R, I: SizeInt;
  v: T;
begin
  R := Pred(d.ElemCount);
  Result := R >= 0;
  if Result then
    begin
      aMin := d.FastGetItem(0);
      aMax := aMin;
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(aMax, v) < 0 then
            aMax := v
          else
            if TCmpRel.Compare(v, aMin) < 0 then
              aMin := v;
        end;
    end;
end;

class function TGBaseDequeHelper.FindMinMax(constref d: TLiteDeque; out aMin, aMax: T): Boolean;
var
  R, I: SizeInt;
  v: T;
begin
  R := Pred(d.Count);
  Result := R >= 0;
  if Result then
    begin
      aMin := d.FastGetItem(0);
      aMax := aMin;
      for I := 1 to R do
        begin
          v := d.FastGetItem(I);
          if TCmpRel.Compare(aMax, v) < 0 then
            aMax := v
          else
            if TCmpRel.Compare(v, aMin) < 0 then
              aMin := v;
        end;
    end;
end;

class function TGBaseDequeHelper.FindNthSmallest(d: TDeque; N: SizeInt; out aValue: T): Boolean;
begin
  Result := THelper.FindNthSmallest(d.ToArray, N, aValue);
end;

class function TGBaseDequeHelper.FindNthSmallest(constref d: TLiteDeque; N: SizeInt; out aValue: T): Boolean;
begin
  Result := THelper.FindNthSmallest(d.ToArray, N, aValue);
end;

class function TGBaseDequeHelper.NthSmallest(d: TDeque; N: SizeInt): TOptional;
var
  v: T;
begin
  if FindNthSmallest(d, N, v) then
    Result.Assign(v);
end;

class function TGBaseDequeHelper.NthSmallest(constref d: TLiteDeque; N: SizeInt): TOptional;
var
  v: T;
begin
  if FindNthSmallest(d, N, v) then
    Result.Assign(v);
end;

class function TGBaseDequeHelper.NextPermutation2Asc(d: TDeque): Boolean;
var
  I, J, R: SizeInt;
begin
  R := Pred(d.ElemCount);
  if R > 0 then
    begin
      d.CheckInIteration;
      J := -1;
      for I := Pred(R) downto 0 do
        if TCmpRel.Compare(d.FastGetItem(I), d.FastGetItem(Succ(I))) > 0 then
          begin
            J := I;
            break;
          end;
      if J < 0 then exit(False);
      for I := R downto 0 do
        if TCmpRel.Compare(d.FastGetItem(J), d.FastGetItem(I)) > 0 then
          begin
            d.FastSwap(I, J);
            break;
          end;
      DoReverse(d, Succ(J), R);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseDequeHelper.NextPermutation2Asc(var d: TLiteDeque): Boolean;
var
  I, J, R: SizeInt;
begin
  R := Pred(d.Count);
  if R > 0 then
    begin
      J := -1;
      for I := Pred(R) downto 0 do
        if TCmpRel.Compare(d.FastGetItem(I), d.FastGetItem(Succ(I))) > 0 then
          begin
            J := I;
            break;
          end;
      if J < 0 then exit(False);
      for I := R downto 0 do
        if TCmpRel.Compare(d.FastGetItem(J), d.FastGetItem(I)) > 0 then
          begin
            d.FastSwap(I, J);
            break;
          end;
      DoReverse(d, Succ(J), R);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseDequeHelper.NextPermutation2Desc(d: TDeque): Boolean;
var
  I, J, R: SizeInt;
begin
  R := Pred(d.ElemCount);
  if R > 0 then
    begin
      d.CheckInIteration;
      J := -1;
      for I := Pred(R) downto 0 do
        if TCmpRel.Compare(d.FastGetItem(I), d.FastGetItem(Succ(I))) < 0 then
          begin
            J := I;
            break;
          end;
      if J < 0 then exit(False);
      for I := R downto 0 do
        if TCmpRel.Compare(d.FastGetItem(J), d.FastGetItem(I)) < 0 then
          begin
            d.FastSwap(I, J);
            break;
          end;
      DoReverse(d, Succ(J), R);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseDequeHelper.NextPermutation2Desc(var d: TLiteDeque): Boolean;
var
  I, J, R: SizeInt;
begin
  R := Pred(d.Count);
  if R > 0 then
    begin
      J := -1;
      for I := Pred(R) downto 0 do
        if TCmpRel.Compare(d.FastGetItem(I), d.FastGetItem(Succ(I))) < 0 then
          begin
            J := I;
            break;
          end;
      if J < 0 then exit(False);
      for I := R downto 0 do
        if TCmpRel.Compare(d.FastGetItem(J), d.FastGetItem(I)) < 0 then
          begin
            d.FastSwap(I, J);
            break;
          end;
      DoReverse(d, Succ(J), R);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseDequeHelper.IsNonDescending(d: TDeque): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to d.ElemCount - 2 do
    if TCmpRel.Compare(d.FastGetItem(Succ(I)), d.FastGetItem(I)) < 0 then
      exit(False);
  Result := True;
end;

class function TGBaseDequeHelper.IsNonDescending(constref d: TLiteDeque): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to d.Count - 2 do
    if TCmpRel.Compare(d.FastGetItem(Succ(I)), d.FastGetItem(I)) < 0 then
      exit(False);
  Result := True;
end;

class function TGBaseDequeHelper.IsStrictAscending(d: TDeque): Boolean;
var
  I, R: SizeInt;
begin
  R := Pred(d.ElemCount);
  if R > 0 then
    begin
      for I := 0 to Pred(R) do
        if TCmpRel.Compare(d.FastGetItem(Succ(I)), d.FastGetItem(I)) <= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseDequeHelper.IsStrictAscending(constref d: TLiteDeque): Boolean;
var
  I, R: SizeInt;
begin
  R := Pred(d.Count);
  if R > 0 then
    begin
      for I := 0 to Pred(R) do
        if TCmpRel.Compare(d.FastGetItem(Succ(I)), d.FastGetItem(I)) <= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseDequeHelper.IsNonAscending(d: TDeque): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to d.ElemCount - 2 do
    if TCmpRel.Compare(d.FastGetItem(I), d.FastGetItem(Succ(I))) < 0 then
      exit(False);
  Result := True;
end;

class function TGBaseDequeHelper.IsNonAscending(constref d: TLiteDeque): Boolean;
var
  I: SizeInt;
begin
  for I := 0 to d.Count - 2 do
    if TCmpRel.Compare(d.FastGetItem(I), d.FastGetItem(Succ(I))) < 0 then
      exit(False);
  Result := True;
end;

class function TGBaseDequeHelper.IsStrictDescending(d: TDeque): Boolean;
var
  I, R: SizeInt;
begin
  R := Pred(d.ElemCount);
  if R > 0 then
    begin
      for I := 0 to Pred(R) do
        if TCmpRel.Compare(d.FastGetItem(I), d.FastGetItem(Succ(I))) <= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseDequeHelper.IsStrictDescending(constref d: TLiteDeque): Boolean;
var
  I, R: SizeInt;
begin
  R := Pred(d.Count);
  if R > 0 then
    begin
      for I := 0 to Pred(R) do
        if TCmpRel.Compare(d.FastGetItem(I), d.FastGetItem(Succ(I))) <= 0 then
          exit(False);
      Result := True;
    end
  else
    Result := False;
end;

class function TGBaseDequeHelper.Same(d1, d2: TDeque): Boolean;
var
  I, c: SizeInt;
begin
  c := d1.ElemCount;
  if d2.ElemCount <> c then
    exit(False);
  for I := 0 to Pred(c) do
    if TCmpRel.Compare(d1.FastGetItem(I), d2.FastGetItem(I)) <> 0 then
      exit(False);
  Result := True;
end;

class function TGBaseDequeHelper.Same(constref d1, d2: TLiteDeque): Boolean;
var
  I, c: SizeInt;
begin
  c := d1.Count;
  if d2.Count <> c then
    exit(False);
  for I := 0 to Pred(c) do
    if TCmpRel.Compare(d1.FastGetItem(I), d2.FastGetItem(I)) <> 0 then
      exit(False);
  Result := True;
end;

class procedure TGBaseDequeHelper.QuickSort(d: TDeque; o: TSortOrder);
var
  R: SizeInt;
begin
  R := Pred(d.ElemCount);
  if R > 0 then
    begin
      d.CheckInIteration;
      if CountRun2Asc(d, R) < R then
        DoQSort(d, 0, R);
      if o = soDesc then
        DoReverse(d, 0, R);
    end;
end;

class procedure TGBaseDequeHelper.QuickSort(var d: TLiteDeque; o: TSortOrder);
var
  R: SizeInt;
begin
  R := Pred(d.Count);
  if R > 0 then
    begin
      if CountRun2Asc(d, R) < R then
        DoQSort(d, 0, R);
      if o = soDesc then
        DoReverse(d, 0, R);
    end;
end;

class procedure TGBaseDequeHelper.IntroSort(d: TDeque; o: TSortOrder);
var
  R: SizeInt;
begin
  R := Pred(d.ElemCount);
  if R > 0 then
    begin
      d.CheckInIteration;
      if CountRun2Asc(d, R) < R then
        DoIntroSort(d, 0, R, Pred(LGUtils.NSB(R + 1)) * THelper.INTRO_LOG_FACTOR);
      if o = soDesc then
        DoReverse(d, 0, R);
    end;
end;

class procedure TGBaseDequeHelper.IntroSort(var d: TLiteDeque; o: TSortOrder);
var
  R: SizeInt;
begin
  R := Pred(d.Count);
  if R > 0 then
    begin
      if CountRun2Asc(d, R) < R then
        DoIntroSort(d, 0, R, Pred(LGUtils.NSB(R + 1)) * THelper.INTRO_LOG_FACTOR);
      if o = soDesc then
        DoReverse(d, 0, R);
    end;
end;

class procedure TGBaseDequeHelper.Sort(d: TDeque; o: TSortOrder);
begin
  IntroSort(d, o);
end;

class procedure TGBaseDequeHelper.Sort(var d: TLiteDeque; o: TSortOrder);
begin
  IntroSort(d, o);
end;

class function TGBaseDequeHelper.SelectDistinct(d: TDeque): TDeque.TArray;
begin
  if d.ElemCount > 0 then
    Result := THelper.SelectDistinct(d.ToArray)
  else
    Result := nil;
end;

class function TGBaseDequeHelper.SelectDistinct(constref d: TLiteDeque): TDeque.TArray;
begin
  if d.Count > 0 then
    Result := THelper.SelectDistinct(d.ToArray)
  else
    Result := nil;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGFunction;

{$MODE OBJFPC}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer;

type

  { TGMapping }

  generic TGMapping<X, Y> = class
  public
  type
    TMapFunc     = specialize TGMapFunc<X, Y>;
    TOnMap       = specialize TGOnMap<X, Y>;
    TNestMap     = specialize TGNestMap<X, Y>;
    TArrayX      = specialize TGArray<X>;
    IEnumerableX = specialize IGEnumerable<X>;
    IEnumerableY = specialize IGEnumerable<Y>;

  strict private
  type

    TArrayCursor = class abstract(specialize TGAutoEnumerable<Y>)
    protected
      FArray: TArrayX;
      FCurrIndex: SizeInt;
    public
      constructor Create(constref a: TArrayX);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TEnumeratorX = specialize TGCustomEnumerator<X>;

    TEnumCursor = class abstract(specialize TGAutoEnumerable<Y>)
    protected
      FEnum: TEnumeratorX;
    public
      constructor Create(e : TEnumeratorX);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TArrayRegularMap = class(TArrayCursor)
    protected
      FMap: TMapFunc;
      function GetCurrent: Y; override;
    public
      constructor Create(constref a: TArrayX; aMap: TMapFunc);
    end;

    TArrayDelegatedMap = class(TArrayCursor)
    protected
      FMap: TOnMap;
      function GetCurrent: Y; override;
    public
      constructor Create(constref a: TArrayX; aMap: TOnMap);
    end;

    TArrayNestedMap = class(TArrayCursor)
    protected
      FMap: TNestMap;
      function GetCurrent: Y; override;
    public
      constructor Create(constref a: TArrayX; aMap: TNestMap);
    end;

    TEnumRegularMap = class(TEnumCursor)
    protected
      FMap: TMapFunc;
      function GetCurrent: Y; override;
    public
      constructor Create(e: IEnumerableX; aMap: TMapFunc);
    end;

    TEnumDelegatedMap = class(TEnumCursor)
    protected
      FMap: TOnMap;
      function GetCurrent: Y; override;
    public
      constructor Create(e: IEnumerableX; aMap: TOnMap);
    end;

    TEnumNestedMap = class(TEnumCursor)
    protected
      FMap: TNestMap;
      function GetCurrent: Y; override;
    public
      constructor Create(e: IEnumerableX; aMap: TNestMap);
    end;

  public
    class function Apply(constref a: TArrayX; f: TMapFunc): IEnumerableY; static; inline;
    class function Apply(constref a: TArrayX; f: TOnMap): IEnumerableY; static; inline;
    class function Apply(constref a: TArrayX; f: TNestMap): IEnumerableY; static; inline;
    class function Apply(e: IEnumerableX; f: TMapFunc): IEnumerableY; static; inline;
    class function Apply(e: IEnumerableX; f: TOnMap): IEnumerableY; static; inline;
    class function Apply(e: IEnumerableX; f: TNestMap): IEnumerableY; static; inline;
  end;

  { TGFolding }

  generic TGFolding<X, Y> = class
  public
  type
    IXEnumerable = specialize IGEnumerable<X>;
    TFold        = specialize TGFold<X, Y>;
    TOnFold      = specialize TGOnFold<X, Y>;
    TNestFold    = specialize TGNestFold<X, Y>;

    class function Left(constref a: array of X; f: TFold; constref y0: Y): Y; static;
    class function Left(constref a: array of X; f: TOnFold; constref y0: Y): Y; static;
    class function Left(constref a: array of X; f: TNestFold; constref y0: Y): Y; static;
    class function Left(e: IXEnumerable; f: TFold; constref y0: Y): Y; static;
    class function Left(e: IXEnumerable; f: TOnFold; constref y0: Y): Y; static;
    class function Left(e: IXEnumerable; f: TNestFold; constref y0: Y): Y; static;
    class function Right(constref a: array of X; f: TFold; constref y0: Y): Y; static;
    class function Right(constref a: array of X; f: TOnFold; constref y0: Y): Y; static;
    class function Right(constref a: array of X; f: TNestFold; constref y0: Y): Y; static;
    class function Right(e: IXEnumerable; f: TFold; constref y0: Y): Y; static;
    class function Right(e: IXEnumerable; f: TOnFold; constref y0: Y): Y; static;
    class function Right(e: IXEnumerable; f: TNestFold; constref y0: Y): Y; static;
  end;
  { monadic regular function }
  generic TGFunction<T, TResult> = function(constref v: T): TResult;
  { dyadic regular function }
  generic TGFunction2A<T1, T2, TResult> = function(constref v1: T1; constref v2: T2): TResult;
  { triadic regular function }
  generic TGFunction3A<T1, T2, T3, TResult> = function(constref v1: T1; constref v2: T2; constref v3: T3): TResult;

  generic TGDefferedCall<T, TResult> = record
  public
  type
    TFunction = specialize TGFunction<T, TResult>;
  strict private
    FStoredFunc: TFunction;
    FParam: T;
  public
    class function Construct(aFunc: TFunction; constref v: T): TGDefferedCall; static;
    function Call: TResult; inline;
  end;

  generic TGDefferedCall2A<T1, T2, TResult> = record
  public
  type
    TFunction = specialize TGFunction2A<T1, T2, TResult>;
  strict private
    FStoredFunc: TFunction;
    FParam1: T1;
    FParam2: T2;
  public
    class function Construct(aFunc: TFunction; constref v1: T1; constref v2: T2): TGDefferedCall2A; static;
    function Call: TResult; inline;
  end;

  generic TGDefferedCall3A<T1, T2, T3, TResult> = record
  public
  type
    TFunction = specialize TGFunction3A<T1, T2, T3, TResult>;
  strict private
    FStoredFunc: TFunction;
    FParam1: T1;
    FParam2: T2;
    FParam3: T3;
  public
    class function Construct(aFunc: TFunction; constref v1: T1; constref v2: T2;
                             constref v3: T3): TGDefferedCall3A; static;
    function Call: TResult; inline;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGMapping.TArrayCursor }

constructor TGMapping.TArrayCursor.Create(constref a: TArrayX);
begin
  inherited Create;
  FArray := a;
  FCurrIndex := -1;
end;

function TGMapping.TArrayCursor.MoveNext: Boolean;
begin
  Result := FCurrIndex < System.High(FArray);
  FCurrIndex += Ord(Result);
end;

procedure TGMapping.TArrayCursor.Reset;
begin
  FCurrIndex := -1;
end;

{ TGMapping.TEnumCursor }

constructor TGMapping.TEnumCursor.Create(e: TEnumeratorX);
begin
  inherited Create;
  FEnum := e;
end;

destructor TGMapping.TEnumCursor.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGMapping.TEnumCursor.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGMapping.TEnumCursor.Reset;
begin
  FEnum.Reset;
end;

{ TArrayRegularMap }

function TGMapping.TArrayRegularMap.GetCurrent: Y;
begin
  Result := FMap(FArray[FCurrIndex]);
end;

constructor TGMapping.TArrayRegularMap.Create(constref a: TArrayX; aMap: TMapFunc);
begin
  inherited Create(a);
  FMap := aMap;
end;

{ TArrayDelegatedMap }

function TGMapping.TArrayDelegatedMap.GetCurrent: Y;
begin
  Result := FMap(FArray[FCurrIndex]);
end;

constructor TGMapping.TArrayDelegatedMap.Create(constref a: TArrayX; aMap: TOnMap);
begin
  inherited Create(a);
  FMap := aMap;
end;

{ TGMapping.TArrayNestedMap }

function TGMapping.TArrayNestedMap.GetCurrent: Y;
begin
  Result := FMap(FArray[FCurrIndex]);
end;

constructor TGMapping.TArrayNestedMap.Create(constref a: TArrayX; aMap: TNestMap);
begin
  inherited Create(a);
  FMap := aMap;
end;

{ TEnumRegularMap }

function TGMapping.TEnumRegularMap.GetCurrent: Y;
begin
  Result := FMap(FEnum.Current);
end;

constructor TGMapping.TEnumRegularMap.Create(e: IEnumerableX; aMap: TMapFunc);
begin
  inherited Create(e.GetEnumerator);
  FMap := aMap;
end;

{ TEnumDelegatedMap }

function TGMapping.TEnumDelegatedMap.GetCurrent: Y;
begin
  Result := FMap(FEnum.Current);
end;

constructor TGMapping.TEnumDelegatedMap.Create(e: IEnumerableX; aMap: TOnMap);
begin
  inherited Create(e.GetEnumerator);
  FMap := aMap;
end;

{ TGMapping.TEnumNestedMap }

function TGMapping.TEnumNestedMap.GetCurrent: Y;
begin
  Result := FMap(FEnum.Current);
end;

constructor TGMapping.TEnumNestedMap.Create(e: IEnumerableX; aMap: TNestMap);
begin
  inherited Create(e.GetEnumerator);
  FMap := aMap;
end;

{ TGMapping }

class function TGMapping.Apply(constref a: TArrayX; f: TMapFunc): IEnumerableY;
begin
  Result := TArrayRegularMap.Create(a, f);
end;

class function TGMapping.Apply(constref a: TArrayX; f: TOnMap): IEnumerableY;
begin
  Result := TArrayDelegatedMap.Create(a, f);
end;

class function TGMapping.Apply(constref a: TArrayX; f: TNestMap): IEnumerableY;
begin
  Result := TArrayNestedMap.Create(a, f);
end;

class function TGMapping.Apply(e: IEnumerableX; f: TMapFunc): IEnumerableY;
begin
  Result := TEnumRegularMap.Create(e, f);
end;

class function TGMapping.Apply(e: IEnumerableX; f: TOnMap): IEnumerableY;
begin
  Result := TEnumDelegatedMap.Create(e, f);
end;

class function TGMapping.Apply(e: IEnumerableX; f: TNestMap): IEnumerableY;
begin
  Result := TEnumNestedMap.Create(e, f);
end;

{ TGFolding }

class function TGFolding.Left(constref a: array of X; f: TFold; constref y0: Y): Y;
var
  v: X;
begin
  Result := y0;
  for v in a do
    Result := f(v, Result);
end;

class function TGFolding.Left(constref a: array of X; f: TOnFold; constref y0: Y): Y;
var
  v: X;
begin
  Result := y0;
  for v in a do
    Result := f(v, Result);
end;

class function TGFolding.Left(constref a: array of X; f: TNestFold; constref y0: Y): Y;
var
  v: X;
begin
  Result := y0;
  for v in a do
    Result := f(v, Result);
end;

class function TGFolding.Left(e: IXEnumerable; f: TFold; constref y0: Y): Y;
var
  v: X;
begin
  Result := y0;
  for v in e do
    Result := f(v, Result);
end;

class function TGFolding.Left(e: IXEnumerable; f: TOnFold; constref y0: Y): Y;
var
  v: X;
begin
  Result := y0;
  for v in e do
    Result := f(v, Result);
end;

class function TGFolding.Left(e: IXEnumerable; f: TNestFold; constref y0: Y): Y;
var
  v: X;
begin
  Result := y0;
  for v in e do
    Result := f(v, Result);
end;

class function TGFolding.Right(constref a: array of X; f: TFold; constref y0: Y): Y;
var
  v: X;
  I: SizeInt;
begin
  Result := y0;
  for I := System.High(a) downto 0 do
    Result := f(a[I], Result);
end;

class function TGFolding.Right(constref a: array of X; f: TOnFold; constref y0: Y): Y;
var
  v: X;
  I: SizeInt;
begin
  Result := y0;
  for I := System.High(a) downto 0 do
    Result := f(a[I], Result);
end;

class function TGFolding.Right(constref a: array of X; f: TNestFold; constref y0: Y): Y;
var
  v: X;
  I: SizeInt;
begin
  Result := y0;
  for I := System.High(a) downto 0 do
    Result := f(a[I], Result);
end;

class function TGFolding.Right(e: IXEnumerable; f: TFold; constref y0: Y): Y;
var
  v: X;
begin
  Result := y0;
  for v in e.Reverse do
    Result := f(v, Result);
end;

class function TGFolding.Right(e: IXEnumerable; f: TOnFold; constref y0: Y): Y;
var
  v: X;
begin
  Result := y0;
  for v in e.Reverse do
    Result := f(v, Result);
end;

class function TGFolding.Right(e: IXEnumerable; f: TNestFold; constref y0: Y): Y;
var
  v: X;
begin
  Result := y0;
  for v in e.Reverse do
    Result := f(v, Result);
end;

{ TGDefferedCall }

class function TGDefferedCall.Construct(aFunc: TFunction; constref v: T): TGDefferedCall;
begin
  Result.FStoredFunc := aFunc;
  Result.FParam := v;
end;

function TGDefferedCall.Call: TResult;
begin
  Result := FStoredFunc(FParam);
end;

{ TGDefferedCall2A }

class function TGDefferedCall2A.Construct(aFunc: TFunction; constref v1: T1; constref v2: T2): TGDefferedCall2A;
begin
  Result.FStoredFunc := aFunc;
  Result.FParam1 := v1;
  Result.FParam2 := v2;
end;

function TGDefferedCall2A.Call: TResult;
begin
  Result := FStoredFunc(FParam1, FParam2);
end;

{ TGDefferedCall3A }

class function TGDefferedCall3A.Construct(aFunc: TFunction; constref v1: T1; constref v2: T2;
  constref v3: T3): TGDefferedCall3A;
begin
  Result.FStoredFunc := aFunc;
  Result.FParam1 := v1;
  Result.FParam2 := v2;
  Result.FParam3 := v3;
end;

function TGDefferedCall3A.Call: TResult;
begin
  Result := FStoredFunc(FParam1, FParam2, FParam3);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Non-cryptographic hash functions for hash table lookup.                 *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}

unit LGHash;

{$MODE OBJFPC}{$H+}
{$INLINE ON}

interface

type

  { TxxHash32LE: little endian implementation of Yann Collet's xxHash32 }
  TxxHash32LE = class
    class function HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord = 0): DWord; static;
    class function HashStr(constref aValue: ansistring; aSeed: DWord = 0): DWord; static; inline;
    class function HashWord(aValue: Word; aSeed: DWord = 0): DWord; static;
    class function HashDWord(aValue: DWord; aSeed: DWord = 0): DWord; static;
    class function HashQWord(aValue: QWord; aSeed: DWord = 0): DWord; static;
    class function HashGuid(constref aValue: TGuid; aSeed: DWord = 0): DWord; static;
  end;

  { TxxHash64LE: little endian implementation of Yann Collet's xxHash64 }
  TxxHash64LE = class
    class function HashBuf(aBuffer: Pointer; aCount: Int64; aSeed: QWord = 0): QWord; static;
    class function HashStr(constref aValue: string; aSeed: QWord = 0): QWord; static; inline;
    class function HashWord(aValue: Word; aSeed: QWord = 0): QWord; static;
    class function HashDWord(aValue: DWord; aSeed: QWord = 0): QWord; static;
    class function HashQWord(aValue: QWord; aSeed: QWord = 0): QWord; static;
    class function HashGuid(constref aValue: TGuid; aSeed: QWord = 0): QWord; static;
  end;

  TMurmur = class
  protected
  type
    TByte3 = array[0..2] of Byte;
    TByte5 = array[0..4] of Byte;
    TByte6 = array[0..5] of Byte;
    TByte7 = array[0..6] of Byte;
    PByte3 = ^TByte3;
    PByte5 = ^TByte5;
    PByte6 = ^TByte6;
    PByte7 = ^TByte7;
  end;

  { TMurmur2LE: little endian implementation of Austin Appleby's MurmurHash2 }
  TMurmur2LE = class(TMurmur)
    class function HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord = 0): DWord; static;
    class function HashStr(constref aValue: string; aSeed: DWord = 0): DWord; static; inline;
    class function HashWord(aValue: Word; aSeed: DWord = 0): DWord; static;
    class function HashDWord(aValue: DWord; aSeed: DWord = 0): DWord; static;
    class function HashQWord(aValue: QWord; aSeed: DWord = 0): DWord; static;
    class function HashGuid(constref aValue: TGuid; aSeed: DWord = 0): DWord; static;
  end;

  { TMurmur2aLE: little endian implementation of Austin Appleby's MurmurHash2A }
  TMurmur2aLE = class(TMurmur)
    class function HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord = 0): DWord; static;
    class function HashStr(constref aValue: string; aSeed: DWord = 0): DWord; static; inline;
    class function HashWord(aValue: Word; aSeed: DWord = 0): DWord; static;
    class function HashDWord(aValue: DWord; aSeed: DWord = 0): DWord; static;
    class function HashQWord(aValue: QWord; aSeed: DWord = 0): DWord; static;
    class function HashGuid(constref aValue: TGuid; aSeed: DWord = 0): DWord; static;
  end;

  { TMurmur3LE: little endian implementation of Austin Appleby's MurmurHash3_x86_32 }
  TMurmur3LE = class(TMurmur)
    class function HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord = 0): DWord; static;
    class function HashStr(constref aValue: string; aSeed: DWord = 0): DWord; static; inline;
    class function HashWord(aValue: Word; aSeed: DWord = 0): DWord; static;
    class function HashDWord(aValue: DWord; aSeed: DWord = 0): DWord; static;
    class function HashQWord(aValue: QWord; aSeed: DWord = 0): DWord; static;
    class function HashGuid(constref aValue: TGuid; aSeed: DWord = 0): DWord; static;
  end;

  { TMurmur64aLE: little endian implementation of Austin Appleby's MurmurHash64A }
  TMurmur64aLE = class(TMurmur)
    class function HashBuf(aBuffer: Pointer; aCount: Int64; aSeed: QWord = 0): QWord; static;
    class function HashStr(constref aValue: string; aSeed: QWord = 0): QWord; static; inline;
    class function HashWord(aValue: Word; aSeed: QWord = 0): QWord; static;
    class function HashDWord(aValue: DWord; aSeed: QWord = 0): QWord; static;
    class function HashQWord(aValue: QWord; aSeed: QWord = 0): QWord; static;
    class function HashGuid(constref aValue: TGuid; aSeed: QWord = 0): QWord; static;
  end;

  function JdkHash(aValue: DWord): DWord; inline;

implementation

{$Q-}{$R-}{$B-}{$COPERATORS ON}{$MACRO ON}
{.$DEFINE FPC_REQUIRES_PROPER_ALIGNMENT  for test purpose only}

function JdkHash(aValue: DWord): DWord;
begin
  aValue := aValue xor aValue shr 20 xor aValue shr 12;
  Result := aValue xor aValue shr 7 xor aValue shr 4;
end;

{$DEFINE c1 := DWord($9e3779b1)}{$DEFINE c2 := DWord($85ebca77)}{$DEFINE c3 := DWord($c2b2ae3d)}
{$DEFINE c4 := DWord($27d4eb2f)}{$DEFINE c5 := DWord($165667b1)}

{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}
class function TxxHash32LE.HashBuf(aBuffer: Pointer; aCount: SizeInt; aSeed: DWord): DWord;
var
  v1, v2, v3, v4: DWord;
  buf: array[0..3] of DWord;
  p: PByte absolute aBuffer;
begin
  Result := DWord(aCount);
  if aCount >= 16 then
    begin
      v1 := aSeed + c1 + c2;
      v2 := aSeed + c2;
      v3 := aSeed;
      v4 := aSeed - c1;
      while aCount >= 16 do
        begin
          System.Move(p^, buf{%H-}, 16);
          v1 := RolDWord(v1 + buf[0] * c2, 13) * c1;
          v2 := RolDWord(v2 + buf[1] * c2, 13) * c1;
          v3 := RolDWord(v3 + buf[2] * c2, 13) * c1;
          v4 := RolDWord(v4 + buf[3] * c2, 13) * c1;
          p += 16;
          aCount -= 16;
        end;
      Result += RolDWord(v1, 1) + RolDWord(v2, 7) + RolDWord(v3, 12) + RolDWord(v4, 18);
    end
  else
    Result += aSeed + c5;
  if aCount > 0 then
    begin
      System.Move(p^, buf, aCount);
      p := @buf;
      case aCount shr 2 of
        1:
          begin
            Result := RolDWord(Result + buf[0] * c3, 17) * c4;
            aCount -= 4;
            p += 4;
          end;
        2:
          begin
            Result := RolDWord(Result + buf[0] * c3, 17) * c4;
            Result := RolDWord(Result + buf[1] * c3, 17) * c4;
            aCount -= 8;
            p += 8;
          end;
        3:
          begin
            Result := RolDWord(Result + buf[0] * c3, 17) * c4;
            Result := RolDWord(Result + buf[1] * c3, 17) * c4;
            Result := RolDWord(Result + buf[2] * c3, 17) * c4;
            aCount -= 12;
            p += 12;
          end;
      end;
      case aCount of
        1:
          begin
            Result := RolDWord(Result + DWord(p[0]) * c5, 11) * c1;
          end;
        2:
          begin
            Result := RolDWord(Result + DWord(p[0]) * c5, 11) * c1;
            Result := RolDWord(Result + DWord(p[1]) * c5, 11) * c1;
          end;
        3:
          begin
            Result := RolDWord(Result + DWord(p[0]) * c5, 11) * c1;
            Result := RolDWord(Result + DWord(p[1]) * c5, 11) * c1;
            Result := RolDWord(Result + DWord(p[2]) * c5, 11) * c1;
          end;
      end;
    end;
  Result := (Result xor Result shr 15) * c2;
  Result := (Result xor Result shr 13) * c3;
  Result :=  Result xor Result shr 16;
end;
{$ELSE FPC_REQUIRES_PROPER_ALIGNMENT}
class function TxxHash32LE.HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord): DWord;
var
  v1, v2, v3, v4: DWord;
  p: PDWord absolute aBuffer;
begin
  Result := DWord(aCount);
  if aCount >= 16 then
    begin
      v1 := aSeed + c1 + c2;
      v2 := aSeed + c2;
      v3 := aSeed;
      v4 := aSeed - c1;
      while aCount >= 16 do
        begin
          v1 := RolDWord(v1 + p[0] * c2, 13) * c1;
          v2 := RolDWord(v2 + p[1] * c2, 13) * c1;
          v3 := RolDWord(v3 + p[2] * c2, 13) * c1;
          v4 := RolDWord(v4 + p[3] * c2, 13) * c1;
          p += 4;
          aCount -= 16;
        end;
      Result += RolDWord(v1, 1) + RolDWord(v2, 7) + RolDWord(v3, 12) + RolDWord(v4, 18);
    end
  else
    Result += aSeed + c5;
  case aCount shr 2 of
    1:
      begin
        Result := RolDWord(Result + p[0] * c3, 17) * c4;
        p += 1;
        aCount -= 4;
      end;
    2:
      begin
        Result := RolDWord(Result + p[0] * c3, 17) * c4;
        Result := RolDWord(Result + p[1] * c3, 17) * c4;
        p += 2;
        aCount -= 8;
      end;
    3:
      begin
        Result := RolDWord(Result + p[0] * c3, 17) * c4;
        Result := RolDWord(Result + p[1] * c3, 17) * c4;
        Result := RolDWord(Result + p[2] * c3, 17) * c4;
        p += 3;
        aCount -= 12;
      end;
  end;
  case aCount of
    1:
      Result := RolDWord(Result + DWord(PByte(p)[0]) * c5, 11) * c1;
    2:
      begin
        Result := RolDWord(Result + DWord(PByte(p)[0]) * c5, 11) * c1;
        Result := RolDWord(Result + DWord(PByte(p)[1]) * c5, 11) * c1;
      end;
    3:
      begin
        Result := RolDWord(Result + DWord(PByte(p)[0]) * c5, 11) * c1;
        Result := RolDWord(Result + DWord(PByte(p)[1]) * c5, 11) * c1;
        Result := RolDWord(Result + DWord(PByte(p)[2]) * c5, 11) * c1;
      end;
  end;
  Result := (Result xor Result shr 15) * c2;
  Result := (Result xor Result shr 13) * c3;
  Result :=  Result xor Result shr 16;
end;
{$ENDIF FPC_REQUIRES_PROPER_ALIGNMENT}

class function TxxHash32LE.HashStr(constref aValue: ansistring; aSeed: DWord): DWord;
begin
  Result := HashBuf(PAnsiChar(aValue), System.Length(aValue), aSeed);
end;

class function TxxHash32LE.HashWord(aValue: Word; aSeed: DWord): DWord;
begin
  Result := RolDWord(aSeed + c5 + SizeOf(aValue) + (aValue and $ff) * c5, 11) * c1;
  Result := RolDWord(Result + (aValue shr 8) * c5, 11) * c1;
  Result := (Result xor Result shr 15) * c2;
  Result := (Result xor Result shr 13) * c3;
  Result := Result xor Result shr 16;
end;

class function TxxHash32LE.HashDWord(aValue: DWord; aSeed: DWord): DWord;
begin
  Result := RolDWord(aSeed + c5 + SizeOf(aValue) + aValue * c3, 17) * c4;
  Result := (Result xor Result shr 15) * c2;
  Result := (Result xor Result shr 13) * c3;
  Result := Result xor Result shr 16;
end;

class function TxxHash32LE.HashQWord(aValue: QWord; aSeed: DWord): DWord;
begin
  Result := RolDWord(c5 + aSeed + SizeOf(aValue) + PDWord(@aValue)[0] * c3, 17) * c4;
  Result := RolDWord(Result + PDWord(@aValue)[1] * c3, 17) * c4;
  Result := (Result xor Result shr 15) * c2;
  Result := (Result xor Result shr 13) * c3;
  Result := Result xor Result shr 16;
end;

type
  TDWords4 = packed record
    D1, D2, D3, D4: DWord;
  end;

class function TxxHash32LE.HashGuid(constref aValue: TGuid; aSeed: DWord): DWord;
var
  g: TDWords4 absolute aValue;
begin
  Result := RolDWord(RolDWord(DWord(aSeed + c1 + c2) + g.D1 * c2, 13) * c1, 1) +
            RolDWord(RolDWord(DWord(aSeed      + c2) + g.D2 * c2, 13) * c1, 7) +
            RolDWord(RolDWord(DWord(aSeed          ) + g.D3 * c2, 13) * c1, 12) +
            RolDWord(RolDWord(DWord(aSeed      - c1) + g.D4 * c2, 13) * c1, 18) + SizeOf(TGuid);
  Result := (Result xor Result shr 15) * c2;
  Result := (Result xor Result shr 13) * c3;
  Result :=  Result xor Result shr 16;
end;
{$UNDEF c1}{$UNDEF c2}{$UNDEF c3}{$UNDEF}{$UNDEF c5}


{$DEFINE c1 := QWord($9e3779b185ebca87)}{$DEFINE c2 := QWord($c2b2ae3d27d4eb4f)}
{$DEFINE c3 := QWord($165667b19e3779f9)}{$DEFINE c4 := QWord($85ebca77c2b2ae63)}
{$DEFINE c5 := QWord($27d4eb2f165667c5)}
{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}
class function TxxHash64LE.HashBuf(aBuffer: Pointer; aCount: Int64; aSeed: QWord): QWord;
var
  v1, v2, v3, v4: QWord;
  buf: array[0..3] of QWord;
  p: PByte absolute aBuffer;
begin
  if aCount >= 32 then
    begin
      v1 := aSeed + c1 + c2;
      v2 := aSeed + c2;
      v3 := aSeed;
      v4 := aSeed - c1;
      aSeed := QWord(aCount);
      repeat
        System.Move(p^, buf{%H-}, 32);
        v1 := RolQWord(v1 + c2 * buf[0], 31) * c1;
        v2 := RolQWord(v2 + c2 * buf[1], 31) * c1;
        v3 := RolQWord(v3 + c2 * buf[2], 31) * c1;
        v4 := RolQWord(v4 + c2 * buf[3], 31) * c1;
        p += 32;
        aCount -= 32;
      until aCount < 32;
      Result := RolQWord(v1, 1) + RolQWord(v2, 7) + RolQWord(v3, 12) + RolQWord(v4, 18);
      Result := (Result xor (RolQWord(v1 * c2, 31) * c1)) * c1 + c4;
      Result := (Result xor (RolQWord(v2 * c2, 31) * c1)) * c1 + c4;
      Result := (Result xor (RolQWord(v3 * c2, 31) * c1)) * c1 + c4;
      Result := (Result xor (RolQWord(v4 * c2, 31) * c1)) * c1 + c4 + aSeed;
    end
  else
    Result := aSeed + QWord(aCount) + c5;
  if aCount > 0 then
    begin
      System.Move(p^, buf, aCount);
      p := @buf;
      case aCount shr 3 of
        1:
          begin
            Result := RolQWord(Result xor (c1 * RolQWord(c2 * PQWord(p)[0], 31)), 27) * c1 + c4;
            aCount -= 8;
            p += 8;
          end;
        2:
          begin
            Result := RolQWord(Result xor (c1 * RolQWord(c2 * PQWord(p)[0], 31)), 27) * c1 + c4;
            Result := RolQWord(Result xor (c1 * RolQWord(c2 * PQWord(p)[1], 31)), 27) * c1 + c4;
            aCount -= 16;
            p += 16;
          end;
        3:
          begin
            Result := RolQWord(Result xor (c1 * RolQWord(c2 * PQWord(p)[0], 31)), 27) * c1 + c4;
            Result := RolQWord(Result xor (c1 * RolQWord(c2 * PQWord(p)[1], 31)), 27) * c1 + c4;
            Result := RolQWord(Result xor (c1 * RolQWord(c2 * PQWord(p)[2], 31)), 27) * c1 + c4;
            aCount -= 24;
            p += 24;
          end;
      end;
      if aCount >= 4 then
        begin
          Result := RolQWord((Result xor QWord(PDWord(p)^)) * c1, 23) * c2 + c3;
          p += 4;
          aCount -= 4;
        end;
      case aCount of
        1:
          begin
            Result := RolQWord(Result xor (QWord(p[0]) * c5), 11) * c1;
          end;
        2:
          begin
            Result := RolQWord(Result xor (QWord(p[0]) * c5), 11) * c1;
            Result := RolQWord(Result xor (QWord(p[1]) * c5), 11) * c1;
          end;
        3:
          begin
            Result := RolQWord(Result xor (QWord(p[0]) * c5), 11) * c1;
            Result := RolQWord(Result xor (QWord(p[1]) * c5), 11) * c1;
            Result := RolQWord(Result xor (QWord(p[2]) * c5), 11) * c1;
          end;
      end;
    end;
  Result := (Result xor Result shr 33) * c2;
  Result := (Result xor Result shr 29) * c3;
  Result :=  Result xor Result shr 32;
end;
{$ELSE FPC_REQUIRES_PROPER_ALIGNMENT}
class function TxxHash64LE.HashBuf(aBuffer: Pointer; aCount: Int64; aSeed: QWord): QWord;
var
  v1, v2, v3, v4: QWord;
  p: PByte absolute aBuffer;
begin
  if aCount >= 32 then
    begin
      v1 := aSeed + c1 + c2;
      v2 := aSeed + c2;
      v3 := aSeed;
      v4 := aSeed - c1;
      aSeed := QWord(aCount);
      repeat
        v1 := RolQWord(v1 + PQWord(p)[0] * c2, 31) * c1;
        v2 := RolQWord(v2 + PQWord(p)[1] * c2, 31) * c1;
        v3 := RolQWord(v3 + PQWord(p)[2] * c2, 31) * c1;
        v4 := RolQWord(v4 + PQWord(p)[3] * c2, 31) * c1;
        p += 32;
        aCount -= 32;
      until aCount < 32;
      Result := RolQWord(v1, 1) + RolQWord(v2, 7) + RolQWord(v3, 12) + RolQWord(v4, 18);
      Result := (Result xor (RolQWord(v1 * c2, 31) * c1)) * c1 + c4;
      Result := (Result xor (RolQWord(v2 * c2, 31) * c1)) * c1 + c4;
      Result := (Result xor (RolQWord(v3 * c2, 31) * c1)) * c1 + c4;
      Result := (Result xor (RolQWord(v4 * c2, 31) * c1)) * c1 + c4 + aSeed;
    end
  else
    Result := aSeed + aCount + c5;
  case aCount shr 3 of
    1:
      begin
        Result := RolQWord(Result xor (c1 * RolQWord(PQWord(p)[0] * c2, 31)), 27) * c1 + c4;
        aCount -= 8;
        p += 8;
      end;
    2:
      begin
        Result := RolQWord(Result xor (c1 * RolQWord(PQWord(p)[0] * c2, 31)), 27) * c1 + c4;
        Result := RolQWord(Result xor (c1 * RolQWord(PQWord(p)[1] * c2, 31)), 27) * c1 + c4;
        aCount -= 16;
        p += 16;
      end;
    3:
      begin
        Result := RolQWord(Result xor (c1 * RolQWord(PQWord(p)[0] * c2, 31)), 27) * c1 + c4;
        Result := RolQWord(Result xor (c1 * RolQWord(PQWord(p)[1] * c2, 31)), 27) * c1 + c4;
        Result := RolQWord(Result xor (c1 * RolQWord(PQWord(p)[2] * c2, 31)), 27) * c1 + c4;
        aCount -= 24;
        p += 24;
      end;
  end;
  if aCount >= 4 then
    begin
      Result := RolQWord((Result xor QWord(PDWord(p)^)) * c1, 23) * c2 + c3;
      p += 4;
      aCount -= 4;
    end;
  case aCount of
    1:
      begin
        Result := RolQWord(Result xor (QWord(p[0]) * c5), 11) * c1;
      end;
    2:
      begin
        Result := RolQWord(Result xor (QWord(p[0]) * c5), 11) * c1;
        Result := RolQWord(Result xor (QWord(p[1]) * c5), 11) * c1;
      end;
    3:
      begin
        Result := RolQWord(Result xor (QWord(p[0]) * c5), 11) * c1;
        Result := RolQWord(Result xor (QWord(p[1]) * c5), 11) * c1;
        Result := RolQWord(Result xor (QWord(p[2]) * c5), 11) * c1;
      end;
  end;
  Result := (Result xor Result shr 33) * c2;
  Result := (Result xor Result shr 29) * c3;
  Result :=  Result xor Result shr 32;
end;
{$ENDIF FPC_REQUIRES_PROPER_ALIGNMENT}

class function TxxHash64LE.HashStr(constref aValue: string; aSeed: QWord): QWord;
begin
  Result := HashBuf(PAnsiChar(aValue), System.Length(aValue), aSeed);
end;

class function TxxHash64LE.HashWord(aValue: Word; aSeed: QWord): QWord;
begin
  Result := RolQWord((aSeed + c5 + 2) xor (QWord(aValue and $ff) * c5), 11) * c1;
  Result := RolQWord(Result xor (QWord(aValue shr 8) * c5), 11) * c1;
  Result := (Result xor Result shr 33) * c2;
  Result := (Result xor Result shr 29) * c3;
  Result :=  Result xor Result shr 32;
end;

class function TxxHash64LE.HashDWord(aValue: DWord; aSeed: QWord): QWord;
begin
  Result := RolQWord(((aSeed + c5 + 4) xor QWord(aValue)) * c1, 23) * c2 + c3;
  Result := (Result xor Result shr 33) * c2;
  Result := (Result xor Result shr 29) * c3;
  Result :=  Result xor Result shr 32;
end;

class function TxxHash64LE.HashQWord(aValue: QWord; aSeed: QWord): QWord;
begin
  Result := RolQWord((aSeed + c5 + 8) xor (c1 * RolQWord(c2 * aValue, 31)), 27) * c1 + c4;
  Result := (Result xor Result shr 33) * c2;
  Result := (Result xor Result shr 29) * c3;
  Result :=  Result xor Result shr 32;
end;

{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}
class function TxxHash64LE.HashGuid(constref aValue: TGuid; aSeed: QWord): QWord; inline;
begin
  Result := HashBuf(@aValue, SizeOf(aValue), aSeed);
end;
{$ELSE FPC_REQUIRES_PROPER_ALIGNMENT}
class function TxxHash64LE.HashGuid(constref aValue: TGuid; aSeed: QWord): QWord;
begin
  Result := RolQWord((aSeed + c5 + SizeOf(TGuid))xor(c1 * RolQWord(PQWord(@aValue)[0] * c2, 31)), 27) * c1 + c4;
  Result := RolQWord(Result xor (c1 * RolQWord(PQWord(@aValue)[1] * c2, 31)), 27) * c1 + c4;
  Result := (Result xor Result shr 33) * c2;
  Result := (Result xor Result shr 29) * c3;
  Result :=  Result xor Result shr 32;
end;
{$ENDIF FPC_REQUIRES_PROPER_ALIGNMENT}
{$UNDEF c1}{$UNDEF c2}{$UNDEF c3}{$UNDEF}{$UNDEF c5}

{ TMurmur2LE }

{$DEFINE m32 := DWord($5bd1e995)}
{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur2LE.HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord): DWord;
var
  k1, k2, k3, k4: DWord;
  buf: array[0..3] of DWord;
  p: PByte absolute aBuffer;
begin
  Result := aSeed xor DWord(aCount);
  while aCount >= 16 do
    begin
      System.Move(p^, buf{%H-}, 16);
      k1 := buf[ 0] * m32;
      k2 := buf[ 1] * m32;
      k3 := buf[ 2] * m32;
      k4 := buf[ 3] * m32;
      Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
      Result := (((Result * m32) xor ((k3 xor k3 shr 24) * m32)) * m32) xor ((k4 xor k4 shr 24) * m32);
      p += 16;
      aCount -= 16;
    end;
  if aCount > 0 then
    begin
      buf[aCount shr 2] := 0;
      System.Move(p^, buf, aCount);
      case aCount shr 2 of
        1:
          begin
            k1 := buf[0] * m32;
            k4 := buf[1];
            Result := (Result * m32) xor ((k1 xor k1 shr 24) * m32);
            aCount -= 4;
          end;
        2:
          begin
            k1 := buf[0] * m32;
            k2 := buf[1] * m32;
            k4 := buf[2];
            Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
            aCount -= 8;
          end;
        3:
          begin
            k1 := buf[0] * m32;
            k2 := buf[1] * m32;
            k3 := buf[2] * m32;
            k4 := buf[3];
            Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
            Result := (Result * m32) xor (k3 xor k3 shr 24) * m32;
            aCount -= 12;
          end;
      else
        k4 := buf[0];
      end;
      if aCount > 0 then
        Result := (Result xor k4) * m32;
    end;
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;
{$ELSE FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur2LE.HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord): DWord;
var
  k1, k2, k3, k4: DWord;
  p: PDWord absolute aBuffer;
begin
  Result := aSeed xor DWord(aCount);
  while aCount >= 16 do
    begin
      k1 := p[0] * m32;
      k2 := p[1] * m32;
      k3 := p[2] * m32;
      k4 := p[3] * m32;
      Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
      Result := (((Result * m32) xor ((k3 xor k3 shr 24) * m32)) * m32) xor ((k4 xor k4 shr 24) * m32);
      p += 4;
      aCount -= 16;
    end;
  case aCount shr 2 of
    1:
      begin
        k1 := p[0] * m32;
        Result := (Result * m32) xor ((k1 xor k1 shr 24) * m32);
        p += 1;
        aCount -= 4;
      end;
    2:
      begin
        k1 := p[0] * m32;
        k2 := p[1] * m32;
        Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
        p += 2;
        aCount -= 8;
      end;
    3:
      begin
        k1 := p[0] * m32;
        k2 := p[1] * m32;
        k3 := p[2] * m32;
        Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
        Result := (Result * m32) xor (k3 xor k3 shr 24) * m32;
        p += 3;
        aCount -= 12;
      end;
  end;
  if aCount > 0 then
    begin
      k4 := 0;
      case aCount of
        1: PByte(@k4)^  := PByte(p)^;
        2: PWord(@k4)^  := PWord(p)^;
        3: PByte3(@k4)^ := PByte3(p)^;
      end;
      Result := (Result xor k4) * m32;
    end;
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;
{$ENDIF FPC_REQUIRES_PROPER_ALIGNMENT}

class function TMurmur2LE.HashStr(constref aValue: string; aSeed: DWord): DWord;
begin
  Result := HashBuf(PAnsiChar(aValue), System.Length(aValue), aSeed);
end;

class function TMurmur2LE.HashWord(aValue: Word; aSeed: DWord): DWord;
begin
  Result := ((aSeed xor 2) xor DWord(aValue)) * m32;
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;

class function TMurmur2LE.HashDWord(aValue: DWord; aSeed: DWord): DWord;
begin
  aValue *= m32;
  Result := ((aSeed xor 4) * m32) xor ((aValue xor aValue shr 24) * m32);
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;

class function TMurmur2LE.HashQWord(aValue: QWord; aSeed: DWord): DWord;
var
  k1, k2: DWord;
begin
  k1 := PDWord(@aValue)[0] * m32;
  k2 := PDWord(@aValue)[1] * m32;
  Result := ((((aSeed xor 8) * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;

class function TMurmur2LE.HashGuid(constref aValue: TGuid; aSeed: DWord): DWord;
var
  k1, k2, k3, k4: DWord;
begin
  Result := aSeed xor DWord(SizeOf(aValue));
  k1 := PDWord(@aValue)[0] * m32;
  k2 := PDWord(@aValue)[1] * m32;
  k3 := PDWord(@aValue)[2] * m32;
  k4 := PDWord(@aValue)[3] * m32;
  Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
  Result := (((Result * m32) xor ((k3 xor k3 shr 24) * m32)) * m32) xor ((k4 xor k4 shr 24) * m32);
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;

{ TMurmur2aLE }

{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur2aLE.HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord): DWord;
var
  k1, k2, k3, k4: DWord;
  buf: array[0..3] of DWord;
  p: PByte absolute aBuffer;
begin
  Result := aSeed;
  aSeed := DWord(aCount) * m32;
  while aCount >= 16 do
    begin
      System.Move(p^, buf{%H-}, 16);
      k1 := buf[0] * m32;
      k2 := buf[1] * m32;
      k3 := buf[2] * m32;
      k4 := buf[3] * m32;
      Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
      Result := (((Result * m32) xor ((k3 xor k3 shr 24) * m32)) * m32) xor ((k4 xor k4 shr 24) * m32);
      p += 16;
      aCount -= 16;
    end;
  if aCount > 0 then
    begin
      buf[aCount shr 2] := 0;
      System.Move(p^, buf, aCount);
      case aCount shr 2 of
        1:
          begin
            k1 := buf[0] * m32;
            k4 := buf[1];
            Result := (Result * m32) xor ((k1 xor k1 shr 24) * m32);
            aCount -= 4;
          end;
        2:
          begin
            k1 := buf[0] * m32;
            k2 := buf[1] * m32;
            k4 := buf[2];
            Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
            aCount -= 8;
          end;
        3:
          begin
            k1 := buf[0] * m32;
            k2 := buf[1] * m32;
            k3 := buf[2] * m32;
            k4 := buf[3];
            Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
            Result := (Result * m32) xor (k3 xor k3 shr 24) * m32;
            aCount -= 12;
          end;
      else
        k4 := buf[0];
      end;
    end
  else
    k4 := 0;
  k4 := k4 * m32;
  Result := (Result * m32) xor ((k4 xor k4 shr 24) * m32);
  Result := (Result * m32) xor ((aSeed xor aSeed shr 24) * m32);
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;
{$ELSE FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur2aLE.HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord): DWord;
var
  k1, k2, k3, k4: DWord;
  p: PDWord absolute aBuffer;
begin
  Result := aSeed;
  aSeed := DWord(aCount) * m32;
  while aCount >= 16 do
    begin
      k1 := p[0] * m32;
      k2 := p[1] * m32;
      k3 := p[2] * m32;
      k4 := p[3] * m32;
      Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
      Result := (((Result * m32) xor ((k3 xor k3 shr 24) * m32)) * m32) xor ((k4 xor k4 shr 24) * m32);
      p += 4;
      aCount -= 16;
    end;
  case aCount shr 2 of
    1:
      begin
        k1 := p[0] * m32;
        Result := (Result * m32) xor ((k1 xor k1 shr 24) * m32);
        p += 1;
        aCount -= 4;
      end;
    2:
      begin
        k1 := p[0] * m32;
        k2 := p[1] * m32;
        Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
        p += 2;
        aCount -= 8;
      end;
    3:
      begin
        k1 := p[0] * m32;
        k2 := p[1] * m32;
        k3 := p[2] * m32;
        Result := (((Result * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
        Result := (Result * m32) xor (k3 xor k3 shr 24) * m32;
        p += 3;
        aCount -= 12;
      end;
  end;
  Result *= m32;///////////////
  if aCount > 0 then
    begin
      k4 := 0;
      case aCount of
        1: PByte(@k4)^  := PByte(p)^;
        2: PWord(@k4)^  := PWord(p)^;
        3: PByte3(@k4)^ := PByte3(p)^;
      end;
      k4 := k4 * m32;
      Result := Result xor (k4 xor k4 shr 24) * m32;
    end;
  Result := (Result * m32) xor ((aSeed xor aSeed shr 24) * m32);  ////
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;
{$ENDIF FPC_REQUIRES_PROPER_ALIGNMENT}

class function TMurmur2aLE.HashStr(constref aValue: string; aSeed: DWord): DWord;
begin
  Result := HashBuf(PAnsiChar(aValue), System.Length(aValue), aSeed);
end;

class function TMurmur2aLE.HashWord(aValue: Word; aSeed: DWord): DWord;
begin
  //((m32 shl 1) xor (m32 shl 1) shr 24) * m32 = $90210F61
  Result := aSeed * m32;
  aSeed := aValue * m32;
  Result := ((Result xor ((aSeed xor aSeed shr 24) * m32)) * m32) xor $90210F61;
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;

class function TMurmur2aLE.HashDWord(aValue: DWord; aSeed: DWord): DWord;
begin
  //((m32 shl 2) xor (m32 shl 2) shr 24) * m32 = $AA2A7357
  //m32^2 = $286A90B9
  aValue *= m32;
  Result := (((aSeed * m32) xor ((aValue xor aValue shr 24) * m32)) * $286A90B9) xor $AA2A7357;
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;

class function TMurmur2aLE.HashQWord(aValue: QWord; aSeed: DWord): DWord;
var
  k1, k2: DWord;
begin
  //((m32 shl 3) xor (m32 shl 3) shr 24) * m32 = $5454E6AE
  //m32^2 = $286A90B9
  k1 := PDWord(@aValue)[0] * m32;
  k2 := PDWord(@aValue)[1] * m32;
  Result := (((aSeed * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
  Result := (Result * $286A90B9) xor $5454E6AE;
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;

class function TMurmur2aLE.HashGuid(constref aValue: TGuid; aSeed: DWord): DWord;
var
  k1, k2, k3, k4: DWord;
begin
  //((m32 shl 3) xor (m32 shl 3) shr 24) * m32 = $D6654BF1
  //m32^2 = $286A90B9
  k1 := PDWord(@aValue)[0] * m32;
  k2 := PDWord(@aValue)[1] * m32;
  k3 := PDWord(@aValue)[2] * m32;
  k4 := PDWord(@aValue)[3] * m32;
  Result := (((aSeed  * m32) xor ((k1 xor k1 shr 24) * m32)) * m32) xor ((k2 xor k2 shr 24) * m32);
  Result := (((Result * m32) xor ((k3 xor k3 shr 24) * m32)) * m32) xor ((k4 xor k4 shr 24) * m32);
  Result := (Result * $286A90B9) xor $D6654BF1;
  Result := (Result xor Result shr 13) * m32;
  Result :=  Result xor Result shr 15;
end;
{$UNDEF m32}

{ TMurmur3LE }

{$DEFINE c1 := DWord($cc9e2d51)}{$DEFINE c2 := DWord($1b873593)}{$DEFINE c3 := DWord($e6546b64)}
{$DEFINE c4 := DWord($85ebca6b)}{$DEFINE c5 := DWord($c2b2ae35)}
{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur3LE.HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord): DWord;
var
  k1, k2, k3, k4: DWord;
  buf: array[0..3] of DWord;
  p: PByte absolute aBuffer;
begin
  Result := aSeed;
  aSeed := DWord(aCount);
  while aCount >= 16 do
    begin
      System.Move(p^, buf{%H-}, 16);
      k1 := RolDWord(buf[0] * c1, 15) * c2;
      k2 := RolDWord(buf[1] * c1, 15) * c2;
      k3 := RolDWord(buf[2] * c1, 15) * c2;
      k4 := RolDWord(buf[3] * c1, 15) * c2;
      Result := RolDWord((RolDWord(Result xor k1, 13) * 5 + c3) xor k2, 13) * 5 + c3;
      Result := RolDWord((RolDWord(Result xor k3, 13) * 5 + c3) xor k4, 13) * 5 + c3;
      p += 16;
      aCount -= 16;
    end;
  if aCount > 0 then
    begin
      buf[aCount shr 2] := 0;
      System.Move(p^, buf, aCount);
      case aCount shr 2 of
        1:
          begin
            Result := RolDWord(Result xor (RolDWord(buf[0] * c1, 15) * c2), 13) * 5 + c3;
            k4 := buf[1];
            aCount -= 4;
          end;
        2:
          begin
            k1 := RolDWord(buf[0] * c1, 15) * c2;
            k2 := RolDWord(buf[1] * c1, 15) * c2;
            k4 := buf[2];
            Result := RolDWord((RolDWord(Result xor k1, 13) * 5 + c3) xor k2, 13) * 5 + c3;
            aCount -= 8;
          end;
        3:
          begin
            k1 := RolDWord(buf[0] * c1, 15) * c2;
            k2 := RolDWord(buf[1] * c1, 15) * c2;
            k3 := RolDWord(buf[2] * c1, 15) * c2;
            k4 := buf[3];
            Result := RolDWord((RolDWord(Result xor k1, 13) * 5 + c3) xor k2, 13) * 5 + c3;
            Result := RolDWord(Result xor k3, 13) * 5 + c3;
            aCount -= 12;
          end;
      else
        k4 := buf[0];
      end;
    end
  else
    k4 := 0;
  Result := Result xor (RolDWord(k4 * c1, 15) * c2);
  Result :=  Result xor aSeed;
  Result := (Result xor Result shr 16) * c4;
  Result := (Result xor Result shr 13) * c5;
  Result :=  Result xor Result shr 16;
end;
{$ELSE FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur3LE.HashBuf(aBuffer: Pointer; aCount: Integer; aSeed: DWord): DWord;
var
  k1, k2, k3, k4: DWord;
  p: PDWord absolute aBuffer;
begin
  Result := aSeed;
  aSeed := DWord(aCount);
  while aCount >= 16 do
    begin
      k1 := RolDWord(p[0] * c1, 15) * c2;
      k2 := RolDWord(p[1] * c1, 15) * c2;
      k3 := RolDWord(p[2] * c1, 15) * c2;
      k4 := RolDWord(p[3] * c1, 15) * c2;
      Result := RolDWord((RolDWord(Result xor k1, 13) * 5 + c3) xor k2, 13) * 5 + c3;
      Result := RolDWord((RolDWord(Result xor k3, 13) * 5 + c3) xor k4, 13) * 5 + c3;
      p += 4;
      aCount -= 16;
    end;
  case aCount shr 2 of
    1:
      begin
        Result := RolDWord(Result xor (RolDWord(p[0] * c1, 15) * c2), 13) * 5 + c3;
        p += 1;
        aCount -= 4;
      end;
    2:
      begin
        k1 := RolDWord(p[0] * c1, 15) * c2;
        k2 := RolDWord(p[1] * c1, 15) * c2;
        Result := RolDWord((RolDWord(Result xor k1, 13) * 5 + c3) xor k2, 13) * 5 + c3;
        p += 2;
        aCount -= 8;
      end;
    3:
      begin
        k1 := RolDWord(p[0] * c1, 15) * c2;
        k2 := RolDWord(p[1] * c1, 15) * c2;
        Result := RolDWord((RolDWord(Result xor k1, 13) * 5 + c3) xor k2, 13) * 5 + c3;
        Result := RolDWord(Result xor (RolDWord(p[2] * c1, 15) * c2), 13) * 5 + c3;
        p += 3;
        aCount -= 12;
      end;
  end;
  if aCount > 0 then
    begin
      k4 := 0;
      case aCount of
        1: PByte(@k4)^  := PByte(p)^;
        2: PWord(@k4)^  := PWord(p)^;
        3: PByte3(@k4)^ := PByte3(p)^;
      end;
      Result := Result xor (RolDWord(k4 * c1, 15) * c2);
    end;
  Result := Result xor aSeed;
  Result := (Result xor Result shr 16) * c4;
  Result := (Result xor Result shr 13) * c5;
  Result := Result xor Result shr 16;
end;
{$ENDIF FPC_REQUIRES_PROPER_ALIGNMENT}

class function TMurmur3LE.HashStr(constref aValue: string; aSeed: DWord): DWord;
begin
  Result := HashBuf(PAnsiChar(aValue), System.Length(aValue), aSeed);
end;

class function TMurmur3LE.HashWord(aValue: Word; aSeed: DWord): DWord;
begin
  Result := (aSeed xor (RolDWord(DWord(aValue) * c1, 15) * c2)) xor 2;
  Result := (Result xor Result shr 16) * c4;
  Result := (Result xor Result shr 13) * c5;
  Result := Result xor Result shr 16;
end;

class function TMurmur3LE.HashDWord(aValue: DWord; aSeed: DWord): DWord;
begin
  Result := (RolDWord(aSeed xor (RolDWord(aValue * c1, 15) * c2), 13) * 5 + c3) xor 4;
  Result := (Result xor Result shr 16) * c4;
  Result := (Result xor Result shr 13) * c5;
  Result := Result xor Result shr 16;
end;

class function TMurmur3LE.HashQWord(aValue: QWord; aSeed: DWord): DWord;
var
  k1, k2: DWord;
begin
  k1 := RolDWord(PDWord(@aValue)[0] * c1, 15) * c2;
  k2 := RolDWord(PDWord(@aValue)[1] * c1, 15) * c2;
  Result := (RolDWord((RolDWord(aSeed xor k1, 13) * 5 + c3) xor k2, 13) * 5 + c3) xor 8;
  Result := (Result xor Result shr 16) * c4;
  Result := (Result xor Result shr 13) * c5;
  Result :=  Result xor Result shr 16;
end;

class function TMurmur3LE.HashGuid(constref aValue: TGuid; aSeed: DWord): DWord;
var
  g: TDWords4 absolute aValue;
begin

  Result :=  RolDWord((RolDWord(aSeed  xor DWord(RolDWord(g.D1 * c1, 15) * c2), 13) * 5 + c3)
                                       xor DWord(RolDWord(g.D2 * c1, 15) * c2), 13) * 5 + c3;
  Result := (RolDWord((RolDWord(Result xor DWord(RolDWord(g.D3 * c1, 15) * c2), 13) * 5 + c3)
                                       xor DWord(RolDWord(g.D4 * c1, 15) * c2), 13) * 5 + c3)
                                       xor DWord(SizeOf(aValue));

  Result := (Result xor Result shr 16) * c4;
  Result := (Result xor Result shr 13) * c5;
  Result := Result xor Result shr 16;
end;
{$UNDEF c1}{$UNDEF c2}{$UNDEF c3}{$UNDEF}{$UNDEF c5}

{ TMurmur64aLE }

{$DEFINE m64 := QWord($c6a4a7935bd1e995)}
{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur64aLE.HashBuf(aBuffer: Pointer; aCount: Int64; aSeed: QWord): QWord;
var
  k1, k2, k3, k4: QWord;
  buf: array[0..3] of QWord;
  p: PByte absolute aBuffer;
begin
  Result := aSeed xor (QWord(aCount) * m64);
  while aCount >= 32 do
    begin
      System.Move(p^, buf{%H-}, 32);
      k1 := buf[0] * m64;
      k2 := buf[1] * m64;
      k3 := buf[2] * m64;
      k4 := buf[3] * m64;
      Result := (((Result xor ((k1 xor k1 shr 47) * m64)) * m64) xor ((k2 xor k2 shr 47) * m64)) * m64;
      Result := (((Result xor ((k3 xor k3 shr 47) * m64)) * m64) xor ((k4 xor k4 shr 47) * m64)) * m64;
      p += 32;
      aCount -= 32;
    end;
  if aCount > 0 then
    begin
      buf[aCount shr 3] := 0;
      System.Move(p^, buf, aCount);
      p := @buf;
      case aCount shr 3 of
        1:
          begin
            k1 := buf[0] * m64;
            k4 := buf[1];
            Result := (Result xor ((k1 xor k1 shr 47) * m64)) * m64;
            aCount -= 8;
          end;
        2:
          begin
            k1 := buf[0] * m64;
            k2 := buf[1] * m64;
            k4 := buf[2];
            Result := (((Result xor ((k1 xor k1 shr 47) * m64)) * m64) xor ((k2 xor k2 shr 47) * m64)) * m64;
            aCount -= 16;
          end;
        3:
          begin
            k1 := buf[0] * m64;
            k2 := buf[1] * m64;
            k3 := buf[2] * m64;
            k4 := buf[3];
            Result := (((Result xor ((k1 xor k1 shr 47) * m64)) * m64) xor ((k2 xor k2 shr 47) * m64)) * m64;
            Result := (Result xor ((k3 xor k3 shr 47) * m64)) * m64;
            aCount -= 24;
          end;
      else
        k4 := buf[0];
      end;
      if aCount > 0 then
        Result := (Result xor k4) * m64;
    end;
  Result := (Result xor Result shr 47) * m64;
  Result :=  Result xor Result shr 47;
end;
{$ELSE FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur64aLE.HashBuf(aBuffer: Pointer; aCount: Int64; aSeed: QWord): QWord;
var
  k1, k2, k3, k4: QWord;
  p: PQWord absolute aBuffer;
begin
  Result := aSeed xor (QWord(aCount) * m64);
  while aCount >= 32 do
    begin
      k1 := p[0] * m64;
      k2 := p[1] * m64;
      k3 := p[2] * m64;
      k4 := p[3] * m64;
      Result := (((Result xor ((k1 xor k1 shr 47) * m64)) * m64) xor ((k2 xor k2 shr 47) * m64)) * m64;
      Result := (((Result xor ((k3 xor k3 shr 47) * m64)) * m64) xor ((k4 xor k4 shr 47) * m64)) * m64;
      p += 4;
      aCount -= 32;
    end;
  case aCount shr 3 of
    1:
      begin
        k1 := p[0] * m64;
        Result := (Result xor ((k1 xor k1 shr 47) * m64)) * m64;
        aCount -= 8;
        p += 1;
      end;
    2:
      begin
        k1 := p[0] * m64;
        k2 := p[1] * m64;
        Result := (((Result xor ((k1 xor k1 shr 47) * m64)) * m64) xor ((k2 xor k2 shr 47) * m64)) * m64;
        aCount -= 16;
        p += 2;
      end;
    3:
      begin
        k1 := p[0] * m64;
        k2 := p[1] * m64;
        k3 := p[2] * m64;
        Result := (((Result xor ((k1 xor k1 shr 47) * m64)) * m64) xor ((k2 xor k2 shr 47) * m64)) * m64;
        Result := (Result xor ((k3 xor k3 shr 47) * m64)) * m64;
        aCount -= 24;
        p += 3;
      end;
  end;
  if aCount > 0 then
    begin
      k4 := 0;
      case aCount of
        1: PByte( @k4)^ := PByte( p)^;
        2: PWord( @k4)^ := PWord( p)^;
        3: PByte3(@k4)^ := PByte3(p)^;
        4: PDWord(@k4)^ := PDWord(p)^;
        5: PByte5(@k4)^ := PByte5(p)^;
        6: PByte6(@k4)^ := PByte6(p)^;
        7: PByte7(@k4)^ := PByte7(p)^;
      end;
      Result := (Result xor k4) * m64;
    end;
  Result := (Result xor Result shr 47) * m64;
  Result :=  Result xor Result shr 47;
end;
{$ENDIF FPC_REQUIRES_PROPER_ALIGNMENT}

class function TMurmur64aLE.HashStr(constref aValue: string; aSeed: QWord): QWord;
begin
  Result := HashBuf(PAnsiChar(aValue), System.Length(aValue), aSeed);
end;

class function TMurmur64aLE.HashWord(aValue: Word; aSeed: QWord): QWord;
begin
  Result := ((aSeed xor m64 shl 1) xor QWord(aValue)) * m64;
  Result := (Result xor Result shr 47) * m64;
  Result :=  Result xor Result shr 47;
end;

class function TMurmur64aLE.HashDWord(aValue: DWord; aSeed: QWord): QWord;
begin
  Result := QWord((aSeed xor m64 shl 2) xor QWord(aValue)) * m64;
  Result := (Result xor Result shr 47) * m64;
  Result :=  Result xor Result shr 47;
end;

class function TMurmur64aLE.HashQWord(aValue: QWord; aSeed: QWord): QWord;
begin
  aValue := aValue * m64;
  Result := QWord((aSeed xor (m64 shl 3)) xor ((aValue xor aValue shr 47) * m64)) * m64;
  Result := (Result xor Result shr 47) * m64;
  Result :=  Result xor Result shr 47;
end;

{$IFDEF FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur64aLE.HashGuid(constref aValue: TGuid; aSeed: QWord): QWord;
begin
  Result := HashBuf(@aValue, SizeOf(aValue), aSeed);
end;
{$ELSE FPC_REQUIRES_PROPER_ALIGNMENT}
class function TMurmur64aLE.HashGuid(constref aValue: TGuid; aSeed: QWord): QWord;
var
  k1, k2: QWord;
begin
  k1 := PQWord(@aValue)[0] * m64;
  k2 := PQWord(@aValue)[1] * m64;
  Result := ((((aSeed xor QWord(m64 shl 4)) xor ((k1 xor k1 shr 47) * m64)) * m64) xor
              ((k2 xor k2 shr 47) * m64)) * m64;
  Result := (Result xor Result shr 47) * m64;
  Result :=  Result xor Result shr 47;
end;
{$ENDIF FPC_REQUIRES_PROPER_ALIGNMENT}
{$UNDEF m64}

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic hashmap implementations.                                        *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGHashMap;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH NESTEDPROCVARS}
{$MODESWITCH ADVANCEDRECORDS}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGHashTable,
  LGStrConst;

type

  { TGCustomHashMap: common abstract ancestor class to implement hashmap }
  generic TGCustomHashMap<TKey, TValue> = class abstract(specialize TGCustomMap<TKey, TValue>)
  protected
  type
    TCustomHashMap       = specialize TGCustomHashMap<TKey, TValue>;
    THashMapClass        = class of TCustomHashMap;
    THashTable           = specialize TGCustomHashTable<TKey, TEntry>;
    THashTableClass      = class of THashTable;
    TSearchResult        = THashTable.TSearchResult;

    TKeyEnumerable = class(TCustomKeyEnumerable)
    protected
      FEnum: THashTable.TEntryEnumerator;
      function  GetCurrent: TKey; override;
    public
      constructor Create(aMap: TCustomHashMap);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TValueEnumerable = class(TCustomValueEnumerable)
    protected
      FEnum: THashTable.TEntryEnumerator;
      function  GetCurrent: TValue; override;
    public
      constructor Create(aMap: TCustomHashMap);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TEntryEnumerable = class(TCustomEntryEnumerable)
    protected
      FEnum: THashTable.TEntryEnumerator;
      function  GetCurrent: TEntry; override;
    public
      constructor Create(aMap: TCustomHashMap);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FTable: THashTable;
    function  GetCount: SizeInt; override;
  { The capacity of the hashmap is treated as the number of entries that can be written without rehashing }
    function  GetCapacity: SizeInt; override;
    function  GetFillRatio: Single;
    function  GetLoadFactor: Single;
    procedure SetLoadFactor(aValue: Single); inline;
    function  GetTableSize: SizeInt; inline;
    function  Find(constref aKey: TKey): PEntry; override;
    //return True if aKey found, otherwise insert (garbage) pair and return False;
    function  FindOrAdd(constref aKey: TKey; out p: PEntry): Boolean; override;
    function  DoExtract(constref aKey: TKey; out v: TValue): Boolean; override;
    function  DoRemoveIf(aTest: TKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestKeyTest): SizeInt; override;
    function  DoExtractIf(aTest: TKeyTest): TEntryArray; override;
    function  DoExtractIf(aTest: TOnKeyTest): TEntryArray; override;
    function  DoExtractIf(aTest: TNestKeyTest): TEntryArray; override;
    procedure DoClear; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    procedure DoTrimToFit; override;
    function  GetKeys: IKeyEnumerable; override;
    function  GetValues: IValueEnumerable; override;
    function  GetEntries: IEntryEnumerable; override;
    class function GetTableClass: THashTableClass; virtual; abstract;
    class function GetClass: THashMapClass; virtual; abstract;
  public
    class function DefaultLoadFactor: Single; inline;
    class function MaxLoadFactor: Single; inline;
    class function MinLoadFactor: Single; inline;
    constructor Create;
    constructor Create(constref a: array of TEntry);
    constructor Create(e: IEntryEnumerable);
    constructor Create(aCapacity: SizeInt);
    constructor Create(aCapacity: SizeInt; constref a: array of TEntry);
    constructor Create(aCapacity: SizeInt; e: IEntryEnumerable);
    constructor Create(aLoadFactor: Double);
    constructor Create(aLoadFactor: Single; constref a: array of TEntry);
    constructor Create(aLoadFactor: Single; e: IEntryEnumerable);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of TEntry);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEntryEnumerable);
    constructor CreateCopy(aMap: TCustomHashMap);
    destructor Destroy; override;
    function  Clone: TCustomHashMap; override;
    property  LoadFactor: Single read GetLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  end;

  { TGBaseHashMapLP implements open addressing hashmap with linear probing;
      TKeyEqRel must provide:
        class function HashCode([const[ref]] aValue: TKey): SizeInt;
        class function Equal([const[ref]] L, R: TKey): Boolean; }
  generic TGBaseHashMapLP<TKey, TValue, TKeyEqRel> = class(specialize TGCustomHashMap<TKey, TValue>)
  protected
    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMapClass; override;
  end;

  { TGHashMapLP implements open addressing hashmap with linear probing;
    it assumes that type TKey implements TKeyEqRel }
  generic TGHashMapLP<TKey, TValue> = class(specialize TGBaseHashMapLP<TKey, TValue, TKey>);

  { TGBaseHashMapLPT implements open addressing hashmap with linear probing and lazy deletion }
  generic TGBaseHashMapLPT<TKey, TValue, TKeyEqRel> = class(specialize TGCustomHashMap<TKey, TValue>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    TTableLPT = specialize TGOpenAddrLPT<TKey, TEntry, TKeyEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMapClass; override;
  public
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGHashMapLPT implements open addressing hashmap with linear probing and lazy deletion;
    it assumes that type TKey implements TKeyEqRel }
  generic TGHashMapLPT<TKey, TValue> = class(specialize TGBaseHashMapLPT<TKey, TValue, TKey>);

  { TGBaseHashMapQP implements open addressing hashmap with quadratic probing(c1 = c2 = 1/2)}
  generic TGBaseHashMapQP<TKey, TValue, TKeyEqRel> = class(specialize TGCustomHashMap<TKey, TValue>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    TTableQP = specialize TGOpenAddrQP<TKey, TEntry, TKeyEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMapClass; override;
  public
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGHashMapQP implements open addressing hashmap with quadratic probing(c1 = c2 = 1/2);
    it assumes that type TKey implements TKeyEqRel }
  generic TGHashMapQP<TKey, TValue> = class(specialize TGBaseHashMapQP<TKey, TValue, TKey>);

  { TGBaseChainHashMap implements node based hashmap with singly linked list chains }
  generic TGBaseChainHashMap<TKey, TValue, TKeyEqRel> = class(specialize TGCustomHashMap<TKey, TValue>)
  protected
    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMapClass; override;
  end;

  { TGChainHashMap implements node based hashmap with singly linked list chains;
    it assumes that type TKey implements TKeyEqRel }
  generic TGChainHashMap<TKey, TValue> = class(specialize TGBaseChainHashMap<TKey, TValue, TKey>)
    function Clone: TGChainHashMap; override;
  end;

  { TGCustomObjectHashMap
      note: for equality comparision of (TValue as TObject) used TObjectHelper from LGHelpers }
  generic TGCustomObjectHashMap<TKey, TValue> = class abstract(specialize TGCustomHashMap<TKey, TValue>)
  private
    FOwnsKeys: Boolean;
    FOwnsValues: Boolean;
  protected
  type
    TObjectHashMapClass = class of TGCustomObjectHashMap;

    procedure EntryRemoving(p: PEntry);
    procedure SetOwnership(aOwns: TMapObjOwnership); inline;
    function  DoRemove(constref aKey: TKey): Boolean; override;
    function  DoRemoveIf(aTest: TKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestKeyTest): SizeInt; override;
    procedure DoClear; override;
    function  DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean; override;
    function  DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean; override;
    class function GetClass: TObjectHashMapClass; reintroduce; virtual; abstract;
  public
    constructor Create(aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(constref a: array of TEntry; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(e: IEntryEnumerable; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; constref a: array of TEntry; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; e: IEntryEnumerable; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aLoadFactor: Single; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aLoadFactor: Single; constref a: array of TEntry; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aLoadFactor: Single; e: IEntryEnumerable; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of TEntry;
                       aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEntryEnumerable;
                       aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor CreateCopy(aMap: TGCustomObjectHashMap);
    property  OwnsKeys: Boolean read FOwnsKeys write FOwnsKeys;
    property  OwnsValues: Boolean read FOwnsValues write FOwnsValues;
  end;


  { TGObjectHashMapLP }

  generic TGObjectHashMapLP<TKey, TValue, TKeyEqRel> = class(specialize TGCustomObjectHashMap<TKey, TValue>)
  protected
    class function GetTableClass: THashTableClass; override;
    class function GetClass: TObjectHashMapClass; override;
  public
    function Clone: TGObjectHashMapLP; override;
  end;

  { TGObjHashMapLP }

  generic TGObjHashMapLP<TKey, TValue> = class(specialize TGObjectHashMapLP<TKey, TValue, TKey>);

  { TGObjectHashMapLPT }

  generic TGObjectHashMapLPT<TKey, TValue, TKeyEqRel> = class(specialize TGCustomObjectHashMap<TKey, TValue>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    TTableLPT = specialize TGOpenAddrLPT<TKey, TEntry, TKeyEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: TObjectHashMapClass; override;
  public
    function  Clone: TGObjectHashMapLPT; override;
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGObjHashMapLPT }

  generic TGObjHashMapLPT<TKey, TValue> = class(specialize TGObjectHashMapLPT<TKey, TValue, TKey>);

  { TGObjectHashMapQP }

  generic TGObjectHashMapQP<TKey, TValue, TKeyEqRel> = class(specialize TGCustomObjectHashMap<TKey, TValue>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    TTableQP = specialize TGOpenAddrQP<TKey, TEntry, TKeyEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: TObjectHashMapClass; override;
  public
    function  Clone: TGObjectHashMapQP; override;
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGObjHashMapQP }

  generic TGObjHashMapQP<TKey, TValue> = class(specialize TGObjectHashMapQP<TKey, TValue, TKey>);

  { TGObjectChainHashMap }

  generic TGObjectChainHashMap<TKey, TValue, TKeyEqRel> = class(specialize TGCustomObjectHashMap<TKey, TValue>)
  protected
    class function GetTableClass: THashTableClass; override;
    class function GetClass: TObjectHashMapClass; override;
  public
    function Clone: TGObjectChainHashMap; override;
  end;

  { TGObjChainHashMap }

  generic TGObjChainHashMap<TKey, TValue> = class(specialize TGObjectChainHashMap<TKey, TValue, TKey>);

  { TGLiteHashMapLP implements open addressing hashmap with linear probing;
      TKeyEqRel must provide:
        class function HashCode([const[ref]] aValue: TKey): SizeInt;
        class function Equal([const[ref]] L, R: TKey): Boolean; }
  generic TGLiteHashMapLP<TKey, TValue, TKeyEqRel> = record
  public
  type
    TEntry           = specialize TGMapEntry<TKey, TValue>;
    TEntryArray      = specialize TGArray<TEntry>;
    TKeyArray        = specialize TGArray<TKey>;
    TKeyTest         = specialize TGTest<TKey>;
    TOnKeyTest       = specialize TGOnTest<TKey>;
    TNestKeyTest     = specialize TGNestTest<TKey>;
    TValueOptional   = specialize TGOptional<TValue>;
    TKeyCollection   = specialize TGCustomCollection<TKey>;
    IKeyEnumerable   = specialize IGEnumerable<TKey>;
    IEntryEnumerable = specialize IGEnumerable<TEntry>;
    IKeyCollection   = specialize IGCollection<TKey>;

  private
  type
    PEntry         = ^TEntry;
    TTableLP       = specialize TGLiteHashTableLP<TKey, TEntry, TKeyEqRel>;
    PLiteHashMapLP = ^TGLiteHashMapLP;

  public
  type
    TKeyEnumerator = record
    private
      FEnum: TTableLP.TEnumerator;
      function  GetCurrent: TKey; inline;
      procedure Init(constref aMap: TGLiteHashMapLP); inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: TKey read GetCurrent;
    end;

    TValueEnumerator = record
    private
      FEnum: TTableLP.TEnumerator;
      function  GetCurrent: TValue; inline;
      procedure Init(constref aMap: TGLiteHashMapLP); inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: TValue read GetCurrent;
    end;

    TEntryEnumerator = record
    private
      FEnum: TTableLP.TEnumerator;
      function  GetCurrent: TEntry; inline;
      procedure Init(constref aMap: TGLiteHashMapLP); inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: TEntry read GetCurrent;
    end;

    TKeys = record
    private
      FMap: PLiteHashMapLP;
      procedure Init(aMap: PLiteHashMapLP); inline;
    public
      function GetEnumerator: TKeyEnumerator; inline;
    end;

    TValues = record
    private
      FMap: PLiteHashMapLP;
      procedure Init(aMap: PLiteHashMapLP); inline;
    public
      function GetEnumerator: TValueEnumerator; inline;
    end;

  private
    FTable: TTableLP;
    function  GetCount: SizeInt; inline;
    function  GetCapacity: SizeInt; inline;
    function  Find(constref aKey: TKey): PEntry; inline;
    //returns True if aKey found, otherwise inserts (garbage) entry and returns False;
    function  FindOrAdd(constref aKey: TKey; out p: PEntry): Boolean;
    function  GetFillRatio: Single; inline;
    function  GetLoadFactor: Single; inline;
    function  GetTableSize: SizeInt; inline;
    function  GetValue(const aKey: TKey): TValue; inline;
    procedure SetLoadFactor(aValue: Single); inline;
    function  SetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean;
    function  GetKeyEnumerator: TKeyEnumerator; inline;
    function  GetValueEnumerator: TValueEnumerator; inline;
  public
    function  DefaultLoadFactor: Single; inline;
    function  MaxLoadFactor: Single; inline;
    function  MinLoadFactor: Single; inline;
    function  GetEnumerator: TEntryEnumerator; inline;
    function  ToArray: TEntryArray;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure Clear; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
  { free unused memory if possible }
    procedure TrimToFit; inline;
  { returns True and aValue mapped to aKey if contains aKey, False otherwise }
    function  TryGetValue(constref aKey: TKey; out aValue: TValue): Boolean;
  { returns Value mapped to aKey or aDefault }
    function  GetValueDef(constref aKey: TKey; constref aDefault: TValue = Default(TValue)): TValue; inline;
  { returns True and add TEntry(aKey, aValue) only if not contains aKey }
    function  Add(constref aKey: TKey; constref aValue: TValue): Boolean;
  { returns True and add e only if not contains e.Key }
    function  Add(constref e: TEntry): Boolean; inline;
    procedure AddOrSetValue(const aKey: TKey; const aValue: TValue);
  { returns True if e.Key added, False otherwise }
    function  AddOrSetValue(constref e: TEntry): Boolean; inline;
  { will add only entries which keys are absent in map }
    function  AddAll(constref a: array of TEntry): SizeInt;
    function  AddAll(e: IEntryEnumerable): SizeInt;
  { returns True and map aNewValue to aKey only if contains aKey, False otherwise }
    function  Replace(constref aKey: TKey; constref aNewValue: TValue): Boolean; inline;
    function  Contains(constref aKey: TKey): Boolean; inline;
    function  ContainsAny(constref a: array of TKey): Boolean;
    function  ContainsAny(e: IKeyEnumerable): Boolean;
    function  ContainsAll(constref a: array of TKey): Boolean;
    function  ContainsAll(e: IKeyEnumerable): Boolean;
  { returns True if entry removed }
    function  Remove(constref aKey: TKey): Boolean; inline;
    function  RemoveAll(constref a: array of TKey): SizeInt;
    function  RemoveAll(e: IKeyEnumerable): SizeInt;
    function  RemoveIf(aTest: TKeyTest): SizeInt;
    function  RemoveIf(aTest: TOnKeyTest): SizeInt;
    function  RemoveIf(aTest: TNestKeyTest): SizeInt;
    function  Extract(constref aKey: TKey; out v: TValue): Boolean;
    function  ExtractIf(aTest: TKeyTest): TEntryArray;
    function  ExtractIf(aTest: TOnKeyTest): TEntryArray;
    function  ExtractIf(aTest: TNestKeyTest): TEntryArray;
    procedure RetainAll(aCollection: IKeyCollection);
    function  Keys: TKeys; inline;
    function  Values: TValues; inline;
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
  { reading will raise ELGMapError if an aKey is not present in map }
    property  Items[const aKey: TKey]: TValue read GetValue write AddOrSetValue; default;
    property  LoadFactor: Single read GetLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGCustomHashMap.TKeyEnumerable }

function TGCustomHashMap.TKeyEnumerable.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Key;
end;

constructor TGCustomHashMap.TKeyEnumerable.Create(aMap: TCustomHashMap);
begin
  inherited Create(aMap);
  FEnum := aMap.FTable.GetEnumerator;
end;

destructor TGCustomHashMap.TKeyEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomHashMap.TKeyEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomHashMap.TKeyEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomHashMap.TValueEnumerable }

function TGCustomHashMap.TValueEnumerable.GetCurrent: TValue;
begin
  Result := FEnum.Current^.Value;
end;

constructor TGCustomHashMap.TValueEnumerable.Create(aMap: TCustomHashMap);
begin
  inherited Create(aMap);
  FEnum := aMap.FTable.GetEnumerator;
end;

destructor TGCustomHashMap.TValueEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomHashMap.TValueEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomHashMap.TValueEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomHashMap.TEntryEnumerable }

function TGCustomHashMap.TEntryEnumerable.GetCurrent: TEntry;
begin
  Result := FEnum.Current^;
end;

constructor TGCustomHashMap.TEntryEnumerable.Create(aMap: TCustomHashMap);
begin
  inherited Create(aMap);
  FEnum := aMap.FTable.GetEnumerator;
end;

destructor TGCustomHashMap.TEntryEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomHashMap.TEntryEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomHashMap.TEntryEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomHashMap }

function TGCustomHashMap.GetCount: SizeInt;
begin
  Result := FTable.Count;
end;

function TGCustomHashMap.GetCapacity: SizeInt;
begin
  Result := FTable.Capacity;
end;

function TGCustomHashMap.GetFillRatio: Single;
begin
  Result := FTable.FillRatio;
end;

function TGCustomHashMap.GetLoadFactor: Single;
begin
  Result := FTable.LoadFactor;
end;

procedure TGCustomHashMap.SetLoadFactor(aValue: Single);
begin
  FTable.LoadFactor := aValue;
end;

function TGCustomHashMap.GetTableSize: SizeInt;
begin
  Result := FTable.TableSize;
end;

function TGCustomHashMap.Find(constref aKey: TKey): PEntry;
var
  sr: TSearchResult;
begin
  Result := FTable.Find(aKey, sr);
end;

function TGCustomHashMap.FindOrAdd(constref aKey: TKey; out p: PEntry): Boolean;
var
  sr: TSearchResult;
begin
  Result := FTable.FindOrAdd(aKey, p, sr);
  if not Result then
    p^.Key := aKey;
end;

function TGCustomHashMap.DoExtract(constref aKey: TKey; out v: TValue): Boolean;
var
  p: PEntry;
  sr: TSearchResult;
begin
  p := FTable.Find(aKey, sr);
  Result := p <> nil;
  if Result then
    begin
      v := p^.Value;
      FTable.RemoveAt(sr);
    end;
end;

function TGCustomHashMap.DoRemoveIf(aTest: TKeyTest): SizeInt;
begin
  Result := FTable.RemoveIf(aTest);
end;

function TGCustomHashMap.DoRemoveIf(aTest: TOnKeyTest): SizeInt;
begin
  Result := FTable.RemoveIf(aTest);
end;

function TGCustomHashMap.DoRemoveIf(aTest: TNestKeyTest): SizeInt;
begin
  Result := FTable.RemoveIf(aTest);
end;

function TGCustomHashMap.DoExtractIf(aTest: TKeyTest): TEntryArray;
var
  eh: TExtractHelper;
begin
  eh.Init;
  FTable.RemoveIf(aTest, @eh.OnExtract);
  Result := eh.Final;
end;

function TGCustomHashMap.DoExtractIf(aTest: TOnKeyTest): TEntryArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTable.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

function TGCustomHashMap.DoExtractIf(aTest: TNestKeyTest): TEntryArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTable.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

procedure TGCustomHashMap.DoClear;
begin
  FTable.Clear;
end;

procedure TGCustomHashMap.DoEnsureCapacity(aValue: SizeInt);
begin
  FTable.EnsureCapacity(aValue);
end;

procedure TGCustomHashMap.DoTrimToFit;
begin
  FTable.TrimToFit;
end;

function TGCustomHashMap.GetKeys: IKeyEnumerable;
begin
  Result := TKeyEnumerable.Create(Self);
end;

function TGCustomHashMap.GetValues: IValueEnumerable;
begin
  Result := TValueEnumerable.Create(Self);
end;

function TGCustomHashMap.GetEntries: IEntryEnumerable;
begin
  Result := TEntryEnumerable.Create(Self);
end;

class function TGCustomHashMap.DefaultLoadFactor: Single;
begin
  Result := GetTableClass.DefaultLoadFactor;
end;

class function TGCustomHashMap.MaxLoadFactor: Single;
begin
  Result := GetTableClass.MaxLoadFactor;
end;

class function TGCustomHashMap.MinLoadFactor: Single;
begin
  Result := GetTableClass.MinLoadFactor;
end;

constructor TGCustomHashMap.Create;
begin
  FTable := GetTableClass.Create;
end;

constructor TGCustomHashMap.Create(constref a: array of TEntry);
begin
  FTable := GetTableClass.Create;
  DoAddAll(a);
end;

constructor TGCustomHashMap.Create(e: IEntryEnumerable);
begin
  FTable := GetTableClass.Create;
  DoAddAll(e);
end;

constructor TGCustomHashMap.Create(aCapacity: SizeInt);
begin
  FTable := GetTableClass.Create(aCapacity);
end;

constructor TGCustomHashMap.Create(aCapacity: SizeInt; constref a: array of TEntry);
begin
  FTable := GetTableClass.Create(aCapacity);
  DoAddAll(a);
end;

constructor TGCustomHashMap.Create(aCapacity: SizeInt; e: IEntryEnumerable);
begin
  FTable := GetTableClass.Create(aCapacity);
  DoAddAll(e);
end;

constructor TGCustomHashMap.Create(aLoadFactor: Double);
begin
  FTable := GetTableClass.Create(aLoadFactor);
end;

constructor TGCustomHashMap.Create(aLoadFactor: Single; constref a: array of TEntry);
begin
  FTable := GetTableClass.Create(aLoadFactor);
  DoAddAll(a);
end;

constructor TGCustomHashMap.Create(aLoadFactor: Single; e: IEntryEnumerable);
begin
  FTable := GetTableClass.Create(aLoadFactor);
  DoAddAll(e);
end;

constructor TGCustomHashMap.Create(aCapacity: SizeInt; aLoadFactor: Single);
begin
  FTable := GetTableClass.Create(aCapacity, aLoadFactor);
end;

constructor TGCustomHashMap.Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of TEntry);
begin
  FTable := GetTableClass.Create(aCapacity, aLoadFactor);
  DoAddAll(a);
end;

constructor TGCustomHashMap.Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEntryEnumerable);
begin
  FTable := GetTableClass.Create(aCapacity, aLoadFactor);
  DoAddAll(e);
end;

constructor TGCustomHashMap.CreateCopy(aMap: TCustomHashMap);
begin
  inherited Create;
  if aMap.GetClass = GetClass then
    FTable := aMap.FTable.Clone
  else
    begin
      FTable := GetTableClass.Create(aMap.Count);
      DoAddAll(aMap.Entries);
    end;
end;

destructor TGCustomHashMap.Destroy;
begin
  DoClear;
  FTable.Free;
  inherited;
end;

function TGCustomHashMap.Clone: TCustomHashMap;
begin
  Result := GetClass.CreateCopy(Self);
end;

{ TGBaseHashMapLP }

class function TGBaseHashMapLP.GetTableClass: THashTableClass;
begin
  Result := specialize TGOpenAddrLP<TKey, TEntry, TKeyEqRel>;
end;

class function TGBaseHashMapLP.GetClass: THashMapClass;
begin
  Result := TGBaseHashMapLP;
end;

{ TGBaseHashMapLPT }

function TGBaseHashMapLPT.GetTombstonesCount: SizeInt;
begin
  Result := TTableLPT(FTable).TombstonesCount;
end;

class function TGBaseHashMapLPT.GetTableClass: THashTableClass;
begin
  Result := TTableLPT;
end;

class function TGBaseHashMapLPT.GetClass: THashMapClass;
begin
  Result := TGBaseHashMapLPT;
end;

procedure TGBaseHashMapLPT.ClearTombstones;
begin
  TTableLPT(FTable).ClearTombstones;
end;

{ TGBaseHashMapQP }

function TGBaseHashMapQP.GetTombstonesCount: SizeInt;
begin
  Result := TTableQP(FTable).TombstonesCount;
end;

class function TGBaseHashMapQP.GetTableClass: THashTableClass;
begin
  Result := TTableQP;
end;

class function TGBaseHashMapQP.GetClass: THashMapClass;
begin
  Result := TGBaseHashMapQP;
end;

procedure TGBaseHashMapQP.ClearTombstones;
begin
  TTableQP(FTable).ClearTombstones;
end;

{ TGBaseChainHashMap }

class function TGBaseChainHashMap.GetTableClass: THashTableClass;
begin
  Result := specialize TGChainHashTable<TKey, TEntry, TKeyEqRel>;
end;

class function TGBaseChainHashMap.GetClass: THashMapClass;
begin
  Result := TGBaseChainHashMap;
end;

{ TGChainHashMap }

function TGChainHashMap.Clone: TGChainHashMap;
begin
  Result := TGChainHashMap(inherited Clone);
end;

{ TGCustomObjectHashMap }

procedure TGCustomObjectHashMap.EntryRemoving(p: PEntry);
begin
  if OwnsKeys then
    TObject(p^.Key).Free;
  if OwnsValues then
    TObject(p^.Value).Free;
end;

procedure TGCustomObjectHashMap.SetOwnership(aOwns: TMapObjOwnership);
begin
  OwnsKeys := moOwnsKeys in aOwns;
  OwnsValues := moOwnsValues in aOwns;
end;

function TGCustomObjectHashMap.DoRemove(constref aKey: TKey): Boolean;
var
  v: TValue;
begin
  Result := DoExtract(aKey, v);
  if Result then
    begin
      if OwnsKeys then
        TObject(aKey).Free;
      if OwnsValues then
        TObject(v).Free;
    end;
end;

function TGCustomObjectHashMap.DoRemoveIf(aTest: TKeyTest): SizeInt;
begin
  Result := FTable.RemoveIf(aTest, @EntryRemoving);
end;

function TGCustomObjectHashMap.DoRemoveIf(aTest: TOnKeyTest): SizeInt;
begin
  Result := FTable.RemoveIf(aTest, @EntryRemoving);
end;

function TGCustomObjectHashMap.DoRemoveIf(aTest: TNestKeyTest): SizeInt;
begin
  Result := FTable.RemoveIf(aTest, @EntryRemoving);
end;

procedure TGCustomObjectHashMap.DoClear;
var
  p: PEntry;
begin
  if OwnsKeys or OwnsValues then
    for p in FTable do
      begin
        if OwnsKeys then
          TObject(p^.Key).Free;
        if OwnsValues then
          TObject(p^.Value).Free;
      end;
  inherited;
end;

function TGCustomObjectHashMap.DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean;
var
  p: PEntry;
begin
  p := Find(aKey);
  Result := p <> nil;
  if Result then
    begin
      if OwnsValues and not TObject.Equal(TObject(p^.Value), TObject(aNewValue)) then
        TObject(p^.Value).Free;
      p^.Value := aNewValue;
    end;
end;

function TGCustomObjectHashMap.DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean;
var
  p: PEntry;
begin
  Result := not FindOrAdd(aKey, p);
  if not Result then
    begin
      if OwnsValues and not TObject.Equal(TObject(p^.Value), TObject(aValue)) then
        TObject(p^.Value).Free;
    end;
  p^.Value := aValue;
end;

constructor TGCustomObjectHashMap.Create(aOwns: TMapObjOwnership);
begin
  inherited Create;
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(constref a: array of TEntry; aOwns: TMapObjOwnership);
begin
  inherited Create(a);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(e: IEntryEnumerable; aOwns: TMapObjOwnership);
begin
  inherited Create(e);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(aCapacity: SizeInt; aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(aCapacity: SizeInt; constref a: array of TEntry;
  aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity, a);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(aCapacity: SizeInt; e: IEntryEnumerable; aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity, e);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(aLoadFactor: Single; aOwns: TMapObjOwnership);
begin
  inherited Create(aLoadFactor);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(aLoadFactor: Single; constref a: array of TEntry;
  aOwns: TMapObjOwnership);
begin
  inherited Create(aLoadFactor, a);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(aLoadFactor: Single; e: IEntryEnumerable; aOwns: TMapObjOwnership);
begin
  inherited Create(aLoadFactor, e);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(aCapacity: SizeInt; aLoadFactor: Single; aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity, aLoadFactor);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of TEntry;
  aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity, aLoadFactor, a);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEntryEnumerable;
  aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity, aLoadFactor, e);
  SetOwnership(aOwns);
end;

constructor TGCustomObjectHashMap.CreateCopy(aMap: TGCustomObjectHashMap);
begin
  inherited CreateCopy(aMap);
  OwnsKeys := aMap.OwnsKeys;
  OwnsValues := aMap.OwnsValues;
end;

{ TGObjectHashMapLP }

class function TGObjectHashMapLP.GetTableClass: THashTableClass;
begin
  Result := specialize TGOpenAddrLP<TKey, TEntry, TKeyEqRel>;
end;

class function TGObjectHashMapLP.GetClass: TObjectHashMapClass;
begin
  Result := TGObjectHashMapLP;
end;

function TGObjectHashMapLP.Clone: TGObjectHashMapLP;
begin
  Result := TGObjectHashMapLP.CreateCopy(Self);
end;

{ TGObjectHashMapLPT }

function TGObjectHashMapLPT.GetTombstonesCount: SizeInt;
begin
  Result := TTableLPT(FTable).TombstonesCount;
end;

class function TGObjectHashMapLPT.GetTableClass: THashTableClass;
begin
  Result := TTableLPT;
end;

class function TGObjectHashMapLPT.GetClass: TObjectHashMapClass;
begin
  Result := TGObjectHashMapLPT;
end;

function TGObjectHashMapLPT.Clone: TGObjectHashMapLPT;
begin
  Result := TGObjectHashMapLPT.CreateCopy(Self);
end;

procedure TGObjectHashMapLPT.ClearTombstones;
begin
  TTableLPT(FTable).ClearTombstones;
end;

{ TGObjectHashMapQP }

function TGObjectHashMapQP.GetTombstonesCount: SizeInt;
begin
  Result := TTableQP(FTable).TombstonesCount;
end;

class function TGObjectHashMapQP.GetTableClass: THashTableClass;
begin
  Result := TTableQP;
end;

class function TGObjectHashMapQP.GetClass: TObjectHashMapClass;
begin
  Result := TGObjectHashMapQP;
end;

function TGObjectHashMapQP.Clone: TGObjectHashMapQP;
begin
  Result := TGObjectHashMapQP.CreateCopy(Self);
end;

procedure TGObjectHashMapQP.ClearTombstones;
begin
  TTableQP(FTable).ClearTombstones;
end;

{ TGObjectChainHashMap }

class function TGObjectChainHashMap.GetTableClass: THashTableClass;
begin
  Result := specialize TGChainHashTable<TKey, TEntry, TKeyEqRel>;
end;

class function TGObjectChainHashMap.GetClass: TObjectHashMapClass;
begin
  Result := TGObjectChainHashMap;
end;

function TGObjectChainHashMap.Clone: TGObjectChainHashMap;
begin
  Result := TGObjectChainHashMap.CreateCopy(Self);
end;

{ TGLiteHashMapLP.TKeyEnumerator }

function TGLiteHashMapLP.TKeyEnumerator.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Key;
end;

procedure TGLiteHashMapLP.TKeyEnumerator.Init(constref aMap: TGLiteHashMapLP);
begin
  FEnum := aMap.FTable.GetEnumerator;
end;

function TGLiteHashMapLP.TKeyEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGLiteHashMapLP.TKeyEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGLiteHashMapLP.TValueEnumerator }

function TGLiteHashMapLP.TValueEnumerator.GetCurrent: TValue;
begin
  Result := FEnum.Current^.Value;
end;

procedure TGLiteHashMapLP.TValueEnumerator.Init(constref aMap: TGLiteHashMapLP);
begin
  FEnum := aMap.FTable.GetEnumerator;
end;

function TGLiteHashMapLP.TValueEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGLiteHashMapLP.TValueEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGLiteHashMapLP.TEntryEnumerator }

function TGLiteHashMapLP.TEntryEnumerator.GetCurrent: TEntry;
begin
  Result := FEnum.Current^;
end;

procedure TGLiteHashMapLP.TEntryEnumerator.Init(constref aMap: TGLiteHashMapLP);
begin
  FEnum := aMap.FTable.GetEnumerator;
end;

function TGLiteHashMapLP.TEntryEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGLiteHashMapLP.TEntryEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGLiteHashMapLP.TKeys }

procedure TGLiteHashMapLP.TKeys.Init(aMap: PLiteHashMapLP);
begin
  FMap := aMap;
end;

function TGLiteHashMapLP.TKeys.GetEnumerator: TKeyEnumerator;
begin
  Result := FMap^.GetKeyEnumerator;
end;

{ TGLiteHashMapLP.TValues }

procedure TGLiteHashMapLP.TValues.Init(aMap: PLiteHashMapLP);
begin
  FMap := aMap;
end;

function TGLiteHashMapLP.TValues.GetEnumerator: TValueEnumerator;
begin
  Result := FMap^.GetValueEnumerator;
end;

{ TGLiteHashMapLP }

function TGLiteHashMapLP.GetCount: SizeInt;
begin
  Result := FTable.Count;
end;

function TGLiteHashMapLP.GetCapacity: SizeInt;
begin
  Result := FTable.Capacity;
end;

function TGLiteHashMapLP.Find(constref aKey: TKey): PEntry;
var
  Pos: SizeInt;
begin
  Result := FTable.Find(aKey, Pos);
end;

function TGLiteHashMapLP.FindOrAdd(constref aKey: TKey; out p: PEntry): Boolean;
var
  Pos: SizeInt;
begin
  Result := FTable.FindOrAdd(aKey, p, Pos);
  if not Result then
    p^.Key := aKey;
end;

function TGLiteHashMapLP.GetFillRatio: Single;
begin
  Result := FTable.FillRatio;
end;

function TGLiteHashMapLP.GetLoadFactor: Single;
begin
  Result := FTable.LoadFactor;
end;

function TGLiteHashMapLP.GetTableSize: SizeInt;
begin
  Result := FTable.Size;
end;

function TGLiteHashMapLP.GetValue(const aKey: TKey): TValue;
begin
  if not TryGetValue(aKey, Result) then
    raise ELGMapError.Create(SEKeyNotFound);
end;

procedure TGLiteHashMapLP.SetLoadFactor(aValue: Single);
begin
  FTable.LoadFactor := aValue;
end;

function TGLiteHashMapLP.SetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean;
var
  p: PEntry;
begin
  p := Find(aKey);
  Result := p <> nil;
  if Result then
    p^.Value := aNewValue;
end;

function TGLiteHashMapLP.GetKeyEnumerator: TKeyEnumerator;
begin
  Result.Init(Self);
end;

function TGLiteHashMapLP.GetValueEnumerator: TValueEnumerator;
begin
  Result.Init(Self);
end;

function TGLiteHashMapLP.DefaultLoadFactor: Single;
begin
  Result := FTable.DEFAULT_LOAD_FACTOR;
end;

function TGLiteHashMapLP.MaxLoadFactor: Single;
begin
  Result := FTable.MAX_LOAD_FACTOR;
end;

function TGLiteHashMapLP.MinLoadFactor: Single;
begin
  Result := FTable.MIN_LOAD_FACTOR;
end;

function TGLiteHashMapLP.GetEnumerator: TEntryEnumerator;
begin
  Result.Init(Self);
end;

function TGLiteHashMapLP.ToArray: TEntryArray;
var
  I: SizeInt = 0;
  p: PEntry;
begin
  System.SetLength(Result, Count);
  for p in FTable do
    begin
      Result[I] := p^;
      Inc(I);
    end;
end;

function TGLiteHashMapLP.IsEmpty: Boolean;
begin
  Result := FTable.Count = 0;
end;

function TGLiteHashMapLP.NonEmpty: Boolean;
begin
  Result := FTable.Count <> 0;
end;

procedure TGLiteHashMapLP.Clear;
begin
  FTable.Clear;
end;

procedure TGLiteHashMapLP.EnsureCapacity(aValue: SizeInt);
begin
  FTable.EnsureCapacity(aValue);
end;

procedure TGLiteHashMapLP.TrimToFit;
begin
  FTable.TrimToFit;
end;

function TGLiteHashMapLP.TryGetValue(constref aKey: TKey; out aValue: TValue): Boolean;
var
  p: PEntry;
begin
  p := Find(aKey);
  Result := p <> nil;
  if Result then
    aValue := p^.Value;
end;

function TGLiteHashMapLP.GetValueDef(constref aKey: TKey; constref aDefault: TValue): TValue;
begin
  if not TryGetValue(aKey, Result) then
    Result := aDefault;
end;

function TGLiteHashMapLP.Add(constref aKey: TKey; constref aValue: TValue): Boolean;
var
  p: PEntry;
begin
  Result := not FindOrAdd(aKey, p);
  if Result then
    p^.Value := aValue;
end;

function TGLiteHashMapLP.Add(constref e: TEntry): Boolean;
begin
  Result := Add(e.Key, e.Value);
end;

procedure TGLiteHashMapLP.AddOrSetValue(const aKey: TKey; const aValue: TValue);
var
  p: PEntry;
begin
  FindOrAdd(aKey, p);
  p^.Value := aValue;
end;

function TGLiteHashMapLP.AddOrSetValue(constref e: TEntry): Boolean;
var
  p: PEntry;
begin
  Result := not FindOrAdd(e.Key, p);
  p^.Value := e.Value;
end;

function TGLiteHashMapLP.AddAll(constref a: array of TEntry): SizeInt;
var
  e: TEntry;
begin
  Result := 0;
  for e in a do
    Result += Ord(Add(e));
end;

function TGLiteHashMapLP.AddAll(e: IEntryEnumerable): SizeInt;
var
  Entry: TEntry;
begin
  Result := 0;
  for Entry in e do
    Result += Ord(Add(Entry));
end;

function TGLiteHashMapLP.Replace(constref aKey: TKey; constref aNewValue: TValue): Boolean;
begin
  Result := SetValue(aKey, aNewValue);
end;

function TGLiteHashMapLP.Contains(constref aKey: TKey): Boolean;
begin
  Result := Find(aKey) <> nil;
end;

function TGLiteHashMapLP.ContainsAny(constref a: array of TKey): Boolean;
var
  k: TKey;
begin
  for k in a do
  if Contains(k) then
    exit(True);
  Result := False;
end;

function TGLiteHashMapLP.ContainsAny(e: IKeyEnumerable): Boolean;
var
  k: TKey;
begin
  for k in e do
  if Contains(k) then
    exit(True);
  Result := False;
end;

function TGLiteHashMapLP.ContainsAll(constref a: array of TKey): Boolean;
var
  k: TKey;
begin
  for k in a do
  if not Contains(k) then
    exit(False);
  Result := True;
end;

function TGLiteHashMapLP.ContainsAll(e: IKeyEnumerable): Boolean;
var
  k: TKey;
begin
  for k in e do
  if not Contains(k) then
    exit(False);
  Result := True;
end;

function TGLiteHashMapLP.Remove(constref aKey: TKey): Boolean;
begin
  Result := FTable.Remove(aKey);
end;

function TGLiteHashMapLP.RemoveAll(constref a: array of TKey): SizeInt;
var
  k: TKey;
begin
  Result := 0;
  for k in a do
    Result += Ord(Remove(k));
end;

function TGLiteHashMapLP.RemoveAll(e: IKeyEnumerable): SizeInt;
var
  k: TKey;
begin
  Result := 0;
  for k in e do
    Result += Ord(Remove(k));
end;
{$PUSH}{$MACRO ON}
function TGLiteHashMapLP.RemoveIf(aTest: TKeyTest): SizeInt;
begin
{$DEFINE RemoveIfMacro :=
  Result := 0;
  with FTable.RemovableEnumerator do
    while MoveNext do
      if aTest(Current^.Key) then
        begin
          RemoveCurrent;
          Inc(Result);
        end}
  RemoveIfMacro;
end;

function TGLiteHashMapLP.RemoveIf(aTest: TOnKeyTest): SizeInt;
begin
  RemoveIfMacro;
end;

function TGLiteHashMapLP.RemoveIf(aTest: TNestKeyTest): SizeInt;
begin
  RemoveIfMacro;
end;

function TGLiteHashMapLP.Extract(constref aKey: TKey; out v: TValue): Boolean;
var
  p: PEntry;
  Pos: SizeInt;
begin
  p := FTable.Find(aKey, Pos);
  Result := p <> nil;
  if Result then
    begin
      v := p^.Value;
      FTable.RemoveAt(Pos);
    end;
end;

function TGLiteHashMapLP.ExtractIf(aTest: TKeyTest): TEntryArray;
var
  I: SizeInt = 0;
  e: TEntry;
begin
{$DEFINE ExtractIfMacro :=
  System.SetLength(Result, ARRAY_INITIAL_SIZE);
  with FTable.RemovableEnumerator do
    while MoveNext do
      begin
        e := Current^;
        if aTest(e.Key) then
          begin
            RemoveCurrent;
            if I = System.Length(Result) then
              System.SetLength(Result, I shl 1);
            Result[I] := e;
            Inc(I);
          end;
      end;
  System.SetLength(Result, I)}
  ExtractIfMacro;
end;

function TGLiteHashMapLP.ExtractIf(aTest: TOnKeyTest): TEntryArray;
var
  I: SizeInt = 0;
  e: TEntry;
begin
  ExtractIfMacro;
end;

function TGLiteHashMapLP.ExtractIf(aTest: TNestKeyTest): TEntryArray;
var
  I: SizeInt = 0;
  e: TEntry;
begin
  ExtractIfMacro;
end;
{$POP}

procedure TGLiteHashMapLP.RetainAll(aCollection: IKeyCollection);
begin
  with FTable.RemovableEnumerator do
    while MoveNext do
      if aCollection.NonContains(Current^.Key) then
        RemoveCurrent;
end;

function TGLiteHashMapLP.Keys: TKeys;
begin
  Result.Init(@Self);
end;

function TGLiteHashMapLP.Values: TValues;
begin
  Result.Init(@Self);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic hash multiset implementations.                                  *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGHashMultiSet;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH NESTEDPROCVARS}
{$MODESWITCH ADVANCEDRECORDS}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGHashTable,
  LGStrConst;

type

  { TGCustomHashMultiSet: common abstract ancestor hash multiset class }
  generic TGCustomHashMultiSet<T> = class abstract(specialize TGCustomMultiSet<T>)
  public
  type
    TCustomHashMultiSet = specialize TGCustomHashMultiSet<T>;

  protected
  type
    THashTable          = specialize TGCustomHashTable<T, TEntry>;
    THashTableClass     = class of THashTable;
    THashMultiSetClass  = class of TCustomHashMultiSet;
    TSearchResult       = THashTable.TSearchResult;

    TEnumerator = class(TContainerEnumerator)
    protected
      FEnum: THashTable.TEntryEnumerator;
      FCurrKeyCount: SizeInt;
      function  GetCurrent: T; override;
    public
      constructor Create(ms: TCustomHashMultiSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TDistinctEnumerable = class(TContainerEnumerable)
    protected
      FEnum: THashTable.TEntryEnumerator;
      function  GetCurrent: T; override;
    public
      constructor Create(aSet: TCustomHashMultiSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TEntryEnumerable = class(specialize TGAutoEnumerable<TEntry>)
    protected
      FOwner: TCustomHashMultiSet;
      FEnum: THashTable.TEntryEnumerator;
      function  GetCurrent: TEntry; override;
    public
      constructor Create(aSet: TCustomHashMultiSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FTable: THashTable;
    procedure EntryRemoved(p: PEntry);
    function  GetFillRatio: Single; inline;
    function  GetLoadFactor: Single; inline;
    procedure SetLoadFactor(aValue: Single); inline;
    function  GetTableSize: SizeInt; inline;
  { The capacity of the hash multiset is treated as the number of entries that can be written without rehashing }
    function  GetCapacity: SizeInt; override;
    function  DoGetEnumerator: TCustomEnumerator; override;
    procedure DoClear; override;
    procedure DoTrimToFit; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    function  FindEntry(constref aKey: T): PEntry; override;
    function  FindOrAdd(constref aKey: T; out p: PEntry): Boolean; override;
    function  DoSubEntry(constref e: TEntry): Boolean; override;
    function  DoSymmSubEntry(constref e: TEntry): Boolean; override;
    function  DoExtract(constref aKey: T): Boolean; override;
    function  GetEntryCount: SizeInt; override;
    function  DoDoubleEntryCounters: SizeInt; override;
    function  GetDistinct: IEnumerable; override;  // distinct keys
    function  GetEntries: IEntryEnumerable; override;
    procedure DoIntersect(aSet: TCustomMultiSet); override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
    function  DoExtractIf(aTest: TTest): TArray; override;
    function  DoExtractIf(aTest: TOnTest): TArray; override;
    function  DoExtractIf(aTest: TNestTest): TArray; override;
    class function GetTableClass: THashTableClass; virtual; abstract;
    class function GetClass: THashMultiSetClass; virtual; abstract;
  public
    class function DefaultLoadFactor: Single; inline;
    class function MaxLoadFactor: Single; inline;
    class function MinLoadFactor: Single; inline;
    constructor Create;
    constructor Create(constref a: array of T);
    constructor Create(e: IEnumerable);
    constructor Create(aCapacity: SizeInt);
    constructor Create(aCapacity: SizeInt; constref a: array of T);
    constructor Create(aCapacity: SizeInt; e: IEnumerable);
    constructor Create(aLoadFactor: Single);
    constructor Create(aLoadFactor: Single; constref a: array of T);
    constructor Create(aLoadFactor: Single; e: IEnumerable);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable);
    constructor CreateCopy(aMultiSet: TCustomHashMultiSet);
    destructor Destroy; override;
    function  Clone: TCustomHashMultiSet; override;
    property  LoadFactor: Single read GetLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  end;

  { TGBaseHashMultiSetLP implements open addressing hash multiset with linear probing;
      functor TEqRel(equality relation) must provide:
        class function HashCode([const[ref]] aValue: T): SizeInt;
        class function Equal([const[ref]] L, R: T): Boolean; }
  generic TGBaseHashMultiSetLP<T, TEqRel> = class(specialize TGCustomHashMultiSet<T>)
  protected
    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMultiSetClass; override;
  end;

  { TGHashMultiSetLP implements open addressing hash multiset with linear probing;
    it assumes that type T implements TEqRel }
  generic TGHashMultiSetLP<T> = class(specialize TGBaseHashMultiSetLP<T, T>);

  { TGBaseHashMultiSetLPT implements open addressing hash multiset with linear probing and lazy deletion }
  generic TGBaseHashMultiSetLPT<T, TEqRel> = class(specialize TGCustomHashMultiSet<T>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    THashTableLPT = specialize TGOpenAddrLPT<T, TEntry, TEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMultiSetClass; override;
  public
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGHashMultiSetLPT implements open addressing hash multiset with linear probing and lazy deletion;
    it assumes that type T implements TEqRel }
  generic TGHashMultiSetLPT<T> = class(specialize TGBaseHashMultiSetLPT<T, T>);

  { TGBaseHashMultiSetQP implements open addressing hashmultiset with quadratic probing(c1 = c2 = 1/2) }
  generic TGBaseHashMultiSetQP<T, TEqRel> = class(specialize TGCustomHashMultiSet<T>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    THashTableQP = specialize TGOpenAddrQP<T, TEntry, TEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMultiSetClass; override;
  public
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGHashMultiSetQP implements open addressing hashmultiset with quadratic probing(c1 = c2 = 1/2);
    it assumes that type T implements TEqRel }
  generic TGHashMultiSetQP<T> = class(specialize TGBaseHashMultiSetQP<T, T>);

  { TGBaseChainHashMultiSet implements node based hashset with singly linked list chains }
  generic TGBaseChainHashMultiSet<T, TEqRel> = class(specialize TGCustomHashMultiSet<T>)
  protected
    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMultiSetClass; override;
  end;

  { TGChainHashMultiSet implements node based hashset with singly linked list chains;
    it assumes that type T implements TEqRel }
  generic TGChainHashMultiSet<T> = class(specialize TGBaseChainHashMultiSet<T, T>);

  { TGCustomObjectHashMultiSet }

  generic TGCustomObjectHashMultiSet<T: class> = class abstract(specialize TGCustomHashMultiSet<T>)
  private
    FOwnsObjects: Boolean;
  protected
  type
    TObjectHashMultiSetClass = class of TGCustomObjectHashMultiSet;

    function  DoSubEntry(constref e: TEntry): Boolean; override;
    function  DoSymmSubEntry(constref e: TEntry): Boolean; override;
    function  DoRemove(constref aKey: T): Boolean; override;
    procedure DoClear; override;
    procedure EntryRemoved(p: PEntry);
    procedure DoIntersect(aSet: TCustomMultiSet); override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aLoadFactor: Single; aOwnsObjects: Boolean = True);
    constructor Create(aLoadFactor: Single; constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(aLoadFactor: Single; e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor CreateCopy(aMultiSet: TGCustomObjectHashMultiSet);
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGObjectHashMultiSetLP }

  generic TGObjectHashMultiSetLP<T: class; TEqRel> = class(specialize TGCustomObjectHashMultiSet<T>)
  protected
    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMultiSetClass; override;
  public
    function Clone: TGObjectHashMultiSetLP; override;
  end;

  generic TGObjHashMultiSetLP<T: class> = class(specialize TGObjectHashMultiSetLP<T, T>);

  { TGObjectHashMultiSetLPT }

  generic TGObjectHashMultiSetLPT<T: class; TEqRel> = class(specialize TGCustomObjectHashMultiSet<T>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    THashTableLPT = specialize TGOpenAddrLPT<T, TEntry, TEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMultiSetClass; override;
  public
    function  Clone: TGObjectHashMultiSetLPT; override;
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  generic TGObjHashMultiSetLPT<T: class> = class(specialize TGObjectHashMultiSetLPT<T, T>);

  { TGObjectHashMultiSetQP }

  generic TGObjectHashMultiSetQP<T: class; TEqRel> = class(specialize TGCustomObjectHashMultiSet<T>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    THashTableQP = specialize TGOpenAddrQP<T, TEntry, TEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMultiSetClass; override;
  public
    function  Clone: TGObjectHashMultiSetQP; override;
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  generic TGObjHashMultiSetQP<T: class> = class(specialize TGObjectHashMultiSetQP<T, T>);

  { TGObjectChainHashMultiSet }

  generic TGObjectChainHashMultiSet<T: class; TEqRel> = class(specialize TGCustomObjectHashMultiSet<T>)
  protected
    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashMultiSetClass; override;
  public
    function Clone: TGObjectChainHashMultiSet; override;
  end;

  generic TGObjChainHashMultiSet<T: class> = class(specialize TGObjectChainHashMultiSet<T, T>);

  { TGLiteHashMultiSetLP implements open addressing hash multiset with linear probing;
      functor TEqRel(equality relation) must provide:
        class function HashCode([const[ref]] aValue: T): SizeInt;
        class function Equal([const[ref]] L, R: T): Boolean; }
  generic TGLiteHashMultiSetLP<T, TEqRel> = record
  public
  type
    TEntry      = specialize TGMultiSetEntry<T>;
    IEnumerable = specialize IGEnumerable<T>;
    ICollection = specialize IGCollection<T>;
    TTest       = specialize TGTest<T>;
    TOnTest     = specialize TGOnTest<T>;
    TNestTest   = specialize TGNestTest<T>;
    TArray      = array of T;
    TEntryArray = array of TEntry;

  private
  type
    TTableLP  = specialize TGLiteHashTableLP<T, TEntry, TEqRel>;
    PMultiSet = ^TGLiteHashMultiSetLP;
    PEntry    = ^TEntry;

  public
  type
    TEnumerator = record
    private
      FEnum: TTableLP.TEnumerator;
      FCurrKeyCount: SizeInt;
      function  GetCurrent: T; inline;
      procedure Init(constref aSet: TGLiteHashMultiSetLP); inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

    TDistinctEnumerator = record
    private
      FEnum: TTableLP.TEnumerator;
      function  GetCurrent: T; inline;
      procedure Init(constref aSet: TGLiteHashMultiSetLP); inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

    TEntryEnumerator = record
    private
      FEnum: TTableLP.TEnumerator;
      function  GetCurrent: TEntry; inline;
      procedure Init(constref aSet: TGLiteHashMultiSetLP); inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: TEntry read GetCurrent;
    end;

    TDistinct = record
    private
      FMultiset: PMultiSet;
      procedure Init(aSet: PMultiSet); inline;
    public
      function GetEnumerator: TDistinctEnumerator;
    end;

    TEntries = record
    private
      FMultiset: PMultiSet;
      procedure Init(aSet: PMultiSet); inline;
    public
      function GetEnumerator: TEntryEnumerator;
    end;

  private
    FTable: TTableLP;
    FCount: SizeInt;
    function  GetCapacity: SizeInt; inline;
    function  GetEntryCount: SizeInt; inline;
    function  GetFillRatio: Single; inline;
    function  GetLoadFactor: Single; inline;
    function  GetTableSize: SizeInt; inline;
    procedure SetLoadFactor(aValue: Single); inline;
    function  GetDistinctEnumerator: TDistinctEnumerator; inline;
    function  GetEntryEnumerator: TEntryEnumerator; inline;
    function  Find(constref aKey: T): PEntry; inline;
    //return True if aKey found, otherwise inserts entry (garbage) and return False;
    function  FindOrAdd(constref aKey: T; out p: PEntry): Boolean;
    function  GetKeyCount(const aKey: T): SizeInt;
    procedure SetKeyCount(const aKey: T; aValue: SizeInt);
    class operator Initialize(var ms: TGLiteHashMultiSetLP);
  public
    function  DefaultLoadFactor: Single; inline;
    function  MaxLoadFactor: Single; inline;
    function  MinLoadFactor: Single; inline;
    function  GetEnumerator: TEnumerator; inline;
    function  ToArray: TArray;
    function  ToEntryArray: TEntryArray;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure Clear;
    procedure TrimToFit; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    function  Contains(constref aValue: T): Boolean; inline;
    function  NonContains(constref aValue: T): Boolean; inline;
    function  ContainsAny(constref a: array of T): Boolean;
    function  ContainsAny(e: IEnumerable): Boolean;
    function  ContainsAll(constref a: array of T): Boolean;
    function  ContainsAll(e: IEnumerable): Boolean;
    procedure Add(constref aValue: T);
  { returns count of added elements }
    function  AddAll(constref a: array of T): SizeInt;
    function  AddAll(e: IEnumerable): SizeInt;
  { returns True if element removed }
    function  Remove(constref aValue: T): Boolean; inline;
  { returns count of removed elements }
    function  RemoveIf(aTest: TTest): SizeInt;
    function  RemoveIf(aTest: TOnTest): SizeInt;
    function  RemoveIf(aTest: TNestTest): SizeInt;
  { returns True if element extracted }
    function  Extract(constref aValue: T): Boolean;
    function  ExtractIf(aTest: TTest): TArray;
    function  ExtractIf(aTest: TOnTest): TArray;
    function  ExtractIf(aTest: TNestTest): TArray;
  { will contain only those elements that are simultaneously contained in self and aCollection }
    procedure RetainAll(aCollection: ICollection);
  { returns True if multiplicity of an any key in self is greater then or equal to
    the multiplicity of that key in aSet }
    function  IsSuperMultiSet(aSet: TGLiteHashMultiSetLP): Boolean;
  { returns True if multiplicity of an any key in aSet is greater then or equal to
    the multiplicity of that key in self }
    function  IsSubMultiSet(aSet: TGLiteHashMultiSetLP): Boolean;
  { returns True if the multiplicity of an any key in self is equal to the multiplicity of that key in aSet }
    function  IsEqual(aSet: TGLiteHashMultiSetLP): Boolean;
    function  Intersecting(aSet: TGLiteHashMultiSetLP): Boolean;
  { will contain only those keys that are simultaneously contained in self and in aSet;
    the multiplicity of a key becomes equal to the MINIMUM of the multiplicities of a key in self and aSet }
    procedure Intersect(aSet: TGLiteHashMultiSetLP);
  { will contain all keys that are contained in self and in aSet;
    the multiplicity of a key will become equal to the MAXIMUM of the multiplicities of
    a key in self and aSet }
    procedure Join(aSet: TGLiteHashMultiSetLP);
  { will contain all keys that are contained in self or in aSet;
    the multiplicity of a key will become equal to the SUM of the multiplicities of a key in self and aSet }
    procedure ArithmeticAdd(aSet: TGLiteHashMultiSetLP);
  { will contain only those keys whose multiplicity is greater then the multiplicity
    of that key in aSet; the multiplicity of a key will become equal to the difference of multiplicities
    of a key in self and aSet }
    procedure ArithmeticSubtract(aSet: TGLiteHashMultiSetLP);
  { will contain only those keys whose multiplicity is not equal to the multiplicity
    of that key in aSet; the multiplicity of a key will become equal to absolute value of difference
    of the multiplicities of a key in self and aSet }
    procedure SymmetricSubtract(aSet: TGLiteHashMultiSetLP);
    //function  Distinct: TDistinct; inline;
    //function  Entries: TEntries; inline;
    property  Count: SizeInt read FCount;
  { returs number of distinct keys }
    property  EntryCount: SizeInt read GetEntryCount; //dimension, Count - cardinality
    property  Capacity: SizeInt read GetCapacity;
    property  LoadFactor: Single read GetLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  { will return 0 if not contains an element aValue;
    will raise EArgumentException if one try to set negative multiplicity of a aValue }
    property  Counts[const aValue: T]: SizeInt read GetKeyCount write SetKeyCount; default;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGCustomHashMultiSet.TEnumerator }

function TGCustomHashMultiSet.TEnumerator.GetCurrent: T;
begin
  Result := FEnum.Current^.Key;
end;

constructor TGCustomHashMultiSet.TEnumerator.Create(ms: TCustomHashMultiSet);
begin
  inherited Create(ms);
  FEnum := ms.FTable.GetEnumerator;
end;

destructor TGCustomHashMultiSet.TEnumerator.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomHashMultiSet.TEnumerator.MoveNext: Boolean;
begin
  Result := FCurrKeyCount > 0;
  FCurrKeyCount -= Ord(Result);
  if not Result then
    begin
      Result := FEnum.MoveNext;
      if Result then
        FCurrKeyCount := Pred(FEnum.Current^.Count);
    end;
end;

procedure TGCustomHashMultiSet.TEnumerator.Reset;
begin
  FEnum.Reset;
  FCurrKeyCount := 0;
end;

{ TGCustomHashMultiSet.TDistinctEnumerable }

function TGCustomHashMultiSet.TDistinctEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Key;
end;

constructor TGCustomHashMultiSet.TDistinctEnumerable.Create(aSet: TCustomHashMultiSet);
begin
  inherited Create(aSet);
  FEnum := aSet.FTable.GetEnumerator;
end;

destructor TGCustomHashMultiSet.TDistinctEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomHashMultiSet.TDistinctEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomHashMultiSet.TDistinctEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomHashMultiSet.TEntryEnumerable }

function TGCustomHashMultiSet.TEntryEnumerable.GetCurrent: TEntry;
begin
  Result := FEnum.Current^;
end;

constructor TGCustomHashMultiSet.TEntryEnumerable.Create(aSet: TCustomHashMultiSet);
begin
  inherited Create;
  FOwner := aSet;
  FEnum := aSet.FTable.GetEnumerator;
end;

destructor TGCustomHashMultiSet.TEntryEnumerable.Destroy;
begin
  FEnum.Free;
  FOwner.EndIteration;
  inherited;
end;

function TGCustomHashMultiSet.TEntryEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomHashMultiSet.TEntryEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomHashMultiSet }

procedure TGCustomHashMultiSet.EntryRemoved(p: PEntry);
begin
  FCount -= p^.Count;
end;

function TGCustomHashMultiSet.GetFillRatio: Single;
begin
  Result := FTable.FillRatio;
end;

function TGCustomHashMultiSet.GetLoadFactor: Single;
begin
  Result := FTable.LoadFactor;
end;

procedure TGCustomHashMultiSet.SetLoadFactor(aValue: Single);
begin
  FTable.LoadFactor := aValue;
end;

function TGCustomHashMultiSet.GetTableSize: SizeInt;
begin
  Result := FTable.TableSize;
end;

function TGCustomHashMultiSet.GetCapacity: SizeInt;
begin
  Result := FTable.Capacity;
end;

function TGCustomHashMultiSet.DoGetEnumerator: TCustomEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

procedure TGCustomHashMultiSet.DoClear;
begin
  FTable.Clear;
  FCount := 0;
end;

procedure TGCustomHashMultiSet.DoTrimToFit;
begin
  FTable.TrimToFit;
end;

procedure TGCustomHashMultiSet.DoEnsureCapacity(aValue: SizeInt);
begin
  FTable.EnsureCapacity(aValue);
end;

function TGCustomHashMultiSet.FindEntry(constref aKey: T): PEntry;
var
  sr: TSearchResult;
begin
  Result := FTable.Find(aKey, sr);
end;

function TGCustomHashMultiSet.FindOrAdd(constref aKey: T; out p: PEntry): Boolean;
var
  sr: TSearchResult;
begin
  Result := FTable.FindOrAdd(aKey, p, sr);
  if not Result then
    begin
      p^.Key := aKey;
      p^.Count := 1;
    end;
end;

function TGCustomHashMultiSet.DoSubEntry(constref e: TEntry): Boolean;
var
  p: PEntry;
  sr: TSearchResult;
begin
  p := FTable.Find(e.Key, sr);
  if p <> nil then
    begin
      if p^.Count > e.Count then
        begin
          FCount -= e.Count;
          p^.Count -= e.Count;
        end
      else
        begin
          FCount -= p^.Count;
          FTable.RemoveAt(sr);
          exit(True);
        end;
    end;
  Result := False;
end;

function TGCustomHashMultiSet.DoSymmSubEntry(constref e: TEntry): Boolean;
var
  sr: TSearchResult;
  p: PEntry;
begin
  if FTable.FindOrAdd(e.Key, p, sr) then
    begin
      if p^.Count > e.Count then
        begin
          FCount -= e.Count;
          p^.Count -= e.Count;
        end
      else
        if p^.Count < e.Count then
          begin
           {$PUSH}{$Q+}
            FCount -= p^.Count shl 1 - e.Count;
           {$POP}
            p^.Count := e.Count - p^.Count;
          end
        else  // counts equals
          begin
            FCount -= p^.Count;
            FTable.RemoveAt(sr);
            exit(True);
          end;
    end
  else
    begin
      p^.Key := e.Key;
      p^.Count := e.Count;
      {$PUSH}{$Q+}
      FCount += e.Count;
      {$POP}
    end;
  Result := False;
end;

function TGCustomHashMultiSet.DoExtract(constref aKey: T): Boolean;
var
  p: PEntry;
  sr: TSearchResult;
begin
  p := FTable.Find(aKey, sr);
  Result := p <> nil;
  if Result then
    begin
      Dec(p^.Count);
      Dec(FCount);
      if p^.Count = 0 then
        FTable.RemoveAt(sr);
    end;
end;

function TGCustomHashMultiSet.GetEntryCount: SizeInt;
begin
  Result := FTable.Count;
end;

function TGCustomHashMultiSet.DoDoubleEntryCounters: SizeInt;
var
  p: PEntry;
begin
  Result := ElemCount;
{$PUSH}{$Q+}
  FCount += ElemCount;
{$POP}
  with FTable.GetEnumerator do
    try
      while MoveNext do
        begin
          p := Current;
          p^.Count += p^.Count;
        end;
    finally
      Free;
    end;
end;

function TGCustomHashMultiSet.GetDistinct: IEnumerable;
begin
  Result := TDistinctEnumerable.Create(Self);
end;

function TGCustomHashMultiSet.GetEntries: IEntryEnumerable;
begin
  Result := TEntryEnumerable.Create(Self);
end;

procedure TGCustomHashMultiSet.DoIntersect(aSet: TCustomMultiSet);
var
  I{%H-}: TIntersectHelper;
begin
  I.FSet := Self;
  I.FOtherSet := aSet;
  FTable.RemoveIf(@I.OnIntersect, @EntryRemoved);
end;

function TGCustomHashMultiSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  Result := ElemCount;
  FTable.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGCustomHashMultiSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  Result := ElemCount;
  FTable.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGCustomHashMultiSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  Result := ElemCount;
  FTable.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGCustomHashMultiSet.DoExtractIf(aTest: TTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTable.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
  FCount -= System.Length(Result);
end;

function TGCustomHashMultiSet.DoExtractIf(aTest: TOnTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTable.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
  FCount -= System.Length(Result);
end;

function TGCustomHashMultiSet.DoExtractIf(aTest: TNestTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTable.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
  FCount -= System.Length(Result);
end;

class function TGCustomHashMultiSet.DefaultLoadFactor: Single;
begin
  Result := GetTableClass.DefaultLoadFactor;
end;

class function TGCustomHashMultiSet.MaxLoadFactor: Single;
begin
  Result := GetTableClass.MaxLoadFactor;
end;

class function TGCustomHashMultiSet.MinLoadFactor: Single;
begin
  Result := GetTableClass.MinLoadFactor;
end;

constructor TGCustomHashMultiSet.Create;
begin
  FTable := GetTableClass.Create;
end;

constructor TGCustomHashMultiSet.Create(constref a: array of T);
begin
  FTable := GetTableClass.Create;
  DoAddAll(a);
end;

constructor TGCustomHashMultiSet.Create(e: IEnumerable);
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TCustomHashMultiSet then
    CreateCopy(TCustomHashMultiSet(o))
  else
    begin
      if o is TCustomMultiSet then
        Create(TCustomMultiSet(o).EntryCount)
      else
        Create;
      DoAddAll(e);
    end;
end;

constructor TGCustomHashMultiSet.Create(aCapacity: SizeInt);
begin
  FTable := GetTableClass.Create(aCapacity);
end;

constructor TGCustomHashMultiSet.Create(aCapacity: SizeInt; constref a: array of T);
begin
  FTable := GetTableClass.Create(aCapacity);
  DoAddAll(a);
end;

constructor TGCustomHashMultiSet.Create(aCapacity: SizeInt; e: IEnumerable);
begin
  FTable := GetTableClass.Create(aCapacity);
  DoAddAll(e);
end;

constructor TGCustomHashMultiSet.Create(aLoadFactor: Single);
begin
  FTable := GetTableClass.Create(aLoadFactor);
end;

constructor TGCustomHashMultiSet.Create(aLoadFactor: Single; constref a: array of T);
begin
  FTable := GetTableClass.Create(aLoadFactor);
  DoAddAll(a);
end;

constructor TGCustomHashMultiSet.Create(aLoadFactor: Single; e: IEnumerable);
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TCustomMultiSet then
    Create(TCustomMultiSet(o).EntryCount, aLoadFactor)
  else
    Create(aLoadFactor);
  DoAddAll(e);
end;

constructor TGCustomHashMultiSet.Create(aCapacity: SizeInt; aLoadFactor: Single);
begin
  FTable := GetTableClass.Create(aCapacity, aLoadFactor);
end;

constructor TGCustomHashMultiSet.Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T);
begin
  FTable := GetTableClass.Create(aCapacity, aLoadFactor);
  DoAddAll(a);
end;

constructor TGCustomHashMultiSet.Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable);
begin
  FTable := GetTableClass.Create(aCapacity, aLoadFactor);
  DoAddAll(e);
end;

constructor TGCustomHashMultiSet.CreateCopy(aMultiSet: TCustomHashMultiSet);
var
  e: TEntry;
begin
  if aMultiSet.GetClass = GetClass then
    begin
      FTable := aMultiSet.FTable.Clone;
      FCount := aMultiSet.Count;
    end
  else
    begin
      FTable := GetTableClass.Create(aMultiSet.EntryCount);
      for e in aMultiSet.Entries do
        DoAddEntry(e);
    end;
end;

destructor TGCustomHashMultiSet.Destroy;
begin
  DoClear;
  FTable.Free;
  inherited;
end;

function TGCustomHashMultiSet.Clone: TCustomHashMultiSet;
begin
  Result := GetClass.Create(Self);
end;

{ TGBaseHashMultiSetLP }

class function TGBaseHashMultiSetLP.GetTableClass: THashTableClass;
begin
  Result := specialize TGOpenAddrLP<T, TEntry, TEqRel>;
end;

class function TGBaseHashMultiSetLP.GetClass: THashMultiSetClass;
begin
  Result := TGBaseHashMultiSetLP;
end;

{ TGBaseHashMultiSetLPT }

function TGBaseHashMultiSetLPT.GetTombstonesCount: SizeInt;
begin
  Result := THashTableLPT(FTable).TombstonesCount;
end;

class function TGBaseHashMultiSetLPT.GetTableClass: THashTableClass;
begin
  Result := THashTableLPT;
end;

class function TGBaseHashMultiSetLPT.GetClass: THashMultiSetClass;
begin
  Result := TGBaseHashMultiSetLPT;
end;

procedure TGBaseHashMultiSetLPT.ClearTombstones;
begin
  THashTableLPT(FTable).ClearTombstones;
end;

{ TGBaseHashMultiSetQP }

function TGBaseHashMultiSetQP.GetTombstonesCount: SizeInt;
begin
  Result := THashTableQP(FTable).TombstonesCount;
end;

class function TGBaseHashMultiSetQP.GetTableClass: THashTableClass;
begin
  Result := THashTableQP;
end;

class function TGBaseHashMultiSetQP.GetClass: THashMultiSetClass;
begin
  Result := TGBaseHashMultiSetQP;
end;

procedure TGBaseHashMultiSetQP.ClearTombstones;
begin
  THashTableQP(FTable).ClearTombstones;
end;

{ TGBaseChainHashMultiSet }

class function TGBaseChainHashMultiSet.GetTableClass: THashTableClass;
begin
 Result := specialize TGChainHashTable<T, TEntry, TEqRel>;
end;

class function TGBaseChainHashMultiSet.GetClass: THashMultiSetClass;
begin
  Result := TGBaseChainHashMultiSet;
end;

{ TGCustomObjectHashMultiSet }

function TGCustomObjectHashMultiSet.DoSubEntry(constref e: TEntry): Boolean;
begin
  Result := inherited DoSubEntry(e);
  if Result and OwnsObjects then
    e.Key.Free;
end;

function TGCustomObjectHashMultiSet.DoSymmSubEntry(constref e: TEntry): Boolean;
begin
  Result := inherited DoSymmSubEntry(e);
  if Result and OwnsObjects then
    e.Key.Free;
end;

function TGCustomObjectHashMultiSet.DoRemove(constref aKey: T): Boolean;
var
  p: PEntry;
  ItemPos: TSearchResult;
begin
  p := FTable.Find(aKey, ItemPos);
  Result := p <> nil;
  if Result then
    begin
      Dec(p^.Count);
      Dec(FCount);
      if p^.Count = 0 then
        begin
          FTable.RemoveAt(ItemPos);
          if OwnsObjects then
            aKey.Free;
        end;
    end;
end;

procedure TGCustomObjectHashMultiSet.DoClear;
var
  p: PEntry;
begin
  if OwnsObjects then
    for p in FTable do
      p^.Key.Free;
  inherited;
end;

procedure TGCustomObjectHashMultiSet.EntryRemoved(p: PEntry);
begin
  FCount -= p^.Count;
  if OwnsObjects then
    p^.Key.Free;
end;

procedure TGCustomObjectHashMultiSet.DoIntersect(aSet: TCustomMultiSet);
var
  {%H-}I: TIntersectHelper;
begin
  I.FSet := Self;
  I.FOtherSet := aSet;
  FTable.RemoveIf(@I.OnIntersect, @EntryRemoved);
end;

function TGCustomObjectHashMultiSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  Result := ElemCount;
  FTable.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGCustomObjectHashMultiSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  Result := ElemCount;
  FTable.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGCustomObjectHashMultiSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  Result := ElemCount;
  FTable.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

constructor TGCustomObjectHashMultiSet.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(a);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(e);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(aCapacity: SizeInt; constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, a);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(aCapacity: SizeInt; e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, e);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(aLoadFactor: Single; aOwnsObjects: Boolean);
begin
  inherited Create(aLoadFactor);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(aLoadFactor: Single; constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(aLoadFactor, a);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(aLoadFactor: Single; e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(aLoadFactor, e);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(aCapacity: SizeInt; aLoadFactor: Single; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aLoadFactor);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T;
  aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aLoadFactor, a);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable;
  aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aLoadFactor, e);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashMultiSet.CreateCopy(aMultiSet: TGCustomObjectHashMultiSet);
begin
  inherited CreateCopy(aMultiSet);
  FOwnsObjects := aMultiSet.OwnsObjects;
end;

{ TGObjectHashMultiSetLP }

class function TGObjectHashMultiSetLP.GetTableClass: THashTableClass;
begin
  Result := specialize TGOpenAddrLP<T, TEntry, TEqRel>;
end;

class function TGObjectHashMultiSetLP.GetClass: THashMultiSetClass;
begin
  Result := TGObjectHashMultiSetLP;
end;

function TGObjectHashMultiSetLP.Clone: TGObjectHashMultiSetLP;
begin
  Result := TGObjectHashMultiSetLP.CreateCopy(Self);
end;

{ TGObjectHashMultiSetLPT }

function TGObjectHashMultiSetLPT.GetTombstonesCount: SizeInt;
begin
  Result := THashTableLPT(FTable).TombstonesCount;
end;

class function TGObjectHashMultiSetLPT.GetTableClass: THashTableClass;
begin
  Result := THashTableLPT;
end;

class function TGObjectHashMultiSetLPT.GetClass: THashMultiSetClass;
begin
  Result := TGObjectHashMultiSetLPT;
end;

function TGObjectHashMultiSetLPT.Clone: TGObjectHashMultiSetLPT;
begin
  Result := TGObjectHashMultiSetLPT.CreateCopy(Self);
end;

procedure TGObjectHashMultiSetLPT.ClearTombstones;
begin
  THashTableLPT(FTable).ClearTombstones;
end;

{ TGObjectHashMultiSetQP }

function TGObjectHashMultiSetQP.GetTombstonesCount: SizeInt;
begin
  Result := THashTableQP(FTable).TombstonesCount;
end;

class function TGObjectHashMultiSetQP.GetTableClass: THashTableClass;
begin
  Result := THashTableQP;
end;

class function TGObjectHashMultiSetQP.GetClass: THashMultiSetClass;
begin
  Result := TGObjectHashMultiSetQP;
end;

function TGObjectHashMultiSetQP.Clone: TGObjectHashMultiSetQP;
begin
  Result := TGObjectHashMultiSetQP.CreateCopy(Self);
end;

procedure TGObjectHashMultiSetQP.ClearTombstones;
begin
  THashTableQP(FTable).ClearTombstones;
end;

{ TGObjectChainHashMultiSet }

class function TGObjectChainHashMultiSet.GetTableClass: THashTableClass;
begin
  Result := specialize TGChainHashTable<T, TEntry, TEqRel>;
end;

class function TGObjectChainHashMultiSet.GetClass: THashMultiSetClass;
begin
  Result := TGObjectChainHashMultiSet;
end;

function TGObjectChainHashMultiSet.Clone: TGObjectChainHashMultiSet;
begin
  Result := TGObjectChainHashMultiSet.CreateCopy(Self);
end;

{ TGLiteHashMultiSetLP.TEnumerator }

function TGLiteHashMultiSetLP.TEnumerator.GetCurrent: T;
begin
  Result := FEnum.Current^.Key;
end;

procedure TGLiteHashMultiSetLP.TEnumerator.Init(constref aSet: TGLiteHashMultiSetLP);
begin
  FEnum := aSet.FTable.GetEnumerator;
  FCurrKeyCount := 0;
end;

function TGLiteHashMultiSetLP.TEnumerator.MoveNext: Boolean;
begin
  Result := FCurrKeyCount > 0;
  FCurrKeyCount -= Ord(Result);
  if not Result then
    begin
      Result := FEnum.MoveNext;
      if Result then
        FCurrKeyCount := Pred(FEnum.Current^.Count);
    end;
end;

procedure TGLiteHashMultiSetLP.TEnumerator.Reset;
begin
  FEnum.Reset;
  FCurrKeyCount := 0;
end;

{ TGLiteHashMultiSetLP.TDistinctEnumerator }

function TGLiteHashMultiSetLP.TDistinctEnumerator.GetCurrent: T;
begin
  Result := FEnum.Current^.Key;
end;

procedure TGLiteHashMultiSetLP.TDistinctEnumerator.Init(constref aSet: TGLiteHashMultiSetLP);
begin
  FEnum := aSet.FTable.GetEnumerator;
end;

function TGLiteHashMultiSetLP.TDistinctEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGLiteHashMultiSetLP.TDistinctEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGLiteHashMultiSetLP.TEntryEnumerator }

function TGLiteHashMultiSetLP.TEntryEnumerator.GetCurrent: TEntry;
begin
  Result := FEnum.Current^;
end;

procedure TGLiteHashMultiSetLP.TEntryEnumerator.Init(constref aSet: TGLiteHashMultiSetLP);
begin
  FEnum := aSet.FTable.GetEnumerator;
end;

function TGLiteHashMultiSetLP.TEntryEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGLiteHashMultiSetLP.TEntryEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGLiteHashMultiSetLP.TDistinct }

procedure TGLiteHashMultiSetLP.TDistinct.Init(aSet: PMultiSet);
begin
  FMultiset := aSet;
end;

function TGLiteHashMultiSetLP.TDistinct.GetEnumerator: TDistinctEnumerator;
begin
  FMultiset^.GetDistinctEnumerator;
end;

{ TGLiteHashMultiSetLP.TEntries }

procedure TGLiteHashMultiSetLP.TEntries.Init(aSet: PMultiSet);
begin
  FMultiset := aSet;
end;

function TGLiteHashMultiSetLP.TEntries.GetEnumerator: TEntryEnumerator;
begin
  FMultiset^.GetEntryEnumerator;
end;

{ TGLiteHashMultiSetLP }

function TGLiteHashMultiSetLP.GetEntryCount: SizeInt;
begin
  Result := FTable.Count;
end;

function TGLiteHashMultiSetLP.GetCapacity: SizeInt;
begin
  Result := FTable.Capacity;
end;

function TGLiteHashMultiSetLP.GetFillRatio: Single;
begin
  Result := FTable.FillRatio;
end;

function TGLiteHashMultiSetLP.GetLoadFactor: Single;
begin
  Result := FTable.LoadFactor;
end;

function TGLiteHashMultiSetLP.GetTableSize: SizeInt;
begin
  Result := FTable.Size;
end;

procedure TGLiteHashMultiSetLP.SetLoadFactor(aValue: Single);
begin
  FTable.LoadFactor := aValue;
end;

function TGLiteHashMultiSetLP.GetDistinctEnumerator: TDistinctEnumerator;
begin
  Result.Init(Self);
end;

function TGLiteHashMultiSetLP.GetEntryEnumerator: TEntryEnumerator;
begin
  Result.Init(Self);
end;

function TGLiteHashMultiSetLP.Find(constref aKey: T): PEntry;
var
  Pos: SizeInt;
begin
  Result := FTable.Find(aKey, Pos);
end;

function TGLiteHashMultiSetLP.FindOrAdd(constref aKey: T; out p: PEntry): Boolean;
var
  Pos: SizeInt;
begin
  Result := FTable.FindOrAdd(aKey, p, Pos);
  if not Result then
    begin
      p^.Key := aKey;
      p^.Count := 1;
    end;
end;

function TGLiteHashMultiSetLP.GetKeyCount(const aKey: T): SizeInt;
var
  p: PEntry;
begin
  p := Find(aKey);
  if p <> nil then
    Result := p^.Count
  else
    Result := 0;
end;

procedure TGLiteHashMultiSetLP.SetKeyCount(const aKey: T; aValue: SizeInt);
var
  p: PEntry;
  Pos: SizeInt;
begin
  if aValue < 0 then
    raise EArgumentException.Create(SECantAcceptNegCount);
  if aValue > 0 then
    begin
{$PUSH}{$Q+}
      if FindOrAdd(aKey, p) then
        begin
          FCount += aValue - p^.Count;
          p^.Count := aValue;
        end
      else
        begin
          FCount += aValue;
          p^.Count := aValue;
        end;
{$POP}
    end
  else
    begin  // aValue = 0;
      p := FTable.Find(aKey, Pos);
      if p <> nil then
        begin
          FCount -= p^.Count;
          FTable.RemoveAt(Pos);
        end;
    end;
end;

class operator TGLiteHashMultiSetLP.Initialize(var ms: TGLiteHashMultiSetLP);
begin
  ms.FCount := 0;
end;

function TGLiteHashMultiSetLP.DefaultLoadFactor: Single;
begin
  Result := FTable.DEFAULT_LOAD_FACTOR;
end;

function TGLiteHashMultiSetLP.MaxLoadFactor: Single;
begin
  Result := FTable.MAX_LOAD_FACTOR;
end;

function TGLiteHashMultiSetLP.MinLoadFactor: Single;
begin
  Result := FTable.MIN_LOAD_FACTOR;
end;

function TGLiteHashMultiSetLP.GetEnumerator: TEnumerator;
begin
  Result.Init(Self);
end;

function TGLiteHashMultiSetLP.ToArray: TArray;
var
  I: SizeInt = 0;
  v: T;
begin
  System.SetLength(Result, Count);
  for v in Self do
    begin
      Result[I] := v;
      Inc(I);
    end;
end;

function TGLiteHashMultiSetLP.ToEntryArray: TEntryArray;
var
  I: SizeInt = 0;
  p: PEntry;
begin
  System.SetLength(Result, EntryCount);
  for p in FTable do
    begin
      Result[I] := p^;
      Inc(I);
    end;
end;

function TGLiteHashMultiSetLP.IsEmpty: Boolean;
begin
  Result := Count = 0;
end;

function TGLiteHashMultiSetLP.NonEmpty: Boolean;
begin
  Result := Count <> 0;
end;

procedure TGLiteHashMultiSetLP.Clear;
begin
  FTable.Clear;
  FCount := 0;
end;

procedure TGLiteHashMultiSetLP.TrimToFit;
begin
  FTable.TrimToFit;
end;

procedure TGLiteHashMultiSetLP.EnsureCapacity(aValue: SizeInt);
begin
  FTable.EnsureCapacity(aValue);
end;

function TGLiteHashMultiSetLP.Contains(constref aValue: T): Boolean;
begin
  Result := Find(aValue) <> nil;
end;

function TGLiteHashMultiSetLP.NonContains(constref aValue: T): Boolean;
begin
  Result := Find(aValue) = nil;
end;

function TGLiteHashMultiSetLP.ContainsAny(constref a: array of T): Boolean;
var
  v: T;
begin
  for v in a do
    if Contains(v) then
      exit(True);
  Result := False;
end;

function TGLiteHashMultiSetLP.ContainsAny(e: IEnumerable): Boolean;
var
  v: T;
begin
  for v in e do
    if Contains(v) then
      exit(True);
  Result := False;
end;

function TGLiteHashMultiSetLP.ContainsAll(constref a: array of T): Boolean;
var
  v: T;
begin
  for v in a do
    if NonContains(v) then
      exit(False);
  Result := True;
end;

function TGLiteHashMultiSetLP.ContainsAll(e: IEnumerable): Boolean;
var
  v: T;
begin
  for v in e do
    if NonContains(v) then
      exit(False);
  Result := True;
end;

procedure TGLiteHashMultiSetLP.Add(constref aValue: T);
var
  p: PEntry;
begin
{$PUSH}{$Q+}
  Inc(FCount);
{$POP}
  if FindOrAdd(aValue, p) then
    Inc(p^.Count);
end;

function TGLiteHashMultiSetLP.AddAll(constref a: array of T): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in a do
    begin
      Add(v);
      Inc(Result);
    end;
end;

function TGLiteHashMultiSetLP.AddAll(e: IEnumerable): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in e do
    begin
      Add(v);
      Inc(Result);
    end;
end;

function TGLiteHashMultiSetLP.Remove(constref aValue: T): Boolean;
begin
  Result := Extract(aValue);
end;
{$PUSH}{$MACRO ON}
function TGLiteHashMultiSetLP.RemoveIf(aTest: TTest): SizeInt;
var
  p: PEntry;
begin
{$DEFINE RemoveIfMacro :=
  Result := 0;
  with FTable.RemovableEnumerator do
    while MoveNext do
      begin
        p := Current;
        if aTest(p^.Key) then
          begin
            FCount -= p^.Count;
            Result += p^.Count;
            RemoveCurrent;
          end
      end}
  RemoveIfMacro;
end;

function TGLiteHashMultiSetLP.RemoveIf(aTest: TOnTest): SizeInt;
var
  p: PEntry;
begin
  RemoveIfMacro;
end;

function TGLiteHashMultiSetLP.RemoveIf(aTest: TNestTest): SizeInt;
var
  p: PEntry;
begin
  RemoveIfMacro;
end;

function TGLiteHashMultiSetLP.Extract(constref aValue: T): Boolean;
var
  p: PEntry;
  Pos: SizeInt;
begin
  p := FTable.Find(aValue, Pos);
  Result := p <> nil;
  if Result then
    begin
      Dec(p^.Count);
      Dec(FCount);
      if p^.Count = 0 then
        FTable.RemoveAt(Pos);
    end;
end;

function TGLiteHashMultiSetLP.ExtractIf(aTest: TTest): TArray;
var
  I, Last: SizeInt;
  p: PEntry;
  v: T;
begin
{$DEFINE ExtractIfMacro :=
  System.SetLength(Result, ARRAY_INITIAL_SIZE);
  I := 0;
  with FTable.RemovableEnumerator do
    while MoveNext do
      begin
        p := Current;
        if aTest(p^.Key) then
          begin
            Last := Pred(I + p^.Count);
            FCount -= p^.Count;
            v := p^.Key;
            if Last >= System.Length(Result) then
                System.SetLength(Result, RoundUpTwoPower(Succ(Last)));
            for I := I to Last do
              Result[I] := v;
            RemoveCurrent;
            I := Succ(Last);
          end;
      end;
  System.SetLength(Result, I)}
  ExtractIfMacro;
end;

function TGLiteHashMultiSetLP.ExtractIf(aTest: TOnTest): TArray;
var
  I, Last: SizeInt;
  p: PEntry;
  v: T;
begin
  ExtractIfMacro;
end;

function TGLiteHashMultiSetLP.ExtractIf(aTest: TNestTest): TArray;
var
  I, Last: SizeInt;
  p: PEntry;
  v: T;
begin
  ExtractIfMacro;
end;
{$POP}

procedure TGLiteHashMultiSetLP.RetainAll(aCollection: ICollection);
begin
  RemoveIf(@aCollection.NonContains);
end;

function TGLiteHashMultiSetLP.IsSuperMultiSet(aSet: TGLiteHashMultiSetLP): Boolean;
var
  p: PEntry;
begin
  if @aSet <> @Self then
    begin
      if (Count >= aSet.Count) and (EntryCount >= aSet.EntryCount) then
        begin
          for p in aSet.FTable do
            if GetKeyCount(p^.Key) < p^.Count then
              exit(False);
          Result := True;
        end
      else
        Result := False;
    end
  else
    Result := True;
end;

function TGLiteHashMultiSetLP.IsSubMultiSet(aSet: TGLiteHashMultiSetLP): Boolean;
var
  p: PEntry;
begin
  if @aSet <> @Self then
    begin
      if (aSet.Count >= Count) and (aSet.EntryCount >= EntryCount) then
        begin
          for p in FTable do
            if aSet[p^.Key] < p^.Count then
              exit(False);
          Result := True;
        end
      else
        Result := False;
    end
  else
    Result := True;
end;

function TGLiteHashMultiSetLP.IsEqual(aSet: TGLiteHashMultiSetLP): Boolean;
var
  p: PEntry;
begin
  if @aSet <> @Self then
    begin
      if (aSet.Count = Count) and (aSet.EntryCount = EntryCount) then
        begin
          for p in FTable do
            if aSet[p^.Key] <> p^.Count then
              exit(False);
          Result := True;
        end
      else
        Result := False;
    end
  else
    Result := True;
end;

function TGLiteHashMultiSetLP.Intersecting(aSet: TGLiteHashMultiSetLP): Boolean;
var
  p: PEntry;
begin
  if @aSet <> @Self then
    begin
      for p in FTable do
        if aSet.Contains(p^.Key) then
          exit(True);
      Result := False;
    end
  else
    Result := True;
end;

procedure TGLiteHashMultiSetLP.Intersect(aSet: TGLiteHashMultiSetLP);
var
  cnt: SizeInt;
  p: PEntry;
begin
  if @aSet <> @Self then
    with FTable.RemovableEnumerator do
      while MoveNext do
        begin
          p := Current;
          cnt := aSet[p^.Key];
          if cnt <> 0 then
            begin
              if cnt < p^.Count then
                begin
                  FCount -= p^.Count - cnt;
                  p^.Count := cnt;
                end;
            end
          else
            begin
              FCount -= p^.Count;
              RemoveCurrent;
            end;
        end;
end;

procedure TGLiteHashMultiSetLP.Join(aSet: TGLiteHashMultiSetLP);
var
  p, ps: PEntry;
begin
{$PUSH}{$Q+}
  if @aSet <> @Self then
    for ps in aSet.FTable do
      if not FindOrAdd(ps^.Key, p) then
        begin
          p^.Count := ps^.Count;
          FCount += ps^.Count;
        end
      else
        if ps^.Count > p^.Count then
          begin
            FCount += ps^.Count - p^.Count;
            p^.Count := ps^.Count;
          end;
{$POP}
end;

procedure TGLiteHashMultiSetLP.ArithmeticAdd(aSet: TGLiteHashMultiSetLP);
var
  p, ps: PEntry;
begin
{$PUSH}{$Q+}
  if @aSet <> @Self then
    for ps in aSet.FTable do
      begin
        FCount += ps^.Count;
        if FindOrAdd(ps^.Key, p) then
          p^.Count += ps^.Count
        else
          begin
            p^.Key := ps^.Key;
            p^.Count := ps^.Count;
          end;
      end
  else
    begin
      FCount += FCount;
      for p in FTable do
        p^.Count += p^.Count;
    end;
{$POP}
end;

procedure TGLiteHashMultiSetLP.ArithmeticSubtract(aSet: TGLiteHashMultiSetLP);
var
  p, ps: PEntry;
  Pos: SizeInt;
begin
  if @aSet <> @Self then
    for ps in aSet.FTable do
      begin
        p := FTable.Find(ps^.Key, Pos);
        if p <> nil then
          begin
            if ps^.Count < p^.Count then
              begin
                FCount -= ps^.Count;
                p^.Count -= ps^.Count;
              end
            else
              begin
                FCount -= p^.Count;
                FTable.RemoveAt(Pos);
              end;
          end;
      end
  else
    Clear;
end;

procedure TGLiteHashMultiSetLP.SymmetricSubtract(aSet: TGLiteHashMultiSetLP);
var
  p, ps: PEntry;
  Pos: SizeInt;
begin
  if @aSet <> @Self then
    for ps in aSet.FTable do
      begin
        if FTable.FindOrAdd(ps^.Key, p, Pos) then
          begin
            if p^.Count > ps^.Count then
              begin
                FCount -= ps^.Count;
                p^.Count -= ps^.Count;
              end
            else
              if p^.Count < ps^.Count then
                begin
                 {$PUSH}{$Q+}
                  FCount -= p^.Count shl 1 - ps^.Count;
                 {$POP}
                  p^.Count := ps^.Count - p^.Count;
                end
              else  // counts equals
                begin
                  FCount -= p^.Count;
                  FTable.RemoveAt(Pos);
                end;
          end
        else
          begin
            p^.Key := ps^.Key;
            p^.Count := ps^.Count;
            {$PUSH}{$Q+}
            FCount += ps^.Count;
            {$POP}
          end;
      end
  else
    Clear;
end;

//function TGLiteHashMultiSetLP.Distinct: TDistinct;
//begin
//  Result.Init(@Self);
//end;
//
//function TGLiteHashMultiSetLP.Entries: TEntries;
//begin
//  Result.Init(@Self);
//end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic hashset implementations.                                        *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGHashSet;

{$MODE OBJFPC}{$H+}
{$INLINE ON}
{$MODESWITCH NESTEDPROCVARS}
{$MODESWITCH ADVANCEDRECORDS}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGHashTable;

type

  {TGCustomHashSet: common abstract ancestor hashset class }
  generic TGCustomHashSet<T> = class abstract(specialize TGCustomSet<T>)
  public
  type
    TCustomHashSet = specialize TGCustomHashSet<T>;

  protected
  type
    THashTable           = specialize TGCustomHashTable<T, TEntry>;
    THashTableClass      = class of THashTable;
    THashSetClass        = class of TCustomHashSet;
    TSearchResult        = THashTable.TSearchResult;

    TEnumerator = class(TContainerEnumerator)
    private
      FEnum: THashTable.TEntryEnumerator;
    protected
      function  GetCurrent: T; override;
    public
      constructor Create(hs: TCustomHashSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TDistinctEnumerable = class(specialize TGEnumCursor<T>)
    protected
      FSet: TCustomHashSet;
    public
      constructor Create(e: TCustomEnumerator; aSetClass: THashSetClass);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FTable: THashTable;
    function  GetCount: SizeInt; override;
  { The capacity of the hashset is treated as the number of elements that can be written without rehashing }
    function  GetCapacity: SizeInt; override;
    function  GetFillRatio: Single; inline;
    function  GetLoadFactor: Single; inline;
    procedure SetLoadFactor(aValue: Single); inline;
    function  GetTableSize: SizeInt; inline;
    function  DoGetEnumerator: TCustomEnumerator; override;
    procedure DoClear; override;
    procedure DoTrimToFit; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    function  DoAdd(constref aValue: T): Boolean; override;
    function  DoExtract(constref aValue: T): Boolean; override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
    function  DoExtractIf(aTest: TTest): TArray; override;
    function  DoExtractIf(aTest: TOnTest): TArray; override;
    function  DoExtractIf(aTest: TNestTest): TArray; override;
    class function GetClass: THashSetClass; virtual; abstract;
    class function GetTableClass: THashTableClass; virtual; abstract;
  public
    class function DefaultLoadFactor: Single; inline;
    class function MaxLoadFactor: Single; inline;
    class function MinLoadFactor: Single; inline;
    class function Distinct(a: TArray): IEnumerable; inline;
    class function Distinct(e: IEnumerable): IEnumerable; inline;
    constructor Create;
    constructor Create(constref a: array of T);
    constructor Create(e: IEnumerable);
    constructor Create(aCapacity: SizeInt);
    constructor Create(aCapacity: SizeInt; constref a: array of T);
    constructor Create(aCapacity: SizeInt; e: IEnumerable);
    constructor Create(aLoadFactor: Single);
    constructor Create(aLoadFactor: Single; constref a: array of T);
    constructor Create(aLoadFactor: Single; e: IEnumerable);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable);
    constructor CreateCopy(aSet: TCustomHashSet);
    destructor Destroy; override;
    function  Contains(constref aValue: T): Boolean; override;
    function  Clone: TCustomHashSet; override;
    property  LoadFactor: Single read GetLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  end;

  { TGBaseHashSetLP implements open addressing hashset with linear probing;
      functor TEqRel(equality relation) must provide:
        class function HashCode([const[ref]] aValue: T): SizeInt;
        class function Equal([const[ref]] L, R: T): Boolean; }
  generic TGBaseHashSetLP<T, TEqRel> = class(specialize TGCustomHashSet<T>)
  protected
    class function GetClass: THashSetClass; override;
    class function GetTableClass: THashTableClass; override;
  end;

  { TGHashSetLP implements open addressing hashset with linear probing;
    it assumes that type T implements TEqRel }
  generic TGHashSetLP<T> = class(specialize TGBaseHashSetLP<T, T>);

  { TGBaseHashSetLPT implements open addressing hashset with linear probing and lazy deletion }
  generic TGBaseHashSetLPT<T, TEqRel> = class(specialize TGCustomHashSet<T>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    THashTableLPT = specialize TGOpenAddrLPT<T, TEntry, TEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashSetClass; override;
  public
    procedure ClearTombstones;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGHashSetLPT implements open addressing hashset with linear probing and lazy deletion;
    it assumes that type T implements TEqRel }
  generic TGHashSetLPT<T> = class(specialize TGBaseHashSetLPT<T, T>);

  { TGBaseHashSetQP implements open addressing hashset with quadratic probing(c1 = c2 = 1/2) }
  generic TGBaseHashSetQP<T, TEqRel> = class(specialize TGCustomHashSet<T>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    THashTableQP = specialize TGOpenAddrQP<T, TEntry, TEqRel>;

    class function GetTableClass: THashTableClass; override;
    class function GetClass: THashSetClass; override;
  public
    procedure ClearTombstones;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGHashSetQP implements open addressing hashset with quadratic probing(c1 = c2 = 1/2);
    it assumes that type T implements TEqRel }
  generic TGHashSetQP<T> = class(specialize TGBaseHashSetQP<T, T>);

  { TGBaseOrderedHashSet implements node based hashset with predictable iteration order,
    which is the order in which elements were inserted into the set (insertion-order) }
  generic TGBaseOrderedHashSet<T, TEqRel> = class(specialize TGCustomHashSet<T>)
  protected
  type
    TOrderedHashTable = specialize TGOrderedHashTable<T, TEntry, TEqRel>;
    PNode             = TOrderedHashTable.PNode;

    TReverseEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TOrderedHashTable.TReverseEnumerator;
      function  GetCurrent: T; override;
    public
      constructor Create(aSet: TGBaseOrderedHashSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    class function GetClass: THashSetClass; override;
    class function GetTableClass: THashTableClass; override;
  public
    function Reverse: IEnumerable; override;
  end;

  { TGOrderedHashSet implements node based hashset with predictable iteration order,
    which is the order in which elements were inserted into the set(insertion-order);
    it assumes that type T implements TEqRel }
  generic TGOrderedHashSet<T> = class(specialize TGBaseOrderedHashSet<T, T>);

  { TGBaseChainHashSet implements node based hashset with singly linked list chains }
  generic TGBaseChainHashSet<T, TEqRel> = class(specialize TGCustomHashSet<T>)
  protected
    class function GetClass: THashSetClass; override;
    class function GetTableClass: THashTableClass; override;
  end;

  { TGChainHashSet implements node based hashset with singly linked list chains;
    it assumes that type T implements TEqRel }
  generic TGChainHashSet<T> = class(specialize TGBaseChainHashSet<T, T>);

  { TGCustomObjectHashSet }

  generic TGCustomObjectHashSet<T: class> = class abstract(specialize TGCustomHashSet<T>)
  private
    FOwnsObjects: Boolean;
  protected
    procedure EntryRemoving(p: PEntry);
    procedure DoClear; override;
    function  DoRemove(constref aValue: T): Boolean; override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aLoadFactor: Single; aOwnsObjects: Boolean = True);
    constructor Create(aLoadFactor: Single; constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(aLoadFactor: Single; e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor CreateCopy(aSet: TGCustomObjectHashSet);
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGObjectHashSetLP }

  generic TGObjectHashSetLP<T: class; TEqRel> = class(specialize TGCustomObjectHashSet<T>)
  protected
    class function GetClass: THashSetClass; override;
    class function GetTableClass: THashTableClass; override;
  public
    function  Clone: TGObjectHashSetLP; override;
  end;

 { TGObjHashSetLP assumes that type T implements TEqRel }
  generic TGObjHashSetLP<T: class> = class(specialize TGObjectHashSetLP<T, T>);

  { TGObjectHashSetLPT }

  generic TGObjectHashSetLPT<T: class; TEqRel> = class(specialize TGCustomObjectHashSet<T>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    THashTableLPT = specialize TGOpenAddrLPT<T, TEntry, TEqRel>;

    class function GetClass: THashSetClass; override;
    class function GetTableClass: THashTableClass; override;
  public
    function  Clone: TGObjectHashSetLPT; override;
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGObjHashSetLPT assumes that type T implements TEqRel }
  generic TGObjHashSetLPT<T: class> = class(specialize TGObjectHashSetLPT<T, T>);

  { TGObjectHashSetQP }

  generic TGObjectHashSetQP<T: class; TEqRel> = class(specialize TGCustomObjectHashSet<T>)
  private
    function GetTombstonesCount: SizeInt; inline;
  protected
  type
    THashTableQP = specialize TGOpenAddrQP<T, TEntry, TEqRel>;

    class function GetClass: THashSetClass; override;
    class function GetTableClass: THashTableClass; override;
  public
    function  Clone: TGObjectHashSetQP; override;
    procedure ClearTombstones; inline;
    property  TombstonesCount: SizeInt read GetTombstonesCount;
  end;

  { TGObjHashSetQP assumes that type T implements TEqRel }
  generic TGObjHashSetQP<T: class> = class(specialize TGObjectHashSetQP<T, T>);

  { TGObjectOrderedHashSet }

  generic TGObjectOrderedHashSet<T: class; TEqRel> = class(specialize TGBaseOrderedHashSet<T, TEqRel>)
  private
    FOwnsObjects: Boolean;
  protected
  type
    TObjectOrderedHashSet = TGObjectOrderedHashSet;

    procedure EntryRemoving(p: PEntry);
    procedure DoClear; override;
    function  DoRemove(constref aValue: T): Boolean; override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
    class function GetClass: THashSetClass; override;
    class function GetTableClass: THashTableClass; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aLoadFactor: Single; aOwnsObjects: Boolean = True);
    constructor Create(aLoadFactor: Single; constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(aLoadFactor: Single; e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor CreateCopy(aSet: TGObjectOrderedHashSet);
    function  Clone: TGObjectOrderedHashSet; override;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGObjOrderedHashSet assumes that type T implements TEqRel }
  generic TGObjOrderedHashSet<T: class> = class(specialize TGObjectOrderedHashSet<T, T>);

  { TGObjectChainHashSet }

  generic TGObjectChainHashSet<T: class; TEqRel> = class(specialize TGCustomObjectHashSet<T>)
  protected
    class function GetClass: THashSetClass; override;
    class function GetTableClass: THashTableClass; override;
  public
    function Clone: TGObjectChainHashSet; override;
  end;

  { TGObjChainHashSet assumes that type T implements TEqRel }
  generic TGObjChainHashSet<T: class> = class(specialize TGObjectChainHashSet<T, T>);

  { TGLiteHashSetLP implements open addressing hashset with linear probing;
      functor TEqRel(equality relation) must provide:
        class function HashCode([const[ref]] aValue: T): SizeInt;
        class function Equal([const[ref]] L, R: T): Boolean; }
  generic TGLiteHashSetLP<T, TEqRel> = record
  private
  type
    TEntry = record
      Key: T;
    end;
    PEntry = ^TEntry;

    TTableLP = specialize TGLiteHashTableLP<T, TEntry, TEqRel>;

  public
  type
    IEnumerable = specialize IGEnumerable<T>;
    ICollection = specialize IGCollection<T>;
    TTest       = specialize TGTest<T>;
    TOnTest     = specialize TGOnTest<T>;
    TNestTest   = specialize TGNestTest<T>;
    TArray      = array of T;

    TEnumerator = record
    private
      FEnum: TTableLP.TEnumerator;
      function  GetCurrent: T; inline;
      procedure Init(constref aSet: TGLiteHashSetLP); inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

  private
    FTable: TTableLP;
    function  GetCapacity: SizeInt; inline;
    function  GetCount: SizeInt; inline;
    function  GetFillRatio: Single; inline;
    function  GetLoadFactor: Single; inline;
    function  GetTableSize: SizeInt; inline;
    procedure SetLoadFactor(aValue: Single); inline;
  public
    function  DefaultLoadFactor: Single; inline;
    function  MaxLoadFactor: Single; inline;
    function  MinLoadFactor: Single; inline;
    function  GetEnumerator: TEnumerator; inline;
    function  ToArray: TArray;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure Clear; inline;
    procedure TrimToFit; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
  { returns True if element added }
    function  Add(constref aValue: T): Boolean;
  { returns count of added elements }
    function  AddAll(constref a: array of T): SizeInt;
    function  AddAll(e: IEnumerable): SizeInt;
    function  Contains(constref aValue: T): Boolean; inline;
    function  NonContains(constref aValue: T): Boolean; inline;
    function  ContainsAny(constref a: array of T): Boolean;
    function  ContainsAny(e: IEnumerable): Boolean;
    function  ContainsAll(constref a: array of T): Boolean;
    function  ContainsAll(e: IEnumerable): Boolean;
  { returns True if element removed }
    function  Remove(constref aValue: T): Boolean; inline;
  { returns count of removed elements }
    function  RemoveAll(constref a: array of T): SizeInt;
    function  RemoveAll(e: IEnumerable): SizeInt;
  { returns count of removed elements }
    function  RemoveIf(aTest: TTest): SizeInt;
    function  RemoveIf(aTest: TOnTest): SizeInt;
    function  RemoveIf(aTest: TNestTest): SizeInt;
  { returns True if element extracted }
    function  Extract(constref aValue: T): Boolean; inline;
    function  ExtractIf(aTest: TTest): TArray;
    function  ExtractIf(aTest: TOnTest): TArray;
    function  ExtractIf(aTest: TNestTest): TArray;
  { will contain only those elements that are simultaneously contained in self and aCollection }
    procedure RetainAll(aCollection: ICollection);
    function  IsSuperset(constref aSet: TGLiteHashSetLP): Boolean;
    function  IsSubset(constref aSet: TGLiteHashSetLP): Boolean; inline;
    function  IsEqual(constref aSet: TGLiteHashSetLP): Boolean;
    function  Intersecting(constref aSet: TGLiteHashSetLP): Boolean; inline;
    procedure Intersect(constref aSet: TGLiteHashSetLP);
    procedure Join(constref aSet: TGLiteHashSetLP);
    procedure Subtract(constref aSet: TGLiteHashSetLP);
    procedure SymmetricSubtract(constref aSet: TGLiteHashSetLP);
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
    property  LoadFactor: Single read GetLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGCustomHashSet.TEnumerator }

function TGCustomHashSet.TEnumerator.GetCurrent: T;
begin
  Result := FEnum.GetCurrent^.Key;
end;

constructor TGCustomHashSet.TEnumerator.Create(hs: TCustomHashSet);
begin
  inherited Create(hs);
  FEnum := hs.FTable.GetEnumerator;
end;

destructor TGCustomHashSet.TEnumerator.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomHashSet.TEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomHashSet.TEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomHashSet.TDistinctEnumerable }

constructor TGCustomHashSet.TDistinctEnumerable.Create(e: TCustomEnumerator; aSetClass: THashSetClass);
begin
  inherited Create(e);
  FSet := aSetClass.Create;
end;

destructor TGCustomHashSet.TDistinctEnumerable.Destroy;
begin
  FSet.Free;
  inherited;
end;

function TGCustomHashSet.TDistinctEnumerable.MoveNext: Boolean;
begin
  repeat
    if not inherited MoveNext then
      exit(False);
    Result := FSet.Add(Current);
  until Result;
end;

procedure TGCustomHashSet.TDistinctEnumerable.Reset;
begin
  inherited;
  FSet.Clear;
end;

{ TGCustomHashSet }

function TGCustomHashSet.GetCount: SizeInt;
begin
  Result := FTable.Count;
end;

function TGCustomHashSet.GetCapacity: SizeInt;
begin
  Result := FTable.Capacity;
end;

function TGCustomHashSet.GetFillRatio: Single;
begin
  Result := FTable.FillRatio;
end;

function TGCustomHashSet.GetLoadFactor: Single;
begin
  Result := FTable.LoadFactor;
end;

procedure TGCustomHashSet.SetLoadFactor(aValue: Single);
begin
  FTable.LoadFactor := aValue;
end;

function TGCustomHashSet.GetTableSize: SizeInt;
begin
  Result := FTable.TableSize;
end;

function TGCustomHashSet.DoGetEnumerator: TCustomEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

procedure TGCustomHashSet.DoClear;
begin
  FTable.Clear;
end;

procedure TGCustomHashSet.DoTrimToFit;
begin
  FTable.TrimToFit;
end;

procedure TGCustomHashSet.DoEnsureCapacity(aValue: SizeInt);
begin
  FTable.EnsureCapacity(aValue);
end;

function TGCustomHashSet.DoAdd(constref aValue: T): Boolean;
var
  p: PEntry;
  sr: TSearchResult;
begin
  Result := not FTable.FindOrAdd(aValue, p, sr);
  if Result then
    p^.Key := aValue;
end;

function TGCustomHashSet.DoExtract(constref aValue: T): Boolean;
begin
  Result := FTable.Remove(aValue);
end;

function TGCustomHashSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  Result := FTable.RemoveIf(aTest);
end;

function TGCustomHashSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  Result := FTable.RemoveIf(aTest);
end;

function TGCustomHashSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  Result := FTable.RemoveIf(aTest);
end;

function TGCustomHashSet.DoExtractIf(aTest: TTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTable.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

function TGCustomHashSet.DoExtractIf(aTest: TOnTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTable.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

function TGCustomHashSet.DoExtractIf(aTest: TNestTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTable.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

class function TGCustomHashSet.DefaultLoadFactor: Single;
begin
  Result := GetTableClass.DefaultLoadFactor;
end;

class function TGCustomHashSet.MaxLoadFactor: Single;
begin
  Result := GetTableClass.MaxLoadFactor;
end;

class function TGCustomHashSet.MinLoadFactor: Single;
begin
  Result := GetTableClass.MinLoadFactor;
end;

class function TGCustomHashSet.Distinct(a: TArray): IEnumerable;
begin
  Result := TDistinctEnumerable.Create(specialize TGArrayEnumerator<T>.Create(a), GetClass);
end;

class function TGCustomHashSet.Distinct(e: IEnumerable): IEnumerable;
begin
  Result := TDistinctEnumerable.Create(e.GetEnumerator, GetClass);
end;

constructor TGCustomHashSet.Create;
begin
  FTable := GetTableClass.Create;
end;

constructor TGCustomHashSet.Create(constref a: array of T);
begin
  FTable := GetTableClass.Create;
  DoAddAll(a);
end;

constructor TGCustomHashSet.Create(e: IEnumerable);
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TCustomHashSet then
    CreateCopy(TCustomHashSet(o))
  else
    begin
      if o is TCustomSet then
        Create(TCustomSet(o).Count)
      else
        Create;
      DoAddAll(e);
    end;
end;

constructor TGCustomHashSet.Create(aCapacity: SizeInt);
begin
  FTable := GetTableClass.Create(aCapacity);
end;

constructor TGCustomHashSet.Create(aCapacity: SizeInt; constref a: array of T);
begin
  FTable := GetTableClass.Create(aCapacity);
  DoAddAll(a);
end;

constructor TGCustomHashSet.Create(aCapacity: SizeInt; e: IEnumerable);
begin
  FTable := GetTableClass.Create(aCapacity);
  DoAddAll(e);
end;

constructor TGCustomHashSet.Create(aLoadFactor: Single);
begin
  FTable := GetTableClass.Create(aLoadFactor);
end;

constructor TGCustomHashSet.Create(aLoadFactor: Single; constref a: array of T);
begin
  FTable := GetTableClass.Create(aLoadFactor);
  DoAddAll(a);
end;

constructor TGCustomHashSet.Create(aLoadFactor: Single; e: IEnumerable);
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TCustomSet then
    Create(TCustomSet(o).Count, aLoadFactor)
  else
    Create(aLoadFactor);
  DoAddAll(e);
end;

constructor TGCustomHashSet.Create(aCapacity: SizeInt; aLoadFactor: Single);
begin
  FTable := GetTableClass.Create(aCapacity, aLoadFactor);
end;

constructor TGCustomHashSet.Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T);
begin
  FTable := GetTableClass.Create(aCapacity, aLoadFactor);
  DoAddAll(a);
end;

constructor TGCustomHashSet.Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable);
begin
  FTable := GetTableClass.Create(aCapacity, aLoadFactor);
  DoAddAll(e);
end;

constructor TGCustomHashSet.CreateCopy(aSet: TCustomHashSet);
begin
  if aSet.GetClass = GetClass then
    FTable := aSet.FTable.Clone
  else
    begin
      FTable := GetTableClass.Create(aSet.Count);
      DoAddAll(aSet);
    end;
end;

destructor TGCustomHashSet.Destroy;
begin
  DoClear;
  FTable.Free;
  inherited;
end;

function TGCustomHashSet.Contains(constref aValue: T): Boolean;
var
  sr: TSearchResult;
begin
  Result := FTable.Find(aValue, sr) <> nil;
end;

function TGCustomHashSet.Clone: TCustomHashSet;
begin
  Result := GetClass.CreateCopy(Self);
end;

{ TGBaseHashSetLP }

class function TGBaseHashSetLP.GetClass: THashSetClass;
begin
  Result := TGBaseHashSetLP;
end;

class function TGBaseHashSetLP.GetTableClass: THashTableClass;
begin
  Result := specialize TGOpenAddrLP<T, TEntry, TEqRel>;
end;

{ TGBaseHashSetLPT }

function TGBaseHashSetLPT.GetTombstonesCount: SizeInt;
begin
  Result :=  THashTableLPT(FTable).TombstonesCount;
end;

class function TGBaseHashSetLPT.GetTableClass: THashTableClass;
begin
  Result := THashTableLPT;
end;

class function TGBaseHashSetLPT.GetClass: THashSetClass;
begin
  Result := TGBaseHashSetLPT;
end;

procedure TGBaseHashSetLPT.ClearTombstones;
begin
  THashTableLPT(FTable).ClearTombstones;
end;

{ TGBaseHashSetQP }

function TGBaseHashSetQP.GetTombstonesCount: SizeInt;
begin
  Result := THashTableQP(FTable).TombstonesCount;
end;

class function TGBaseHashSetQP.GetTableClass: THashTableClass;
begin
  Result := THashTableQP;
end;

class function TGBaseHashSetQP.GetClass: THashSetClass;
begin
  Result := TGBaseHashSetQP;
end;

procedure TGBaseHashSetQP.ClearTombstones;
begin
  THashTableQP(FTable).ClearTombstones;
end;

{ TGBaseOrderedHashSet.TReverseEnumerable }

function TGBaseOrderedHashSet.TReverseEnumerable.GetCurrent: T;
begin
  Result := FEnum.GetCurrent^.Key;
end;

constructor TGBaseOrderedHashSet.TReverseEnumerable.Create(aSet: TGBaseOrderedHashSet);
begin
  inherited Create(aSet);
  FEnum := TOrderedHashTable(aSet.FTable).GetReverseEnumerator;
end;

destructor TGBaseOrderedHashSet.TReverseEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGBaseOrderedHashSet.TReverseEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGBaseOrderedHashSet.TReverseEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGBaseOrderedHashSet }

class function TGBaseOrderedHashSet.GetClass: THashSetClass;
begin
  Result := TGBaseOrderedHashSet;
end;

class function TGBaseOrderedHashSet.GetTableClass: THashTableClass;
begin
  Result := TOrderedHashTable;
end;

function TGBaseOrderedHashSet.Reverse: IEnumerable;
begin
  BeginIteration;
  Result := TReverseEnumerable.Create(Self);
end;

{ TGBaseChainHashSet }

class function TGBaseChainHashSet.GetClass: THashSetClass;
begin
  Result := TGBaseChainHashSet;
end;

class function TGBaseChainHashSet.GetTableClass: THashTableClass;
begin
  Result := specialize TGChainHashTable<T, TEntry, TEqRel>;
end;

{ TGCustomObjectHashSet }

procedure TGCustomObjectHashSet.EntryRemoving(p: PEntry);
begin
  p^.Key.Free;
end;

procedure TGCustomObjectHashSet.DoClear;
var
  e: PEntry;
begin
  if OwnsObjects then
    for e in FTable do
      e^.Key.Free;
  inherited;
end;

function TGCustomObjectHashSet.DoRemove(constref aValue: T): Boolean;
begin
  Result := inherited DoRemove(aValue);
  if Result and OwnsObjects then
    aValue.Free;
end;

function TGCustomObjectHashSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTable.RemoveIf(aTest, @EntryRemoving)
  else
    Result := FTable.RemoveIf(aTest);
end;

function TGCustomObjectHashSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTable.RemoveIf(aTest, @EntryRemoving)
  else
    Result := FTable.RemoveIf(aTest);
end;

function TGCustomObjectHashSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTable.RemoveIf(aTest, @EntryRemoving)
  else
    Result := FTable.RemoveIf(aTest);
end;

constructor TGCustomObjectHashSet.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(a);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(e);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(aCapacity: SizeInt; constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, a);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(aCapacity: SizeInt; e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, e);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(aLoadFactor: Single; aOwnsObjects: Boolean);
begin
  inherited Create(aLoadFactor);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(aLoadFactor: Single; constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(aLoadFactor, a);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(aLoadFactor: Single; e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(aLoadFactor, e);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(aCapacity: SizeInt; aLoadFactor: Single; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aLoadFactor);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T;
  aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aLoadFactor, a);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable;
  aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aLoadFactor, e);
  OwnsObjects := aOwnsObjects;
end;

constructor TGCustomObjectHashSet.CreateCopy(aSet: TGCustomObjectHashSet);
begin
  inherited CreateCopy(aSet);
  OwnsObjects := aSet.OwnsObjects;
end;

{ TGObjectHashSetLP }

class function TGObjectHashSetLP.GetClass: THashSetClass;
begin
  Result := TGObjectHashSetLP;
end;

class function TGObjectHashSetLP.GetTableClass: THashTableClass;
begin
  Result := specialize TGOpenAddrLP<T, TEntry, TEqRel>;
end;

function TGObjectHashSetLP.Clone: TGObjectHashSetLP;
begin
  Result := TGObjectHashSetLP.CreateCopy(Self);
end;

{ TGObjectHashSetLPT }

function TGObjectHashSetLPT.GetTombstonesCount: SizeInt;
begin
  Result := THashTableLPT(FTable).TombstonesCount;
end;

class function TGObjectHashSetLPT.GetClass: THashSetClass;
begin
  Result := TGObjectHashSetLPT;
end;

class function TGObjectHashSetLPT.GetTableClass: THashTableClass;
begin
  Result := THashTableLPT;
end;

function TGObjectHashSetLPT.Clone: TGObjectHashSetLPT;
begin
  Result := TGObjectHashSetLPT.CreateCopy(Self);
end;

procedure TGObjectHashSetLPT.ClearTombstones;
begin
  THashTableLPT(FTable).ClearTombstones;
end;

{ TGObjectHashSetQP }

function TGObjectHashSetQP.GetTombstonesCount: SizeInt;
begin
  Result := THashTableQP(FTable).TombstonesCount;
end;

class function TGObjectHashSetQP.GetClass: THashSetClass;
begin
  Result := TGObjectHashSetQP;
end;

class function TGObjectHashSetQP.GetTableClass: THashTableClass;
begin
  Result := THashTableQP;
end;

function TGObjectHashSetQP.Clone: TGObjectHashSetQP;
begin
  Result := TGObjectHashSetQP.CreateCopy(Self);
end;

procedure TGObjectHashSetQP.ClearTombstones;
begin
  THashTableQP(FTable).ClearTombstones;
end;

{ TGObjectOrderedHashSet }

procedure TGObjectOrderedHashSet.EntryRemoving(p: PEntry);
begin
  p^.Key.Free;
end;

procedure TGObjectOrderedHashSet.DoClear;
var
  e: PEntry;
begin
  if OwnsObjects then
    for e in FTable do
      e^.Key.Free;
  inherited;
end;

function TGObjectOrderedHashSet.DoRemove(constref aValue: T): Boolean;
begin
  Result := inherited DoRemove(aValue);
  if Result and OwnsObjects then
    aValue.Free;
end;

function TGObjectOrderedHashSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTable.RemoveIf(aTest, @EntryRemoving)
  else
    Result := FTable.RemoveIf(aTest);
end;

function TGObjectOrderedHashSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTable.RemoveIf(aTest, @EntryRemoving)
  else
    Result := FTable.RemoveIf(aTest);
end;

function TGObjectOrderedHashSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTable.RemoveIf(aTest, @EntryRemoving)
  else
    Result := FTable.RemoveIf(aTest);
end;

class function TGObjectOrderedHashSet.GetClass: THashSetClass;
begin
  Result := TGObjectOrderedHashSet;
end;

class function TGObjectOrderedHashSet.GetTableClass: THashTableClass;
begin
  Result := TOrderedHashTable;
end;

constructor TGObjectOrderedHashSet.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(a);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(e);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(aCapacity: SizeInt; constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, a);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(aCapacity: SizeInt; e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, e);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(aLoadFactor: Single; aOwnsObjects: Boolean);
begin
  inherited Create(aLoadFactor);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(aLoadFactor: Single; constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(aLoadFactor, a);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(aLoadFactor: Single; e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(aLoadFactor, e);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(aCapacity: SizeInt; aLoadFactor: Single; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aLoadFactor);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(aCapacity: SizeInt; aLoadFactor: Single; constref a: array of T;
  aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aLoadFactor, a);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.Create(aCapacity: SizeInt; aLoadFactor: Single; e: IEnumerable;
  aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aLoadFactor, e);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectOrderedHashSet.CreateCopy(aSet: TGObjectOrderedHashSet);
begin
  inherited CreateCopy(aSet);
  OwnsObjects := aSet.OwnsObjects;
end;

function TGObjectOrderedHashSet.Clone: TGObjectOrderedHashSet;
begin
  Result := TGObjectOrderedHashSet.CreateCopy(Self);
end;

{ TGObjectChainHashSet }

class function TGObjectChainHashSet.GetClass: THashSetClass;
begin
  Result := TGObjectChainHashSet;
end;

class function TGObjectChainHashSet.GetTableClass: THashTableClass;
begin
  Result := specialize TGChainHashTable<T, TEntry, TEqRel>;
end;

function TGObjectChainHashSet.Clone: TGObjectChainHashSet;
begin
  Result := TGObjectChainHashSet.CreateCopy(Self);
end;

{ TGLiteHashSetLP.TEnumerator }

function TGLiteHashSetLP.TEnumerator.GetCurrent: T;
begin
  Result := FEnum.Current^.Key;
end;

procedure TGLiteHashSetLP.TEnumerator.Init(constref aSet: TGLiteHashSetLP);
begin
  FEnum := aSet.FTable.GetEnumerator;
end;

function TGLiteHashSetLP.TEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGLiteHashSetLP.TEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGLiteHashSetLP }

function TGLiteHashSetLP.GetCapacity: SizeInt;
begin
  Result := FTable.Capacity;
end;

function TGLiteHashSetLP.GetCount: SizeInt;
begin
  Result := FTable.Count;
end;

function TGLiteHashSetLP.GetFillRatio: Single;
begin
  Result := FTable.FillRatio;
end;

function TGLiteHashSetLP.GetLoadFactor: Single;
begin
  Result := FTable.LoadFactor;
end;

function TGLiteHashSetLP.GetTableSize: SizeInt;
begin
  Result := FTable.Size;
end;

procedure TGLiteHashSetLP.SetLoadFactor(aValue: Single);
begin
  FTable.LoadFactor := aValue;
end;

function TGLiteHashSetLP.DefaultLoadFactor: Single;
begin
  Result := FTable.DEFAULT_LOAD_FACTOR;
end;

function TGLiteHashSetLP.MaxLoadFactor: Single;
begin
  Result := FTable.MAX_LOAD_FACTOR;
end;

function TGLiteHashSetLP.MinLoadFactor: Single;
begin
  Result := FTable.MIN_LOAD_FACTOR;
end;

function TGLiteHashSetLP.GetEnumerator: TEnumerator;
begin
  Result.Init(Self);
end;

function TGLiteHashSetLP.ToArray: TArray;
var
  I: SizeInt = 0;
  p: PEntry;
begin
  System.SetLength(Result, Count);
  for p in FTable do
    begin
      Result[I] := p^.Key;
      Inc(I);
    end;
end;

function TGLiteHashSetLP.IsEmpty: Boolean;
begin
  Result := FTable.Count = 0;
end;

function TGLiteHashSetLP.NonEmpty: Boolean;
begin
  Result := FTable.Count <> 0;
end;

procedure TGLiteHashSetLP.Clear;
begin
  FTable.Clear;
end;

procedure TGLiteHashSetLP.TrimToFit;
begin
  FTable.TrimToFit;
end;

procedure TGLiteHashSetLP.EnsureCapacity(aValue: SizeInt);
begin
  FTable.EnsureCapacity(aValue);
end;

function TGLiteHashSetLP.Add(constref aValue: T): Boolean;
var
  p: PEntry;
  Pos: SizeInt;
begin
  Result := not FTable.FindOrAdd(aValue, p, Pos);
  if Result then
    p^.Key := aValue;
end;

function TGLiteHashSetLP.AddAll(constref a: array of T): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in a do
    Result += Ord(Add(v));
end;

function TGLiteHashSetLP.AddAll(e: IEnumerable): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in e do
    Result += Ord(Add(v));
end;

function TGLiteHashSetLP.Contains(constref aValue: T): Boolean;
var
  p: SizeInt;
begin
  Result := FTable.Find(aValue, p) <> nil;
end;

function TGLiteHashSetLP.NonContains(constref aValue: T): Boolean;
begin
  Result := not Contains(aValue);
end;

function TGLiteHashSetLP.ContainsAny(constref a: array of T): Boolean;
var
  v: T;
begin
  for v in a do
    if Contains(v) then
      exit(True);
  Result := False;
end;

function TGLiteHashSetLP.ContainsAny(e: IEnumerable): Boolean;
var
  v: T;
begin
  for v in e do
    if Contains(v) then
      exit(True);
  Result := False;
end;

function TGLiteHashSetLP.ContainsAll(constref a: array of T): Boolean;
var
  v: T;
begin
  for v in a do
    if NonContains(v) then
      exit(False);
  Result := True;
end;

function TGLiteHashSetLP.ContainsAll(e: IEnumerable): Boolean;
var
  v: T;
begin
  for v in e do
    if NonContains(v) then
      exit(False);
  Result := True;
end;

function TGLiteHashSetLP.Remove(constref aValue: T): Boolean;
begin
  Result := FTable.Remove(aValue);
end;

function TGLiteHashSetLP.RemoveAll(constref a: array of T): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in a do
    Result += Ord(Remove(v));
end;

function TGLiteHashSetLP.RemoveAll(e: IEnumerable): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in e do
    Result += Ord(Remove(v));
end;
{$PUSH}{$MACRO ON}
function TGLiteHashSetLP.RemoveIf(aTest: TTest): SizeInt;
begin
{$DEFINE RemoveIfMacro :=
  Result := 0;
  with FTable.RemovableEnumerator do
    while MoveNext do
      if aTest(Current^.Key) then
        begin
          RemoveCurrent;
          Inc(Result);
        end}
  RemoveIfMacro;
end;

function TGLiteHashSetLP.RemoveIf(aTest: TOnTest): SizeInt;
begin
  RemoveIfMacro;
end;

function TGLiteHashSetLP.RemoveIf(aTest: TNestTest): SizeInt;
begin
  RemoveIfMacro;
end;

function TGLiteHashSetLP.Extract(constref aValue: T): Boolean;
begin
  Result := FTable.Remove(aValue);
end;

function TGLiteHashSetLP.ExtractIf(aTest: TTest): TArray;
var
  I: SizeInt = 0;
  v: T;
begin
{$DEFINE ExtractIfMacro :=
  System.SetLength(Result, ARRAY_INITIAL_SIZE);
  with FTable.RemovableEnumerator do
    while MoveNext do
      begin
        v := Current^.Key;
        if aTest(v) then
          begin
            RemoveCurrent;
            if I = System.Length(Result) then
              System.SetLength(Result, I shl 1);
            Result[I] := v;
            Inc(I);
          end;
      end;
  System.SetLength(Result, I)}
  ExtractIfMacro;
end;

function TGLiteHashSetLP.ExtractIf(aTest: TOnTest): TArray;
var
  I: SizeInt = 0;
  v: T;
begin
  ExtractIfMacro;
end;

function TGLiteHashSetLP.ExtractIf(aTest: TNestTest): TArray;
var
  I: SizeInt = 0;
  v: T;
begin
  ExtractIfMacro;
end;
{$POP}

procedure TGLiteHashSetLP.RetainAll(aCollection: ICollection);
begin
  with FTable.RemovableEnumerator do
    while MoveNext do
      if aCollection.NonContains(Current^.Key) then
        RemoveCurrent;
end;

function TGLiteHashSetLP.IsSuperset(constref aSet: TGLiteHashSetLP): Boolean;
var
  v: T;
begin
  if @aSet <> @Self then
    begin
      if Count >= aSet.Count then
        begin
          for v in aSet do
            if NonContains(v) then
              exit(False);
          Result := True;
        end
      else
        Result := False;
    end
  else
    Result := True;
end;

function TGLiteHashSetLP.IsSubset(constref aSet: TGLiteHashSetLP): Boolean;
begin
  Result := aSet.IsSuperset(Self);
end;

function TGLiteHashSetLP.IsEqual(constref aSet: TGLiteHashSetLP): Boolean;
var
  v: T;
begin
  if @aSet <> @Self then
    begin
      if Count <> aSet.Count then
        exit(False);
      for v in aSet do
        if NonContains(v) then
          exit(False);
      Result := True;
    end
  else
    Result := True;
end;

function TGLiteHashSetLP.Intersecting(constref aSet: TGLiteHashSetLP): Boolean;
var
  v: T;
begin
  if @aSet <> @Self then
    begin
      for v in aSet do
        if Contains(v) then
          exit(True);
      Result := False;
    end
  else
    Result := True;
end;

procedure TGLiteHashSetLP.Intersect(constref aSet: TGLiteHashSetLP);
begin
  with FTable.RemovableEnumerator do
    while MoveNext do
      if aSet.NonContains(Current^.Key) then
        RemoveCurrent;
end;

procedure TGLiteHashSetLP.Join(constref aSet: TGLiteHashSetLP);
var
  v: T;
begin
  for v in aSet do
    Add(v);
end;

procedure TGLiteHashSetLP.Subtract(constref aSet: TGLiteHashSetLP);
var
  v: T;
begin
  for v in aSet do
    Remove(v);
end;

procedure TGLiteHashSetLP.SymmetricSubtract(constref aSet: TGLiteHashSetLP);
var
  v: T;
begin
  for v in aSet do
    if not Remove(v) then
      Add(v);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic hash table implementations for internal use.                    *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGHashTable;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  math,
  LGUtils,
  {%H-}LGHelpers,
  LGStrConst;

type

  { TGCustomHashTable}

  generic TGCustomHashTable<TKey, TEntry> = class abstract
  strict protected
  const
    MIN_LOAD_FACTOR  = 0.25;
    MAX_SIZE         = Succ(High(SizeInt) shr 1);
    //ENTRY_SIZE       = SizeOf(TEntry); - does not compiles with TMapEntry
    //workaround :
    /////////////////////////////////////////////
    E_SIZE           = SizeOf(TEntry);
    ENTRY_SIZE       = E_SIZE or Ord(E_SIZE = 0);
    /////////////////////////////////////////////

  type
    TCustomHashTable = specialize TGCustomHashTable<TKey, TEntry>;
    THashTableClass  = class of TGCustomHashTable;
    //to supress unnecessary refcounting:
    TFakeEntry = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(ENTRY_SIZE)] of Byte{$ELSE}TEntry{$ENDIF};
  var
    FCount,
    FExpandTreshold: SizeInt;
    FLoadFactor: Single;
    procedure AllocList(aCapacity: SizeInt); virtual; abstract;
    procedure SetLoadFactor(aValue: Single); virtual; abstract;
    function  GetTableSize: SizeInt;  virtual; abstract;
    function  GetFillRatio: Single;
    function  RestrictLoadFactor(aValue: Single): Single; inline;
    function  GetCapacity: SizeInt; inline;
    property  ExpandTreshold: SizeInt read FExpandTreshold;
    class function EstimateCapacity(aCount: SizeInt; aLoadFactor: Single): SizeInt; virtual; abstract;
  public
  type
    PEntry           = ^TEntry;
    TEntryEvent      = procedure(p: PEntry) of object;
    TTest            = specialize TGTest<TKey>;
    TOnTest          = specialize TGOnTest<TKey>;
    TNestTest        = specialize TGNestTest<TKey>;
    TEntryTest       = function(p: PEntry): Boolean of object;
    TEntryEnumerator = specialize TGCustomEnumerator<PEntry>;

    TSearchResult = record
      case Integer of
        0: (FoundIndex, InsertIndex: SizeInt);
        1: (Node, PrevNode: Pointer);
    end;

    class function DefaultLoadFactor: Single; virtual; abstract;
    class function MaxLoadFactor: Single; virtual; abstract;
    class function MinLoadFactor: Single; static; inline;
    constructor CreateEmpty; virtual;
    constructor CreateEmpty(aLoadFactor: Single); virtual;
    constructor Create; virtual;
    constructor Create(aCapacity: SizeInt); virtual;
    constructor Create(aLoadFactor: Single); virtual;
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single); virtual;
    function  GetEnumerator: TEntryEnumerator; virtual; abstract;
    function  Clone: TCustomHashTable; virtual; abstract;
    procedure Clear; virtual; abstract;
    procedure EnsureCapacity(aValue: SizeInt); virtual; abstract;
    procedure TrimToFit; virtual; abstract;
    //return True if aKey found, otherwise insert garbage entry and return False;
    function  FindOrAdd(constref aKey: TKey; out e: PEntry; out aRes: TSearchResult): Boolean; virtual;abstract; overload;
    function  Find(constref aKey: TKey; out aPos: TSearchResult): PEntry; virtual; abstract;
    function  Remove(constref aKey: TKey): Boolean; virtual; abstract;
    procedure RemoveAt(constref aPos: TSearchResult); virtual; abstract;
    function  RemoveIf(aTest: TTest; aOnRemove: TEntryEvent = nil): SizeInt; virtual; abstract;
    function  RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent = nil): SizeInt; virtual; abstract;
    function  RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent = nil): SizeInt; virtual; abstract;
    function  RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent = nil): SizeInt; virtual; abstract;
    property  Count: SizeInt read FCount;
  { The capacity of the table is the number of elements that can be written without rehashing,
    so real capacity is ExpandTreshold, isn't it? }
    property  Capacity: SizeInt read GetCapacity;
    property  LoadFactor: Single read FLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  end;

  { TGOpenAddressing }

  generic TGOpenAddressing<TKey, TEntry, TEqRel, TProbeSeq> = class abstract(
    specialize TGCustomHashTable<TKey, TEntry>)
  strict protected
  const
    SLOT_NOT_FOUND: SizeInt = SizeInt(-1);
    USED_FLAG: SizeInt      = SizeInt(SizeInt(1) shl Pred(BitSizeOf(SizeInt)));

  type
    TNode = record
      Hash: SizeInt;
      Data: TEntry;
    end;

    TNodeList = array of TNode;

    TEnumerator = class(TEntryEnumerator)
    private
      FList: TNodeList;
      FCurrIndex,
      FLastIndex: SizeInt;
    protected
      function  GetCurrent: PEntry; override;
    public
      constructor Create(aList: TNodeList);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  const
    NODE_SIZE             = SizeOf(TNode);
    MAX_CAPACITY: SizeInt = MAX_SIZE div NODE_SIZE;

  type
    TFakeNode = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(NODE_SIZE)] of Byte{$ELSE}TNode{$ENDIF};

  var
    FList: TNodeList;
    class function NodeUsed(constref aNode: TNode): Boolean; static; inline;
    class function NewList(aCapacity: SizeInt): TNodeList; static; inline;
    procedure AllocList(aCapacity: SizeInt); override;
    function  GetTableSize: SizeInt; override;
    function  ListCapacity: SizeInt; inline;
    procedure SetLoadFactor(aValue: Single); override;
    procedure UpdateExpandTreshold; inline;
    procedure Rehash(var aTarget: TNodeList); virtual;
    procedure Resize(aNewCapacity: SizeInt);
    procedure Expand;
    function  DoFind(constref aKey: TKey; aKeyHash: SizeInt): TSearchResult; virtual;
    procedure DoRemove(aIndex: SizeInt); virtual; abstract;
    class function EstimateCapacity(aCount: SizeInt; aLoadFactor: Single): SizeInt; override;
    class constructor Init;
  public
    class function DefaultLoadFactor: Single; override;
    class function MaxLoadFactor: Single; override;
    function  GetEnumerator: TEntryEnumerator; override;
    procedure Clear; override;
    procedure EnsureCapacity(aValue: SizeInt); override;
    procedure TrimToFit; override;
    function  FindOrAdd(constref aKey: TKey; out e: PEntry; out aRes: TSearchResult): Boolean; override;
    function  Find(constref aKey: TKey; out aPos: TSearchResult): PEntry; override;
    function  Remove(constref aKey: TKey): Boolean; override;
    procedure RemoveAt(constref aPos: TSearchResult); override;
  end;

  TLPSeq = class
  const
    DEFAULT_LOAD_FACTOR: Single = 0.55;
    MAX_LOAD_FACTOR: Single     = 0.90;

    class function NextProbe(aPrevPos, {%H-}aIndex: SizeInt): SizeInt; static; inline;
  end;

  { TGOpenAddrLP implements open addressing hash table with linear probing(step = 1) }
  generic TGOpenAddrLP<TKey, TEntry, TEqRel> = class(specialize TGOpenAddressing<TKey, TEntry, TEqRel, TLPSeq>)
  strict protected
    procedure DoRemove(aIndex: SizeInt); override;
  public
    function  Clone: TCustomHashTable; override;
    function  RemoveIf(aTest: TTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
  end;

  { TGOpenAddrTombstones }

  generic TGOpenAddrTombstones<TKey, TEntry, TEqRel, TProbeSeq> = class abstract(
    specialize TGOpenAddressing<TKey, TEntry, TEqRel, TProbeSeq>)
  strict protected
  const
    TOMBSTONE: SizeInt = SizeInt(1);

  var
    FTombstonesCount: SizeInt;
    function  BusyCount: SizeInt; inline;
    procedure Rehash(var aTarget: TNodeList); override;
    function  DoFind(constref aKey: TKey; aKeyHash: SizeInt): TSearchResult; override;
    procedure DoRemove(aIndex: SizeInt); override;
  public
    procedure Clear; override;
    procedure ClearTombstones; inline;
    function  FindOrAdd(constref aKey: TKey; out e: PEntry; out aRes: TSearchResult): Boolean; override;
    function  RemoveIf(aTest: TTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    property  TombstonesCount: SizeInt read FTombstonesCount;
  end;

  { TGOpenAddrLPT implements open addressing tombstones hash table with linear probing and lazy deletion}
  generic TGOpenAddrLPT<TKey, TEntry, TEqRel> = class(
    specialize TGOpenAddrTombstones<TKey, TEntry, TEqRel, TLPSeq>)
    function Clone: TCustomHashTable; override;
  end;

  TQP12Seq = class
  const
    DEFAULT_LOAD_FACTOR: Single = 0.50;
    MAX_LOAD_FACTOR: Single     = 0.75;
    class function NextProbe(aPrevPos, aIndex: SizeInt): SizeInt; static; inline;
  end;

  { TGOpenAddrQP implements open addressing hash table with quadratic probing(c1 = 1/2, c2 = 1/2) }
  generic TGOpenAddrQP<TKey, TEntry, TEqRel> = class(
    specialize TGOpenAddrTombstones<TKey, TEntry, TEqRel, TQP12Seq>)
    function Clone: TCustomHashTable; override;
  end;

{.$DEFINE ORDEREDHASHTABLE_ENABLE_PAGEDNODEMANAGER}{ if uncomment define, TGOrderedHashTable
                                                     will use TGPageNodeManager }
  { TGOrderedHashTable }

  generic TGOrderedHashTable<TKey, TEntry, TEqRel> = class(specialize TGCustomHashTable<TKey, TEntry>)
  public
  type
    PNode = ^TNode;

    TNode = record
      ChainNext,
      Prior,
      Next: PNode;
      Hash: SizeInt;
      Data: TEntry;
      //for node manager
      property  NextLink: PNode read ChainNext write ChainNext;
    end;

  strict protected
  type
    TChainList = array of PNode;

    TEnumerator = class(TEntryEnumerator)
    private
      FHead,
      FCurrNode: PNode;
      FInCycle: Boolean;
    protected
      function  GetCurrent: PEntry; override;
    public
      constructor Create(aHead: PNode);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  public
  type
    TReverseEnumerator = class(TEntryEnumerator)
    protected
      FHead,
      FTail,
      FCurrNode: PNode;
      FInCycle: Boolean;
      function  GetCurrent: PEntry; override;
    public
      constructor Create(aTable: TGOrderedHashTable);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
      property  Head: PNode read FHead;
      property  Tail: PNode read FTail;
    end;

  strict protected
  type
{$IFDEF ORDEREDHASHTABLE_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGPageNodeManager<TNode>;
{$ELSE ORDEREDHASHTABLE_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGNodeManager<TNode>;
{$ENDIF ORDEREDHASHTABLE_ENABLE_PAGEDNODEMANAGER}

  const
    DEFAULT_LOAD_FACTOR: Single = 0.75;
    MAX_LOAD_FACTOR: Single     = 4.0;
    MAX_CAPACITY                = (MAX_SIZE shr 2) div SizeOf(Pointer);

  var
    FList: TChainList;
    FHead,
    FTail: PNode;
    FNodeManager: TNodeManager;
    procedure AllocList(aCapacity: SizeInt); override;
    function  GetTableSize: SizeInt; override;
    function  ListCapacity: SizeInt; inline;
    procedure SetLoadFactor(aValue: Single); override;
    function  NewNode: PNode; inline;
    procedure DisposeNode(aNode: PNode); inline;
    procedure ClearChainList;
    procedure UpdateExpandTreshold; inline;
    procedure Rehash(var aTarget: TChainList);
    procedure Resize(aNewCapacity: SizeInt);
    procedure Expand;
    function  DoAdd(aKeyHash: SizeInt): PNode;
    function  DoFind(constref aKey: TKey; aKeyHash: SizeInt): TSearchResult;
    procedure RemoveNode(aNode: PNode);
    class function EstimateCapacity(aCount: SizeInt; aLoadFactor: Single): SizeInt; override;
  public
    class function DefaultLoadFactor: Single; override;
    class function MaxLoadFactor: Single;  override;
    constructor CreateEmpty; override;
    constructor CreateEmpty(aLoadFactor: Single); override;
    constructor Create; override;
    constructor Create(aCapacity: SizeInt); override;
    constructor Create(aLoadFactor: Single); override;
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single); override;
    destructor Destroy; override;
    procedure Clear; override;
    function  Clone: TCustomHashTable; override;
    procedure EnsureCapacity(aValue: SizeInt); override;
    procedure TrimToFit; override;
    function  GetEnumerator: TEntryEnumerator; override;
    function  GetReverseEnumerator: TReverseEnumerator;
    //return True if aKey found, otherwise insert empty Entry and return False;
    function  FindOrAdd(constref aKey: TKey; out e: PEntry; out aRes: TSearchResult): Boolean; override;
    function  Find(constref aKey: TKey; out aPos: TSearchResult): PEntry; override;
    function  Remove(constref aKey: TKey): Boolean; override;
    procedure RemoveAt(constref aPos: TSearchResult); override;
    function  RemoveIf(aTest: TTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  GetFirst: PEntry;
    function  GetLast: PEntry;
    property  Head: PNode read FHead;
    property  Tail: PNode read FTail;
  end;

{.$DEFINE CHAINHASHTABLE_ENABLE_PAGEDNODEMANAGER}{ if uncomment define, TGChainHashTable
                                                   will use TGPageNodeManager }
  { TGChainHashTable }

  generic TGChainHashTable<TKey, TEntry, TEqRel> = class(specialize TGCustomHashTable<TKey, TEntry>)
  public
  type
    PNode = ^TNode;
    TNode = record
      Next: PNode;
      Hash: SizeInt;
      Data: TEntry;
      //for node manager
      property  NextLink: PNode read Next write Next;
    end;

  strict protected
  type
    TChainList = array of PNode;

    TEnumerator = class(TEntryEnumerator)
    private
      FList: TChainList;
      FCurrNode: PNode;
      FLastIndex,
      FCurrIndex: SizeInt;
    protected
      function  GetCurrent: PEntry; override;
    public
      constructor Create(aList: TChainList);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;
{$IFDEF CHAINHASHTABLE_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGPageNodeManager<TNode>;
{$ELSE CHAINHASHTABLE_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGNodeManager<TNode>;
{$ENDIF CHAINHASHTABLE_ENABLE_PAGEDNODEMANAGER}
  const
    DEFAULT_LOAD_FACTOR: Single = 0.75;
    MAX_LOAD_FACTOR: Single     = 4.0;
    MAX_CAPACITY                = (MAX_SIZE shr 1) div SizeOf(Pointer);

  var
    FList: TChainList;
    FNodeManager: TNodeManager;
    procedure AllocList(aCapacity: SizeInt); override;
    function  GetTableSize: SizeInt; override;
    function  ListCapacity: SizeInt; inline;
    procedure SetLoadFactor(aValue: Single); override;
    function  NewNode: PNode; inline;
    procedure DisposeNode(aNode: PNode); inline;
    procedure ClearList;
    procedure UpdateExpandTreshold; inline;
    procedure Rehash(var aTarget: TChainList);
    procedure Resize(aNewCapacity: SizeInt);
    procedure Expand;
    function  DoAdd(aKeyHash: SizeInt): PNode;
    function  DoFind(constref aKey: TKey; aKeyHash: SizeInt): TSearchResult;
    procedure DoRemove(constref aPos: TSearchResult); inline;
    class function EstimateCapacity(aCount: SizeInt; aLoadFactor: Single): SizeInt; override;
  public
    class function DefaultLoadFactor: Single; override;
    class function MaxLoadFactor: Single; override;
    constructor CreateEmpty; override;
    constructor CreateEmpty(aLoadFactor: Single); override;
    constructor Create; override;
    constructor Create(aCapacity: SizeInt); override;
    constructor Create(aLoadFactor: Single); override;
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single); override;
    destructor Destroy; override;
    procedure Clear; override;
    function  Clone: TCustomHashTable; override;
    procedure EnsureCapacity(aValue: SizeInt); override;
    procedure TrimToFit; override;
    function  GetEnumerator: TEntryEnumerator; override;
    //return True if aKey found, otherwise insert empty Entry and return False;
    function  FindOrAdd(constref aKey: TKey; out e: PEntry; out aRes: TSearchResult): Boolean; override;
    function  Find(constref aKey: TKey; out aPos: TSearchResult): PEntry; override;
    function  Add(constref aKey: TKey): PNode; inline;
    function  Remove(constref aKey: TKey): Boolean; override;
    procedure RemoveAt(constref aPos: TSearchResult); override;
    function  RemoveIf(aTest: TTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
    function  RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent = nil): SizeInt; override;
  end;

  { TGHashTableLP: simplified version TGOpenAddrLP }
  generic TGHashTableLP<TKey, TEntry, TEqRel> = class
  strict protected
  const
    MAX_SIZE         = Succ(High(SizeInt) shr 1);
    //ENTRY_SIZE       = SizeOf(TEntry); does not compiles with TMapEntry
    //workaround :
    /////////////////////////////////////////////
    E_SIZE           = SizeOf(TEntry);
    ENTRY_SIZE       = E_SIZE or Ord(E_SIZE = 0);
    /////////////////////////////////////////////
  type
    TFakeEntry = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(ENTRY_SIZE)] of Byte{$ELSE}TEntry{$ENDIF};
    TNode = record
      Hash: SizeInt;
      Data: TEntry;
    end;

    TNodeList = array of TNode;

  const
    NODE_SIZE               = SizeOf(TNode);
    SLOT_NOT_FOUND: SizeInt = Low(SizeInt);
    USED_FLAG: SizeInt      = SizeInt(SizeInt(1) shl Pred(BitSizeOf(SizeInt)));
    MAX_CAPACITY: SizeInt   = MAX_SIZE div NODE_SIZE;

  type
    TFakeNode = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(NODE_SIZE)] of Byte{$ELSE}TNode{$ENDIF};

  public
  type
    PEntry = ^TEntry;

    TEnumerator = record
    private
      FList: TNodeList;
      FCurrIndex,
      FLastIndex: SizeInt;
      function  GetCurrent: PEntry; inline;
      procedure Init(aList: TNodeList); inline;
    public
      function  MoveNext: Boolean;
      procedure Reset; inline;
      property  Current: PEntry read GetCurrent;
    end;

  strict protected
    FList: TNodeList;
    FCount,
    FExpandTreshold: SizeInt;
    FLoadFactor: Single;
    function  RestrictLoadFactor(aValue: Single): Single; inline;
    function  ListCapacity: SizeInt; inline;
    procedure UpdateExpandTreshold; inline;
    procedure SetLoadFactor(aValue: Single);
    function  GetCapacity: SizeInt; inline;
    function  GetFillRatio: Single; inline;
    function  GetTableSize: SizeInt; inline;
    procedure AllocList(aCapacity: SizeInt);
    procedure Rehash(var aTarget: TNodeList);
    procedure Resize(aNewCapacity: SizeInt);
    procedure Expand;
    function  DoFind(constref aKey: TKey; aKeyHash: SizeInt): SizeInt;
    procedure DoRemove(aIndex: SizeInt);
    property  ExpandTreshold: SizeInt read FExpandTreshold;
    class function NewList(aCapacity: SizeInt): TNodeList; static; inline;
    class function EstimateCapacity(aCount: SizeInt; aLoadFactor: Single): SizeInt; static; inline;
    class constructor Init;
  public
  const
    DEFAULT_LOAD_FACTOR: Single = 0.55;
    MAX_LOAD_FACTOR: Single     = 0.90;
    MIN_LOAD_FACTOR: Single     = 0.25;
    class function DefaultLoadFactor: Single; static; inline;
    class function MaxLoadFactor: Single; static; inline;
    class function MinLoadFactor: Single; static; inline;
    constructor CreateEmpty;
    constructor CreateEmpty(aLoadFactor: Single);
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(aLoadFactor: Single);
    constructor Create(aCapacity: SizeInt; aLoadFactor: Single);
    function  GetEnumerator: TEnumerator;
    procedure Clear;
    function  EnsureCapacity(aValue: SizeInt): Boolean;
    procedure TrimToFit;
    function  FindOrAdd(constref aKey: TKey; out e: PEntry; out aPos: SizeInt): Boolean;
    function  Find(constref aKey: TKey; out aPos: SizeInt): PEntry;
    function  Remove(constref aKey: TKey): Boolean;
    procedure RemoveAt(constref aPos: SizeInt); inline;
    property  Count: SizeInt read FCount;
    property  Capacity: SizeInt read GetCapacity;
    property  LoadFactor: Single read FLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  end;

  { TGLiteHashTableLP }

  generic TGLiteHashTableLP<TKey, TEntry, TEqRel> = record
  private
  const

    MAX_SIZE         = Succ(High(SizeInt) shr 1);
    //ENTRY_SIZE       = SizeOf(TEntry); - does not compiles with TMapEntry
    //workaround :
    /////////////////////////////////////////////
    E_SIZE           = SizeOf(TEntry);
    ENTRY_SIZE       = E_SIZE or Ord(E_SIZE = 0);
    /////////////////////////////////////////////

  type
    //to supress unnecessary refcounting:
    TFakeEntry = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(ENTRY_SIZE)] of Byte{$ELSE}TEntry{$ENDIF};

    TNode = record
      Hash: SizeInt;
      Data: TEntry;
    end;

    TNodeList = array of TNode;

  const
    NODE_SIZE               = SizeOf(TNode);
    SLOT_NOT_FOUND: SizeInt = Low(SizeInt);
    USED_FLAG: SizeInt      = SizeInt(SizeInt(1) shl Pred(BitSizeOf(SizeInt)));
    MAX_CAPACITY: SizeInt   = MAX_SIZE div NODE_SIZE;

  type
    TFakeNode = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(NODE_SIZE)] of Byte{$ELSE}TNode{$ENDIF};
    PLiteHashTableLP = ^TGLiteHashTableLP;

  public
  type
    PEntry = ^TEntry;

    TEnumerator = record
    private
      FList: TNodeList;
      FCurrIndex,
      FLastIndex: SizeInt;
      function  GetCurrent: PEntry; inline;
      procedure Init(aList: TNodeList); inline;
    public
      function  MoveNext: Boolean;
      procedure Reset; inline;
      property  Current: PEntry read GetCurrent;
    end;

    TRemovableEnumerator = record
    private
      FEnum: TEnumerator;
      FTable: PLiteHashTableLP;
      function  GetCurrent: PEntry; inline;
      procedure Init(aTable: PLiteHashTableLP); inline;
    public
      function  MoveNext: Boolean;
      procedure RemoveCurrent; inline;
      procedure Reset; inline;
      property  Current: PEntry read GetCurrent;
    end;

  private
    FList: TNodeList;
    FCount,
    FExpandTreshold: SizeInt;
    FLoadFactor: Single;
    function  RestrictLoadFactor(aValue: Single): Single; inline;
    procedure UpdateExpandTreshold; inline;
    procedure SetLoadFactor(aValue: Single);
    function  GetCapacity: SizeInt; inline;
    function  GetFillRatio: Single; inline;
    function  GetSize: SizeInt; inline;
    procedure AllocList(aCapacity: SizeInt);
    procedure Rehash(var aTarget: TNodeList);
    procedure Resize(aNewCapacity: SizeInt);
    procedure Expand;
    function  DoFind(constref aKey: TKey; aKeyHash: SizeInt): SizeInt;
    procedure DoRemove(aIndex: SizeInt);
    property  ExpandTreshold: SizeInt read FExpandTreshold;
    class function NewList(aCapacity: SizeInt): TNodeList; static; inline;
    class function EstimateSize(aCount: SizeInt; aLoadFactor: Single): SizeInt; static; inline;
    class constructor Init;
    class operator Initialize(var ht: TGLiteHashTableLP);
    class operator Finalize(var ht: TGLiteHashTableLP);
    class operator Copy(constref aSrc: TGLiteHashTableLP; var aDst: TGLiteHashTableLP); inline;
  public
  const
    DEFAULT_LOAD_FACTOR: Single = 0.55;
    MAX_LOAD_FACTOR: Single     = 0.90;
    MIN_LOAD_FACTOR: Single     = 0.25;

    function  GetEnumerator: TEnumerator; inline;
    function  RemovableEnumerator: TRemovableEnumerator; inline;
    procedure Clear;
    procedure EnsureCapacity(aValue: SizeInt);
    procedure TrimToFit;
    //return True if aKey found, otherwise insert garbage entry and return False;
    function  FindOrAdd(constref aKey: TKey; out e: PEntry; out aPos: SizeInt): Boolean;
    function  Find(constref aKey: TKey; out aPos: SizeInt): PEntry;
    function  Remove(constref aKey: TKey): Boolean;
    procedure RemoveAt(constref aPos: SizeInt);
    property  Count: SizeInt read FCount;
  { The capacity of the table is the number of elements that can be written without rehashing,
    so real capacity is ExpandTreshold }
    property  Capacity: SizeInt read GetCapacity;
    property  LoadFactor: Single read FLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  Size: SizeInt read GetSize; //todo: Split(predicate): TGLiteHashTableLP; ???
  end;

  { TGLiteHashList: node based hash table with alter access by index(or vice versa);
      functor TEqRel(equality relation) must provide:
        class function HashCode([const[ref]] aValue: T): SizeInt;
        class function Equal([const[ref]] L, R: T): Boolean; }
  generic TGLiteHashList<T, TEqRel> = record
  private
  type
    TNode = record
      Hash,
      Next: SizeInt;
      Data: T;
    end;

    TNodeList     = array of TNode;
    THashList     = array of SizeInt;
    PLiteHashList = ^TGLiteHashList;

  const
    NULL_INDEX  = SizeInt(-1);
    MAX_SIZE    = Succ(High(SizeInt) shr 1);
    NODE_SIZE   = SizeOf(TNode);
    MAX_CAPACITY: SizeInt  = MAX_SIZE div NODE_SIZE;

  public
  type
    IEnumerable = specialize IGEnumerable<T>;
    TArray      = array of T;

    TEnumerator = record
    private
      FList: TNodeList;
      FLastIndex,
      FCurrIndex: SizeInt;
      function  GetCurrent: T; inline;
      procedure Init(constref aList: TGLiteHashList);
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

    TReverseEnumerator = record
    private
      FList: TNodeList;
      FCount,
      FCurrIndex: SizeInt;
      function  GetCurrent: T; inline;
      procedure Init(constref aList: TGLiteHashList);
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

    TReverse = record
    private
      FList: PLiteHashList;
      procedure Init(aList: PLiteHashList); inline;
    public
      function  GetEnumerator: TReverseEnumerator; inline;
    end;

  private
    FNodeList: TNodeList;
    FHashList: THashList;
    FCount: SizeInt;
    function  GetCapacity: SizeInt; inline;
    function  GetItem(aIndex: SizeInt): T;
    procedure SetItem(aIndex: SizeInt; const aValue: T);
    procedure InitialAlloc; inline;
    procedure Rehash;
    procedure Resize(aNewCapacity: SizeInt);
    procedure Expand;
    function  Find(constref aValue: T): SizeInt;
    function  GetCount(constref aValue: T): SizeInt;
    function  DoAdd(constref aValue: T): SizeInt;
    procedure DoInsert(aIndex: SizeInt; constref aValue: T);
    procedure DoDelete(aIndex: SizeInt);
    procedure RemoveFromChain(aIndex: SizeInt);
    function  DoRemove(constref aValue: T): Boolean;
    function  GetReverseEnumerator: TReverseEnumerator; inline;
    function  IndexInRange(aIndex: SizeInt): Boolean; inline;
    function  IndexInInsertRange(aIndex: SizeInt): Boolean; inline;
    procedure CheckIndexRange(aIndex: SizeInt); inline;
    procedure CheckInsertIndexRange(aIndex: SizeInt); inline;
    class constructor Init;
    class function  NewHashList(aCapacity: SizeInt): THashList; static; inline;
    class procedure IndexOutOfBoundError(aIndex: SizeInt); static; inline;
    class procedure CapacityExceedError(aValue: SizeInt); static; inline;
    class operator Initialize(var hl: TGLiteHashList);
    class operator Finalize(var hl: TGLiteHashList);
    class operator Copy(constref aSrc: TGLiteHashList; var aDst: TGLiteHashList);
  public
    function  GetEnumerator: TEnumerator;
    function  ToArray: TArray;
    function  Reverse: TReverse;
    procedure Clear;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt);
    procedure TrimToFit;
    function  Contains(constref aValue: T): Boolean; inline;
    function  NonContains(constref aValue: T): Boolean; inline;
    function  IndexOf(constref aValue: T): SizeInt; inline;
    function  CountOf(constref aValue: T): SizeInt; inline;
    function  Add(constref aValue: T): SizeInt; inline;
    function  AddAll(constref a: array of T): SizeInt;
    function  AddAll(e: IEnumerable): SizeInt;
    procedure Insert(aIndex: SizeInt; constref aValue: T); inline;
    procedure Delete(aIndex: SizeInt); inline;
    function  Remove(constref aValue: T): Boolean; inline;
    property  Count: SizeInt read FCount;
    property  Capacity: SizeInt read GetCapacity;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
  end;

implementation
{$Q-}{$B-}{$COPERATORS ON}

{ TGCustomHashTable }

function TGCustomHashTable.GetFillRatio: Single;
var
  c: SizeInt;
begin
  c := GetTableSize;
  if c > 0 then
    Result := Count / c
  else
    Result := 0.0;
end;

function TGCustomHashTable.RestrictLoadFactor(aValue: Single): Single;
begin
  Result := Math.Min(Math.Max(aValue, MinLoadFactor), MaxLoadFactor);
end;

function TGCustomHashTable.GetCapacity: SizeInt;
begin
  Result := Trunc(TableSize * LoadFactor);
end;

class function TGCustomHashTable.MinLoadFactor: Single;
begin
  Result := MIN_LOAD_FACTOR;
end;

constructor TGCustomHashTable.CreateEmpty;
begin
  FLoadFactor := DefaultLoadFactor;
end;

constructor TGCustomHashTable.CreateEmpty(aLoadFactor: Single);
begin
  FLoadFactor := RestrictLoadFactor(aLoadFactor);
end;

constructor TGCustomHashTable.Create;
begin
  FLoadFactor := DefaultLoadFactor;
  AllocList(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGCustomHashTable.Create(aCapacity: SizeInt);
begin
  FLoadFactor := DefaultLoadFactor;
  AllocList(EstimateCapacity(aCapacity, LoadFactor));
end;

constructor TGCustomHashTable.Create(aLoadFactor: Single);
begin
  FLoadFactor := RestrictLoadFactor(aLoadFactor);
  AllocList(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGCustomHashTable.Create(aCapacity: SizeInt; aLoadFactor: Single);
begin
  FLoadFactor := RestrictLoadFactor(aLoadFactor);
  AllocList(EstimateCapacity(aCapacity, LoadFactor));
end;

{ TGOpenAddressing.TEnumerator }

function TGOpenAddressing.TEnumerator.GetCurrent: PEntry;
begin
  Result := @FList[FCurrIndex].Data;
end;

constructor TGOpenAddressing.TEnumerator.Create(aList: TNodeList);
begin
  FList := aList;
  FLastIndex := System.High(aList);
  FCurrIndex := -1;
end;

function TGOpenAddressing.TEnumerator.MoveNext: Boolean;
begin
  repeat
    if FCurrIndex >= FLastIndex then
      exit(False);
    Inc(FCurrIndex);
    Result := NodeUsed(FList[FCurrIndex]);
  until Result;
end;

procedure TGOpenAddressing.TEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGOpenAddressing }

class function TGOpenAddressing.NodeUsed(constref aNode: TNode): Boolean;
begin
  Result := (aNode.Hash and USED_FLAG) <> 0;
end;

class function TGOpenAddressing.NewList(aCapacity: SizeInt): TNodeList;
begin
  System.SetLength(Result, aCapacity);
  System.FillChar(Result[0], aCapacity * NODE_SIZE, 0);
end;

procedure TGOpenAddressing.AllocList(aCapacity: SizeInt);
begin
  if aCapacity > 0 then
    begin
      aCapacity := Math.Min(aCapacity, MAX_CAPACITY);
      if not IsTwoPower(aCapacity) then
        aCapacity := LGUtils.RoundUpTwoPower(aCapacity);
    end
  else
    aCapacity := DEFAULT_CONTAINER_CAPACITY;
  FList := NewList(aCapacity);
  UpdateExpandTreshold;
end;

function TGOpenAddressing.GetTableSize: SizeInt;
begin
  Result := ListCapacity;
end;

function TGOpenAddressing.ListCapacity: SizeInt;
begin
  Result := System.Length(FList);
end;

procedure TGOpenAddressing.SetLoadFactor(aValue: Single);
begin
  aValue := RestrictLoadFactor(aValue);
  if aValue <> LoadFactor then
    begin
      FLoadFactor := aValue;
      UpdateExpandTreshold;
      if Count >= ExpandTreshold then
        Expand;
    end;
end;

procedure TGOpenAddressing.UpdateExpandTreshold;
begin
  if ListCapacity < MAX_CAPACITY then
    FExpandTreshold := Trunc(ListCapacity * FLoadFactor)
  else
    FExpandTreshold := High(SizeInt);
end;

procedure TGOpenAddressing.Rehash(var aTarget: TNodeList);
var
  h, I, J, Mask: SizeInt;
begin
  if Count > 0 then
    begin
      Mask := System.High(aTarget);
      for I := 0 to System.High(FList) do
        begin
          if NodeUsed(FList[I]) then
            begin
              h := FList[I].Hash and Mask;
              for J := 0 to Mask do
                begin
                  if aTarget[h].Hash = 0 then // -> target node is empty
                    begin
                      TFakeNode(aTarget[h]) := TFakeNode(FList[I]);
                      TFakeEntry(FList[I].Data) := Default(TFakeEntry);
                      break;
                    end;
                  h := TProbeSeq.NextProbe(h, J) and Mask;// probe sequence
                end;
            end;
        end;
    end;
end;

procedure TGOpenAddressing.Resize(aNewCapacity: SizeInt);
var
  List: TNodeList;
begin
  List := NewList(aNewCapacity);
  Rehash(List);
  FList := List;
  UpdateExpandTreshold;
end;

procedure TGOpenAddressing.Expand;
var
  NewCapacity, OldCapacity: SizeInt;
begin
  OldCapacity := ListCapacity;
  if OldCapacity > 0 then
    begin
      NewCapacity := Math.Min(MAX_CAPACITY, OldCapacity shl 1);
      if NewCapacity > OldCapacity then
        Resize(NewCapacity);
    end
  else
    AllocList(DEFAULT_CONTAINER_CAPACITY);
end;

function TGOpenAddressing.DoFind(constref aKey: TKey; aKeyHash: SizeInt): TSearchResult;
var
  I, Pos, h, Mask: SizeInt;
begin
  Mask := System.High(FList);
  aKeyHash := aKeyHash or USED_FLAG;
  Result.FoundIndex := SLOT_NOT_FOUND;
  Result.InsertIndex := SLOT_NOT_FOUND;
  Pos := aKeyHash and Mask;
  for I := 0 to Mask do
    begin
      h := FList[Pos].Hash;
      if h = 0 then                               // node empty => key not found
        begin
          Result.InsertIndex := Pos;
          exit;
        end
      else
        if (h = aKeyHash) and TEqRel.Equal(FList[Pos].Data.Key, aKey) then
          begin
            Result.FoundIndex := Pos;             // key found
            exit;
          end;
      Pos := TProbeSeq.NextProbe(Pos, I) and Mask;// probe sequence
    end;
end;

class function TGOpenAddressing.EstimateCapacity(aCount: SizeInt; aLoadFactor: Single): SizeInt;
begin
  //aCount := Math.Min(Math.Max(aCount, 0), MaxCapacity);
  if aCount > 0 then
    Result := LGUtils.RoundUpTwoPower(Math.Min(Ceil64(Double(aCount) / aLoadFactor), MAX_CAPACITY))
  else
    Result := DEFAULT_CONTAINER_CAPACITY;
end;

class constructor TGOpenAddressing.Init;
begin
{$PUSH}{$J+}
  MAX_CAPACITY := LGUtils.RoundUpTwoPower(MAX_CAPACITY);
{$POP}
end;

class function TGOpenAddressing.DefaultLoadFactor: Single;
begin
  Result := TProbeSeq.DEFAULT_LOAD_FACTOR;
end;

class function TGOpenAddressing.MaxLoadFactor: Single;
begin
  Result := TProbeSeq.MAX_LOAD_FACTOR;
end;

function TGOpenAddressing.GetEnumerator: TEntryEnumerator;
begin
  Result := TEnumerator.Create(FList);
end;

procedure TGOpenAddressing.Clear;
begin
  FList := nil;
  FCount := 0;
  FExpandTreshold := 0;
end;

procedure TGOpenAddressing.EnsureCapacity(aValue: SizeInt);
var
  NewCapacity: SizeInt;
begin
  if aValue > ExpandTreshold then
    begin
      NewCapacity := EstimateCapacity(aValue, LoadFactor);
      if NewCapacity <> ListCapacity then
        Resize(NewCapacity);
    end;
end;

procedure TGOpenAddressing.TrimToFit;
var
  NewCapacity: SizeInt;
begin
  if Count > 0 then
    begin
      NewCapacity := EstimateCapacity(Count, LoadFactor);
      if NewCapacity < ListCapacity then
        Resize(NewCapacity);
    end
  else
    Clear;
end;

function TGOpenAddressing.FindOrAdd(constref aKey: TKey; out e: PEntry; out aRes: TSearchResult): Boolean;
var
  h: SizeInt;
begin
  if FList = nil then
    AllocList(DEFAULT_CONTAINER_CAPACITY);
  h := TEqRel.HashCode(aKey);
  aRes := DoFind(aKey, h);
  Result := aRes.FoundIndex >= 0; // key found?
  if not Result then              // key not found
    begin
      if Count >= ExpandTreshold then
        begin
          Expand;
          aRes := DoFind(aKey, h);
        end;
      if aRes.InsertIndex > SLOT_NOT_FOUND then
        begin
          FList[aRes.InsertIndex].Hash := h or USED_FLAG;
          aRes.FoundIndex := aRes.InsertIndex;
          Inc(FCount);
        end
      else
        raise ELGCapacityExceed.CreateFmt(SEClassCapacityExceedFmt, [ClassName, Succ(Count)]);
    end;
  e := @FList[aRes.FoundIndex].Data;
end;

function TGOpenAddressing.Find(constref aKey: TKey; out aPos: TSearchResult): PEntry;
begin
  Result := nil;
  if Count > 0 then
    begin
      aPos := DoFind(aKey, TEqRel.HashCode(aKey));
      if aPos.FoundIndex >= 0 then
        Result := @FList[aPos.FoundIndex].Data;
    end;
end;

function TGOpenAddressing.Remove(constref aKey: TKey): Boolean;
var
  p: TSearchResult;
begin
  if Count > 0 then
    begin
      p := DoFind(aKey, TEqRel.HashCode(aKey));
      Result := p.FoundIndex >= 0;
      if Result then
        DoRemove(p.FoundIndex);
    end
  else
    Result := False;
end;

procedure TGOpenAddressing.RemoveAt(constref aPos: TSearchResult);
begin
  if (aPos.FoundIndex >= 0) and (aPos.FoundIndex <= System.High(FList)) then
    DoRemove(aPos.FoundIndex);
end;

{ TLPSeq }

class function TLPSeq.NextProbe(aPrevPos, aIndex: SizeInt): SizeInt;
begin
  Result := Succ(aPrevPos);
end;

{ TGOpenAddrLP }

procedure TGOpenAddrLP.DoRemove(aIndex: SizeInt);
var
  I, h, Gap, Mask: SizeInt;
begin
  Mask := System.High(FList);
  FList[aIndex].Hash := 0;
  FList[aIndex].Data := Default(TEntry);
  Gap := aIndex;
  aIndex := Succ(aIndex) and Mask;
  Dec(FCount);
  for I := 0 to Mask do
    begin
      h := FList[aIndex].Hash;
      if h <> 0 then
        begin
          h := h and Mask;
          if (h <> aIndex) and (Succ(aIndex - h + Mask) and Mask >= Succ(aIndex - Gap + Mask) and Mask) then
            begin
              TFakeNode(FList[Gap]) := TFakeNode(FList[aIndex]);
              TFakeNode(FList[aIndex]) := Default(TFakeNode);
              Gap := aIndex;
            end;
          aIndex := Succ(aIndex) and Mask;
        end
      else
        break;
    end;
end;

function TGOpenAddrLP.Clone: TCustomHashTable;
var
  c: TGOpenAddrLP;
begin
  c := TGOpenAddrLP.CreateEmpty(LoadFactor);
  c.FList := System.Copy(FList);
  c.FCount := Count;
  c.FExpandTreshold := ExpandTreshold;
  Result := c;
end;
{$PUSH}{$MACRO ON}
function TGOpenAddrLP.RemoveIf(aTest: TTest; aOnRemove: TEntryEvent): SizeInt;
var
  I: SizeInt;
begin
{$DEFINE TestMacro := aTest(FList[I].Data.Key)}
{$DEFINE RemoveIfMacro :=
  Result := 0;
  if Count > 0 then
    begin
      I := 0;
      while I <= Pred(ListCapacity) do
        if (FList[I].Hash <> 0) and TestMacro then
          begin
            if aOnRemove <> nil then
              aOnRemove(@FList[I].Data);
            DoRemove(I);
            Inc(Result);
          end
        else
          Inc(I);
    end}
  RemoveIfMacro;
end;

function TGOpenAddrLP.RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent): SizeInt;
var
  I: SizeInt;
begin
  RemoveIfMacro;
end;

function TGOpenAddrLP.RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent): SizeInt;
var
  I: SizeInt;
begin
  RemoveIfMacro;
end;

function TGOpenAddrLP.RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent): SizeInt;
var
  I: SizeInt;
begin
  {$DEFINE TestMacro := aTest(@FList[I].Data)}
  RemoveIfMacro;
end;
{$POP}

{ TGOpenAddrTombstones }

function TGOpenAddrTombstones.BusyCount: SizeInt;
begin
  Result := Count + TombstonesCount;
end;

procedure TGOpenAddrTombstones.Rehash(var aTarget: TNodeList);
begin
  inherited;
  FTombstonesCount := 0;
end;

procedure TGOpenAddrTombstones.DoRemove(aIndex: SizeInt);
begin
  FList[aIndex].Hash := TOMBSTONE;
  FList[aIndex].Data := Default(TEntry);
  Inc(FTombstonesCount);
  Dec(FCount);
end;

procedure TGOpenAddrTombstones.Clear;
begin
  inherited;
  FTombstonesCount := 0;
end;

procedure TGOpenAddrTombstones.ClearTombstones;
begin
  Resize(ListCapacity);
end;

function TGOpenAddrTombstones.FindOrAdd(constref aKey: TKey; out e: PEntry; out aRes: TSearchResult): Boolean;
var
  h: SizeInt;
begin
  if FList = nil then
    AllocList(DEFAULT_CONTAINER_CAPACITY);
  h := TEqRel.HashCode(aKey);
  aRes := DoFind(aKey, h);
  Result := aRes.FoundIndex >= 0; // key found?
  if not Result then              // key not found
    begin
      if BusyCount >= ExpandTreshold then
        begin
          if TombstonesCount >= Count shr 1 then  //todo: Count shr 1 ??? why ???
            ClearTombstones
          else
            Expand;
          aRes := DoFind(aKey, h);
        end;
      if aRes.InsertIndex >= 0 then
        begin
          if FList[aRes.InsertIndex].Hash = TOMBSTONE then
            Dec(FTombstonesCount);
          FList[aRes.InsertIndex].Hash := h or USED_FLAG;
          aRes.FoundIndex := aRes.InsertIndex;
          Inc(FCount);
        end
      else
        raise Exception.CreateFmt(SEClassCapacityExceedFmt, [ClassName, Succ(Count)]);
    end;
  e := @FList[aRes.FoundIndex].Data;
end;
{$PUSH}{$MACRO ON}
function TGOpenAddrTombstones.RemoveIf(aTest: TTest; aOnRemove: TEntryEvent): SizeInt;
var
  I: SizeInt;
begin
{$DEFINE TestMacro := aTest(FList[I].Data.Key)}
{$DEFINE RemoveIfMacro :=
  Result := 0;
  if Count > 0 then
    begin
      I := 0;
      while I <= Pred(ListCapacity) do
        begin
          if NodeUsed(FList[I]) and TestMacro then
            begin
              if aOnRemove <> nil then
                aOnRemove(@FList[I].Data);
              DoRemove(I);
              Inc(Result);
            end;
          Inc(I);
        end;
    end}
  RemoveIfMacro;
end;

function TGOpenAddrTombstones.RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent): SizeInt;
var
  I: SizeInt;
begin
  RemoveIfMacro;
end;

function TGOpenAddrTombstones.RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent): SizeInt;
var
  I: SizeInt;
begin
  RemoveIfMacro;
end;

function TGOpenAddrTombstones.RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent): SizeInt;
var
  I: SizeInt;
begin
  {$DEFINE TestMacro := aTest(@FList[I].Data)}
  RemoveIfMacro;
end;
{$POP}

function TGOpenAddrTombstones.DoFind(constref aKey: TKey; aKeyHash: SizeInt): TSearchResult;
var
  I, Pos, h, Mask: SizeInt;
begin
  Mask := System.High(FList);
  aKeyHash := aKeyHash or USED_FLAG;
  Result.FoundIndex := SLOT_NOT_FOUND;
  Result.InsertIndex := SLOT_NOT_FOUND;
  Pos := aKeyHash and Mask;
  for I := 0 to Mask do
    begin
      h := FList[Pos].Hash;
      if h = 0 then                                    // node empty => key not found
        begin
          if Result.InsertIndex = SLOT_NOT_FOUND then  // if none tombstone found, remember first empty
            Result.InsertIndex := Pos;
          exit;
        end
      else
        if h = TOMBSTONE then
          begin
            if Result.InsertIndex = SLOT_NOT_FOUND then// remember first tombstone position
              Result.InsertIndex := Pos;
          end
        else
          if (h = aKeyHash) and TEqRel.Equal(FList[Pos].Data.Key, aKey) then
            begin
              Result.FoundIndex := Pos;                // key found
              exit;
            end;
      Pos := TProbeSeq.NextProbe(Pos, I) and Mask;     // probe sequence
    end;
end;

{ TGOpenAddrLPT }

function TGOpenAddrLPT.Clone: TCustomHashTable;
var
  c: TGOpenAddrLPT;
begin
  c := TGOpenAddrLPT.CreateEmpty(LoadFactor);
  c.FList := System.Copy(FList);
  c.FCount := Count;
  c.FExpandTreshold := ExpandTreshold;
  c.FTombstonesCount := TombstonesCount;
  Result := c;
end;

{ TQP12Seq }

class function TQP12Seq.NextProbe(aPrevPos, aIndex: SizeInt): SizeInt;
begin
  Result := Succ(aPrevPos + aIndex);
end;


{ TGOpenAddrQP }

function TGOpenAddrQP.Clone: TCustomHashTable;
var
  c: TGOpenAddrQP;
begin
  c := TGOpenAddrQP.CreateEmpty(LoadFactor);
  c.FList := System.Copy(FList);
  c.FCount := Count;
  c.FExpandTreshold := ExpandTreshold;
  c.FTombstonesCount := TombstonesCount;
  Result := c;
end;

{ TGOrderedHashTable.TEnumerator }

function TGOrderedHashTable.TEnumerator.GetCurrent: PEntry;
begin
  Result := @FCurrNode^.Data;
end;

constructor TGOrderedHashTable.TEnumerator.Create(aHead: PNode);
begin
  FHead := aHead;
end;

function TGOrderedHashTable.TEnumerator.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Next
  else
    if not FInCycle then
      begin
        NextNode := FHead;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

procedure TGOrderedHashTable.TEnumerator.Reset;
begin
  FCurrNode := nil;
  FInCycle := False;
end;

{ TGOrderedHashTable.TReverseEnumerator }

function TGOrderedHashTable.TReverseEnumerator.GetCurrent: PEntry;
begin
  Result := @FCurrNode^.Data;
end;

constructor TGOrderedHashTable.TReverseEnumerator.Create(aTable: TGOrderedHashTable);
begin
  FHead := aTable.Head;
  FTail := aTable.Tail;
  FCurrNode := nil;
end;

function TGOrderedHashTable.TReverseEnumerator.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Prior
  else
    if not FInCycle then
      begin
        NextNode := FTail;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

procedure TGOrderedHashTable.TReverseEnumerator.Reset;
begin
  FCurrNode := nil;
  FInCycle := False;
end;

{ TGOrderedHashTable }

procedure TGOrderedHashTable.AllocList(aCapacity: SizeInt);
begin
  if aCapacity > 0 then
    begin
      aCapacity := Math.Min(aCapacity, MAX_CAPACITY);
      if not IsTwoPower(aCapacity) then
        aCapacity := LGUtils.RoundUpTwoPower(aCapacity);
    end
  else
    aCapacity := DEFAULT_CONTAINER_CAPACITY;
  System.SetLength(FList, aCapacity);
  UpdateExpandTreshold;
end;

function TGOrderedHashTable.GetTableSize: SizeInt;
begin
  Result := ListCapacity;
end;

function TGOrderedHashTable.ListCapacity: SizeInt;
begin
  Result := System.Length(FList);
end;

procedure TGOrderedHashTable.SetLoadFactor(aValue: Single);
begin
  aValue := RestrictLoadFactor(aValue);
  if aValue <> LoadFactor then
    begin
      FLoadFactor := aValue;
      UpdateExpandTreshold;
      if Count >= ExpandTreshold then
        Expand;
    end;
end;

function TGOrderedHashTable.NewNode: PNode;
begin
  Result := FNodeManager.NewNode;
  Inc(FCount);
end;

procedure TGOrderedHashTable.DisposeNode(aNode: PNode);
begin
  if aNode <> nil then
    begin
      aNode^ := Default(TNode);
      FNodeManager.FreeNode(aNode);
      Dec(FCount);
    end;
end;

procedure TGOrderedHashTable.ClearChainList;
var
  CurrNode, NextNode: PNode;
begin
  CurrNode := Head;
  while CurrNode <> nil do
    begin
      NextNode := CurrNode^.Next;
      CurrNode^ := Default(TNode);
      FNodeManager.DisposeNode(CurrNode);
      CurrNode := NextNode;
    end;
  FHead := nil;
  FTail := nil;
  FList := nil;
  FCount := 0;
end;

procedure TGOrderedHashTable.UpdateExpandTreshold;
begin
  if ListCapacity < MAX_CAPACITY then
    FExpandTreshold := Trunc(ListCapacity * LoadFactor)
  else
    FExpandTreshold := High(SizeInt);
end;

procedure TGOrderedHashTable.Rehash(var aTarget: TChainList);
var
  Node, CurrNode, NextNode: PNode;
  I, Mask: SizeInt;
begin
  if Count > 0 then
    begin
      Mask := System.High(aTarget);
      for Node in FList do
        begin
          CurrNode := Node;
          while CurrNode <> nil do
            begin
              I := CurrNode^.Hash and Mask;
              NextNode := CurrNode^.ChainNext;
              CurrNode^.ChainNext := aTarget[I];
              aTarget[I] := CurrNode;
              CurrNode := NextNode;
            end;
        end;
    end;
end;

procedure TGOrderedHashTable.Resize(aNewCapacity: SizeInt);
var
  NewList: TChainList;
begin
  System.SetLength(NewList, aNewCapacity);
  Rehash(NewList);
  FList := NewList;
  UpdateExpandTreshold;
end;

procedure TGOrderedHashTable.Expand;
var
  NewCapacity, OldCapacity: SizeInt;
begin
  OldCapacity := ListCapacity;
  if OldCapacity > 0 then
    begin
      NewCapacity := Math.Min(MAX_CAPACITY, OldCapacity shl 1);
      if NewCapacity > OldCapacity then
        Resize(NewCapacity);
    end
  else
    AllocList(DEFAULT_CONTAINER_CAPACITY);
end;

function TGOrderedHashTable.DoAdd(aKeyHash: SizeInt): PNode;
var
  I: SizeInt;
begin
  //add node to chain
  I := aKeyHash and System.High(FList);
  Result := NewNode;
  Result^.Hash := aKeyHash;
  Result^.ChainNext := FList[I];
  FList[I] := Result;
  //add node to inorder list
  if Head = nil then
    FHead := Result;
  if Tail <> nil then
    Tail^.Next := Result;
  Result^.Prior := Tail;
  FTail := Result;
end;

function TGOrderedHashTable.DoFind(constref aKey: TKey; aKeyHash: SizeInt): TSearchResult;
var
  CurrNode, PrevNode: PNode;
begin
  CurrNode := FList[aKeyHash and System.High(FList)];
  PrevNode := nil;
  while CurrNode <> nil do
    begin
      if (CurrNode^.Hash = aKeyHash) and TEqRel.Equal(CurrNode^.Data.Key, aKey) then
        break;
      PrevNode := CurrNode;
      CurrNode := CurrNode^.ChainNext;
    end;
  Result.Node := CurrNode;
  Result.PrevNode := PrevNode;
end;

procedure TGOrderedHashTable.RemoveNode(aNode: PNode);
var
  CurrNode, PrevNode: PNode;
  Pos: TSearchResult;
begin
  CurrNode := FList[aNode^.Hash and System.High(FList)];
  PrevNode := nil;
  while CurrNode <> nil do
    begin
      if CurrNode = aNode then
        break;
      PrevNode := CurrNode;
      CurrNode := CurrNode^.ChainNext;
    end;
  Pos.Node := CurrNode;
  Pos.PrevNode := PrevNode;
  RemoveAt(Pos);
end;

class function TGOrderedHashTable.EstimateCapacity(aCount: SizeInt; aLoadFactor: Single): SizeInt;
begin
  //aCount := Math.Min(Math.Max(aCount, 0), MAX_CAPACITY);
  if aCount > 0 then
    Result := LGUtils.RoundUpTwoPower(Math.Min(Ceil64(Double(aCount) / aLoadFactor), MAX_CAPACITY))
  else
    Result := DEFAULT_CONTAINER_CAPACITY;
end;

class function TGOrderedHashTable.DefaultLoadFactor: Single;
begin
  Result := DEFAULT_LOAD_FACTOR;
end;

class function TGOrderedHashTable.MaxLoadFactor: Single;
begin
  Result := MAX_LOAD_FACTOR;
end;

constructor TGOrderedHashTable.CreateEmpty;
begin
  inherited;
  FNodeManager := TNodeManager.Create;
end;

constructor TGOrderedHashTable.CreateEmpty(aLoadFactor: Single);
begin
  inherited CreateEmpty(aLoadFactor);
  FNodeManager := TNodeManager.Create;
end;

constructor TGOrderedHashTable.Create;
begin
  inherited Create;
  FNodeManager := TNodeManager.Create;
  FNodeManager.EnsureFreeCount(Capacity);
end;

constructor TGOrderedHashTable.Create(aCapacity: SizeInt);
begin
  inherited Create(aCapacity);
  FNodeManager := TNodeManager.Create;
  FNodeManager.EnsureFreeCount(Capacity);
end;

constructor TGOrderedHashTable.Create(aLoadFactor: Single);
begin
  inherited Create(aLoadFactor);
  FNodeManager := TNodeManager.Create;
  FNodeManager.EnsureFreeCount(Capacity);
end;

constructor TGOrderedHashTable.Create(aCapacity: SizeInt; aLoadFactor: Single);
begin
  inherited Create(aCapacity, aLoadFactor);
  FNodeManager := TNodeManager.Create;
  FNodeManager.EnsureFreeCount(Capacity);
end;

destructor TGOrderedHashTable.Destroy;
begin
  ClearChainList;
  FNodeManager.Free;
  inherited;
end;

procedure TGOrderedHashTable.Clear;
begin
  ClearChainList;
  FNodeManager.Clear;
  FExpandTreshold := 0;
end;

function TGOrderedHashTable.Clone: TCustomHashTable;
var
  CurrNode, AddedNode: PNode;
begin
  Result := TGOrderedHashTable.Create(ListCapacity, LoadFactor);
  CurrNode := FHead;
  while CurrNode <> nil do
    begin
      AddedNode := TGOrderedHashTable(Result).DoAdd(CurrNode^.Hash);
      AddedNode^.Data := CurrNode^.Data;
      CurrNode := CurrNode^.Next;
    end;
end;

procedure TGOrderedHashTable.EnsureCapacity(aValue: SizeInt);
var
  NewCapacity: SizeInt;
begin
  if aValue > ExpandTreshold then
    begin
      FNodeManager.EnsureFreeCount(aValue - Count);
      NewCapacity := EstimateCapacity(aValue, LoadFactor);
      if NewCapacity <> ListCapacity then
        Resize(NewCapacity);
    end;
end;

procedure TGOrderedHashTable.TrimToFit;
var
  NewCapacity: SizeInt;
begin
  if Count > 0 then
    begin
      NewCapacity := EstimateCapacity(Count, LoadFactor);
      if NewCapacity < ListCapacity then
        Resize(NewCapacity);
      FNodeManager.ClearFreeList;
    end
  else
    Clear;
end;

function TGOrderedHashTable.GetEnumerator: TEntryEnumerator;
begin
  Result := TEnumerator.Create(Head);
end;

function TGOrderedHashTable.GetReverseEnumerator: TReverseEnumerator;
begin
  Result := TReverseEnumerator.Create(Self);
end;

function TGOrderedHashTable.FindOrAdd(constref aKey: TKey; out e: PEntry; out aRes: TSearchResult): Boolean;
var
  h: SizeInt;
begin
  if FList = nil then
    AllocList(DEFAULT_CONTAINER_CAPACITY);
  h := TEqRel.HashCode(aKey);
  aRes := DoFind(aKey, h);
  Result := aRes.Node <> nil; // key found?
  if not Result then          // key not found
    begin
      if Count >= ExpandTreshold then
        Expand;
      aRes.Node := DoAdd(h);
    end;
  e := @PNode(aRes.Node)^.Data;
end;

function TGOrderedHashTable.Find(constref aKey: TKey; out aPos: TSearchResult): PEntry;
begin
  if Count > 0 then
    begin
      aPos := DoFind(aKey, TEqRel.HashCode(aKey));
      if aPos.Node <> nil then
        Result := @PNode(aPos.Node)^.Data
      else
        Result := nil;
    end
  else
    Result := nil;
end;

function TGOrderedHashTable.Remove(constref aKey: TKey): Boolean;
var
  sr: TSearchResult;
begin
  sr := DoFind(aKey, TEqRel.HashCode(aKey));
  Result := sr.Node <> nil;
  if Result then
    RemoveAt(sr);
end;

procedure TGOrderedHashTable.RemoveAt(constref aPos: TSearchResult);
var
  CurrNode, PrevNode: PNode;
begin
  if aPos.Node <> nil then
    begin
      PrevNode := aPos.PrevNode;
      CurrNode := aPos.Node;
      if PrevNode <> nil then  //is not head of chain
        PrevNode^.ChainNext := CurrNode^.ChainNext
      else
        FList[CurrNode^.Hash and System.High(FList)] := CurrNode^.ChainNext;

      if CurrNode^.Prior <> nil then //is not in order head
        CurrNode^.Prior^.Next := CurrNode^.Next
      else
        FHead := CurrNode^.Next;

      if CurrNode^.Next <> nil then //is not in order tail
        CurrNode^.Next^.Prior := CurrNode^.Prior;

      DisposeNode(aPos.Node);
    end;
end;
{$PUSH}{$MACRO ON}
function TGOrderedHashTable.RemoveIf(aTest: TTest; aOnRemove: TEntryEvent): SizeInt;
var
  CurrNode, NextNode: PNode;
begin
{$DEFINE TestMacro := aTest(CurrNode^.Data.Key)}
{$DEFINE RemoveIfMacro :=
  Result := 0;
  CurrNode := FHead;
  while CurrNode <> nil do
    begin
      NextNode := CurrNode^.Next;
      if TestMacro then
        begin
          if aOnRemove <> nil then
            aOnRemove(@CurrNode^.Data);
          RemoveNode(CurrNode);
          Inc(Result);
        end;
      CurrNode := NextNode;
    end}
  RemoveIfMacro;
end;

function TGOrderedHashTable.RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent): SizeInt;
var
  CurrNode, NextNode: PNode;
begin
  RemoveIfMacro;
end;

function TGOrderedHashTable.RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent): SizeInt;
var
  CurrNode, NextNode: PNode;
begin
  RemoveIfMacro;
end;

function TGOrderedHashTable.RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent): SizeInt;
var
  CurrNode, NextNode: PNode;
begin
  {$DEFINE TestMacro := aTest(@CurrNode^.Data)}
  RemoveIfMacro;
end;
{$POP}

function TGOrderedHashTable.GetFirst: PEntry;
begin
  if Head <> nil then
    Result := @Head^.Data
  else
    Result := nil;
end;

function TGOrderedHashTable.GetLast: PEntry;
begin
  if Tail <> nil then
    Result := @Tail^.Data
  else
    Result := nil;
end;

{ TGChainHashTable.TEnumerator }

function TGChainHashTable.TEnumerator.GetCurrent: PEntry;
begin
  Result := @FCurrNode^.Data;
end;

constructor TGChainHashTable.TEnumerator.Create(aList: TChainList);
begin
  FList := aList;
  FLastIndex := High(aList);
  FCurrIndex := -1;
end;

function TGChainHashTable.TEnumerator.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Next;
  while NextNode = nil do
    begin
      if FCurrIndex >= FLastIndex then
        exit(False);
      Inc(FCurrIndex);
      NextNode := FList[FCurrIndex];
    end;
  FCurrNode := NextNode;
  Result := True;
end;

procedure TGChainHashTable.TEnumerator.Reset;
begin
  FCurrNode := nil;
  FCurrIndex := -1;
end;

{ TGChainHashTable }

procedure TGChainHashTable.AllocList(aCapacity: SizeInt);
begin
  if aCapacity > 0 then
    begin
      aCapacity := Math.Min(aCapacity, MAX_CAPACITY);
      if not IsTwoPower(aCapacity) then
        aCapacity := LGUtils.RoundUpTwoPower(aCapacity);
    end
  else
    aCapacity := DEFAULT_CONTAINER_CAPACITY;
  System.SetLength(FList, aCapacity);
  UpdateExpandTreshold;
end;

function TGChainHashTable.GetTableSize: SizeInt;
begin
  Result := ListCapacity;
end;

function TGChainHashTable.ListCapacity: SizeInt;
begin
  Result := System.Length(FList);
end;

procedure TGChainHashTable.SetLoadFactor(aValue: Single);
begin
  aValue := RestrictLoadFactor(aValue);
  if aValue <> LoadFactor then
    begin
      FLoadFactor := aValue;
      UpdateExpandTreshold;
      if Count >= ExpandTreshold then
        Expand;
    end;
end;

function TGChainHashTable.NewNode: PNode;
begin
  Result := FNodeManager.NewNode;
  Inc(FCount);
end;

procedure TGChainHashTable.DisposeNode(aNode: PNode);
begin
  if aNode <> nil then
    begin
      aNode^ := Default(TNode);
      FNodeManager.FreeNode(aNode);
      Dec(FCount);
    end;
end;

procedure TGChainHashTable.ClearList;
var
  Node, CurrNode, NextNode: PNode;
begin
  for Node in FList do
    begin
      CurrNode := Node;
      while CurrNode <> nil do
        begin
          NextNode := CurrNode^.Next;
          CurrNode^.Data := Default(TEntry);
          FNodeManager.DisposeNode(CurrNode);
          CurrNode := NextNode;
        end;
    end;
  FList := nil;
  FCount := 0;
end;

procedure TGChainHashTable.UpdateExpandTreshold;
begin
  if ListCapacity < MAX_CAPACITY then
    FExpandTreshold := Trunc(ListCapacity * LoadFactor)
  else
    FExpandTreshold := High(SizeInt);
end;

procedure TGChainHashTable.Rehash(var aTarget: TChainList);
var
  Node, CurrNode, NextNode: PNode;
  I, Mask: SizeInt;
begin
  if Count > 0 then
    begin
      Mask := System.High(aTarget);
      for Node in FList do
        begin
          CurrNode := Node;
          while CurrNode <> nil do
            begin
              I := CurrNode^.Hash and Mask;
              NextNode := CurrNode^.Next;
              CurrNode^.Next := aTarget[I];
              aTarget[I] := CurrNode;
              CurrNode := NextNode;
            end;
        end;
    end;
end;

procedure TGChainHashTable.Resize(aNewCapacity: SizeInt);
var
  NewList: TChainList;
begin
  System.SetLength(NewList, aNewCapacity);
  Rehash(NewList);
  FList := NewList;
  UpdateExpandTreshold;
end;

procedure TGChainHashTable.Expand;
var
  NewCapacity, OldCapacity: SizeInt;
begin
  OldCapacity := ListCapacity;
  if OldCapacity > 0 then
    begin
      NewCapacity := Math.Min(MAX_CAPACITY, OldCapacity shl 1);
      if NewCapacity > OldCapacity then
        Resize(NewCapacity);
    end
  else
    AllocList(DEFAULT_CONTAINER_CAPACITY);
end;

function TGChainHashTable.DoAdd(aKeyHash: SizeInt): PNode;
var
  I: SizeInt;
begin
  //add node to chain
  I := aKeyHash and System.High(FList);
  Result := NewNode;
  Result^.Hash := aKeyHash;
  Result^.Next := FList[I];
  FList[I] := Result;
end;

function TGChainHashTable.DoFind(constref aKey: TKey; aKeyHash: SizeInt): TSearchResult;
var
  CurrNode, PrevNode: PNode;
begin
  CurrNode := FList[aKeyHash and System.High(FList)];
  PrevNode := nil;

  while CurrNode <> nil do
    begin
      if (CurrNode^.Hash = aKeyHash) and TEqRel.Equal(CurrNode^.Data.Key, aKey) then
        break;
      PrevNode := CurrNode;
      CurrNode := CurrNode^.Next;
    end;

  Result.Node := CurrNode;
  Result.PrevNode := PrevNode;
end;

procedure TGChainHashTable.DoRemove(constref aPos: TSearchResult);
begin
  if aPos.Node <> nil then
    begin
      if aPos.PrevNode <> nil then  //is not head of chain
        PNode(aPos.PrevNode)^.Next := PNode(aPos.Node)^.Next
      else
        FList[PNode(aPos.Node)^.Hash and System.High(FList)] := PNode(aPos.Node)^.Next;
      DisposeNode(aPos.Node);
    end;
end;

class function TGChainHashTable.EstimateCapacity(aCount: SizeInt; aLoadFactor: Single): SizeInt;
begin
  //aCount := Math.Min(Math.Max(aCount, 0), MAX_CAPACITY);
  if aCount > 0 then
    Result := LGUtils.RoundUpTwoPower(Math.Min(Ceil64(Double(aCount) / aLoadFactor), MAX_CAPACITY))
  else
    Result := DEFAULT_CONTAINER_CAPACITY;
end;

class function TGChainHashTable.DefaultLoadFactor: Single;
begin
  Result := DEFAULT_LOAD_FACTOR;
end;

class function TGChainHashTable.MaxLoadFactor: Single;
begin
  Result := MAX_LOAD_FACTOR;
end;

constructor TGChainHashTable.CreateEmpty;
begin
  inherited CreateEmpty;
  FNodeManager := TNodeManager.Create;
end;

constructor TGChainHashTable.CreateEmpty(aLoadFactor: Single);
begin
  inherited CreateEmpty(aLoadFactor);
  FNodeManager := TNodeManager.Create;
end;

constructor TGChainHashTable.Create;
begin
  inherited Create;
  FNodeManager := TNodeManager.Create;
  FNodeManager.EnsureFreeCount(Capacity);
end;

constructor TGChainHashTable.Create(aCapacity: SizeInt);
begin
  inherited Create(aCapacity);
  FNodeManager := TNodeManager.Create;
  FNodeManager.EnsureFreeCount(Capacity);
end;

constructor TGChainHashTable.Create(aLoadFactor: Single);
begin
  inherited Create(aLoadFactor);
  FNodeManager := TNodeManager.Create;
  FNodeManager.EnsureFreeCount(Capacity);
end;

constructor TGChainHashTable.Create(aCapacity: SizeInt; aLoadFactor: Single);
begin
  inherited Create(aCapacity, aLoadFactor);
  FNodeManager := TNodeManager.Create;
  FNodeManager.EnsureFreeCount(Capacity);
end;

destructor TGChainHashTable.Destroy;
begin
  ClearList;
  FNodeManager.Free;
  inherited;
end;

procedure TGChainHashTable.Clear;
begin
  ClearList;
  FNodeManager.Clear;
  FExpandTreshold := 0;
end;

function TGChainHashTable.Clone: TCustomHashTable;
var
  AddedNode, CurrNode: PNode;
  I: SizeInt;
begin
  Result := TGChainHashTable.Create(ListCapacity, LoadFactor);
  for I := 0 to System.High(FList) do
    begin
      CurrNode := FList[I];
      while CurrNode <> nil do
        begin
          AddedNode := TGChainHashTable(Result).DoAdd(CurrNode^.Hash);
          AddedNode^.Data := CurrNode^.Data;
          CurrNode := CurrNode^.Next;
        end;
    end;
end;

procedure TGChainHashTable.EnsureCapacity(aValue: SizeInt);
var
  NewCapacity: SizeInt;
begin
  if aValue > ExpandTreshold then
    begin
      FNodeManager.EnsureFreeCount(aValue - Count);
      NewCapacity := EstimateCapacity(aValue, LoadFactor);
      if NewCapacity <> ListCapacity then
        Resize(NewCapacity);
    end;
end;

procedure TGChainHashTable.TrimToFit;
var
  NewCapacity: SizeInt;
begin
  if Count > 0 then
    begin
      NewCapacity := EstimateCapacity(Count, LoadFactor);
      if NewCapacity < ListCapacity then
        Resize(NewCapacity);
      FNodeManager.ClearFreeList;
    end
  else
    Clear;
end;

function TGChainHashTable.GetEnumerator: TEntryEnumerator;
begin
  Result := TEnumerator.Create(FList);
end;

function TGChainHashTable.FindOrAdd(constref aKey: TKey; out e: PEntry; out aRes: TSearchResult): Boolean;
var
  h: SizeInt;
begin
  if FList = nil then
    AllocList(DEFAULT_CONTAINER_CAPACITY);
  h := TEqRel.HashCode(aKey);
  aRes := DoFind(aKey, h);
  Result := aRes.Node <> nil; // key found ?
  if not Result then          // key not found
    begin
      if Count >= ExpandTreshold then
        Expand;
      aRes.Node := DoAdd(h);
    end;
  e := @PNode(aRes.Node)^.Data;
end;

function TGChainHashTable.Find(constref aKey: TKey; out aPos: TSearchResult): PEntry;
begin
  if Count > 0 then
    begin
      aPos := DoFind(aKey, TEqRel.HashCode(aKey));
      if aPos.Node <> nil then
        Result := @PNode(aPos.Node)^.Data
      else
        Result := nil;
    end
  else
    Result := nil;
end;

function TGChainHashTable.Add(constref aKey: TKey): PNode;
begin
  if FList = nil then
    AllocList(DEFAULT_CONTAINER_CAPACITY);
  if Count >= ExpandTreshold then
    Expand;
  Result := DoAdd(TEqRel.HashCode(aKey));
end;

function TGChainHashTable.Remove(constref aKey: TKey): Boolean;
var
  p: TSearchResult;
begin
  p := DoFind(aKey, TEqRel.HashCode(aKey));
  Result := p.Node <> nil;
  if Result then
    DoRemove(p);
end;

procedure TGChainHashTable.RemoveAt(constref aPos: TSearchResult);
begin
  DoRemove(aPos);
end;
{$PUSH}{$MACRO ON}
function TGChainHashTable.RemoveIf(aTest: TTest; aOnRemove: TEntryEvent): SizeInt;
var
  PrevNode, CurrNode, NextNode: PNode;
  I: SizeInt;
begin
{$DEFINE TestMacro := aTest(CurrNode^.Data.Key)}
{$DEFINE RemoveIfMacro :=
  Result := 0;
  if Count > 0 then
    for I := 0 to Pred(ListCapacity) do
      begin
        CurrNode := FList[I];
        PrevNode := nil;
        while CurrNode <> nil do
          begin
            NextNode := CurrNode^.Next;
            if TestMacro then
              begin
                if PrevNode <> nil then
                  PrevNode^.Next := NextNode
                else
                  FList[I] := NextNode;
                if aOnRemove <> nil then
                  aOnRemove(@CurrNode^.Data);
                DisposeNode(CurrNode);
                Inc(Result);
              end
            else
              PrevNode := CurrNode;
            CurrNode := NextNode;
          end;
      end}
  RemoveIfMacro;
end;

function TGChainHashTable.RemoveIf(aTest: TOnTest; aOnRemove: TEntryEvent): SizeInt;
var
  PrevNode, CurrNode, NextNode: PNode;
  I: SizeInt;
begin
  RemoveIfMacro;
end;

function TGChainHashTable.RemoveIf(aTest: TNestTest; aOnRemove: TEntryEvent): SizeInt;
var
  PrevNode, CurrNode, NextNode: PNode;
  I: SizeInt;
begin
  RemoveIfMacro;
end;

function TGChainHashTable.RemoveIf(aTest: TEntryTest; aOnRemove: TEntryEvent): SizeInt;
var
  PrevNode, CurrNode, NextNode: PNode;
  I: SizeInt;
begin
  {$DEFINE TestMacro := aTest(@CurrNode^.Data)}
  RemoveIfMacro;
end;
{$POP}

{ TGHashTableLP.TEnumerator }

function TGHashTableLP.TEnumerator.GetCurrent: PEntry;
begin
  Result := @FList[FCurrIndex].Data;
end;

procedure TGHashTableLP.TEnumerator.Init(aList: TNodeList);
begin
  FList := aList;
  FLastIndex := System.High(aList);
  FCurrIndex := -1;
end;

function TGHashTableLP.TEnumerator.MoveNext: Boolean;
begin
  repeat
    if FCurrIndex >= FLastIndex then
      exit(False);
    Inc(FCurrIndex);
    Result := FList[FCurrIndex].Hash <> 0;
  until Result;
end;

procedure TGHashTableLP.TEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGHashTableLP }

function TGHashTableLP.RestrictLoadFactor(aValue: Single): Single;
begin
  Result := Math.Min(Math.Max(aValue, MIN_LOAD_FACTOR), MAX_LOAD_FACTOR);
end;

function TGHashTableLP.ListCapacity: SizeInt;
begin
  Result := System.Length(FList);
end;

procedure TGHashTableLP.UpdateExpandTreshold;
begin
  if ListCapacity < MAX_CAPACITY then
    FExpandTreshold := Trunc(ListCapacity * LoadFactor)
  else
    FExpandTreshold := MAX_CAPACITY;
end;

procedure TGHashTableLP.SetLoadFactor(aValue: Single);
begin
  aValue := RestrictLoadFactor(aValue);
  if aValue <> LoadFactor then
    begin
      FLoadFactor := aValue;
      UpdateExpandTreshold;
      if Count >= ExpandTreshold then
        Expand;
    end;
end;

function TGHashTableLP.GetCapacity: SizeInt;
begin
  Result := Trunc(ListCapacity * LoadFactor);
end;

function TGHashTableLP.GetFillRatio: Single;
var
  c: SizeInt;
begin
  c := ListCapacity;
  if c > 0 then
    Result := Count / c
  else
    Result := 0.0;
end;

function TGHashTableLP.GetTableSize: SizeInt;
begin
  Result := ListCapacity;
end;

procedure TGHashTableLP.AllocList(aCapacity: SizeInt);
begin
  if aCapacity > 0 then
    begin
      aCapacity := Math.Min(aCapacity, MAX_CAPACITY);
      if not IsTwoPower(aCapacity) then
        aCapacity := LGUtils.RoundUpTwoPower(aCapacity);
    end
  else
    aCapacity := DEFAULT_CONTAINER_CAPACITY;
  FList := NewList(aCapacity);
  UpdateExpandTreshold;
end;

procedure TGHashTableLP.Rehash(var aTarget: TNodeList);
var
  h, I, J, Mask: SizeInt;
begin
  if Count > 0 then
    begin
      Mask := System.High(aTarget);
      for I := 0 to System.High(FList) do
        begin
          if FList[I].Hash <> 0 then
            begin
              h := FList[I].Hash and Mask;
              for J := 0 to Mask do
                begin
                  if aTarget[h].Hash = 0 then // -> target node is empty
                    begin
                      TFakeNode(aTarget[h]) := TFakeNode(FList[I]);
                      TFakeEntry(FList[I].Data) := Default(TFakeEntry);
                      break;
                    end;
                  h := Succ(h) and Mask;     // probe sequence
                end;
            end;
        end;
    end;
end;

procedure TGHashTableLP.Resize(aNewCapacity: SizeInt);
var
  List: TNodeList;
begin
  List := NewList(aNewCapacity);
  Rehash(List);
  FList := List;
  UpdateExpandTreshold;
end;

procedure TGHashTableLP.Expand;
var
  NewCapacity, OldCapacity: SizeInt;
begin
  OldCapacity := ListCapacity;
  if OldCapacity > 0 then
    begin
      NewCapacity := Math.Min(MAX_CAPACITY, OldCapacity shl 1);
      if NewCapacity > OldCapacity then
        Resize(NewCapacity);
    end
  else
    AllocList(DEFAULT_CONTAINER_CAPACITY);
end;

function TGHashTableLP.DoFind(constref aKey: TKey; aKeyHash: SizeInt): SizeInt;
var
  I, Pos, h, Mask: SizeInt;
begin
  Mask := System.High(FList);
  aKeyHash := aKeyHash or USED_FLAG;
  Result := SLOT_NOT_FOUND;
  Pos := aKeyHash and Mask;
  for I := 0 to Mask do
    begin
      h := FList[Pos].Hash;
      if h = 0 then               // node empty => key not found
        exit(not Pos)
      else
        if (h = aKeyHash) and TEqRel.Equal(FList[Pos].Data.Key, aKey) then
          exit(Pos);              // key found
      Pos := Succ(Pos) and Mask;  // probe sequence
    end;
end;

procedure TGHashTableLP.DoRemove(aIndex: SizeInt);
var
  I, h, Gap, Mask: SizeInt;
begin
  Mask := System.High(FList);
  FList[aIndex].Hash := 0;
  FList[aIndex].Data := Default(TEntry);
  Gap := aIndex;
  aIndex := Succ(aIndex) and Mask;
  Dec(FCount);
  for I := 0 to Mask do
    begin
      h := FList[aIndex].Hash;
      if h <> 0 then
        begin
          h := h and Mask;
          if (h <> aIndex) and (Succ(aIndex - h + Mask) and Mask >= Succ(aIndex - Gap + Mask) and Mask) then
            begin
              TFakeNode(FList[Gap]) := TFakeNode(FList[aIndex]);
              TFakeNode(FList[aIndex]) := Default(TFakeNode);
              Gap := aIndex;
            end;
          aIndex := Succ(aIndex) and Mask;
        end
      else
        break;
    end;
end;

class function TGHashTableLP.NewList(aCapacity: SizeInt): TNodeList;
begin
  System.SetLength(Result, aCapacity);
  System.FillChar(Result[0], aCapacity * NODE_SIZE, 0);
end;

class function TGHashTableLP.EstimateCapacity(aCount: SizeInt; aLoadFactor: Single): SizeInt;
begin
  if aCount > 0 then
    Result := LGUtils.RoundUpTwoPower(Math.Min(Ceil64(Double(aCount) / aLoadFactor), MAX_CAPACITY))
  else
    Result := DEFAULT_CONTAINER_CAPACITY;
end;

class constructor TGHashTableLP.Init;
begin
{$PUSH}{$J+}
  MAX_CAPACITY := LGUtils.RoundUpTwoPower(MAX_CAPACITY);
{$POP}
end;

class function TGHashTableLP.DefaultLoadFactor: Single;
begin
  Result := DEFAULT_LOAD_FACTOR;
end;

class function TGHashTableLP.MaxLoadFactor: Single;
begin
  Result := MAX_LOAD_FACTOR;
end;

class function TGHashTableLP.MinLoadFactor: Single;
begin
  Result := MIN_LOAD_FACTOR;
end;

constructor TGHashTableLP.CreateEmpty;
begin
  FLoadFactor := DefaultLoadFactor;
end;

constructor TGHashTableLP.CreateEmpty(aLoadFactor: Single);
begin
  FLoadFactor := RestrictLoadFactor(aLoadFactor);
end;

constructor TGHashTableLP.Create;
begin
  FLoadFactor := DefaultLoadFactor;
  AllocList(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGHashTableLP.Create(aCapacity: SizeInt);
begin
  FLoadFactor := DefaultLoadFactor;
  AllocList(EstimateCapacity(aCapacity, LoadFactor));
end;

constructor TGHashTableLP.Create(aLoadFactor: Single);
begin
  FLoadFactor := RestrictLoadFactor(aLoadFactor);
  AllocList(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGHashTableLP.Create(aCapacity: SizeInt; aLoadFactor: Single);
begin
  FLoadFactor := RestrictLoadFactor(aLoadFactor);
  AllocList(EstimateCapacity(aCapacity, LoadFactor));
end;

function TGHashTableLP.GetEnumerator: TEnumerator;
begin
  Result.Init(FList);
end;

procedure TGHashTableLP.Clear;
begin
  FList := nil;
  FCount := 0;
  FExpandTreshold := 0;
end;

function TGHashTableLP.EnsureCapacity(aValue: SizeInt): Boolean;
var
  NewCapacity: SizeInt;
begin
  if aValue > ExpandTreshold then
    begin
      NewCapacity := EstimateCapacity(aValue, LoadFactor);
      if NewCapacity <> ListCapacity then
        try
          Resize(NewCapacity);
          Result := True;
        except
          Result := False;
        end;
    end
  else
    Result := True;
end;

procedure TGHashTableLP.TrimToFit;
var
  NewCapacity: SizeInt;
begin
  if Count > 0 then
    begin
      NewCapacity := EstimateCapacity(Count, LoadFactor);
      if NewCapacity < ListCapacity then
        Resize(NewCapacity);
    end
  else
    Clear;
end;

function TGHashTableLP.FindOrAdd(constref aKey: TKey; out e: PEntry; out aPos: SizeInt): Boolean;
var
  h: SizeInt;
begin
  if FList = nil then
    AllocList(DEFAULT_CONTAINER_CAPACITY);
  h := TEqRel.HashCode(aKey);
  aPos := DoFind(aKey, h);
  Result := aPos >= 0; // key found?
  if not Result then   // key not found, will add new slot
    begin
      if Count >= ExpandTreshold then
        begin
          Expand;
          aPos := DoFind(aKey, h);
        end;
      if aPos > SLOT_NOT_FOUND then
        begin
          aPos := not aPos;
          FList[aPos].Hash := h or USED_FLAG;
          Inc(FCount);
        end
      else
        raise ELGCapacityExceed.CreateFmt(SEClassCapacityExceedFmt, [ClassName, Succ(Count)]);
    end;
  e := @FList[aPos].Data;
end;

function TGHashTableLP.Find(constref aKey: TKey; out aPos: SizeInt): PEntry;
begin
  Result := nil;
  if Count > 0 then
    begin
      aPos := DoFind(aKey, TEqRel.HashCode(aKey));
      if aPos >= 0 then
        Result := @FList[aPos].Data;
    end;
end;

function TGHashTableLP.Remove(constref aKey: TKey): Boolean;
var
  Pos: SizeInt;
begin
  if Count > 0 then
    begin
      Pos := DoFind(aKey, TEqRel.HashCode(aKey));
      Result := Pos >= 0;
      if Result then
        DoRemove(Pos);
    end
  else
    Result := False;
end;

procedure TGHashTableLP.RemoveAt(constref aPos: SizeInt);
begin
  if (aPos >= 0) and (aPos <= System.High(FList)) then
    DoRemove(aPos);
end;

{ TGLiteHashTableLP.TEnumerator }

function TGLiteHashTableLP.TEnumerator.GetCurrent: PEntry;
begin
  Result := @FList[FCurrIndex].Data;
end;

procedure TGLiteHashTableLP.TEnumerator.Init(aList: TNodeList);
begin
  FList := aList;
  FLastIndex := System.High(aList);
  FCurrIndex := -1;
end;

function TGLiteHashTableLP.TEnumerator.MoveNext: Boolean;
begin
  repeat
    if FCurrIndex >= FLastIndex then
      exit(False);
    Inc(FCurrIndex);
    Result := FList[FCurrIndex].Hash <> 0;
  until Result;
end;

procedure TGLiteHashTableLP.TEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGLiteHashTableLP.TRemovableEnumerator }

function TGLiteHashTableLP.TRemovableEnumerator.GetCurrent: PEntry;
begin
  Result := FEnum.Current;
end;

procedure TGLiteHashTableLP.TRemovableEnumerator.Init(aTable: PLiteHashTableLP);
begin
  FTable := aTable;
  FEnum := aTable^.GetEnumerator;
end;

function TGLiteHashTableLP.TRemovableEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGLiteHashTableLP.TRemovableEnumerator.RemoveCurrent;
begin
  FTable^.DoRemove(FEnum.FCurrIndex);
  Dec(FEnum.FCurrIndex);
end;

procedure TGLiteHashTableLP.TRemovableEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGLiteHashTableLP }

function TGLiteHashTableLP.RestrictLoadFactor(aValue: Single): Single;
begin
  Result := Math.Min(Math.Max(aValue, MIN_LOAD_FACTOR), MAX_LOAD_FACTOR);
end;

procedure TGLiteHashTableLP.UpdateExpandTreshold;
begin
  if Size < MAX_CAPACITY then
    FExpandTreshold := Trunc(Size * LoadFactor)
  else
    FExpandTreshold := MAX_CAPACITY;
end;

procedure TGLiteHashTableLP.SetLoadFactor(aValue: Single);
begin
  aValue := RestrictLoadFactor(aValue);
  if aValue <> LoadFactor then
    begin
      FLoadFactor := aValue;
      UpdateExpandTreshold;
      if Count >= ExpandTreshold then
        Expand;
    end;
end;

function TGLiteHashTableLP.GetCapacity: SizeInt;
begin
  Result := ExpandTreshold;
end;

function TGLiteHashTableLP.GetFillRatio: Single;
var
  sz: SizeInt;
begin
  sz := Size;
  if sz > 0 then
    Result := Count / sz
  else
    Result := 0.0;
end;

function TGLiteHashTableLP.GetSize: SizeInt;
begin
  Result := System.Length(FList);
end;

procedure TGLiteHashTableLP.AllocList(aCapacity: SizeInt);
begin
  if aCapacity > 0 then
    begin
      aCapacity := Math.Min(aCapacity, MAX_CAPACITY);
      if not IsTwoPower(aCapacity) then
        aCapacity := LGUtils.RoundUpTwoPower(aCapacity);
    end
  else
    aCapacity := DEFAULT_CONTAINER_CAPACITY;
  FList := NewList(aCapacity);
  UpdateExpandTreshold;
end;

procedure TGLiteHashTableLP.Rehash(var aTarget: TNodeList);
var
  h, I, J, Mask: SizeInt;
begin
  if Count > 0 then
    begin
      Mask := System.High(aTarget);
      for I := 0 to System.High(FList) do
        begin
          if FList[I].Hash <> 0 then
            begin
              h := FList[I].Hash and Mask;
              for J := 0 to Mask do
                begin
                  if aTarget[h].Hash = 0 then // -> target node is empty
                    begin
                      TFakeNode(aTarget[h]) := TFakeNode(FList[I]);
                      TFakeEntry(FList[I].Data) := Default(TFakeEntry);
                      break;
                    end;
                  h := Succ(h) and Mask;     // probe sequence
                end;
            end;
        end;
    end;
end;

procedure TGLiteHashTableLP.Resize(aNewCapacity: SizeInt);
var
  List: TNodeList;
begin
  List := NewList(aNewCapacity);
  Rehash(List);
  FList := List;
  UpdateExpandTreshold;
end;

procedure TGLiteHashTableLP.Expand;
var
  NewSize, OldSize: SizeInt;
begin
  OldSize := Size;
  if OldSize > 0 then
    begin
      NewSize := Math.Min(MAX_CAPACITY, OldSize shl 1);
      if NewSize > OldSize then
        Resize(NewSize);
    end
  else
    AllocList(DEFAULT_CONTAINER_CAPACITY);
end;

function TGLiteHashTableLP.DoFind(constref aKey: TKey; aKeyHash: SizeInt): SizeInt;
var
  I, Pos, h, Mask: SizeInt;
begin
  Mask := System.High(FList);
  aKeyHash := aKeyHash or USED_FLAG;
  Result := SLOT_NOT_FOUND;
  Pos := aKeyHash and Mask;
  for I := 0 to Mask do
    begin
      h := FList[Pos].Hash;
      if h = 0 then               // node empty => key not found
        exit(not Pos)
      else
        if (h = aKeyHash) and TEqRel.Equal(FList[Pos].Data.Key, aKey) then
          exit(Pos);              // key found
      Pos := Succ(Pos) and Mask;  // probe sequence
    end;
end;

procedure TGLiteHashTableLP.DoRemove(aIndex: SizeInt);
var
  I, h, Gap, Mask: SizeInt;
begin
  Mask := System.High(FList);
  FList[aIndex].Hash := 0;
  FList[aIndex].Data := Default(TEntry);
  Gap := aIndex;
  aIndex := Succ(aIndex) and Mask;
  Dec(FCount);
  for I := 0 to Mask do
    begin
      h := FList[aIndex].Hash;
      if h <> 0 then
        begin
          h := h and Mask;
          if (h <> aIndex) and (Succ(aIndex - h + Mask) and Mask >= Succ(aIndex - Gap + Mask) and Mask) then
            begin
              TFakeNode(FList[Gap]) := TFakeNode(FList[aIndex]);
              TFakeNode(FList[aIndex]) := Default(TFakeNode);
              Gap := aIndex;
            end;
          aIndex := Succ(aIndex) and Mask;
        end
      else
        break;
    end;
end;

class function TGLiteHashTableLP.NewList(aCapacity: SizeInt): TNodeList;
begin
  System.SetLength(Result, aCapacity);
  System.FillChar(Result[0], aCapacity * NODE_SIZE, 0);
end;

class function TGLiteHashTableLP.EstimateSize(aCount: SizeInt; aLoadFactor: Single): SizeInt;
begin
  if aCount > 0 then
    Result := LGUtils.RoundUpTwoPower(Math.Min(Ceil64(Double(aCount) / aLoadFactor), MAX_CAPACITY))
  else
    Result := DEFAULT_CONTAINER_CAPACITY;
end;

class constructor TGLiteHashTableLP.Init;
begin
{$PUSH}{$J+}
  MAX_CAPACITY := LGUtils.RoundUpTwoPower(MAX_CAPACITY);
{$POP}
end;

class operator TGLiteHashTableLP.Initialize(var ht: TGLiteHashTableLP);
begin
  ht.FList := nil;
  ht.FCount := 0;
  ht.FExpandTreshold := 0;
  ht.FLoadFactor := DEFAULT_LOAD_FACTOR;
end;

class operator TGLiteHashTableLP.Finalize(var ht: TGLiteHashTableLP);
begin
  ht.Clear;
end;

class operator TGLiteHashTableLP.Copy(constref aSrc: TGLiteHashTableLP; var aDst: TGLiteHashTableLP);
begin
  aDst.FList := System.Copy(aSrc.FList);
end;

function TGLiteHashTableLP.GetEnumerator: TEnumerator;
begin
  Result.Init(FList);
end;

function TGLiteHashTableLP.RemovableEnumerator: TRemovableEnumerator;
begin
  Result.Init(@Self);
end;

procedure TGLiteHashTableLP.Clear;
begin
  FList := nil;
  FCount := 0;
  FExpandTreshold := 0;
end;

procedure TGLiteHashTableLP.EnsureCapacity(aValue: SizeInt);
var
  NewSize: SizeInt;
begin
  if aValue > ExpandTreshold then
    begin
      NewSize := EstimateSize(aValue, LoadFactor);
      if NewSize <> Size then
        Resize(NewSize);
    end;
end;

procedure TGLiteHashTableLP.TrimToFit;
var
  NewSize: SizeInt;
begin
  if Count > 0 then
    begin
      NewSize := EstimateSize(Count, LoadFactor);
      if NewSize < Size then
        Resize(NewSize);
    end
  else
    Clear;
end;

function TGLiteHashTableLP.FindOrAdd(constref aKey: TKey; out e: PEntry; out aPos: SizeInt): Boolean;
var
  h: SizeInt;
begin
  if FList = nil then
    AllocList(DEFAULT_CONTAINER_CAPACITY);
  h := TEqRel.HashCode(aKey);
  aPos := DoFind(aKey, h);
  Result := aPos >= 0; // key found?
  if not Result then   // key not found, will add new slot
    begin
      if Count >= ExpandTreshold then
        begin
          Expand;
          aPos := DoFind(aKey, h);
        end;
      if aPos > SLOT_NOT_FOUND then
        begin
          aPos := not aPos;
          FList[aPos].Hash := h or USED_FLAG;
          Inc(FCount);
        end
      else
        raise ELGCapacityExceed.CreateFmt(SECapacityExceedFmt, [Succ(Count)]);
    end;
  e := @FList[aPos].Data;
end;

function TGLiteHashTableLP.Find(constref aKey: TKey; out aPos: SizeInt): PEntry;
begin
  Result := nil;
  if Count > 0 then
    begin
      aPos := DoFind(aKey, TEqRel.HashCode(aKey));
      if aPos >= 0 then
        Result := @FList[aPos].Data;
    end;
end;

function TGLiteHashTableLP.Remove(constref aKey: TKey): Boolean;
var
  Pos: SizeInt;
begin
  if Count > 0 then
    begin
      Pos := DoFind(aKey, TEqRel.HashCode(aKey));
      Result := Pos >= 0;
      if Result then
        DoRemove(Pos);
    end
  else
    Result := False;
end;

procedure TGLiteHashTableLP.RemoveAt(constref aPos: SizeInt);
begin
  if (aPos >= 0) and (aPos <= System.High(FList)) then
    DoRemove(aPos);
end;

{ TGLiteHashList.TEnumerator }

function TGLiteHashList.TEnumerator.GetCurrent: T;
begin
  Result := FList[FCurrIndex].Data;
end;

procedure TGLiteHashList.TEnumerator.Init(constref aList: TGLiteHashList);
begin
  FList := aList.FNodeList;
  FLastIndex := System.High(FList);
  FCurrIndex := -1;
end;

function TGLiteHashList.TEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLastIndex;
  FCurrIndex += Ord(Result);
end;

procedure TGLiteHashList.TEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGLiteHashList.TReverseEnumerator }

function TGLiteHashList.TReverseEnumerator.GetCurrent: T;
begin
  Result := FList[FCurrIndex].Data;
end;

procedure TGLiteHashList.TReverseEnumerator.Init(constref aList: TGLiteHashList);
begin
  FList := aList.FNodeList;
  FCount := aList.Count;
  FCurrIndex := FCount;
end;

function TGLiteHashList.TReverseEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex > 0;
  FCurrIndex -= Ord(Result);
end;

procedure TGLiteHashList.TReverseEnumerator.Reset;
begin
  FCurrIndex := FCount;
end;

{ TGLiteHashList.TReverse }

procedure TGLiteHashList.TReverse.Init(aList: PLiteHashList);
begin
  FList := aList;
end;

function TGLiteHashList.TReverse.GetEnumerator: TReverseEnumerator;
begin
  Result := FList^.GetReverseEnumerator;
end;

{ TGLiteHashList }

function TGLiteHashList.GetCapacity: SizeInt;
begin
  Result := System.Length(FNodeList);
end;

function TGLiteHashList.GetItem(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := FNodeList[aIndex].Data;
end;

procedure TGLiteHashList.SetItem(aIndex: SizeInt; const aValue: T);
var
  I: SizeInt;
begin
  CheckIndexRange(aIndex);
  if TEqRel.Equal(aValue, FNodeList[aIndex].Data) then
    exit;
  RemoveFromChain(aIndex);
  //add to new chain
  FNodeList[aIndex].Data := aValue;
  FNodeList[aIndex].Hash := TEqRel.HashCode(aValue);
  I := FNodeList[aIndex].Hash and Pred(Capacity);
  FNodeList[aIndex].Next := FHashList[I];
  FHashList[I] := aIndex;
end;

procedure TGLiteHashList.InitialAlloc;
begin
  if Capacity = 0 then
    begin
      System.SetLength(FNodeList, DEFAULT_CONTAINER_CAPACITY);
      FHashList := NewHashList(DEFAULT_CONTAINER_CAPACITY);
    end;
end;

procedure TGLiteHashList.Rehash;
var
  I, J, Mask: SizeInt;
begin
  Mask := Pred(Capacity);
  for I := 0 to Pred(Count) do
    begin
      J := FNodeList[I].Hash and Mask;
      FNodeList[I].Next := FHashList[J];
      FHashList[J] := I;
    end;
end;

procedure TGLiteHashList.Resize(aNewCapacity: SizeInt);
begin
  System.SetLength(FNodeList, aNewCapacity);
  FHashList := NewHashList(aNewCapacity);
  Rehash;
end;

procedure TGLiteHashList.Expand;
var
  NewSize, OldSize: SizeInt;
begin
  OldSize := Capacity;
  if OldSize > 0 then
    begin
      NewSize := Math.Min(MAX_CAPACITY, OldSize shl 1);
      if NewSize > OldSize then
        Resize(NewSize);
    end
  else
    InitialAlloc;
end;

function TGLiteHashList.Find(constref aValue: T): SizeInt;
var
  h, I: SizeInt;
begin
  h := TEqRel.HashCode(aValue);
  I := FHashList[h and Pred(Capacity)];
  while I <> NULL_INDEX do
    begin
      if (FNodeList[I].Hash = h) and TEqRel.Equal(FNodeList[I].Data, aValue) then
        exit(I);
      I := FNodeList[I].Next;
    end;
  Result := NULL_INDEX;
end;

function TGLiteHashList.GetCount(constref aValue: T): SizeInt;
var
  h, I: SizeInt;
begin
  h := TEqRel.HashCode(aValue);
  I := FHashList[h and Pred(Capacity)];
  Result := 0;
  while I <> NULL_INDEX do
    begin
      if (FNodeList[I].Hash = h) and TEqRel.Equal(FNodeList[I].Data, aValue) then
        Inc(Result);
      I := FNodeList[I].Next;
    end;
end;

function TGLiteHashList.DoAdd(constref aValue: T): SizeInt;
var
  I: SizeInt;
begin
  FNodeList[Count].Hash := TEqRel.HashCode(aValue);
  I := FNodeList[Count].Hash and Pred(Capacity);
  FNodeList[Count].Data := aValue;
  FNodeList[Count].Next := FHashList[I];
  FHashList[I] := Count;
  Inc(FCount);
end;

procedure TGLiteHashList.DoInsert(aIndex: SizeInt; constref aValue: T);
begin
  System.Move(FNodeList[aIndex], FNodeList[Succ(aIndex)], (Count - aIndex) * NODE_SIZE);
  System.FillChar(FNodeList[aIndex].Data, SizeOf(T), 0);
  FNodeList[aIndex].Hash := TEqRel.HashCode(aValue);
  FNodeList[aIndex].Data := aValue;
  Inc(FCount);
  System.FillChar(FHashList[0], Capacity * SizeOf(SizeInt), $ff);
  Rehash;
end;

procedure TGLiteHashList.DoDelete(aIndex: SizeInt);
begin
  Dec(FCount);
  FNodeList[aIndex].Data := Default(T);
  System.Move(FNodeList[Succ(aIndex)], FNodeList[aIndex], (Count - aIndex) * NODE_SIZE);
  System.FillChar(FNodeList[Count].Data, SizeOf(T), 0);
  System.FillChar(FHashList[0], Capacity * SizeOf(SizeInt), $ff);
  Rehash;
end;

procedure TGLiteHashList.RemoveFromChain(aIndex: SizeInt);
var
  I, Curr, Prev: SizeInt;
begin
  I := FNodeList[aIndex].Hash and Pred(Capacity);
  Curr := FHashList[I];
  Prev := NULL_INDEX;
  while Curr <> aIndex do
    begin
      if Curr = aIndex then
        begin
          if Prev <> NULL_INDEX then
            FNodeList[Prev].Next := FNodeList[Curr].Next
          else
            FHashList[I] := FNodeList[Curr].Next;
        end
      else
        Prev := Curr;
      Curr := FNodeList[Curr].Next;
    end;
end;

function TGLiteHashList.DoRemove(constref aValue: T): Boolean;
var
  Removed: SizeInt;
begin
  Removed := Find(aValue);
  Result := Removed >= 0;
  if Result then
    DoDelete(Removed);
end;

function TGLiteHashList.GetReverseEnumerator: TReverseEnumerator;
begin
  Result.Init(Self);
end;

function TGLiteHashList.IndexInRange(aIndex: SizeInt): Boolean;
begin
  Result := (aIndex >= 0) and (aIndex < Count);
end;

function TGLiteHashList.IndexInInsertRange(aIndex: SizeInt): Boolean;
begin
  Result := (aIndex >= 0) and (aIndex <= Count);
end;

procedure TGLiteHashList.CheckIndexRange(aIndex: SizeInt);
begin
  if not IndexInRange(aIndex) then
    IndexOutOfBoundError(aIndex);
end;

procedure TGLiteHashList.CheckInsertIndexRange(aIndex: SizeInt);
begin
  if not IndexInInsertRange(aIndex) then
    IndexOutOfBoundError(aIndex);
end;

class constructor TGLiteHashList.Init;
begin
{$PUSH}{$J+}
  MAX_CAPACITY := LGUtils.RoundUpTwoPower(MAX_CAPACITY);
{$POP}
end;

class function TGLiteHashList.NewHashList(aCapacity: SizeInt): THashList;
begin
  System.SetLength(Result, aCapacity);
  System.FillChar(Result[0], aCapacity * SizeOf(SizeInt), $ff);
end;

class procedure TGLiteHashList.IndexOutOfBoundError(aIndex: SizeInt);
begin
  raise ELGListError.CreateFmt(SEIndexOutOfBoundsFmt, [aIndex]);
end;

class procedure TGLiteHashList.CapacityExceedError(aValue: SizeInt);
begin
  raise ELGCapacityExceed.CreateFmt(SECapacityExceedFmt, [aValue]);
end;

class operator TGLiteHashList.Initialize(var hl: TGLiteHashList);
begin
  hl.FCount := 0;
end;

class operator TGLiteHashList.Finalize(var hl: TGLiteHashList);
begin
  hl.Clear;
end;

class operator TGLiteHashList.Copy(constref aSrc: TGLiteHashList; var aDst: TGLiteHashList);
begin
  aDst.FNodeList := System.Copy(aSrc.FNodeList);
  aDst.FHashList := System.Copy(aSrc.FHashList);
end;

function TGLiteHashList.GetEnumerator: TEnumerator;
begin
  Result.Init(Self);
end;

function TGLiteHashList.ToArray: TArray;
begin

end;

function TGLiteHashList.Reverse: TReverse;
begin
  Result.Init(@Self);
end;

procedure TGLiteHashList.Clear;
begin
  FNodeList := nil;
  FHashList := nil;
  FCount := 0;
end;

function TGLiteHashList.IsEmpty: Boolean;
begin
  Result := Count = 0;
end;

function TGLiteHashList.NonEmpty: Boolean;
begin
  Result := Count <> 0;
end;

procedure TGLiteHashList.EnsureCapacity(aValue: SizeInt);
begin
  if aValue <= Capacity then
    exit;
  if aValue <= DEFAULT_CONTAINER_CAPACITY then
    aValue := DEFAULT_CONTAINER_CAPACITY
  else
    if aValue < MAX_CAPACITY then
      aValue := LGUtils.RoundUpTwoPower(aValue)
    else
      CapacityExceedError(aValue);
  Resize(aValue);
end;

procedure TGLiteHashList.TrimToFit;
var
  NewSize: SizeInt;
begin
  if NonEmpty then
    begin
      NewSize := LGUtils.RoundUpTwoPower(Count);
      if NewSize < Capacity then
        Resize(NewSize);
    end
  else
    Clear;
end;

function TGLiteHashList.Contains(constref aValue: T): Boolean;
begin
  Result := IndexOf(aValue) >= 0;
end;

function TGLiteHashList.NonContains(constref aValue: T): Boolean;
begin
  Result := IndexOf(aValue) < 0;
end;

function TGLiteHashList.IndexOf(constref aValue: T): SizeInt;
begin
  if NonEmpty then
    Result := Find(aValue)
  else
    Result := NULL_INDEX;
end;

function TGLiteHashList.CountOf(constref aValue: T): SizeInt;
begin
  if NonEmpty then
    Result := GetCount(aValue)
  else
    Result := 0;
end;

function TGLiteHashList.Add(constref aValue: T): SizeInt;
begin
  if Count = Capacity then
    Expand;
  Result := DoAdd(aValue);
end;

function TGLiteHashList.AddAll(constref a: array of T): SizeInt;
var
  v: T;
begin
  Result := System.Length(a);
  EnsureCapacity(Count + Result);
  for v in a do
    DoAdd(v);
end;

function TGLiteHashList.AddAll(e: IEnumerable): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in e do
    begin
      Add(v);
      Inc(Result);
    end;
end;

procedure TGLiteHashList.Insert(aIndex: SizeInt; constref aValue: T);
begin
  CheckInsertIndexRange(aIndex);
  if Count = Capacity then
    Expand;
  DoInsert(aIndex, aValue);
end;

procedure TGLiteHashList.Delete(aIndex: SizeInt);
begin
  CheckIndexRange(aIndex);
  DoDelete(aIndex);
end;

function TGLiteHashList.Remove(constref aValue: T): Boolean;
begin
  if NonEmpty then
    Result := DoRemove(aValue)
  else
    Result := False;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Helpers for some basic types.                                           *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGHelpers;

{$MODE OBJFPC}{$H+}
{$MODESWITCH TYPEHELPERS}
{$MODESWITCH ADVANCEDRECORDS}
{$INLINE ON}

interface

uses

  SysUtils,
  typinfo,
  variants,
  LGUtils,
  LgHash;

type

  TGGuidHelper = record helper(TGuidHelper) for TGUID
  type
    class function HashCode(constref aValue: TGUID): SizeInt; static; inline;
    class function Equal(constref L, R: TGUID): Boolean; static; inline;
    class function Compare(constref L, R: TGUID): SizeInt; static; inline;
  end;

  { TStrHelper }

  TStrHelper = type helper for string
    class function HashCode(constref aValue: string): SizeInt; static; inline;
    class function Equal(constref L, R: string): Boolean; static; inline;
    class function Compare(constref L, R: string): SizeInt; static; inline;
  end;

  { TAStrHelper }

  TAStrHelper = type helper(TStringHelper) for ansistring
    class function HashCode(constref aValue: ansistring): SizeInt; static; inline;
    class function Equal(constref L, R: ansistring): Boolean; static; inline;
    class function Compare(constref L, R: ansistring): SizeInt; static; inline;
  end;

  { TWStrHelper }

  TWStrHelper = type helper for widestring
    class function HashCode(constref aValue: widestring): SizeInt; static; inline;
    class function Equal(constref L, R: widestring): Boolean; static; inline;
    class function Compare(constref L, R: widestring): SizeInt; static; inline;
  end;

  { TUStrHelper }

  TUStrHelper = type helper for unicodestring
    class function HashCode(constref aValue: unicodestring): SizeInt; static; inline;
    class function Equal(constref L, R: unicodestring): Boolean; static; inline;
    class function Compare(constref L, R: unicodestring): SizeInt; static; inline;
  end;

  { TShortStrHelper }

  TShortStrHelper = type helper for shortstring
    class function HashCode(constref aValue: shortstring): SizeInt; static; inline;
    class function Equal(constref L, R: shortstring): Boolean; static; inline;
    class function Compare(constref L, R: shortstring): SizeInt; static; inline;
  end;

  TGACharHelper = type helper for AnsiChar
    class function HashCode(aValue: AnsiChar): SizeInt; static; inline;
    class function Equal(L, R: AnsiChar): Boolean; static; inline;
    class function Compare(L, R: AnsiChar): SizeInt; static; inline;
  end;

  TGWCharHelper = type helper for WideChar
    class function HashCode(aValue: WideChar): SizeInt; static; inline;
    class function Equal(L, R: WideChar): Boolean; static; inline;
    class function Compare(L, R: WideChar): SizeInt; static; inline;
  end;

  TGByteHelper = type helper(TByteHelper) for Byte
    class function HashCode(aValue: Byte): SizeInt; static; inline;
    class function Equal(L, R: Byte): Boolean; static; inline;
    class function Compare(L, R: Byte): SizeInt; static; inline;
  end;

  TGShortIntHelper = type helper(TShortIntHelper) for ShortInt
    class function HashCode(aValue: ShortInt): SizeInt; static; inline;
    class function Equal(L, R: ShortInt): Boolean; static; inline;
    class function Compare(L, R: ShortInt): SizeInt; static; inline;
  end;

  TGWordHelper = type helper(TWordHelper) for Word
    class function HashCode(aValue: Word): SizeInt; static; inline;
    class function Equal(L, R: Word): Boolean; static; inline;
    class function Compare(L, R: Word): SizeInt; static; inline;
  end;

  TGSmallIntHelper = type helper(TSmallIntHelper) for SmallInt
    class function HashCode(aValue: SmallInt): SizeInt; static; inline;
    class function Equal(L, R: SmallInt): Boolean; static; inline;
    class function Compare(L, R: SmallInt): SizeInt; static; inline;
  end;

  TGDWordHelper = type helper(TCardinalHelper) for DWord
    class function HashCode(aValue: DWord): SizeInt; static; inline;
    class function Equal(L, R: DWord): Boolean; static; inline;
    class function Compare(L, R: DWord): SizeInt; static; inline;
  end;

  TGLongIntHelper = type helper(TIntegerHelper) for LongInt
    class function HashCode(aValue: LongInt): SizeInt; static; inline;
    class function Equal(L, R: LongInt): Boolean; static; inline;
    class function Compare(L, R: LongInt): SizeInt; static; inline;
  end;

  TGQWordHelper = type helper(TQWordHelper) for QWord
    class function HashCode(aValue: QWord): SizeInt; static; inline;
    class function Equal(L, R: QWord): Boolean; static; inline;
    class function Compare(L, R: QWord): SizeInt; static; inline;
  end;

  TGInt64Helper = type helper(TInt64Helper) for Int64
    class function HashCode(aValue: Int64): SizeInt; static; inline;
    class function Equal(L, R: Int64): Boolean; static; inline;
    class function Compare(L, R: Int64): SizeInt; static; inline;
  end;

  TGNativeUIntHelper = type helper(TNativeUIntHelper) for NativeUInt
    class function HashCode(aValue: NativeUInt): SizeInt; static; inline;
    class function Equal(L, R: NativeUInt): Boolean; static; inline;
    class function Compare(L, R: NativeUInt): SizeInt; static; inline;
  end;

  TGNativeIntHelper = type helper(TNativeIntHelper) for NativeInt
    class function HashCode(aValue: NativeInt): SizeInt; static; inline;
    class function Equal(L, R: NativeInt): Boolean; static; inline;
    class function Compare(L, R: NativeInt): SizeInt; static; inline;
  end;

  TGPointerHelper = type helper for Pointer
    class function HashCode(aValue: Pointer): SizeInt; static; inline;
    class function Equal(L, R: Pointer): Boolean; static; inline;
    class function Compare(L, R: Pointer): SizeInt; static; inline;
  end;

 // currently special float types (nan, infinity) are ignored

  TGSingleHelper = type helper(TSingleHelper) for Single
    function IsZero: Boolean; inline;
    class function HashCode(aValue: Single): SizeInt; static; inline;
    class function Equal(L, R: Single): Boolean; static; inline;
    class function Compare(L, R: Single): SizeInt; static; inline;
  end;

  TGDoubleHelper = type helper(TDoubleHelper) for Double
    function IsZero: Boolean; inline;
    class function HashCode(aValue: Double): SizeInt; static; inline;
    class function Equal(L, R: Double): Boolean; static; inline;
    class function Compare(L, R: Double): SizeInt; static; inline;
  end;

{$ifdef FPC_HAS_TYPE_EXTENDED}
  TGExtendedHelper = type helper(TExtendedHelper) for Extended
    function IsZero: Boolean; inline;
    class function HashCode(aValue: Extended): SizeInt; static; inline;
    class function Equal(L, R: Extended): Boolean; static; inline;
    class function Compare(L, R: Extended): SizeInt; static; inline;
  end;
{$ENDIF}

  TCompHelper = type helper for Comp
    class function HashCode(aValue: Comp): SizeInt; static; inline;
    class function Equal(L, R: Comp): Boolean; static; inline;
    class function Compare(L, R: Comp): SizeInt; static; inline;
  end;

  TGDateTimeHelper = type helper for TDateTime
    class function HashCode(aValue: TDateTime): SizeInt; static; inline;
    class function Equal(L, R: TDateTime): Boolean; static; inline;
    class function Compare(L, R: TDateTime): SizeInt; static; inline;
  end;

  TGDateHelper = type helper for TDate
    class function HashCode(aValue: TDate): SizeInt; static; inline;
    class function Equal(L, R: TDate): Boolean; static; inline;
    class function Compare(L, R: TDate): SizeInt; static; inline;
  end;

  TGTimeHelper = type helper for TTime
    class function HashCode(aValue: TTime): SizeInt; static; inline;
    class function Equal(L, R: TTime): Boolean; static; inline;
    class function Compare(L, R: TTime): SizeInt; static; inline;
  end;

  TGCurrencyHelper = type helper for Currency
   class function HashCode(const aValue: Currency): SizeInt; static; inline;
   class function Equal(const L, R: Currency): Boolean; static; inline;
   class function Compare(const L, R: Currency): SizeInt; static; inline;
  end;

  TGObjectHelper = class helper for TObject
   class function HashCode(aValue: TObject): SizeInt; static; inline;
   class function Equal(L, R: TObject): Boolean; static; inline;
   class function Compare(L, R: TObject): SizeInt; static; inline;
  end;

  TVariantHelper = type helper for Variant
    class function HashCode(constref aValue: Variant): SizeInt; static; inline;
    class function Equal(constref L, R: Variant): Boolean; static; inline;
    class function Compare(constref L, R: Variant): SizeInt; static; inline;
  end;

  TStringArrayHelper = type helper for TStringArray
  private
    function  GetLength: SizeInt;
    procedure SetLen(aValue: SizeInt);
  public
    function  IsEmpty: Boolean;
    function  NonEmpty: Boolean;
    procedure Add(constref aValue: string);
    property  Length: SizeInt read GetLength write SetLen;
  end;

  PTypeInfo = TypInfo.PTypeInfo;
  PTypeData = TypInfo.PTypeData;

  generic TGDefaults<T> = class
  public
  type
    TCompare          = specialize TGCompare<T>;
    TOnCompare        = specialize TGOnCompare<T>;
    TEqualCompare     = specialize TGEqualCompare<T>;
    TOnEqualCompare   = specialize TGOnEqualCompare<T>;

    TComparer = class
      class function Compare(constref L, R: T): SizeInt; static; inline;
    end;

    TEqualityComparer = class
      class function Equal(constref L, R: T): Boolean; static; inline;
      class function HashCode(constref aValue: T): SizeInt; static; inline;
    end;

  private
  type
    THashCode = function(constref aValue: T): SizeInt;

    TComparator = object
      function Compare(constref L, R: T): SizeInt;
      function EqualCompare(constref L, R: T): Boolean;
    end;

  class var
    CFCompare: TCompare;
    CFEqualCompare: TEqualCompare;
    CFHashCode: THashCode;
    CFComparator: TComparator;
    class constructor Init;
    class procedure InitInt(aData: PTypeData); static;
    class procedure InitFloat(aData: PTypeData); static;
    class function CompareBin(constref L, R: T): SizeInt; static;
    class function EqualBin(constref L, R: T): Boolean; static;
    class function HashBin(constref aValue: T): SizeInt; static;
    class function GetOnCompare: TOnCompare; static; inline;
    class function GetOnEqualCompare: TOnEqualCompare; static; inline;
  public
    class property Compare: TCompare read CFCompare;
    class property EqualCompare: TEqualCompare read CFEqualCompare;
    class property OnCompare: TOnCompare read GetOnCompare;
    class property OnEqualCompare: TOnEqualCompare read GetOnEqualCompare;
  end;

  function CompareShortInt(constref L, R: ShortInt): SizeInt;
  function CompareUByte(constref L, R: Byte): SizeInt;
  function CompareSmallInt(constref L, R: SmallInt): SizeInt;
  function CompareWord(constref L, R: Word): SizeInt;
  function CompareLongInt(constref L, R: LongInt): SizeInt;
  function CompareDWord(constref L, R: DWord): SizeInt;
  function CompareInt64(constref L, R: Int64): SizeInt;
  function CompareQWord(constref L, R: QWord): SizeInt;
  function CompareChar(constref L, R: AnsiChar): SizeInt;
  function CompareSingle(constref L, R: Single): SizeInt;
  function CompareDouble(constref L, R: Double): SizeInt;
  function CompareExtended(constref L, R: Extended): SizeInt;
  function CompareComp(constref L, R: Comp): SizeInt;
  function CompareCurrency(constref L, R: Currency): SizeInt;
  function CompareShortStr(constref L, R: shortstring): SizeInt;
  function CompareLStr(constref L, R: string): SizeInt;
  function CompareAStr(constref L, R: ansistring): SizeInt;
  function CompareWStr(constref L, R: widestring): SizeInt;
  function CompareVariant(constref L, R: Variant): SizeInt;
  function CompareObj(constref L, R: TObject): SizeInt;
  function CompareWChar(constref L, R: WideChar): SizeInt;
  function CompareUStr(constref L, R: unicodestring): SizeInt;
  function ComparePointer(constref L, R: Pointer): SizeInt;

  function ShortIntEqual(constref L, R: ShortInt): Boolean;
  function UByteEqual(constref L, R: Byte): Boolean;
  function SmallIntEqual(constref L, R: SmallInt): Boolean;
  function WordEqual(constref L, R: Word): Boolean;
  function LongIntEqual(constref L, R: LongInt): Boolean;
  function DWordEqual(constref L, R: DWord): Boolean;
  function Int64Equal(constref L, R: Int64): Boolean;
  function QWordEqual(constref L, R: QWord): Boolean;
  function CharEqual(constref L, R: AnsiChar): Boolean;
  function SingleEqual(constref L, R: Single): Boolean;
  function DoubleEqual(constref L, R: Double): Boolean;
  function ExtendedEqual(constref L, R: Extended): Boolean;
  function CompEqual(constref L, R: Comp): Boolean;
  function CurrencyEqual(constref L, R: Currency): Boolean;
  function ShortStrEqual(constref L, R: shortstring): Boolean;
  function LStrEqual(constref L, R: string): Boolean;
  function AStrEqual(constref L, R: ansistring): Boolean;
  function WStrEqual(constref L, R: widestring): Boolean;
  function VariantEqual(constref L, R: Variant): Boolean;
  function ObjEqual(constref L, R: TObject): Boolean;
  function WCharEqual(constref L, R: WideChar): Boolean;
  function UStrEqual(constref L, R: unicodestring): Boolean;
  function PointerEqual(constref L, R: Pointer): Boolean;

  function HashShortInt(constref aValue: ShortInt): SizeInt;
  function HashUByte(constref aValue: Byte): SizeInt;
  function HashSmallInt(constref aValue: SmallInt): SizeInt;
  function HashWord(constref aValue: Word): SizeInt;
  function HashLongInt(constref aValue: LongInt): SizeInt;
  function HashDWord(constref aValue: DWord): SizeInt;
  function HashInt64(constref aValue: Int64): SizeInt;
  function HashQWord(constref aValue: QWord): SizeInt;
  function HashChar(constref aValue: AnsiChar): SizeInt;
  function HashSingle(constref aValue: Single): SizeInt;
  function HashDouble(constref aValue: Double): SizeInt;
  function HashExtended(constref aValue: Extended): SizeInt;
  function HashComp(constref aValue: Comp): SizeInt;
  function HashCurrency(constref aValue: Currency): SizeInt;
  function HashShortStr(constref aValue: shortstring): SizeInt;
  function HashLStr(constref aValue: string): SizeInt;
  function HashAStr(constref aValue: ansistring): SizeInt;
  function HashWStr(constref aValue: widestring): SizeInt;
  function HashVariant(constref aValue: Variant): SizeInt;
  function HashObj(constref aValue: TObject): SizeInt;
  function HashWChar(constref aValue: WideChar): SizeInt;
  function HashUStr(constref aValue: unicodestring): SizeInt;
  function HashPointer(constref aValue: Pointer): SizeInt;

implementation
{$Q-}{$B-}{$COPERATORS ON}{$MACRO ON}
{$DEFINE HashFunc := TxxHash32LE}
{.$DEFINE HashFunc := TMurmur3LE}

class function TGGuidHelper.HashCode(constref aValue: TGUID): SizeInt;
begin
  Result := HashFunc.HashGuid(aValue);
end;

class function TGGuidHelper.Equal(constref L, R: TGUID): Boolean;
type
  TDWords4 = packed record
    D1, D2, D3, D4: DWord;
  end;
var
  dL: TDWords4 absolute L;
  dR: TDWords4 absolute R;
begin
  if @L = @R then
    exit(True);
  Result := (dL.D1 = dR.D1) and (dL.D2 = dR.D2) and (dL.D3 = dR.D3) and (dL.D4 = dR.D4);
end;

class function TGGuidHelper.Compare(constref L, R: TGUID): SizeInt;
begin
  // todo: compare as 128-bit numbers ???
  Result := CompareMemRange(@L, @R, SizeOf(TGUID));
end;

{ TStrHelper }

class function TStrHelper.HashCode(constref aValue: string): SizeInt;
begin
  Result := HashFunc.HashStr(aValue);
end;

class function TStrHelper.Equal(constref L, R: string): Boolean;
begin
  Result := L = R;
end;

class function TStrHelper.Compare(constref L, R: string): SizeInt;
begin
  Result := CompareStr(L, R);
end;

class function TAStrHelper.HashCode(constref aValue: ansistring): SizeInt;
begin
  Result := HashFunc.HashStr(aValue);
end;

class function TAStrHelper.Equal(constref L, R: ansistring): Boolean;
begin
  Result := L = R;
end;

class function TAStrHelper.Compare(constref L, R: ansistring): SizeInt;
begin
  //Result := StrComp(PAnsiChar(L), PAnsiChar(R));
  Result := AnsiCompareStr(L, R);
end;

class function TWStrHelper.HashCode(constref aValue: widestring): SizeInt;
begin
  Result := HashFunc.HashBuf(PWideChar(aValue), System.Length(aValue) * SizeOf(System.WideChar));
end;

class function TWStrHelper.Equal(constref L, R: widestring): Boolean;
begin
  Result := L = R;
end;

class function TWStrHelper.Compare(constref L, R: widestring): SizeInt;
begin
  //Result := StrComp(PWideChar(L), PWideChar(R));
  Result := WideCompareStr(L, R);
end;

class function TUStrHelper.HashCode(constref aValue: unicodestring): SizeInt;
begin
  Result := HashFunc.HashBuf(PUnicodeChar(aValue), System.Length(aValue) * SizeOf(System.UnicodeChar));
end;

class function TUStrHelper.Equal(constref L, R: unicodestring): Boolean;
begin
  Result := L = R;
end;

class function TUStrHelper.Compare(constref L, R: unicodestring): SizeInt;
begin
  Result := UnicodeCompareStr(L, R);
end;

class function TShortStrHelper.HashCode(constref aValue: shortstring): SizeInt;
begin
  Result := HashFunc.HashBuf(@aValue[1], System.Length(aValue));
end;

class function TShortStrHelper.Equal(constref L, R: shortstring): Boolean;
begin
  Result := L = R;
end;

class function TShortStrHelper.Compare(constref L, R: shortstring): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGACharHelper.HashCode(aValue: AnsiChar): SizeInt;
begin
  //Result := Ord(aValue);
  Result := Ord(aValue) xor Ord(aValue) shr 5;
end;

class function TGACharHelper.Equal(L, R: AnsiChar): Boolean;
begin
  Result := L = R;
end;

class function TGACharHelper.Compare(L, R: AnsiChar): SizeInt;
begin
  Result := SizeInt(L) - SizeInt(R);
end;

class function TGWCharHelper.HashCode(aValue: WideChar): SizeInt;
begin
  Result := HashFunc.HashWord(Word(aValue));
end;

class function TGWCharHelper.Equal(L, R: WideChar): Boolean;
begin
  Result := L = R;
end;

class function TGWCharHelper.Compare(L, R: WideChar): SizeInt;
begin
{$IFNDEF CPU16}
  Result := SizeInt(L) - SizeInt(R);
{$ELSE !CPU16}
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
{$ENDIF !CPU16}
end;

class function TGByteHelper.HashCode(aValue: Byte): SizeInt;
begin
  Result := aValue xor aValue shr 5;
end;

class function TGByteHelper.Equal(L, R: Byte): Boolean;
begin
  Result := L = R;
end;

class function TGByteHelper.Compare(L, R: Byte): SizeInt;
begin
  Result := SizeInt(L) - SizeInt(R);
end;

class function TGShortIntHelper.HashCode(aValue: ShortInt): SizeInt;
begin
  Result := aValue xor aValue shr 5;
end;

class function TGShortIntHelper.Equal(L, R: ShortInt): Boolean;
begin
  Result := L = R;
end;

class function TGShortIntHelper.Compare(L, R: ShortInt): SizeInt;
begin
  Result := SizeInt(L) - SizeInt(R);
end;

class function TGWordHelper.HashCode(aValue: Word): SizeInt;
begin
  Result := HashFunc.HashWord(aValue);
end;

class function TGWordHelper.Equal(L, R: Word): Boolean;
begin
  Result := L = R;
end;

class function TGWordHelper.Compare(L, R: Word): SizeInt;
begin
{$IFNDEF CPU16}
  Result := SizeInt(L) - SizeInt(R);
{$ELSE !CPU16}
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
{$ENDIF !CPU16}
end;

class function TGSmallIntHelper.HashCode(aValue: SmallInt): SizeInt;
begin
  Result := HashFunc.HashWord(Word(aValue));
end;

class function TGSmallIntHelper.Equal(L, R: SmallInt): Boolean;
begin
  Result := L = R;
end;

class function TGSmallIntHelper.Compare(L, R: SmallInt): SizeInt;
begin
{$IFNDEF CPU16}
  Result := SizeInt(L) - SizeInt(R);
{$ELSE !CPU16}
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
{$ENDIF !CPU16}
end;

class function TGDWordHelper.HashCode(aValue: DWord): SizeInt;
begin
  Result := HashFunc.HashDWord(aValue);
end;

class function TGDWordHelper.Equal(L, R: DWord): Boolean;
begin
  Result := L = R;
end;

class function TGDWordHelper.Compare(L, R: DWord): SizeInt;
begin
{$IFDEF CPU64}
  Result := SizeInt(L) - SizeInt(R);
{$ELSE CPU64}
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
{$ENDIF CPU64}
end;

class function TGLongIntHelper.HashCode(aValue: LongInt): SizeInt;
begin
  Result := SizeInt(HashFunc.HashDWord(DWord(aValue)));
end;

class function TGLongIntHelper.Equal(L, R: LongInt): Boolean;
begin
  Result := L = R;
end;

class function TGLongIntHelper.Compare(L, R: LongInt): SizeInt;
begin
{$IFDEF CPU64}
  Result := SizeInt(L) - SizeInt(R);
{$ELSE CPU64}
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
{$ENDIF CPU64}
end;

class function TGQWordHelper.HashCode(aValue: QWord): SizeInt;
begin
  Result := HashFunc.HashQWord(aValue);
end;

class function TGQWordHelper.Equal(L, R: QWord): Boolean;
begin
  Result := L = R;
end;

class function TGQWordHelper.Compare(L, R: QWord): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGInt64Helper.HashCode(aValue: Int64): SizeInt;
begin
  Result := HashFunc.HashQWord(QWord(aValue));
end;

class function TGInt64Helper.Equal(L, R: Int64): Boolean;
begin
  Result := L = R;
end;

class function TGInt64Helper.Compare(L, R: Int64): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGNativeUIntHelper.HashCode(aValue: NativeUInt): SizeInt;
begin
{$IF DEFINED(CPU64)}
  Result := HashFunc.HashQWord(aValue);
{$ELSEIF DEFINED(CPU32)}
  Result := HashFunc.HashDWord(aValue);
{$ELSE}
  Result := HashFunc.HasWord(aValue);
{$ENDIF}
end;

class function TGNativeUIntHelper.Equal(L, R: NativeUInt): Boolean;
begin
  Result := L = R;
end;

class function TGNativeUIntHelper.Compare(L, R: NativeUInt): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGNativeIntHelper.HashCode(aValue: NativeInt): SizeInt;
begin
{$IF DEFINED(CPU64)}
  Result := HashFunc.HashQWord(aValue);
{$ELSEIF DEFINED(CPU32)}
  Result := HashFunc.HashDWord(aValue);
{$ELSE}
  Result := HashFunc.HashWord(aValue);
{$ENDIF}
end;

class function TGNativeIntHelper.Equal(L, R: NativeInt): Boolean;
begin
  Result := L = R;
end;

class function TGNativeIntHelper.Compare(L, R: NativeInt): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGPointerHelper.HashCode(aValue: Pointer): SizeInt;
begin
  Result := SizeUInt.HashCode({%H-}SizeUInt(aValue));
end;

class function TGPointerHelper.Equal(L, R: Pointer): Boolean;
begin
  Result := L = R;
end;

class function TGPointerHelper.Compare(L, R: Pointer): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

function TGSingleHelper.IsZero: Boolean;
begin
  Result:= (DWord(Self) and $7fffffff) = 0;
end;

class function TGSingleHelper.HashCode(aValue: Single): SizeInt;
begin
  if aValue.IsZero then
    Result := HashFunc.HashDWord(DWord(Single(0.0)))
  else
    Result := HashFunc.HashDWord(DWord(aValue));
end;

class function TGSingleHelper.Equal(L, R: Single): Boolean;
begin
  Result := L = R;
end;

class function TGSingleHelper.Compare(L, R: Single): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

function TGDoubleHelper.IsZero: Boolean;
begin
  Result := (QWord(Self) and $7fffffffffffffff) = 0;
end;

class function TGDoubleHelper.HashCode(aValue: Double): SizeInt;
begin
  if aValue.IsZero then
    Result := HashFunc.HashQWord(QWord(Double(0.0)))
  else
    Result := HashFunc.HashQWord(QWord(aValue));
end;

class function TGDoubleHelper.Equal(L, R: Double): Boolean;
begin
  Result := L = R;
end;

class function TGDoubleHelper.Compare(L, R: Double): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;
{$ifdef FPC_HAS_TYPE_EXTENDED}
function TGExtendedHelper.IsZero: Boolean;
begin
  Result := SpecialType < fsDenormal;
end;

class function TGExtendedHelper.HashCode(aValue: Extended): SizeInt;
const
  Zero: Extended = 0.0;
begin
  if aValue.IsZero then
    Result := HashFunc.HashBuf(@Zero, SizeOf(Zero))
  else
    Result := HashFunc.HashBuf(@aValue, SizeOf(aValue));
end;

class function TGExtendedHelper.Equal(L, R: Extended): Boolean;
begin
  Result := L = R;
end;

class function TGExtendedHelper.Compare(L, R: Extended): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;
{$ENDIF}

{ TCompHelper }

class function TCompHelper.HashCode(aValue: Comp): SizeInt;
begin
  Result := QWord.HashCode(QWord(aValue));
end;

class function TCompHelper.Equal(L, R: Comp): Boolean;
begin
  Result := L = R;
end;

class function TCompHelper.Compare(L, R: Comp): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGDateTimeHelper.HashCode(aValue: TDateTime): SizeInt;
begin
  Result := HashFunc.HashQWord(QWord(aValue));
end;

class function TGDateTimeHelper.Equal(L, R: TDateTime): Boolean;
begin
  Result := L = R;
end;

class function TGDateTimeHelper.Compare(L, R: TDateTime): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGDateHelper.HashCode(aValue: TDate): SizeInt;
begin
  Result := HashFunc.HashQWord(QWord(aValue));
end;

class function TGDateHelper.Equal(L, R: TDate): Boolean;
begin
  Result := L = R;
end;

class function TGDateHelper.Compare(L, R: TDate): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGTimeHelper.HashCode(aValue: TTime): SizeInt;
begin
  Result := HashFunc.HashQWord(QWord(aValue));
end;

class function TGTimeHelper.Equal(L, R: TTime): Boolean;
begin
  Result := L = R;
end;

class function TGTimeHelper.Compare(L, R: TTime): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGCurrencyHelper.HashCode(const aValue: Currency): SizeInt;
begin
  Result := HashFunc.HashQWord(QWord(aValue));
end;

class function TGCurrencyHelper.Equal(const L, R: Currency): Boolean;
begin
  Result := L = R;
end;

class function TGCurrencyHelper.Compare(const L, R: Currency): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGObjectHelper.HashCode(aValue: TObject): SizeInt;
begin
  if Assigned(aValue) then
    Result := SizeInt.HashCode(aValue.GetHashCode)
  else
    Result := SizeInt.HashCode(0);
end;

class function TGObjectHelper.Equal(L, R: TObject): Boolean;
begin
  if Assigned(L) then
    Result := L.Equals(R)
  else
    Result := R = nil;
end;

class function TGObjectHelper.Compare(L, R: TObject): SizeInt;
begin
  Result := Pointer.Compare(Pointer(L), Pointer(R));
end;

class function TVariantHelper.HashCode(constref aValue: Variant): SizeInt;
begin
  Result := HashFunc.HashBuf(@aValue, SizeOf(System.Variant), 0);
end;

class function TVariantHelper.Equal(constref L, R: Variant): Boolean;
begin
  Result := VarCompareValue(L, R) = vrEqual;
end;

class function TVariantHelper.Compare(constref L, R: Variant): SizeInt;
begin
  case VarCompareValue(L, R) of
    vrGreaterThan: Result := 1;
    vrLessThan:    Result := -1;
    vrEqual:       Result := 0;
  else //vrNotEqual
    if VarIsEmpty(L) or VarIsNull(L) then
      Result := 1
    else
      Result := -1;
  end;
end;

function TStringArrayHelper.GetLength: SizeInt;
begin
  Result := System.Length(Self);
end;

procedure TStringArrayHelper.SetLen(aValue: SizeInt);
begin
  System.SetLength(Self, aValue);
end;

function TStringArrayHelper.IsEmpty: Boolean;
begin
  Result := Self = nil;
end;

function TStringArrayHelper.NonEmpty: Boolean;
begin
  Result := Self <> nil;
end;

procedure TStringArrayHelper.Add(constref aValue: string);
var
  len: SizeInt;
begin
  len := System.Length(Self);
  System.SetLength(Self, len + 1);
  Self[len] := aValue;
end;

function CompareShortInt(constref L, R: ShortInt): SizeInt;
begin
  Result := ShortInt.Compare(L, R);
end;

function CompareUByte(constref L, R: Byte): SizeInt;
begin
  Result := Byte.Compare(L, R);
end;

function CompareSmallInt(constref L, R: SmallInt): SizeInt;
begin
  Result := SmallInt.Compare(L, R);
end;

function CompareWord(constref L, R: Word): SizeInt;
begin
  Result := Word.Compare(L, R);
end;

function CompareLongInt(constref L, R: LongInt): SizeInt;
begin
  Result := LongInt.Compare(L, R);
end;

function CompareDWord(constref L, R: DWord): SizeInt;
begin
  Result := DWord.Compare(L, R);
end;

function CompareInt64(constref L, R: Int64): SizeInt;
begin
  Result := Int64.Compare(L, R);
end;

function CompareQWord(constref L, R: QWord): SizeInt;
begin
  Result := QWord.Compare(L, R);
end;

function CompareChar(constref L, R: AnsiChar): SizeInt;
begin
  Result := AnsiChar.Compare(L, R);
end;

function CompareSingle(constref L, R: Single): SizeInt;
begin
  Result := Single.Compare(L, R);
end;

function CompareDouble(constref L, R: Double): SizeInt;
begin
  Result := Double.Compare(L, R);
end;

function CompareExtended(constref L, R: Extended): SizeInt;
begin
  Result := Extended.Compare(L, R);
end;

function CompareComp(constref L, R: Comp): SizeInt;
begin
  Result := Comp.Compare(L, R);
end;

function CompareCurrency(constref L, R: Currency): SizeInt;
begin
  Result := Currency.Compare(L, R);
end;

function CompareShortStr(constref L, R: shortstring): SizeInt;
begin
  Result := shortstring.Compare(L, R);
end;

function CompareLStr(constref L, R: string): SizeInt;
begin
  Result := ansistring.Compare(L, R);
end;

function CompareAStr(constref L, R: ansistring): SizeInt;
begin
  Result := ansistring.Compare(L, R);
end;

function CompareWStr(constref L, R: widestring): SizeInt;
begin
  Result := widestring.Compare(L, R);
end;

function CompareVariant(constref L, R: Variant): SizeInt;
begin
  Result := Variant.Compare(L, R);
end;

function CompareObj(constref L, R: TObject): SizeInt;
begin
  Result := TObject.Compare(L, R);
end;

function CompareWChar(constref L, R: WideChar): SizeInt;
begin
  Result := WideChar.Compare(L, R);
end;

function CompareUStr(constref L, R: unicodestring): SizeInt;
begin
  Result := unicodestring.Compare(L, R);
end;

function ComparePointer(constref L, R: Pointer): SizeInt;
begin
  Result := Pointer.Compare(L, R);
end;

function ShortIntEqual(constref L, R: ShortInt): Boolean;
begin
  Result := ShortInt.Equal(L, R);
end;

function UByteEqual(constref L, R: Byte): Boolean;
begin
  Result := Byte.Equal(L, R);
end;

function SmallIntEqual(constref L, R: SmallInt): Boolean;
begin
  Result := SmallInt.Equal(L, R);
end;

function WordEqual(constref L, R: Word): Boolean;
begin
  Result := Word.Equal(L, R);
end;

function LongIntEqual(constref L, R: LongInt): Boolean;
begin
  Result := LongInt.Equal(L, R);
end;

function DWordEqual(constref L, R: DWord): Boolean;
begin
  Result := DWord.Equal(L, R);
end;

function Int64Equal(constref L, R: Int64): Boolean;
begin
  Result := Int64.Equal(L, R);
end;

function QWordEqual(constref L, R: QWord): Boolean;
begin
  Result := QWord.Equal(L, R);
end;

function CharEqual(constref L, R: AnsiChar): Boolean;
begin
  Result := AnsiChar.Equal(L, R);
end;

function SingleEqual(constref L, R: Single): Boolean;
begin
  Result := Single.Equal(L, R);
end;

function DoubleEqual(constref L, R: Double): Boolean;
begin
  Result := Double.Equal(L, R);
end;

function ExtendedEqual(constref L, R: Extended): Boolean;
begin
  Result := Extended.Equal(L, R);
end;

function CompEqual(constref L, R: Comp): Boolean;
begin
  Result := Comp.Equal(L, R);
end;

function CurrencyEqual(constref L, R: Currency): Boolean;
begin
  Result := Currency.Equal(L, R);
end;

function ShortStrEqual(constref L, R: shortstring): Boolean;
begin
  Result := shortstring.Equal(L, R);
end;

function LStrEqual(constref L, R: string): Boolean;
begin
  Result := ansistring.Equal(L, R);
end;

function AStrEqual(constref L, R: ansistring): Boolean;
begin
  Result := ansistring.Equal(L, R);
end;

function WStrEqual(constref L, R: widestring): Boolean;
begin
  Result := widestring.Equal(L, R);
end;

function VariantEqual(constref L, R: Variant): Boolean;
begin
  Result := Variant.Equal(L, R);
end;

function ObjEqual(constref L, R: TObject): Boolean;
begin
  Result := TObject.Equal(L, R);
end;

function WCharEqual(constref L, R: WideChar): Boolean;
begin
  Result := WideChar.Equal(L, R);
end;

function UStrEqual(constref L, R: unicodestring): Boolean;
begin
  Result := unicodestring.Equal(L, R);
end;

function PointerEqual(constref L, R: Pointer): Boolean;
begin
  Result := Pointer.Equal(L, R);
end;

function HashShortInt(constref aValue: ShortInt): SizeInt;
begin
  Result := ShortInt.HashCode(aValue);
end;

function HashUByte(constref aValue: Byte): SizeInt;
begin
  Result := Byte.HashCode(aValue);
end;

function HashSmallInt(constref aValue: SmallInt): SizeInt;
begin
  Result := SmallInt.HashCode(aValue);
end;

function HashWord(constref aValue: Word): SizeInt;
begin
  Result := Word.HashCode(aValue);
end;

function HashLongInt(constref aValue: LongInt): SizeInt;
begin
  Result := LongInt.HashCode(aValue);
end;

function HashDWord(constref aValue: DWord): SizeInt;
begin
  Result := DWord.HashCode(aValue);
end;

function HashInt64(constref aValue: Int64): SizeInt;
begin
  Result := Int64.HashCode(aValue);
end;

function HashQWord(constref aValue: QWord): SizeInt;
begin
  Result := QWord.HashCode(aValue);
end;

function HashChar(constref aValue: AnsiChar): SizeInt;
begin
  Result := AnsiChar.HashCode(aValue);
end;

function HashSingle(constref aValue: Single): SizeInt;
begin
  Result := Single.HashCode(aValue);
end;

function HashDouble(constref aValue: Double): SizeInt;
begin
  Result := Double.HashCode(aValue);
end;

function HashExtended(constref aValue: Extended): SizeInt;
begin
  Result := Extended.HashCode(aValue);
end;

function HashComp(constref aValue: Comp): SizeInt;
begin
  Result := Comp.HashCode(aValue);
end;

function HashCurrency(constref aValue: Currency): SizeInt;
begin
  Result := Currency.HashCode(aValue);
end;

function HashShortStr(constref aValue: shortstring): SizeInt;
begin
  Result := shortstring.HashCode(aValue);
end;

function HashLStr(constref aValue: string): SizeInt;
begin
  Result := ansistring.HashCode(aValue);
end;

function HashAStr(constref aValue: ansistring): SizeInt;
begin
  Result := ansistring.HashCode(aValue);
end;

function HashWStr(constref aValue: widestring): SizeInt;
begin
  Result := widestring.HashCode(aValue);
end;

function HashVariant(constref aValue: Variant): SizeInt;
begin
  Result := Variant.HashCode(aValue);
end;

function HashObj(constref aValue: TObject): SizeInt;
begin
  Result := TObject.HashCode(aValue);
end;

function HashWChar(constref aValue: WideChar): SizeInt;
begin
  Result := WideChar.HashCode(aValue);
end;

function HashUStr(constref aValue: unicodestring): SizeInt;
begin
  Result := unicodestring.HashCode(aValue);
end;

function HashPointer(constref aValue: Pointer): SizeInt;
begin
  Result := Pointer.HashCode(aValue);
end;

{ TGDefaults.TComparer }

class function TGDefaults.TComparer.Compare(constref L, R: T): SizeInt;
begin
  Result := CFCompare(L, R);
end;

{ TGDefaults.TEqualityComparer }

class function TGDefaults.TEqualityComparer.Equal(constref L, R: T): Boolean;
begin
  Result := CFEqualCompare(L, R);
end;

class function TGDefaults.TEqualityComparer.HashCode(constref aValue: T): SizeInt;
begin
  Result := CFHashCode(aValue);
end;

{ TGDefaults.TComparator }

function TGDefaults.TComparator.Compare(constref L, R: T): SizeInt;
begin
  Result := CFCompare(L, R);
end;

function TGDefaults.TComparator.EqualCompare(constref L, R: T): Boolean;
begin
  Result := CFEqualCompare(L, R);
end;

{ TGDefaultComparer }

class constructor TGDefaults.Init;
var
  p: PTypeInfo;
begin
  p := System.TypeInfo(T);
  if p <> nil then
    begin
      case p^.Kind of
        tkInteger:
          InitInt(GetTypeData(p));
        tkChar:
          begin
            CFCompare := TCompare(@CompareChar);
            CFEqualCompare := TEqualCompare(@CharEqual);
            CFHashCode := THashCode(@HashChar);
          end;
        tkFloat:
          InitFloat(GetTypeData(p));
        tkSString:
          begin
            CFCompare := TCompare(@CompareShortStr);
            CFEqualCompare := TEqualCompare(@ShortStrEqual);
            CFHashCode := THashCode(@HashShortStr);
          end;
        tkLString:
          begin
            CFCompare := TCompare(@CompareLStr);
            CFEqualCompare := TEqualCompare(@LStrEqual);
            CFHashCode := THashCode(@HashLStr);
          end;
        tkAString:
          begin
            CFCompare := TCompare(@CompareAStr);
            CFEqualCompare := TEqualCompare(@AStrEqual);
            CFHashCode := THashCode(@HashAStr);
          end;
        tkWString:
          begin
            CFCompare := TCompare(@CompareWStr);
            CFEqualCompare := TEqualCompare(@WStrEqual);
            CFHashCode := THashCode(@HashWStr);
          end;
        tkVariant:
          begin
            CFCompare := TCompare(@CompareVariant);
            CFEqualCompare := TEqualCompare(@VariantEqual);
            CFHashCode := THashCode(@HashVariant);
          end;
        tkClass:
          begin
            CFCompare := TCompare(@CompareObj);
            CFEqualCompare := TEqualCompare(@ObjEqual);
            CFHashCode := THashCode(@HashObj);
          end;
        tkWChar:
          begin
            CFCompare := TCompare(@CompareWChar);
            CFEqualCompare := TEqualCompare(@WCharEqual);
            CFHashCode := THashCode(@HashWChar);
          end;
        tkUString:
          begin
            CFCompare := TCompare(@CompareUStr);
            CFEqualCompare := TEqualCompare(@UStrEqual);
            CFHashCode := THashCode(@HashUStr);
          end;
        tkUChar:
          begin
            CFCompare := TCompare(@CompareWChar);
            CFEqualCompare := TEqualCompare(@WCharEqual);
            CFHashCode := THashCode(@HashWChar);
          end;
        tkPointer:
          begin
            CFCompare := TCompare(@ComparePointer);
            CFEqualCompare := TEqualCompare(@PointerEqual);
            CFHashCode := THashCode(@HashPointer);
          end;
      else
        CFCompare := TCompare(@CompareBin);
        CFEqualCompare := TEqualCompare(@EqualBin);
        CFHashCode := THashCode(@HashBin);
      end;
    end
  else
    begin
      CFCompare := TCompare(@CompareBin);
      CFEqualCompare := TEqualCompare(@EqualBin);
      CFHashCode := THashCode(@HashBin);
    end;
end;

class procedure TGDefaults.InitInt(aData: PTypeData);
begin
  case aData^.OrdType of
    otSByte:
      begin
        CFCompare := TCompare(@CompareShortInt);
        CFEqualCompare := TEqualCompare(@ShortIntEqual);
        CFHashCode := THashCode(@HashShortInt);
      end;
    otUByte:
      begin
        CFCompare := TCompare(@CompareUByte);
        CFEqualCompare := TEqualCompare(@UByteEqual);
        CFHashCode := THashCode(@HashUByte);
      end;
    otSWord:
      begin
        CFCompare := TCompare(@CompareSmallInt);
        CFEqualCompare := TEqualCompare(@SmallIntEqual);
        CFHashCode := THashCode(@HashSmallInt);
      end;
    otUWord:
      begin
        CFCompare := TCompare(@CompareWord);
        CFEqualCompare := TEqualCompare(@WordEqual);
        CFHashCode := THashCode(@HashWord);
      end;
    otSLong:
      begin
        CFCompare := TCompare(@CompareLongInt);
        CFEqualCompare := TEqualCompare(@LongIntEqual);
        CFHashCode := THashCode(@HashLongInt);
      end;
    otULong:
      begin
        CFCompare := TCompare(@CompareDWord);
        CFEqualCompare := TEqualCompare(@DWordEqual);
        CFHashCode := THashCode(@HashDWord);
      end;
    otSQWord:
      begin
        CFCompare := TCompare(@CompareInt64);
        CFEqualCompare := TEqualCompare(@Int64Equal);
        CFHashCode := THashCode(@HashInt64);
      end;
    otUQWord:
      begin
        CFCompare := TCompare(@CompareQWord);
        CFEqualCompare := TEqualCompare(@QWordEqual);
        CFHashCode := THashCode(@HashQWord);
      end;
  else
    CFCompare := TCompare(@CompareBin);
    CFEqualCompare := TEqualCompare(@EqualBin);
    CFHashCode := THashCode(@HashBin);
  end;
end;

class procedure TGDefaults.InitFloat(aData: PTypeData);
begin
  case aData^.FloatType of
    ftSingle:
      begin
        CFCompare := TCompare(@CompareSingle);
        CFEqualCompare := TEqualCompare(@SingleEqual);
        CFHashCode := THashCode(@HashSingle);
      end;
    ftDouble:
      begin
        CFCompare := TCompare(@CompareDouble);
        CFEqualCompare := TEqualCompare(@DoubleEqual);
        CFHashCode := THashCode(@HashDouble);
      end;
    ftExtended:
      begin
        CFCompare := TCompare(@CompareExtended);
        CFEqualCompare := TEqualCompare(@ExtendedEqual);
        CFHashCode := THashCode(@HashExtended);
      end;
    ftComp:
      begin
        CFCompare := TCompare(@CompareComp);
        CFEqualCompare := TEqualCompare(@CompEqual);
        CFHashCode := THashCode(@HashComp);
      end;
    ftCurr:
      begin
        CFCompare := TCompare(@CompareCurrency);
        CFEqualCompare := TEqualCompare(@CurrencyEqual);
        CFHashCode := THashCode(@HashCurrency);
      end;
  else
    CFCompare := TCompare(@CompareBin);
    CFEqualCompare := TEqualCompare(@EqualBin);
    CFHashCode := THashCode(@HashBin);
  end;
end;

class function TGDefaults.CompareBin(constref L, R: T): SizeInt;
begin
  Result := CompareMemRange(@L, @R, SizeOf(T));
end;

class function TGDefaults.EqualBin(constref L, R: T): Boolean;
begin
  Result := CompareMemRange(@L, @R, SizeOf(T)) = 0;
end;

class function TGDefaults.HashBin(constref aValue: T): SizeInt;
begin
  Result := HashFunc.HashBuf(@aValue, SizeOf(T));
end;

class function TGDefaults.GetOnCompare: TOnCompare;
begin
  Result := @CFComparator.Compare;
end;

class function TGDefaults.GetOnEqualCompare: TOnEqualCompare;
begin
  Result := @CFComparator.EqualCompare;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Miscellaneous classes and utils.                                        *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGMiscUtils;

{$MODE OBJFPC}{$H+}
{$MODESWITCH ADVANCEDRECORDS}
{$INLINE ON}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  Classes,
  SysUtils,
  math,
  FileUtil,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGArrayHelpers;

type

  generic TGNumRange<T> = class
  type
    TRange = record
    private
      FCurrent,
      FMax,
      FStep: T;
      FInCycle: Boolean;
    public
      function GetEnumerator: TRange; inline;
      function MoveNext: Boolean; inline;
      property Current: T read FCurrent;
    end;

    TDownRange = record
    private
      FCurrent,
      FMin,
      FStep: T;
      FInCycle: Boolean;
    public
      function GetEnumerator: TDownRange; inline;
      function MoveNext: Boolean; inline;
      property Current: T read FCurrent;
    end;

    class function Up(const aFrom, aTo: T; const aStep: T = 1): TRange; static; inline;
    class function Down(const aFrom, aDownTo: T; const aStep: T = 1): TDownRange; static; inline;
  end;

  { TGCustomTimSort:  base ancestor class }
  generic TGCustomTimSort<T> = class
  public
  type
    TItem      = T;
    PItem      = ^T;

  protected
  type
    //to supress unnecessary refcounting
    TFake      = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(SizeOf(T))] of Byte{$ELSE}T{$ENDIF};
    TFakeArray = array of TFake;

    { TTimSortBase }

    TTimSortBase = object
    protected
    const
      MERGE_STACK_INIT_SIZE  = 16;
      MERGE_BUFFER_INIT_SIZE = 64;
      MIN_MERGE_POW          = 5;
      MIN_MERGE_LEN          = SizeInt(1) shl MIN_MERGE_POW;
      MIN_GALLOP             = 7;

    type
      TRun = record
        Base,
        Count: SizeInt;
      end;
      TRunArray  = array of TRun;

    var
      FData: PItem; // pointer to data array
      FBuffer: TFakeArray;
      FStack: TRunArray;
      FStackSize,
      FMinGallop: SizeInt;
      procedure PushRun(aBase, aCount: SizeInt);
      function  EnsureBufferSize(aSize: SizeInt): PItem; inline;
      procedure Init(A: PItem);
      procedure Swap(Base1, Len1, Base2, Len2: SizeInt);
      class function  MinRunLen(aTotalSize: SizeInt): SizeInt; static;
      class procedure DoReverse(p: PItem; R: SizeInt); static;
    end;

  end;

  { TGTimSortBase
      functor TCmpRel (comparision relation) must provide:
        class function Compare([const[ref]] L, R: T): SizeInt }
  generic TGTimSortBase<T, TCmpRel> = class(specialize TGCustomTimSort<T>)
  protected
  type
    TTimSort = object(TTimSortBase)
    protected
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      function  GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      procedure MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt); static;
      class function  CountRunAsc(A: PItem; R: SizeInt): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt); static;
      class procedure SortDesc(A: PItem; R: SizeInt); static;
    end;

  public
    class procedure Sort(var A: array of T; aOrder: TSortOrder = soAsc); static;
  end;

  { TGTimSort assumes that type T has implemented TCmpRel }
  generic TGTimSort<T> = class(specialize TGTimSortBase<T, T>);

  { TGComparableTimSort assumes that type T has defined comparision operators }
  generic TGComparableTimSort<T> = class(specialize TGCustomTimSort<T>)
  protected
  type
    TTimSort = object(TTimSortBase)
    protected
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      function  GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      procedure MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt); static;
      class function  CountRunAsc(A: PItem; R: SizeInt): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt); static;
      class procedure SortDesc(A: PItem; R: SizeInt); static;
    end;

  public
    class procedure Sort(var A: array of T; aOrder: TSortOrder = soAsc); static;
  end;

  { TGRegularTimSort: TimSort with regular comparator }
  generic TGRegularTimSort<T> = class(specialize TGCustomTimSort<T>)
  public
  type
    TCompare = specialize TGCompare<T>;

  protected
  type
    TTimSort = object(TTimSortBase)
    protected
      FCompare: TCompare;
      procedure Init(A: PItem; c: TCompare);
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      function  GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      procedure MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt; c: TCompare); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt; c: TCompare); static;
      class function  CountRunAsc(A: PItem; R: SizeInt; c: TCompare): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt; c: TCompare): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt; c: TCompare); static;
      class procedure SortDesc(A: PItem; R: SizeInt; c: TCompare); static;
    end;

  public
    class procedure Sort(var A: array of T; c: TCompare; aOrder: TSortOrder = soAsc); static;
  end;

  { TGDelegatedTimSort: TimSort with delegated comparator }
  generic TGDelegatedTimSort<T> = class(specialize TGCustomTimSort<T>)
  public
  type
    TOnCompare = specialize TGOnCompare<T>;

  protected
  type
    TTimSort = object(TTimSortBase)
    protected
      FCompare: TOnCompare;
      procedure Init(A: PItem; c: TOnCompare);
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      function  GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      procedure MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt; c: TOnCompare); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt; c: TOnCompare); static;
      class function  CountRunAsc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt; c: TOnCompare); static;
      class procedure SortDesc(A: PItem; R: SizeInt; c: TOnCompare); static;
    end;

  public
    class procedure Sort(var A: array of T; c: TOnCompare; aOrder: TSortOrder = soAsc); static;
  end;

  { TGNestedTimSort: TimSort with nested comparator }
  generic TGNestedTimSort<T> = class(specialize TGCustomTimSort<T>)
  public
  type
    TNestCompare = specialize TGNestCompare<T>;

  protected
  type
    TTimSort = object(TTimSortBase)
    protected
      FCompare: TNestCompare;
      procedure Init(A: PItem; c: TNestCompare);
      procedure CollapseA;
      procedure CollapseD;
      procedure ForceCollapseA;
      procedure ForceCollapseD;
      procedure MergeAtA(aIndex: SizeInt);
      procedure MergeAtD(aIndex: SizeInt);
      function  GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      function  GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
      procedure MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
      procedure MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
      class procedure InsertSortA(A: PItem; R, At: SizeInt; c: TNestCompare); static;
      class procedure InsertSortD(A: PItem; R, At: SizeInt; c: TNestCompare); static;
      class function  CountRunAsc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt; static;
      class function  CountRunDesc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt; static;
    public
      class procedure SortAsc(A: PItem; R: SizeInt; c: TNestCompare); static;
      class procedure SortDesc(A: PItem; R: SizeInt; c: TNestCompare); static;
    end;

  public
    class procedure Sort(var A: array of T; c: TNestCompare; aOrder: TSortOrder = soAsc); static;
  end;

  { TTextFileReader is small wrapper around TextFile to mimic string enumerable with buffered read as a bonus;
     it isn't understand 'Input' or 'StdIn' as FileName; }
  TTextFileReader = class sealed(specialize TGEnumerable<string>)
  private
  type
    TEnumerator = class(TCustomEnumerator)
    private
      FReader: TTextFileReader;
    protected
      function  GetCurrent: string; override;
    public
      constructor Create(aReader: TTextFileReader);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FFile: TextFile;
    FFileName,
    FCurrent,
    FExceptClass,
    FExceptMsg: string;
    FBuffer: array[0..511] of QWord; //????
    FIsOpen: Boolean;
    procedure Close;
  protected
    function  GetCurrent: string; inline;
    function  MoveNext: Boolean; inline;
    procedure Reset; inline;
    property  IsOpen: Boolean read FIsOpen;
  public
    class function FileExists(const aFileName: string): Boolean; static;
    class function FileSize(const aFileName: string): Int64; static;
    constructor Create;
    destructor Destroy; override;
    function GetEnumerator: TEnumerator; override;
    function Open(const aFileName: string): Boolean;
    function LoadText(const aFileName: string; out aText: string): Boolean;
    function ExceptionClass: string; inline;
    function ExceptionMessage: string; inline;
  end;

  { TTextFileWrite is small wrapper around TextFile with buffered write as a bonus;
     it understand 'Output', 'StdOut' and 'StdErr' as file names in case-insensitive manner }
  TTextFileWriter = class sealed
  private
  const
    sOutput = 'output';
    sStdOut = 'stdout';
    sStdErr = 'stderr';

  var
    FFile: TextFile;
    FFileName,
    FExceptClass,
    FExceptMsg: string;
    FBuffer: array[0..511] of QWord;
    FIsOpen,
    FIsStandard,
    FAppend: Boolean;
    function  IsStandardFile: Boolean; inline;
    procedure Open;
    procedure AppendFile;
    procedure Close;
    property  IsStandard: Boolean read FIsStandard;
  public
  type
    IStringEnumerable = specialize IGEnumerable<string>;
    constructor Create(const aFileName: string = ''; Append: Boolean = False);
    destructor Destroy; override;
    procedure AfterConstruction; override;
    function IsOpen: Boolean; inline;
    function FileName: string; inline;
    function Add(const aValue: string): Boolean;
    function AddAll(constref a: array of string): SizeInt;
    function AddAll(e: IStringEnumerable): SizeInt;
    function ExceptionClass: string; inline;
    function ExceptionMessage: string; inline;
  end;

  TParamKind = (pkOption, pkLongOption, pkArgument);

  TCmdLineOption = record
    Kind:  TParamKind;
    Key:   string;
    Value: string;
  end;

  TCmdLineOptions = array of TCmdLineOption;

  function CmdLineOptions: TCmdLineOptions;

implementation
{$B-}{$COPERATORS ON}

type

  TCmdLine = class sealed
  private
  const
    EQ        = '=';
    COLON     = ':';
    SEP_CHARS = [EQ, COLON];
    OPT_CHAR  = '-';
    INIT_SIZE = 4;
  class var
    Options: TCmdLineOptions;
    class procedure ParseOptions;
  public
    class function GetOptions: TCmdLineOptions;
  end;

function CmdLineOptions: TCmdLineOptions;
begin
  Result := TCmdLine.GetOptions;
end;

class procedure TCmdLine.ParseOptions;
var

  CurrParam: string;
  I, Count: SizeInt;
  o: TCmdLineOption;

  procedure ItemAdding;
  begin
    if Count = System.Length(Options) then
      System.SetLength(Options, System.Length(Options) * 2);
  end;

  procedure OptionAdd(constref aOption: TCmdLineOption);
  begin
    ItemAdding;
    Options[Count] := aOption;
    Inc(Count);
  end;
  function IsKeyValue(constref aOpt: string; out aKey, aValue: string): Boolean;
  var
    I: SizeInt;
    DivPos: SizeInt;
  begin
    if System.Length(aOpt) < 3 then
      exit(False);
    DivPos := 0;
    for I := 2 to System.Length(aOpt) - 1 do //ignore separator on first and last position
      if aOpt[I] in SEP_CHARS then           //only first match matter
        begin
          DivPos := I;
          break;
        end;
    Result := DivPos > 0;
    if Result then
      begin
        aKey := Copy(aOpt, 1, DivPos - 1);
        aValue := Copy(aOpt, DivPos + 1, System.Length(aOpt) - DivPos);
      end;
  end;

  procedure ParseLongOption(constref aValue: string);
  var
    k, v: string;
  begin
    if aValue = '' then
      exit;
    o.Kind := pkLongOption;
    if IsKeyValue(aValue, k, v) then
      begin
       o.Key := k;
       o.Value := v;
      end
    else
      begin
        o.Key := aValue;
        o.Value := '';
      end;
    OptionAdd(o);
  end;

  procedure ParseShortOption(constref aValue: string);
  var
    I: SizeInt;
    k, v: string;
  begin
    if aValue = '' then
      exit;
    o.Kind := pkOption;
    if IsKeyValue(aValue, k, v) then
      begin
        for I := 1 to System.Length(k) - 1 do     //-abc=de -> a, b, c=de
          begin                                   //-a=bcde -> a=bcde
            o.Key := k[I];
            o.Value := '';
            OptionAdd(o);
          end;
        o.Key := k[System.Length(k)];
        o.Value := v;
        OptionAdd(o);
      end
    else
      for I := 1 to System.Length(aValue) do
        begin
          o.Key := aValue[I];
          o.Value := '';
          OptionAdd(o);
        end;
  end;
  procedure ParseOption(constref aValue: string);
  begin
    if aValue = '' then
      exit;
    if aValue[1] = OPT_CHAR then
      ParseLongOption(Copy(aValue, 2, System.Length(aValue) - 1))
    else
      ParseShortOption(aValue);
  end;
  procedure ParseParam(constref aParam: string);
  begin
    o.Kind := pkArgument;
    o.Key := '';
    o.Value := aParam;
    OptionAdd(o);
  end;
begin
  Count := 0;
  System.SetLength(Options, INIT_SIZE);
  for I := 1 to System.ParamCount do
    begin
      CurrParam := System.ParamStr(I);
      if CurrParam = '' then
        continue;
      if CurrParam[1] = OPT_CHAR then
        ParseOption(Copy(CurrParam, 2, System.Length(CurrParam) - 1))
      else
        ParseParam(CurrParam);
    end;
  System.SetLength(Options, Count);
end;

class function TCmdLine.GetOptions: TCmdLineOptions;
begin
  if Options = nil then
    ParseOptions;
  Result := System.Copy(Options, 0, System.Length(Options)) ;
end;

{ TGNumRange.TRange }

function TGNumRange.TRange.GetEnumerator: TRange;
begin
  Result := Self;
end;

function TGNumRange.TRange.MoveNext: Boolean;
begin
  if FInCycle then
    begin
      Result := FMax - FCurrent >= FStep;
      if Result then
        FCurrent += FStep;
    end
  else
    begin
      Result := FCurrent <= FMax;
      FInCycle := True;
    end;
end;

{ TGNumRange.TDownRange }

function TGNumRange.TDownRange.GetEnumerator: TDownRange;
begin
  Result := Self;
end;

function TGNumRange.TDownRange.MoveNext: Boolean;
begin
  if FInCycle then
    begin
      Result := FCurrent - FMin >= FStep;
      if Result then
        FCurrent -= FStep;
    end
  else
    begin
      Result := FCurrent >= FMin;
      FInCycle := True;
    end;
end;

class function TGNumRange.Up(const aFrom, aTo: T; const aStep: T): TRange;
begin
  with Result do
    begin
      FMax := aTo;
      FStep := aStep;
      FCurrent := aFrom;
      FInCycle := False;
    end;
end;

class function TGNumRange.Down(const aFrom, aDownTo: T; const aStep: T): TDownRange;
begin
  with Result do
    begin
      FMin := aDownTo;
      FStep := aStep;
      FCurrent := aFrom;
      FInCycle := False;
    end;
end;

{ TGCustomTimSort.TTimSortBase }

procedure TGCustomTimSort.TTimSortBase.PushRun(aBase, aCount: SizeInt);
var
  I: SizeInt;
begin
  I := FStackSize;
  Inc(FStackSize);
  if System.Length(FStack) = I then
    System.SetLength(FStack, I * 2);
  FStack[I].Base := aBase;
  FStack[I].Count := aCount;
end;

function TGCustomTimSort.TTimSortBase.EnsureBufferSize(aSize: SizeInt): PItem;
begin
  if aSize > System.Length(FBuffer) then
    System.SetLength(FBuffer, LGUtils.RoundUpTwoPower(aSize));
  Result := @FBuffer[0];
end;

procedure TGCustomTimSort.TTimSortBase.Init(A: PItem);
begin
  FData := A;
  FStackSize := 0;
  FMinGallop := MIN_GALLOP;
  if System.Length(FBuffer) < MERGE_BUFFER_INIT_SIZE then
    System.SetLength(FBuffer, MERGE_BUFFER_INIT_SIZE);
  if System.Length(FStack) < MERGE_STACK_INIT_SIZE then
    System.SetLength(FStack, MERGE_STACK_INIT_SIZE);
end;

procedure TGCustomTimSort.TTimSortBase.Swap(Base1, Len1, Base2, Len2: SizeInt);
var
  LocB: PItem;
begin
  if Len1 <= Len2 then
    begin
      LocB := EnsureBufferSize(Len1);
      System.Move(FData[Base1], LocB[0], Len1 * SizeOf(T));
      System.Move(FData[Base2], FData[Base1], Len2 * SizeOf(T));
      System.Move(LocB[0], FData[Base1 + Len2], Len1 * SizeOf(T));
    end
  else
    begin
      LocB := EnsureBufferSize(Len2);
      System.Move(FData[Base2], LocB[0], Len2 * SizeOf(T));
      System.Move(FData[Base1], FData[Base1 + Len2], Len1 * SizeOf(T));
      System.Move(LocB[0], FData[Base1], Len2 * SizeOf(T));
    end;
end;

class function TGCustomTimSort.TTimSortBase.MinRunLen(aTotalSize: SizeInt): SizeInt;
var
  s: SizeInt;
begin
  if aTotalSize > MIN_MERGE_LEN then
    begin
      s := LGUtils.NSB(aTotalSize) - MIN_MERGE_POW;
      Result := aTotalSize shr s;
      Result += Ord((Result shl s xor aTotalSize) <> 0);
    end
  else
    Result := aTotalSize;
end;

class procedure TGCustomTimSort.TTimSortBase.DoReverse(p: PItem; R: SizeInt);
var
  v0, v1, v2, v3: TFake;
  L: SizeInt;
begin
  L := 0;
  while R - L >= 7 do
    begin
      v0 := TFake(p[L    ]);
      v1 := TFake(p[L + 1]);
      v2 := TFake(p[L + 2]);
      v3 := TFake(p[L + 3]);
      TFake(p[L    ]) := TFake(p[R    ]);
      TFake(p[L + 1]) := TFake(p[R - 1]);
      TFake(p[L + 2]) := TFake(p[R - 2]);
      TFake(p[L + 3]) := TFake(p[R - 3]);
      TFake(p[R    ]) := v0;
      TFake(p[R - 1]) := v1;
      TFake(p[R - 2]) := v2;
      TFake(p[R - 3]) := v3;
      L += 4;
      R -= 4;
    end;
  case R - L of
    1..2:
      begin
        v0 := TFake(p[L]);
        TFake(p[L]) := TFake(p[R]);
        TFake(p[R]) := v0;
      end;
    3..4:
      begin
        v0 := TFake(p[L    ]);
        v1 := TFake(p[L + 1]);
        TFake(p[L    ]) := TFake(p[R    ]);
        TFake(p[L + 1]) := TFake(p[R - 1]);
        TFake(p[R    ]) := v0;
        TFake(p[R - 1]) := v1;
      end;
    5..6:
      begin
        v0 := TFake(p[L    ]);
        v1 := TFake(p[L + 1]);
        v2 := TFake(p[L + 2]);
        TFake(p[L    ]) := TFake(p[R    ]);
        TFake(p[L + 1]) := TFake(p[R - 1]);
        TFake(p[L + 2]) := TFake(p[R - 2]);
        TFake(p[R    ]) := v0;
        TFake(p[R - 1]) := v1;
        TFake(p[R - 2]) := v2;
      end;
  end;
end;

{ TGTimSortBase.TTimSort }

procedure TGTimSortBase.TTimSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGTimSortBase.TTimSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGTimSortBase.TTimSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGTimSortBase.TTimSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGTimSortBase.TTimSort.MergeAtA(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, D: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if TCmpRel.Compare(FData[Pred(Base2)], FData[Base2]) > 0 then
    begin
      D := GallopRightA(FData, FData[Base2], Base1, Len1, 0);
      Base1 += D;
      Len1 -= D;
      if Len1 > 0 then
        if TCmpRel.Compare(FData[Pred(Base2 + Len2)], FData[Base1]) >= 0 then
          begin
            Len2 := GallopLeftA(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoA(Base1, Len1, Base2, Len2)
              else
                MergeHiA(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

procedure TGTimSortBase.TTimSort.MergeAtD(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, D: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if TCmpRel.Compare(FData[Pred(Base2)], FData[Base2]) < 0 then
    begin
      D := GallopRightD(FData, FData[Base2], Base1, Len1, 0);
      Base1 += D;
      Len1 -= D;
      if Len1 > 0 then
        if TCmpRel.Compare(FData[Pred(Base2 + Len2)], FData[Base1]) <= 0 then
          begin
            Len2 := GallopLeftD(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoD(Base1, Len1, Base2, Len2)
              else
                MergeHiD(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

function TGTimSortBase.TTimSort.GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
begin
  Dist := 0;
  Result := 1;
  if TCmpRel.Compare(Key, A[Base + Hint]) > 0 then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (TCmpRel.Compare(Key, A[Base + Hint + Result]) > 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (TCmpRel.Compare(Key, A[Base + Hint - Result]) <= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if TCmpRel.Compare(Key, A[Base + M]) > 0 then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGTimSortBase.TTimSort.GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
begin
  Dist := 0;
  Result := 1;
  if TCmpRel.Compare(Key, A[Base + Hint]) < 0 then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (TCmpRel.Compare(Key, A[Base + Hint + Result]) < 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (TCmpRel.Compare(Key, A[Base + Hint - Result]) >= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if TCmpRel.Compare(Key, A[Base + M]) < 0 then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGTimSortBase.TTimSort.GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
begin
  Dist := 0;
  Result := 1;
  if TCmpRel.Compare(Key, A[Base + Hint]) < 0 then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (TCmpRel.Compare(Key, A[Base + Hint - Result]) < 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (TCmpRel.Compare(Key, A[Base + Hint + Result]) >= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if TCmpRel.Compare(Key, A[Base + M]) < 0 then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

function TGTimSortBase.TTimSort.GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
begin
  Dist := 0;
  Result := 1;
  if TCmpRel.Compare(Key, A[Base + Hint]) > 0 then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (TCmpRel.Compare(Key, A[Base + Hint - Result]) > 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (TCmpRel.Compare(Key, A[Base + Hint + Result]) <= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if TCmpRel.Compare(Key, A[Base + M]) > 0 then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

procedure TGTimSortBase.TTimSort.MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if TCmpRel.Compare(LocB[pLo], LocA[pHi]) <= 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightA(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftA(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGTimSortBase.TTimSort.MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if TCmpRel.Compare(LocB[pLo], LocA[pHi]) >= 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightD(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftD(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGTimSortBase.TTimSort.MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if TCmpRel.Compare(LocA[pLo], LocB[pHi]) > 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightA(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftA(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGTimSortBase.TTimSort.MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if TCmpRel.Compare(LocA[pLo], LocB[pHi]) < 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightD(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftD(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

class procedure TGTimSortBase.TTimSort.InsertSortA(A: PItem; R, At: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (TCmpRel.Compare(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGTimSortBase.TTimSort.InsertSortD(A: PItem; R, At: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (TCmpRel.Compare(A[J], T(v)) < 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGTimSortBase.TTimSort.CountRunAsc(A: PItem; R: SizeInt): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if TCmpRel.Compare(A[0], A[1]) <= 0 then  // ascending
        while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                                      // descending
        begin
          while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) > 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGTimSortBase.TTimSort.CountRunDesc(A: PItem; R: SizeInt): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if TCmpRel.Compare(A[0], A[1]) >= 0 then  // descending
        while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) >= 0) do
          Inc(Result)
      else                                      // ascending
        begin
          while (Result < R) and (TCmpRel.Compare(A[Result], A[Succ(Result)]) < 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGTimSortBase.TTimSort.SortAsc(A: PItem; R: SizeInt);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunAsc(@A[L], R - L));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortA(@A[L], Pred(Len), RunLen);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseA;
      until L > R;
      ts.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R)));
end;

class procedure TGTimSortBase.TTimSort.SortDesc(A: PItem; R: SizeInt);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunDesc(@A[L], R - L));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortD(@A[L], Pred(Len), RunLen);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseD;
      until L > R;
      ts.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R)));
end;

{ TGTimSortBase }

class procedure TGTimSortBase.Sort(var A: array of T; aOrder: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if aOrder = soAsc then
      TTimSort.SortAsc(@A[0], R)
    else
      TTimSort.SortDesc(@A[0], R);
end;

{ TGComparableTimSort.TTimSort }

procedure TGComparableTimSort.TTimSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGComparableTimSort.TTimSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGComparableTimSort.TTimSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGComparableTimSort.TTimSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGComparableTimSort.TTimSort.MergeAtA(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, D: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if FData[Pred(Base2)] > FData[Base2] then
    begin
      D := GallopRightA(FData, FData[Base2], Base1, Len1, 0);
      Base1 += D;
      Len1 -= D;
      if Len1 > 0 then
        if FData[Pred(Base2 + Len2)] >= FData[Base1] then
          begin
            Len2 := GallopLeftA(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoA(Base1, Len1, Base2, Len2)
              else
                MergeHiA(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

procedure TGComparableTimSort.TTimSort.MergeAtD(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, D: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if FData[Pred(Base2)] < FData[Base2] then
    begin
      D := GallopRightD(FData, FData[Base2], Base1, Len1, 0);
      Base1 += D;
      Len1 -= D;
      if Len1 > 0 then
        if FData[Pred(Base2 + Len2)] <= FData[Base1] then
          begin
            Len2 := GallopLeftD(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoD(Base1, Len1, Base2, Len2)
              else
                MergeHiD(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

function TGComparableTimSort.TTimSort.GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
begin
  Dist := 0;
  Result := 1;
  if Key > A[Base + Hint] then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (Key > A[Base + Hint + Result]) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (Key <= A[Base + Hint - Result]) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if Key > A[Base + M] then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGComparableTimSort.TTimSort.GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
begin
  Dist := 0;
  Result := 1;
  if Key < A[Base + Hint] then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (Key < A[Base + Hint + Result]) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (Key >= A[Base + Hint - Result]) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if Key < A[Base + M] then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGComparableTimSort.TTimSort.GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
begin
  Dist := 0;
  Result := 1;
  if Key < A[Base + Hint] then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (Key < A[Base + Hint - Result]) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (Key >= A[Base + Hint + Result]) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if Key < A[Base + M] then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

function TGComparableTimSort.TTimSort.GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
begin
  Dist := 0;
  Result := 1;
  if Key > A[Base + Hint] then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (Key > A[Base + Hint - Result]) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (Key <= A[Base + Hint + Result]) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if Key > A[Base + M] then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

procedure TGComparableTimSort.TTimSort.MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if LocB[pLo] <= LocA[pHi] then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightA(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftA(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGComparableTimSort.TTimSort.MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if LocB[pLo] >= LocA[pHi] then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightD(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftD(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGComparableTimSort.TTimSort.MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if LocA[pLo] > LocB[pHi] then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightA(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftA(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGComparableTimSort.TTimSort.MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if LocA[pLo] < LocB[pHi] then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightD(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftD(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

class procedure TGComparableTimSort.TTimSort.InsertSortA(A: PItem; R, At: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (A[J] > T(v)) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGComparableTimSort.TTimSort.InsertSortD(A: PItem; R, At: SizeInt);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (A[J] < T(v)) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGComparableTimSort.TTimSort.CountRunAsc(A: PItem; R: SizeInt): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if A[0] <= A[1] then  // ascending
        while (Result < R) and (A[Result] <= A[Succ(Result)]) do
          Inc(Result)
      else                  // descending
        begin
          while (Result < R) and (A[Result] > A[Succ(Result)]) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGComparableTimSort.TTimSort.CountRunDesc(A: PItem; R: SizeInt): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if A[0] >= A[1] then  // descending
        while (Result < R) and (A[Result] >= A[Succ(Result)]) do
          Inc(Result)
      else                  // ascending
        begin
          while (Result < R) and (A[Result] <  A[Succ(Result)]) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGComparableTimSort.TTimSort.SortAsc(A: PItem; R: SizeInt);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunAsc(@A[L], R - L));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortA(@A[L], Pred(Len), RunLen);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseA;
      until L > R;
      ts.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R)));
end;

class procedure TGComparableTimSort.TTimSort.SortDesc(A: PItem; R: SizeInt);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunDesc(@A[L], R - L));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortD(@A[L], Pred(Len), RunLen);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseD;
      until L > R;
      ts.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R)));
end;

{ TGComparableTimSort }

class procedure TGComparableTimSort.Sort(var A: array of T; aOrder: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if aOrder = soAsc then
      TTimSort.SortAsc(@A[0], R)
    else
      TTimSort.SortDesc(@A[0], R);
end;

{ TGRegularTimSort.TTimSort }

procedure TGRegularTimSort.TTimSort.Init(A: PItem; c: TCompare);
begin
  inherited Init(A);
  FCompare := c;
end;

procedure TGRegularTimSort.TTimSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGRegularTimSort.TTimSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGRegularTimSort.TTimSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGRegularTimSort.TTimSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGRegularTimSort.TTimSort.MergeAtA(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, Dist: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if FCompare(FData[Pred(Base2)], FData[Base2]) > 0 then
    begin
      Dist := GallopRightA(FData, FData[Base2], Base1, Len1, 0);
      Base1 += Dist;
      Len1 -= Dist;
      if Len1 > 0 then
        if FCompare(FData[Pred(Base2 + Len2)], FData[Base1]) >= 0 then
          begin
            Len2 := GallopLeftA(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoA(Base1, Len1, Base2, Len2)
              else
                MergeHiA(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

procedure TGRegularTimSort.TTimSort.MergeAtD(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, Dist: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if FCompare(FData[Pred(Base2)], FData[Base2]) < 0 then
    begin
      Dist := GallopRightD(FData, FData[Base2], Base1, Len1, 0);
      Base1 += Dist;
      Len1 -= Dist;
      if Len1 > 0 then
        if FCompare(FData[Pred(Base2 + Len2)], FData[Base1]) <= 0 then
          begin
            Len2 := GallopLeftD(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoD(Base1, Len1, Base2, Len2)
              else
                MergeHiD(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

function TGRegularTimSort.TTimSort.GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) > 0 then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) > 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) <= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) > 0 then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGRegularTimSort.TTimSort.GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) < 0 then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) < 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) >= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) < 0 then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGRegularTimSort.TTimSort.GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) < 0 then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) < 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) >= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) < 0 then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

function TGRegularTimSort.TTimSort.GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) > 0 then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) > 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) <= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) > 0 then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

procedure TGRegularTimSort.TTimSort.MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
  c: TCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  c := FCompare;
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocB[pLo], LocA[pHi]) <= 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightA(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftA(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGRegularTimSort.TTimSort.MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
  c: TCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  c := FCompare;
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocB[pLo], LocA[pHi]) >= 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightD(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftD(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGRegularTimSort.TTimSort.MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
  c: TCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  c := FCompare;
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocA[pLo], LocB[pHi]) > 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightA(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftA(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGRegularTimSort.TTimSort.MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
  c: TCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  c := FCompare;
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocA[pLo], LocB[pHi]) < 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightD(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftD(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

class procedure TGRegularTimSort.TTimSort.InsertSortA(A: PItem; R, At: SizeInt; c: TCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGRegularTimSort.TTimSort.InsertSortD(A: PItem; R, At: SizeInt; c: TCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) < 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGRegularTimSort.TTimSort.CountRunAsc(A: PItem; R: SizeInt; c: TCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) <= 0 then  // ascending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                        // descending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) > 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGRegularTimSort.TTimSort.CountRunDesc(A: PItem; R: SizeInt; c: TCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) >= 0 then  // descending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) >= 0) do
          Inc(Result)
      else                        // ascending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) < 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGRegularTimSort.TTimSort.SortAsc(A: PItem; R: SizeInt; c: TCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunAsc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortA(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseA;
      until L > R;
      ts.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R, c)), c);
end;

class procedure TGRegularTimSort.TTimSort.SortDesc(A: PItem; R: SizeInt; c: TCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunDesc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortD(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseD;
      until L > R;
      ts.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R, c)), c);
end;

{ TGRegularTimSort }

class procedure TGRegularTimSort.Sort(var A: array of T; c: TCompare; aOrder: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if aOrder = soAsc then
      TTimSort.SortAsc(@A[0], R, c)
    else
      TTimSort.SortDesc(@A[0], R, c);
end;

{ TGDelegatedTimSort.TTimSort }

procedure TGDelegatedTimSort.TTimSort.Init(A: PItem; c: TOnCompare);
begin
  inherited Init(A);
  FCompare := c;
end;

procedure TGDelegatedTimSort.TTimSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGDelegatedTimSort.TTimSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGDelegatedTimSort.TTimSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGDelegatedTimSort.TTimSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGDelegatedTimSort.TTimSort.MergeAtA(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, Dist: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if FCompare(FData[Pred(Base2)], FData[Base2]) > 0 then
    begin
      Dist := GallopRightA(FData, FData[Base2], Base1, Len1, 0);
      Base1 += Dist;
      Len1 -= Dist;
      if Len1 > 0 then
        if FCompare(FData[Pred(Base2 + Len2)], FData[Base1]) >= 0 then
          begin
            Len2 := GallopLeftA(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoA(Base1, Len1, Base2, Len2)
              else
                MergeHiA(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

procedure TGDelegatedTimSort.TTimSort.MergeAtD(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, Dist: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if FCompare(FData[Pred(Base2)], FData[Base2]) < 0 then
    begin
      Dist := GallopRightD(FData, FData[Base2], Base1, Len1, 0);
      Base1 += Dist;
      Len1 -= Dist;
      if Len1 > 0 then
        if FCompare(FData[Pred(Base2 + Len2)], FData[Base1]) <= 0 then
          begin
            Len2 := GallopLeftD(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoD(Base1, Len1, Base2, Len2)
              else
                MergeHiD(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

function TGDelegatedTimSort.TTimSort.GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TOnCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) > 0 then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) > 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) <= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) > 0 then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGDelegatedTimSort.TTimSort.GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TOnCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) < 0 then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) < 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) >= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) < 0 then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGDelegatedTimSort.TTimSort.GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TOnCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) < 0 then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) < 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) >= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) < 0 then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

function TGDelegatedTimSort.TTimSort.GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TOnCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) > 0 then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) > 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) <= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) > 0 then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

procedure TGDelegatedTimSort.TTimSort.MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
  c: TOnCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  c := FCompare;
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocB[pLo], LocA[pHi]) <= 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightA(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftA(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGDelegatedTimSort.TTimSort.MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
  c: TOnCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  c := FCompare;
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocB[pLo], LocA[pHi]) >= 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightD(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftD(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGDelegatedTimSort.TTimSort.MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
  c: TOnCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  c := FCompare;
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocA[pLo], LocB[pHi]) > 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightA(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftA(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGDelegatedTimSort.TTimSort.MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
  c: TOnCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  c := FCompare;
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocA[pLo], LocB[pHi]) < 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightD(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftD(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

class procedure TGDelegatedTimSort.TTimSort.InsertSortA(A: PItem; R, At: SizeInt; c: TOnCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGDelegatedTimSort.TTimSort.InsertSortD(A: PItem; R, At: SizeInt; c: TOnCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) < 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGDelegatedTimSort.TTimSort.CountRunAsc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) <= 0 then  // ascending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                        // descending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) > 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGDelegatedTimSort.TTimSort.CountRunDesc(A: PItem; R: SizeInt; c: TOnCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) >= 0 then  // descending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) >= 0) do
          Inc(Result)
      else                        // ascending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) < 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGDelegatedTimSort.TTimSort.SortAsc(A: PItem; R: SizeInt; c: TOnCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunAsc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortA(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseA;
      until L > R;
      ts.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R, c)), c);
end;

class procedure TGDelegatedTimSort.TTimSort.SortDesc(A: PItem; R: SizeInt; c: TOnCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunDesc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortD(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseD;
      until L > R;
      ts.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R, c)), c);
end;

{ TGDelegatedTimSort }

class procedure TGDelegatedTimSort.Sort(var A: array of T; c: TOnCompare; aOrder: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if aOrder = soAsc then
      TTimSort.SortAsc(@A[0], R, c)
    else
      TTimSort.SortDesc(@A[0], R, c);
end;

{ TGNestedTimSort.TTimSort }

procedure TGNestedTimSort.TTimSort.Init(A: PItem; c: TNestCompare);
begin
  inherited Init(A);
  FCompare := c;
end;

procedure TGNestedTimSort.TTimSort.CollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtA(I);
    end;
end;

procedure TGNestedTimSort.TTimSort.CollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count <= FStack[I].Count + FStack[I + 1].Count) then
        begin
          if FStack[I - 1].Count < FStack[I + 1].Count then
            Dec(I);
        end
      else
        if FStack[I].Count > FStack[I + 1].Count then
          break;
      MergeAtD(I);
    end;
end;

procedure TGNestedTimSort.TTimSort.ForceCollapseA;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtA(I - 1)
      else
        MergeAtA(I);
    end;
end;

procedure TGNestedTimSort.TTimSort.ForceCollapseD;
var
  I: SizeInt;
begin
  while FStackSize > 1 do
    begin
      I := FStackSize - 2;
      if (I > 0) and (FStack[I - 1].Count < FStack[I + 1].Count) then
        MergeAtD(I - 1)
      else
        MergeAtD(I);
    end;
end;

procedure TGNestedTimSort.TTimSort.MergeAtA(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, Dist: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if FCompare(FData[Pred(Base2)], FData[Base2]) > 0 then
    begin
      Dist := GallopRightA(FData, FData[Base2], Base1, Len1, 0);
      Base1 += Dist;
      Len1 -= Dist;
      if Len1 > 0 then
        if FCompare(FData[Pred(Base2 + Len2)], FData[Base1]) >= 0 then
          begin
            Len2 := GallopLeftA(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoA(Base1, Len1, Base2, Len2)
              else
                MergeHiA(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

procedure TGNestedTimSort.TTimSort.MergeAtD(aIndex: SizeInt);
var
  Base1, Len1, Base2, Len2, Dist: SizeInt;
begin
  Base1 := FStack[aIndex].Base;
  Len1 := FStack[aIndex].Count;
  Base2 := FStack[aIndex + 1].Base;
  Len2 := FStack[aIndex + 1].Count;
  FStack[aIndex].Count := Len1 + Len2;
  if aIndex = FStackSize - 3 then
    begin
      FStack[aIndex + 1].Base := FStack[aIndex + 2].Base;
      FStack[aIndex + 1].Count := FStack[aIndex + 2].Count;
    end;
  Dec(FStackSize);
  if FCompare(FData[Pred(Base2)], FData[Base2]) < 0 then
    begin
      Dist := GallopRightD(FData, FData[Base2], Base1, Len1, 0);
      Base1 += Dist;
      Len1 -= Dist;
      if Len1 > 0 then
        if FCompare(FData[Pred(Base2 + Len2)], FData[Base1]) <= 0 then
          begin
            Len2 := GallopLeftD(FData, FData[Pred(Base1 + Len1)], Base2, Len2, Len2 - 1);
            if Len2 > 0 then
              if Len1 <= Len2 then
                MergeLoD(Base1, Len1, Base2, Len2)
              else
                MergeHiD(Base1, Len1, Base2, Len2);
          end
        else
          Swap(Base1, Len1, Base2, Len2);
    end;
end;

function TGNestedTimSort.TTimSort.GallopLeftA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TNestCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) > 0 then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) > 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) <= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) > 0 then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGNestedTimSort.TTimSort.GallopLeftD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TNestCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) < 0 then
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) < 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then  //
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end
  else
    begin
      MaxDist := Hint + 1;
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) >= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then   //
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) < 0 then
        Dist := Succ(M)
      else
        Result := M;
    end;
end;

function TGNestedTimSort.TTimSort.GallopRightA(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TNestCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) < 0 then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) < 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) >= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) < 0 then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

function TGNestedTimSort.TTimSort.GallopRightD(A: PItem; constref Key: T; Base, Len, Hint: SizeInt): SizeInt;
var
  Dist, MaxDist, M: SizeInt;
  c: TNestCompare;
begin
  c := FCompare;
  Dist := 0;
  Result := 1;
  if c(Key, A[Base + Hint]) > 0 then
    begin
      MaxDist := Succ(Hint);
      while (Result < MaxDist) and (c(Key, A[Base + Hint - Result]) > 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      M := Dist;
      Dist := Succ(Hint - Math.Min(Result, MaxDist));
      Result := Hint - M;
    end
  else
    begin
      MaxDist := Len - Hint;
      while (Result < MaxDist) and (c(Key, A[Base + Hint + Result]) <= 0) do
        begin
          Dist := Result;
          Result := Succ(Result shl 1);
          if Result <= 0 then
            Result := MaxDist;
        end;
      Result := Math.Min(Result, MaxDist) + Hint;
      Dist += Succ(Hint);
    end;
  while Dist < Result do
    begin
      M := Dist + (Result - Dist) shr 1;
      if c(Key, A[Base + M]) > 0 then
        Result := M
      else
        Dist := Succ(M);
    end;
end;

procedure TGNestedTimSort.TTimSort.MergeLoA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
  c: TNestCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  c := FCompare;
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocB[pLo], LocA[pHi]) <= 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightA(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftA(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGNestedTimSort.TTimSort.MergeLoD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in buffer)
  pHi,             // position in high part  (in data array)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data
  LocB: PItem;     // local pointer to buffer
  c: TNestCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len1);
  c := FCompare;
  System.Move(LocA[Base1], LocB[0], Len1 * SizeOf(T));
  pLo := 0;
  pHi := Base2;
  pDst := Base1;
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocB[pLo], LocA[pHi]) >= 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocB[pLo]);
          Inc(pDst);
          Inc(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocA[pHi]);
          Inc(pDst);
          Inc(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := GallopRightD(@LocB[0], LocA[pHi], pLo, Len1, 0);
      if Count1 <> 0 then
        begin
          System.Move(LocB[pLo], LocA[pDst], Count1 * SizeOf(T));
          Len1 -= Count1;
          pDst += Count1;
          pLo += Count1;
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pHi]);
      Dec(Len2);
      Inc(pDst);
      Inc(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := GallopLeftD(LocA, LocB[pLo], pHi, Len2, 0);
      if Count2 <> 0 then
        begin
          System.Move(LocA[pHi], LocA[pDst], Count2 * SizeOf(T));
          Len2 -= Count2;
          pDst += Count2;
          pHi += Count2;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pLo]);
      Dec(Len1);
      Inc(pDst);
      Inc(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len1 > 0 then
    System.Move(LocB[pLo], LocA[pDst], Len1 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGNestedTimSort.TTimSort.MergeHiA(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
  c: TNestCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  c := FCompare;
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocA[pLo], LocB[pHi]) > 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightA(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftA(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

procedure TGNestedTimSort.TTimSort.MergeHiD(Base1, Len1, Base2, Len2: SizeInt);
var
  LocMinGallop,    // local copy FMinGallop
  pLo,             // position in low part   (in data array)
  pHi,             // position in high part  (in buffer)
  pDst,            // current merge position (in data array)
  Count1,          // first run win count
  Count2: SizeInt; // second run win count
  LocA: PItem;     // local pointer to data array
  LocB: PItem;     // local pointer to buffer
  c: TNestCompare;
label
  MainLoopDone;
begin
  LocA := FData;
  LocB := EnsureBufferSize(Len2);
  c := FCompare;
  System.Move(LocA[Base2], LocB[0], Len2 * SizeOf(T));
  pLo := Pred(Base1 + Len1);
  pHi := Pred(Len2);
  pDst := Pred(Base2 + Len2);
  LocMinGallop := FMinGallop;
  repeat  //MainLoop
    Count1 := 0;
    Count2 := 0;
    repeat
      if c(LocA[pLo], LocB[pHi]) < 0 then
        begin
          TFake(LocA[pDst]) := TFake(LocA[pLo]);
          Dec(pDst);
          Dec(pLo);
          Dec(Len1);
          Inc(Count1);
          Count2 := 0;
          if Len1 = 0 then
            goto MainLoopDone;
        end
      else
        begin
          TFake(LocA[pDst]) := TFake(LocB[pHi]);
          Dec(pDst);
          Dec(pHi);
          Dec(Len2);
          Inc(Count2);
          Count1 := 0;
          if Len2 = 0 then
            goto MainLoopDone;
        end;
    until (Count1 or Count2) >= LocMinGallop;
    repeat
      Count1 := Len1 - GallopRightD(LocA, LocB[pHi], Base1, Len1, Pred(Len1));
      if Count1 <> 0 then
        begin
          Len1 -= Count1;
          pDst -= Count1;
          pLo -= Count1;
          System.Move(LocA[Succ(pLo)], LocA[Succ(pDst)], Count1 * SizeOf(T));
          if Len1 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocB[pHi]);
      Dec(Len2);
      Dec(pDst);
      Dec(pHi);
      if Len2 = 0 then
        goto MainLoopDone;
      Count2 := Len2 - GallopLeftD(@LocB[0], LocA[pLo], 0, Len2, Pred(Len2));
      if Count2 <> 0 then
        begin
          Len2 -= Count2;
          pDst -= Count2;
          pHi -= Count2;
          System.Move(LocB[Succ(pHi)], LocA[Succ(pDst)], Count2 * SizeOf(T));
          if Len2 = 0 then
            goto MainLoopDone;
        end;
      TFake(LocA[pDst]) := TFake(LocA[pLo]);
      Dec(Len1);
      Dec(pDst);
      Dec(pLo);
      if Len1 = 0 then
        goto MainLoopDone;
      Dec(LocMinGallop);
    until (Count1 < LocMinGallop) and (Count2 < LocMinGallop);
    if LocMinGallop < 0 then
      LocMinGallop := 0;
    LocMinGallop += 2;
  until False;

MainLoopDone:
  if Len2 > 0 then
    System.Move(LocB[0], LocA[Succ(pDst - Len2)], Len2 * SizeOf(T));
  if LocMinGallop < 1 then
    FMinGallop := 1
  else
    FMinGallop := LocMinGallop;
end;

class procedure TGNestedTimSort.TTimSort.InsertSortA(A: PItem; R, At: SizeInt; c: TNestCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) > 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class procedure TGNestedTimSort.TTimSort.InsertSortD(A: PItem; R, At: SizeInt; c: TNestCompare);
var
  I, J: SizeInt;
  v: TFake;
begin
  if At < 1 then
    At := 1;
  for I := At to R do
    begin
      v := TFake(A[I]);
      J := I - 1;
      while (J >= 0) and (c(A[J], T(v)) < 0) do
        begin
          TFake(A[J + 1]) := TFake(A[J]);
          Dec(J);
        end;
      TFake(A[J + 1]) := v;
    end;
end;

class function TGNestedTimSort.TTimSort.CountRunAsc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) <= 0 then  // ascending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) <= 0) do
          Inc(Result)
      else                        // descending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) > 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class function TGNestedTimSort.TTimSort.CountRunDesc(A: PItem; R: SizeInt; c: TNestCompare): SizeInt;
begin
  if R > 0 then
    begin
      Result := 1;
      if c(A[0], A[1]) >= 0 then  // descending
        while (Result < R) and (c(A[Result], A[Succ(Result)]) >= 0) do
          Inc(Result)
      else                        // ascending
        begin
          while (Result < R) and (c(A[Result], A[Succ(Result)]) < 0) do
            Inc(Result);
          DoReverse(A, Result);
        end;
    end
  else
    Result := 0;
end;

class procedure TGNestedTimSort.TTimSort.SortAsc(A: PItem; R: SizeInt; c: TNestCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunAsc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortA(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseA;
      until L > R;
      ts.ForceCollapseA;
    end
  else
    InsertSortA(A, R, Succ(CountRunAsc(A, R, c)), c);
end;

class procedure TGNestedTimSort.TTimSort.SortDesc(A: PItem; R: SizeInt; c: TNestCompare);
var
  RunLen, MinLen, Len, L: SizeInt;
  ts: TTimSort;
begin
  if R + 1 > MIN_MERGE_LEN shl 1 then
    begin
      ts.Init(A, c);
      MinLen := MinRunLen(R + 1);
      L := 0;
      repeat
        RunLen := Succ(CountRunDesc(@A[L], R - L, c));
        if RunLen < MinLen then
          begin
            Len := Math.Min(Succ(R - L), MinLen);
            InsertSortD(@A[L], Pred(Len), RunLen, c);
            RunLen := Len;
          end;
        ts.PushRun(L, RunLen);
        L += RunLen;
        ts.CollapseD;
      until L > R;
      ts.ForceCollapseD;
    end
  else
    InsertSortD(A, R, Succ(CountRunDesc(A, R, c)), c);
end;

{ TGNestedTimSort }

class procedure TGNestedTimSort.Sort(var A: array of T; c: TNestCompare; aOrder: TSortOrder);
var
  R: SizeInt;
begin
  R := High(A);
  if R > 0 then
    if aOrder = soAsc then
      TTimSort.SortAsc(@A[0], R, c)
    else
      TTimSort.SortDesc(@A[0], R, c);
end;

{ TTextFileReader.TEnumerator }

function TTextFileReader.TEnumerator.GetCurrent: string;
begin
  Result := FReader.GetCurrent;
end;

constructor TTextFileReader.TEnumerator.Create(aReader: TTextFileReader);
begin
  FReader := aReader;
end;

function TTextFileReader.TEnumerator.MoveNext: Boolean;
begin
  Result := FReader.MoveNext;
end;

procedure TTextFileReader.TEnumerator.Reset;
begin
  FReader.Reset;
end;

{ TTextFileReader }

procedure TTextFileReader.Close;
begin
  if IsOpen then
    begin
      System.Close(FFile);
      FCurrent := '';
      FFileName := '';
      FExceptClass := '';
      FExceptMsg := '';
      FIsOpen := False;
    end;
end;

function TTextFileReader.GetCurrent: string;
begin
  Result := FCurrent;
end;

function TTextFileReader.MoveNext: Boolean;
begin
  Result := IsOpen and not System.Eof(FFile);
  if Result then
    System.ReadLn(FFile, FCurrent);
end;

procedure TTextFileReader.Reset;
begin
  if IsOpen then
    System.Reset(FFile);
end;

class function TTextFileReader.FileExists(const aFileName: string): Boolean;
begin
  Result := SysUtils.FileExists(aFileName);
end;

class function TTextFileReader.FileSize(const aFileName: string): Int64;
begin
  Result := FileUtil.FileSize(aFileName);
end;

constructor TTextFileReader.Create;
begin
  inherited Create;
  System.SetTextBuf(FFile, FBuffer, SizeOf(FBuffer));
end;

destructor TTextFileReader.Destroy;
begin
  if IsOpen then
    System.Close(FFile);
  inherited;
end;

function TTextFileReader.GetEnumerator: TEnumerator;
begin
  Reset;
  Result := TEnumerator.Create(Self);
end;

{$PUSH}{$IOCHECKS ON}
function TTextFileReader.Open(const aFileName: string): Boolean;
begin
  Close;
  FFileName := aFileName;
  try
    Assign(FFile, FFileName);
    System.Reset(FFile);
    FIsOpen := True;
  except
    on e: Exception do
      begin
        FExceptClass := e.ClassName;
        FExceptMsg := e.Message;
      end;
  end;
  Result := IsOpen;
end;
{$POP}

function TTextFileReader.LoadText(const aFileName: string; out aText: string): Boolean;
begin
  Result := False;
  try
    with TStringStream.Create do
      try
        LoadFromFile(aFileName);
        aText := DataString;
        Result := True;
      finally
        Free;
      end;
  except
    on e: Exception do
      begin
        FExceptClass := e.ClassName;
        FExceptMsg := e.Message;
      end;
  end;
end;

function TTextFileReader.ExceptionClass: string;
begin
  Result := FExceptClass;
end;

function TTextFileReader.ExceptionMessage: string;
begin
  Result := FExceptMsg;
end;

function TTextFileWriter.IsStandardFile: Boolean;
begin
  Result := True;
  case FFileName.ToLower of
    sOutput, sStdOut: FFile := Stdout;
    sStdErr:          FFile := StdErr;
  else
    Result := False;
  end;
  FIsStandard := Result;
end;

{$PUSH}{$IOCHECKS ON}
procedure TTextFileWriter.Open;
begin
  if not IsStandardFile then
    try
      System.Assign(FFile, FFileName);
      System.SetTextBuf(FFile, FBuffer, SizeOf(FBuffer));
      System.Rewrite(FFile);
      FIsOpen := True;
    except
      on e: Exception do
        begin
          FExceptClass := e.ClassName;
          FExceptMsg := e.Message;
        end;
    end
  else
    FIsOpen := True;
end;

procedure TTextFileWriter.AppendFile;
begin
  if not IsStandardFile then
    try
      System.Assign(FFile, FFileName);
      System.SetTextBuf(FFile, FBuffer, SizeOf(FBuffer));
      System.Append(FFile);
      FIsOpen := True;
    except
      on e: Exception do
        begin
          FExceptClass := e.ClassName;
          FExceptMsg := e.Message;
        end;
    end
  else
    FIsOpen := True;
end;
{$POP}

procedure TTextFileWriter.Close;
begin
  if IsOpen then
    begin
      System.Flush(FFile);
      if not IsStandard then
        System.Close(FFile);
      FIsOpen := False;
    end;
end;

constructor TTextFileWriter.Create(const aFileName: string; Append: Boolean);
begin
  inherited Create;
  FFileName := aFileName;
  FAppend := Append;
end;

destructor TTextFileWriter.Destroy;
begin
  Close;
  inherited;
end;

procedure TTextFileWriter.AfterConstruction;
begin
  inherited;
  if FAppend then
    AppendFile
  else
    Open;
end;

function TTextFileWriter.IsOpen: Boolean;
begin
  Result := FIsOpen;
end;

function TTextFileWriter.FileName: string;
begin
  Result := FFileName;
end;

function TTextFileWriter.Add(const aValue: string): Boolean;
begin
  Result := IsOpen;
  if Result then
    System.Writeln(FFile, aValue)
end;

function TTextFileWriter.AddAll(constref a: array of string): SizeInt;
var
  s: string;
begin
  Result := 0;
  for s in a do
    Result += Ord(Add(s));
end;

function TTextFileWriter.AddAll(e: IStringEnumerable): SizeInt;
var
  s: string;
begin
  Result := 0;
  for s in e do
    Result += Ord(Add(s));
end;

function TTextFileWriter.ExceptionClass: string;
begin
  Result := FExceptClass;
end;

function TTextFileWriter.ExceptionMessage: string;
begin
  Result := FExceptMsg;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic multimap implementations.                                       *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGMultiMap;

{$mode objfpc}{$H+}
{$INLINE ON}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGHashTable,
  LGAvlTree,
  LGSortedList;

type

  { TGCustomHashMultiMap: common abstract ancestor class}
  generic TGCustomHashMultiMap<TKey, TValue, TKeyEqRel> = class abstract(specialize TGCustomMultiMap<TKey, TValue>)
  protected
  type

    THashTable    = class(specialize TGHashTableLP<TKey, TMMEntry, TKeyEqRel>);

    TKeyEnumerable = class(TCustomKeyEnumerable)
    protected
      FEnum: THashTable.TEnumerator;
      function  GetCurrent: TKey; override;
    public
      constructor Create(aMap: TGCustomHashMultiMap);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TValueEnumerable = class(TCustomValueEnumerable)
    protected
      FValueEnum: TCustomValueEnumerator;
      FEntryEnum: THashTable.TEnumerator;
      function  GetCurrent: TValue; override;
    public
      constructor Create(aMap: TGCustomHashMultiMap);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TEntryEnumerable = class(TCustomEntryEnumerable)
    protected
      FValueEnum: TCustomValueEnumerator;
      FEntryEnum: THashTable.TEnumerator;
      function  GetCurrent: TEntry; override;
    public
      constructor Create(aMap: TGCustomHashMultiMap);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FTable: THashTable;
    function  GetFillRatio: Single;
    function  GetLoadFactor: Single;
    function  GetTableSize: SizeInt;
    procedure SetLoadFactor(aValue: Single);
    function  GetKeyCount: SizeInt; override;
    function  GetCapacity: SizeInt; override;
    procedure DoClear; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    procedure DoTrimToFit; override;
    function  Find(constref aKey: TKey): PMMEntry; override;
    function  FindOrAdd(constref aKey: TKey): PMMEntry; override;
    function  DoRemoveKey(constref aKey: TKey): SizeInt; override;
    function  GetKeys: IKeyEnumerable; override;
    function  GetValues: IValueEnumerable; override;
    function  GetEntries: IEntryEnumerable; override;
    function  CreateValueSet: TCustomValueSet; virtual; abstract;
  public
    class function DefaultLoadFactor: Single; inline;
    class function MaxLoadFactor: Single; inline;
    class function MinLoadFactor: Single; inline;
    constructor Create;
    constructor Create(constref a: array of TEntry);
    constructor Create(e: IEntryEnumerable);
    constructor Create(aCapacity: SizeInt);
    constructor Create(aCapacity: SizeInt; constref a: array of TEntry);
    constructor Create(aCapacity: SizeInt; e: IEntryEnumerable);
    property  LoadFactor: Single read GetLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
    property  TableSize: SizeInt read GetTableSize;
  end;

  { TGHashMultiMap implements multimap with value collections as linear probing hashset;

      functor TKeyEqRel(key equality relation) must provide:
        class function HashCode([const[ref]] k: TKey): SizeInt;
        class function Equal([const[ref]] L, R: TKey): Boolean;

      functor TValueEqRel(value equality relation) must provide:
        class function HashCode([const[ref]] v: TValue): SizeInt;
        class function Equal([const[ref]] L, R: TValue): Boolean; }
  generic TGHashMultiMap<TKey, TValue, TKeyEqRel, TValueEqRel> = class(specialize TGCustomHashMultiMap<TKey, TValue, TKeyEqRel>)
  protected
  type
    TValueSet = class(TCustomValueSet)
    protected
    type
      TValEntry = record
        Key: TValue;
      end;
      PValEntry = ^TValEntry;

      TTable = specialize TGHashTableLP<TValue, TValEntry, TValueEqRel>;

      TEnumerator = class(TCustomValueEnumerator)
      protected
        FEnum: TTable.TEnumerator;
        function  GetCurrent: TValue; override;
      public
        constructor Create(aTable: TTable);
        function  MoveNext: Boolean; override;
        procedure Reset; override;
      end;

    const
      START_CAPACITY = 8;
      LOAD_FACTOR    = 0.65; //todo: why ???

    var
      FTable: TTable;
      function GetCount: SizeInt; override;
    public
      constructor Create;
      destructor Destroy; override;
      function  GetEnumerator: TCustomValueEnumerator; override;
      function  Contains(constref aValue: TValue): Boolean; override;
      function  Add(constref aValue: TValue): Boolean; override;
      function  Remove(constref aValue: TValue): Boolean; override;
    end;

    function GetUniqueKeyValues: Boolean; override;
    function CreateValueSet: TCustomValueSet; override;
  public
    destructor Destroy; override;
  end;

  { TGHashMultiMapK assumes that TKey implements TKeyEqRel }
  generic TGHashMultiMapK<TKey, TValue, TValueEqRel> = class(
    specialize TGHashMultiMap<TKey, TValue, TKey, TValueEqRel>);

  { TGHashMultiMapV assumes that TValue implements TValueEqRel }
  generic TGHashMultiMapV<TKey, TValue, TKeyEqRel> = class(
    specialize TGHashMultiMap<TKey, TValue, TKeyEqRel, TValue>);

  { TGHashMultiMap2 assumes that TKey implements TKeyEqRel and TValue implements TValueEqRel }
  generic TGHashMultiMap2<TKey, TValue> = class(specialize TGHashMultiMap<TKey, TValue, TKey, TValue>);

  { TGTreeMultiMap implements multimap with value collections as avl tree;

      functor TKeyEqRel(key equality relation) must provide:
        class function HashCode([const[ref]] k: TKey): SizeInt;
        class function Equal([const[ref]] L, R: TKey): Boolean;

      functor TValueCmpRel(value comparision relation) must provide:
        class function Compare([const[ref]] L, R: TValue): SizeInt; }
  generic TGTreeMultiMap<TKey, TValue, TKeyEqRel, TValueCmpRel> = class(specialize TGCustomHashMultiMap<TKey, TValue, TKeyEqRel>)
  protected
  type
    TValEntry = record
      Key: TValue;
    end;
    PValEntry = ^TValEntry;

    TNode        = specialize TGAvlTreeNode<TValEntry>;
    PNode        = ^TNode;
    TNodeManager = specialize TGPageNodeManager<TNode>;
    PNodeManager = ^TNodeManager;

    TValueSet = class(TCustomValueSet)
    protected
    type
      TTable = specialize TGAvlTree2<TValue, TValEntry, TNodeManager, TValueCmpRel>;

      TEnumerator = class(TCustomValueEnumerator)
      protected
        FEnum: TTable.TEnumerator;
        function  GetCurrent: TValue; override;
      public
        constructor Create(aTable: TTable);
        function  MoveNext: Boolean; override;
        procedure Reset; override;
      end;

    var
      FTable: TTable;
      function GetCount: SizeInt; override;
    public
      constructor Create(aNodeManager: TNodeManager);
      destructor Destroy; override;
      function  GetEnumerator: TCustomValueEnumerator; override;
      function  Contains(constref aValue: TValue): Boolean; override;
      function  Add(constref aValue: TValue): Boolean; override;
      function  Remove(constref aValue: TValue): Boolean; override;
    end;
  var
    FNodeManager: TNodeManager;
    procedure DoClear; override;
    procedure DoTrimToFit; override;
    function  GetUniqueKeyValues: Boolean; override;
    function  CreateValueSet: TCustomValueSet; override;
  public
    constructor Create;
    constructor Create(constref a: array of TEntry);
    constructor Create(e: IEntryEnumerable);
    constructor Create(aCapacity: SizeInt);
    constructor Create(aCapacity: SizeInt; constref a: array of TEntry);
    constructor Create(aCapacity: SizeInt; e: IEntryEnumerable);
    destructor  Destroy; override;
  end;

  { TGTreeMultiMapK assumes that TKey implements TKeyEqRel }
  generic TGTreeMultiMapK<TKey, TValue, TValueCmpRel> = class(
    specialize TGTreeMultiMap<TKey, TValue, TKey, TValueCmpRel>);

  { TGHashMultiMapV assumes that TValue implements TValueCmpRel }
  generic TGTreeMultiMapV<TKey, TValue, TKeyEqRel> = class(
    specialize TGTreeMultiMap<TKey, TValue, TKeyEqRel, TValue>);

  { TGTreeMultiMap2 assumes that TKey implements TKeyEqRel and TValue implements TValueCmpRel }
  generic TGTreeMultiMap2<TKey, TValue> = class(specialize TGTreeMultiMap<TKey, TValue, TKey, TValue>);

  { TGListMultiMap implements multimap with value collections as sorted list;

      functor TKeyEqRel(key equality relation) must provide:
        class function HashCode([const[ref]] k: TKey): SizeInt;
        class function Equal([const[ref]] L, R: TKey): Boolean;

      functor TValueCmpRel(value comparision relation) must provide:
        class function Compare([const[ref]] L, R: TValue): SizeInt; }
  generic TGListMultiMap<TKey, TValue, TKeyEqRel, TValueCmpRel> = class(specialize TGCustomHashMultiMap<TKey, TValue, TKeyEqRel>)
  protected
  const
    INITIAL_CAPACITY = 8;

  type
    TValueSet = class(TCustomValueSet)
    protected
    type
      TList = specialize TGSortedList2<TValue, TValueCmpRel>;

      TEnumerator = class(TCustomValueEnumerator)
      protected
        FEnum: TList.TEnumerator;
        function  GetCurrent: TValue; override;
      public
        constructor Create(aList: TList);
        function  MoveNext: Boolean; override;
        procedure Reset; override;
      end;

    var
      FList: TList;
      function GetCount: SizeInt; override;
    public
      constructor Create;
      destructor Destroy; override; final;
      function  GetEnumerator: TCustomValueEnumerator; override;
      procedure TrimToFit;
      function  Contains(constref aValue: TValue): Boolean; override;
      function  Add(constref aValue: TValue): Boolean; override;
      function  Remove(constref aValue: TValue): Boolean; override;
    end;

    procedure DoTrimToFit; override;
    function  GetUniqueKeyValues: Boolean; override;
    function  CreateValueSet: TCustomValueSet; override;
  public
     destructor Destroy; override;
  end;

  { TGListMultiMapK assumes that TKey implements TKeyEqRel }
  generic TGListMultiMapK<TKey, TValue, TValueCmpRel> = class(
    specialize TGListMultiMap<TKey, TValue, TKey, TValueCmpRel>);

  { TGListMultiMapV assumes that TValue implements TValueCmpRel }
  generic TGListMultiMapV<TKey, TValue, TKeyEqRel> = class(
    specialize TGListMultiMap<TKey, TValue, TKeyEqRel, TValue>);

  { TGListMultiMap2 assumes that TKey implements TKeyEqRel and TValue implements TValueCmpRel }
  generic TGListMultiMap2<TKey, TValue> = class(specialize TGListMultiMap<TKey, TValue, TKey, TValue>);

implementation
{$B-}{$COPERATORS ON}

{ TGCustomHashMultiMap.TKeyEnumerable }

function TGCustomHashMultiMap.TKeyEnumerable.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Key;
end;

constructor TGCustomHashMultiMap.TKeyEnumerable.Create(aMap: TGCustomHashMultiMap);
begin
  inherited Create(aMap);
  FEnum := aMap.FTable.GetEnumerator;
end;

function TGCustomHashMultiMap.TKeyEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomHashMultiMap.TKeyEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomHashMultiMap.TValueEnumerable }

function TGCustomHashMultiMap.TValueEnumerable.GetCurrent: TValue;
begin
  Result := FValueEnum.Current;
end;

constructor TGCustomHashMultiMap.TValueEnumerable.Create(aMap: TGCustomHashMultiMap);
begin
  inherited Create(aMap);
  FEntryEnum := aMap.FTable.GetEnumerator;
end;

function TGCustomHashMultiMap.TValueEnumerable.MoveNext: Boolean;
begin
  repeat
    if not Assigned(FValueEnum) then
      begin
        if not FEntryEnum.MoveNext then
          exit(False);
        FValueEnum := FEntryEnum.Current^.Values.GetEnumerator;
      end;
    Result := FValueEnum.MoveNext;
    if not Result then
      FreeAndNil(FValueEnum);
  until Result;
end;

procedure TGCustomHashMultiMap.TValueEnumerable.Reset;
begin
  FEntryEnum.Reset;
  FValueEnum := nil;
end;

{ TGCustomHashMultiMap.TEntryEnumerable }

function TGCustomHashMultiMap.TEntryEnumerable.GetCurrent: TEntry;
begin
  Result.Key := FEntryEnum.Current^.Key;
  Result.Value := FValueEnum.Current;
end;

constructor TGCustomHashMultiMap.TEntryEnumerable.Create(aMap: TGCustomHashMultiMap);
begin
  inherited Create(aMap);
  FEntryEnum := aMap.FTable.GetEnumerator;
end;

function TGCustomHashMultiMap.TEntryEnumerable.MoveNext: Boolean;
begin
  repeat
    if not Assigned(FValueEnum) then
      begin
        if not FEntryEnum.MoveNext then
          exit(False);
        FValueEnum := FEntryEnum.Current^.Values.GetEnumerator;
      end;
    Result := FValueEnum.MoveNext;
    if not Result then
      FreeAndNil(FValueEnum);
  until Result;
end;

procedure TGCustomHashMultiMap.TEntryEnumerable.Reset;
begin
  FEntryEnum.Reset;
  FValueEnum := nil;
end;

{ TGCustomHashMultiMap }

function TGCustomHashMultiMap.GetFillRatio: Single;
begin
  Result := FTable.FillRatio;
end;

function TGCustomHashMultiMap.GetLoadFactor: Single;
begin
  Result := FTable.LoadFactor;
end;

function TGCustomHashMultiMap.GetTableSize: SizeInt;
begin
  Result := FTable.TableSize;
end;

procedure TGCustomHashMultiMap.SetLoadFactor(aValue: Single);
begin
  FTable.LoadFactor := aValue;
end;

function TGCustomHashMultiMap.GetKeyCount: SizeInt;
begin
  Result := FTable.Count;
end;

function TGCustomHashMultiMap.GetCapacity: SizeInt;
begin
  Result := FTable.Capacity;
end;

procedure TGCustomHashMultiMap.DoClear;
var
  p: PMMEntry;
begin
  for p in FTable do
    p^.Values.Free;
  FTable.Clear;
end;

procedure TGCustomHashMultiMap.DoEnsureCapacity(aValue: SizeInt);
begin
  if not FTable.EnsureCapacity(aValue) then
    CapacityExceedError(aValue);
end;

procedure TGCustomHashMultiMap.DoTrimToFit;
begin
  FTable.TrimToFit;
end;

function TGCustomHashMultiMap.Find(constref aKey: TKey): PMMEntry;
var
  p: SizeInt;
begin
  Result := FTable.Find(aKey, p);
end;

function TGCustomHashMultiMap.FindOrAdd(constref aKey: TKey): PMMEntry;
var
  p: SizeInt;
begin
  if not FTable.FindOrAdd(aKey, Result, p) then
    begin
      Result^.Key := aKey;
      Result^.Values := CreateValueSet;
    end;
end;

function TGCustomHashMultiMap.DoRemoveKey(constref aKey: TKey): SizeInt;
var
  Pos: SizeInt;
  p: PMMEntry;
begin
  p := FTable.Find(aKey, Pos);
  if p <> nil then
    begin
      Result := p^.Values.Count;
      p^.Values.Free;
      FTable.RemoveAt(Pos);
    end
  else
    Result := 0;
end;

function TGCustomHashMultiMap.GetKeys: IKeyEnumerable;
begin
  Result := TKeyEnumerable.Create(Self);
end;

function TGCustomHashMultiMap.GetValues: IValueEnumerable;
begin
  Result := TValueEnumerable.Create(Self);
end;

function TGCustomHashMultiMap.GetEntries: IEntryEnumerable;
begin
  Result := TEntryEnumerable.Create(Self);
end;

class function TGCustomHashMultiMap.DefaultLoadFactor: Single;
begin
  Result := THashTable.DefaultLoadFactor;
end;

class function TGCustomHashMultiMap.MaxLoadFactor: Single;
begin
  Result := THashTable.MaxLoadFactor;
end;

class function TGCustomHashMultiMap.MinLoadFactor: Single;
begin
  Result := THashTable.MinLoadFactor;
end;

constructor TGCustomHashMultiMap.Create;
begin
  FTable := THashTable.Create;
end;

constructor TGCustomHashMultiMap.Create(constref a: array of TEntry);
begin
  FTable := THashTable.Create;
  DoAddAll(a);
end;

constructor TGCustomHashMultiMap.Create(e: IEntryEnumerable);
begin
  FTable := THashTable.Create;
  DoAddAll(e);
end;

constructor TGCustomHashMultiMap.Create(aCapacity: SizeInt);
begin
  FTable := THashTable.Create(aCapacity);
end;

constructor TGCustomHashMultiMap.Create(aCapacity: SizeInt; constref a: array of TEntry);
begin
  FTable := THashTable.Create(aCapacity);
  DoAddAll(a);
end;

constructor TGCustomHashMultiMap.Create(aCapacity: SizeInt; e: IEntryEnumerable);
begin
  FTable := THashTable.Create(aCapacity);
  DoAddAll(e);
end;

{ TGHashMultiMap.TValueSet.TEnumerator }

function TGHashMultiMap.TValueSet.TEnumerator.GetCurrent: TValue;
begin
  Result := FEnum.Current^.Key;
end;

constructor TGHashMultiMap.TValueSet.TEnumerator.Create(aTable: TTable);
begin
  FEnum := aTable.GetEnumerator;
end;

function TGHashMultiMap.TValueSet.TEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGHashMultiMap.TValueSet.TEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGHashMultiMap.TValueSet }

function TGHashMultiMap.TValueSet.GetCount: SizeInt;
begin
  Result := FTable.Count;
end;

constructor TGHashMultiMap.TValueSet.Create;
begin
  FTable := TTable.Create(START_CAPACITY, LOAD_FACTOR);
end;

destructor TGHashMultiMap.TValueSet.Destroy;
begin
  FTable.Free;
  inherited;
end;

function TGHashMultiMap.TValueSet.GetEnumerator: TCustomValueEnumerator;
begin
  Result := TEnumerator.Create(Ftable);
end;

function TGHashMultiMap.TValueSet.Contains(constref aValue: TValue): Boolean;
var
  p: SizeInt;
begin
  Result := FTable.Find(aValue, p) <> nil;
end;

function TGHashMultiMap.TValueSet.Add(constref aValue: TValue): Boolean;
var
  p: PValEntry;
  Pos: SizeInt;
begin
  Result := not FTable.FindOrAdd(aValue, p, Pos);
  if Result then
    p^.Key := aValue;
end;

function TGHashMultiMap.TValueSet.Remove(constref aValue: TValue): Boolean;
begin
  Result := FTable.Remove(aValue);
  if Result then
    FTable.TrimToFit;
end;

{ TGHashMultiMap }

function TGHashMultiMap.GetUniqueKeyValues: Boolean;
begin
  Result := True;
end;

function TGHashMultiMap.CreateValueSet: TCustomValueSet;
begin
  Result := TValueSet.Create;
end;

destructor TGHashMultiMap.Destroy;
begin
  DoClear;
  FTable.Free;
  inherited;
end;

{ TGTreeMultiMap.TValueSet.TEnumerator }

function TGTreeMultiMap.TValueSet.TEnumerator.GetCurrent: TValue;
begin
  Result := FEnum.Current^.Key;
end;

constructor TGTreeMultiMap.TValueSet.TEnumerator.Create(aTable: TTable);
begin
  FEnum := aTable.GetEnumerator;
end;

function TGTreeMultiMap.TValueSet.TEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGTreeMultiMap.TValueSet.TEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGTreeMultiMap.TValueSet }

function TGTreeMultiMap.TValueSet.GetCount: SizeInt;
begin
  Result := FTable.Count;
end;

constructor TGTreeMultiMap.TValueSet.Create(aNodeManager: TNodeManager);
begin
  FTable := TTable.Create(aNodeManager);
end;

destructor TGTreeMultiMap.TValueSet.Destroy;
begin
  FTable.Free;
  inherited;
end;

function TGTreeMultiMap.TValueSet.GetEnumerator: TCustomValueEnumerator;
begin
  Result := TEnumerator.Create(FTable);
end;

function TGTreeMultiMap.TValueSet.Contains(constref aValue: TValue): Boolean;
begin
  Result := FTable.Find(aValue) <> nil;
end;

function TGTreeMultiMap.TValueSet.Add(constref aValue: TValue): Boolean;
var
  p: PNode;
begin
  Result := not FTable.FindOrAdd(aValue, p);
  if Result then
    p^.Data.Key := aValue;
end;

function TGTreeMultiMap.TValueSet.Remove(constref aValue: TValue): Boolean;
begin
  Result := FTable.Remove(aValue);
end;

{ TGTreeMultiMap }

procedure TGTreeMultiMap.DoClear;
begin
  inherited DoClear;
  FNodeManager.Clear;
end;

procedure TGTreeMultiMap.DoTrimToFit;
begin
  inherited;
  if Count = 0 then
    FNodeManager.Clear;
end;

function TGTreeMultiMap.GetUniqueKeyValues: Boolean;
begin
  Result := True;
end;

function TGTreeMultiMap.CreateValueSet: TCustomValueSet;
begin
  Result := TValueSet.Create(FNodeManager);
end;

constructor TGTreeMultiMap.Create;
begin
  FTable := THashTable.Create;
  FNodeManager := TNodeManager.Create;
end;

constructor TGTreeMultiMap.Create(constref a: array of TEntry);
begin
  FTable := THashTable.Create;
  FNodeManager := TNodeManager.Create;
  DoAddAll(a);
end;

constructor TGTreeMultiMap.Create(e: IEntryEnumerable);
begin
  FTable := THashTable.Create;
  FNodeManager := TNodeManager.Create;
  DoAddAll(e);
end;

constructor TGTreeMultiMap.Create(aCapacity: SizeInt);
begin
  FTable := THashTable.Create(aCapacity);
  FNodeManager := TNodeManager.Create;
end;

constructor TGTreeMultiMap.Create(aCapacity: SizeInt; constref a: array of TEntry);
begin
  FTable := THashTable.Create(aCapacity);
  FNodeManager := TNodeManager.Create;
  DoAddAll(a);
end;

constructor TGTreeMultiMap.Create(aCapacity: SizeInt; e: IEntryEnumerable);
begin
  FTable := THashTable.Create(aCapacity);
  FNodeManager := TNodeManager.Create;
  DoAddAll(e);
end;

destructor TGTreeMultiMap.Destroy;
begin
  DoClear;
  FTable.Free;
  FNodeManager.Free;
  inherited;
end;

{ TGListMultiMap.TValueSet.TEnumerator }

function TGListMultiMap.TValueSet.TEnumerator.GetCurrent: TValue;
begin
  Result := FEnum.Current;
end;

constructor TGListMultiMap.TValueSet.TEnumerator.Create(aList: TList);
begin
  FEnum := aList.GetEnumerator;
end;

function TGListMultiMap.TValueSet.TEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGListMultiMap.TValueSet.TEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGListMultiMap.TValueSet }

function TGListMultiMap.TValueSet.GetCount: SizeInt;
begin
  Result := FList.Count;
end;

constructor TGListMultiMap.TValueSet.Create;
begin
  FList := TList.Create(INITIAL_CAPACITY, True);
end;

destructor TGListMultiMap.TValueSet.Destroy;
begin
  FList.Free;
  inherited;
end;

function TGListMultiMap.TValueSet.GetEnumerator: TCustomValueEnumerator;
begin
  Result := TEnumerator.Create(FList);
end;

procedure TGListMultiMap.TValueSet.TrimToFit;
begin
  FList.TrimToFit;
end;

function TGListMultiMap.TValueSet.Contains(constref aValue: TValue): Boolean;
var
  I: SizeInt;
begin
  Result := FList.Contains(aValue);
end;

function TGListMultiMap.TValueSet.Add(constref aValue: TValue): Boolean;
begin
  Result := FList.Add(aValue);
end;

function TGListMultiMap.TValueSet.Remove(constref aValue: TValue): Boolean;
begin
  Result := FList.Remove(aValue);
  FList.TrimToFit;
end;

{ TGListMultiMap }

procedure TGListMultiMap.DoTrimToFit;
var
  p: PMMEntry;
begin
  inherited;
  for p in FTable do
    TValueSet(p^.Values).TrimToFit;
end;

function TGListMultiMap.GetUniqueKeyValues: Boolean;
begin
  Result := False;
end;

function TGListMultiMap.CreateValueSet: TCustomValueSet;
begin
  Result := TValueSet.Create;
end;

destructor TGListMultiMap.Destroy;
begin
  DoClear;
  inherited;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic prority queue implementations.                                  *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGPriorityQueue;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}

interface

uses

  SysUtils,
  math,
  LGUtils,
  LGHelpers,
  LGCustomContainer,
  LGStrConst;

type

  { TGCustomBinHeap: abstract ancestor class of priority queue with queue interface on top of binary heap }
  generic TGCustomBinHeap<T> = class abstract(specialize TGCustomArrayContainer<T>, specialize IGQueue<T>)
  protected
    procedure BuildHeap; virtual; abstract;
    procedure FixHeap(aFrom: SizeInt); inline;
    procedure SiftDown; virtual; abstract;
    procedure FloatUp(aIndex: SizeInt); virtual; abstract;
    function  DequeueItem: T;
    procedure FixAfterEnqueue(aOldCount: SizeInt); inline;
  public
    procedure AfterConstruction; override;
    procedure Enqueue(constref aValue: T);// O(logN)
    function  EnqueueAll(constref a: array of T): SizeInt;
    function  EnqueueAll(e: IEnumerable): SizeInt;
    function  Dequeue: T;                 // O(logN)
    function  TryDequeue(out aValue: T): Boolean;
    function  Peek: T;                    // O(1)
    function  TryPeek(out aValue: T): Boolean;
  end;

  { TGBaseBinHeap implements maximizing priority queue with queue interface;
      functor TCmpRel (comparision relation) must provide
        class function Compare([const[ref]] L, R: T): SizeInt; }
  generic TGBaseBinHeap<T, TCmpRel> = class(specialize TGCustomBinHeap<T>)
  protected
    procedure BuildHeap; override;
    procedure SiftDown; override;
    procedure FloatUp(aIndex: SizeInt);  override;
    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
  end;

  { TGBinHeap assumes that type T implements TCmpRel}
  generic TGBinHeap<T> = class(specialize TGBaseBinHeap<T, T>);

  { TGObjectBinHeap implements maximizing priority queue with queue interface;
      TGObjectBinHeap.Dequeue(or TryDequeue) EXTRACTS object from queue,
      you need to free this object yourself }
  generic TGObjectBinHeap<T: class; TCmpRel> = class(specialize TGBaseBinHeap<T, TCmpRel>)
  private
    FOwnsObjects: Boolean;
  protected
    procedure DoClear; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(constref A: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGObjBinHeap assumes that class T implements TCmpRel}
  generic TGObjBinHeap<T: class> = class(specialize TGObjectBinHeap<T, T>);

  { TGComparableBinHeap }

  generic TGComparableBinHeap<T> = class(specialize TGCustomBinHeap<T>)
  protected
    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
  end;

  { TGComparableBinHeapMax: maximizing priority queue with queue interface,
    it assumes that type T has defined comparision operators}
  generic TGComparableBinHeapMax<T> = class(specialize TGComparableBinHeap<T>)
  protected
    procedure BuildHeap; override;
    procedure SiftDown; override;
    procedure FloatUp(aIndex: SizeInt); override;
  end;

  { TGComparableBinHeapMin: minimizing priority queue with queue interface,
    it assumes that type T has defined comparision operators}
  generic TGComparableBinHeapMin<T> = class(specialize TGComparableBinHeap<T>)
  protected
    procedure BuildHeap; override;
    procedure SiftDown; override;
    procedure FloatUp(aIndex: SizeInt); override;
  end;

  { TGRegularBinHeap: maximizing priority queue with queue interface and regular comparator }
  generic TGRegularBinHeap<T> = class(specialize TGCustomBinHeap<T>)
  private
    FCompare: TCompare;
  protected
    procedure BuildHeap; override;
    procedure SiftDown; override;
    procedure FloatUp(aIndex: SizeInt); override;
  public
  type
    TComparator = TCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref A: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    function Comparator: TComparator; inline;
  end;

  { TGDelegatedBinHeap: maximizing priority queue with queue interface and delegated comparator }
  generic TGDelegatedBinHeap<T> = class(specialize TGCustomBinHeap<T>)
  private
    FCompare: TOnCompare;
  protected
    procedure BuildHeap; override;
    procedure SiftDown; override;
    procedure FloatUp(aIndex: SizeInt); override;
  public
  type
    TComparator = TOnCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref A: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    function Comparator: TOnCompare; inline;
  end;

  { TGBaseLiteBinHeap implements maximizing priority queue with queue interface;
      functor TCmpRel (comparision relation) must provide
        class function Compare([const[ref]] L, R: T): SizeInt; }
  generic TGBaseLiteBinHeap<T, TCmpRel> = record
  public
  type
    TBuffer     = specialize TGLiteDynBuffer<T>;
    TEnumerator = TBuffer.TEnumerator;
    TMutable    = TBuffer.TMutable;
    TReverse    = TBuffer.TReverse;
    TArray      = TBuffer.TArray;
  strict private
  type
    TFake = {$IFNDEF FPC_REQUIRES_PROPER_ALIGNMENT}array[0..Pred(SizeOf(T))] of Byte{$ELSE}T{$ENDIF};

  private
    FBuffer: TBuffer;
    function  GetCapacity: SizeInt; inline;
    procedure BuildHeap;
    procedure SiftDown;
    procedure FloatUp(aIndex: SizeInt);
    function  DequeueItem: T;
    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = specialize TGCompare<T>;
    function  Comparator: TComparator; inline;
    function  GetEnumerator: TEnumerator; inline;
    function  Mutable: TMutable; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    procedure Modified; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    procedure Enqueue(constref aValue: T); inline;
  { EXTRACTS element from the head of queue }
    function  Dequeue: T; inline;
    function  TryDequeue(out aValue: T): Boolean; inline;
    function  Peek: T; inline;
    function  TryPeek(out aValue: T): Boolean; inline;
    property  Count: SizeInt read FBuffer.FCount;
    property  Capacity: SizeInt read GetCapacity;
  end;

  { TGLiteThreadBinHeap }

  generic TGLiteThreadBinHeap<T, TCmpRel> = class
  public
  type
    TQueue = specialize TGBaseLiteBinHeap<T, TCmpRel>;
    PQueue = ^TQueue;

  strict private
    FQueue: TQueue;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    procedure Enqueue(constref aValue: T);
    function  TryDequeue(out aValue: T): Boolean;
    function  TryPeek(out aValue: T): Boolean;
    function  Lock: PQueue;
    procedure Unlock; inline;
  end;

  THandle = SysUtils.THandle;

  { TGCustomBinHeapPQ: abstract ancestor class to implement priority queue on top of binary heap(array based) }
  generic TGCustomBinHeapPQ<T> = class abstract(specialize TGCustomContainer<T>, specialize IGQueue<T>,
    specialize IGPriorityQueue<T>)
    private
      FStackCount: SizeInt;
  public
  type
    TCustomBinHeapPQ = specialize TGCustomBinHeapPQ<T>;
    IPriorityQueue   = specialize IGPriorityQueue<T>;
  protected
  type
    TNode = record
      Data: T;
      HeapIndex: SizeInt;
    end;

    TIntArray = array of SizeInt;
    TNodeList = array of TNode;

    TEnumerator = class(TContainerEnumerator)
    private
      FHeap: TIntArray;
      FNodes: TNodeList;
      FCurrIndex,
      FLast: SizeInt;
    protected
      function  GetCurrent: T; override;
    public
      constructor Create(aQueue: TCustomBinHeapPQ);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TReverseEnum = class(TContainerEnumerable)
    protected
      FHeap: TIntArray;
      FNodes: TNodeList;
      FCurrIndex,
      FLast: SizeInt;
      function  GetCurrent: T; override;
    public
      constructor Create(aQueue: TGCustomBinHeapPQ);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  const
    // MAX_CAPACITY must be <= Succ(SizeInt.MaxValue div 2)
    MAX_CAPACITY: SizeInt          = SizeInt(MAX_CONTAINER_SIZE div SizeOf(TItem));
    MAX_NODELIST_CAPACITY: SizeInt = SizeInt(MAX_CONTAINER_SIZE div SizeOf(TNode));
    NULL = -1;

  var
    FNodeList: TNodeList;
    FHeap: TIntArray;
    FCount,
    FNodeListCount,
    FStackTop: SizeInt;
    procedure CheckEmpty; inline;
    function  GetCount: SizeInt; override;
    function  GetCapacity: SizeInt; override;
    function  NodeListCapacity: SizeInt; inline;
    function  HeapCapacity: SizeInt; inline;
    procedure InitialAlloc(aCapacity: SizeInt);
    procedure HeapExpand(aValue: SizeInt);
    procedure NodeListExpand(aValue: SizeInt);
    function  StackPop: SizeInt; inline;
    procedure StackPush(aValue: SizeInt); inline;
    function  StackEmpty: Boolean; inline;
    procedure ItemAdding;
    function  AddNode(constref aValue: T; aIndex: SizeInt): SizeInt;
    function  NodeListRemove(aIndex: SizeInt): T; inline;
    procedure CopyItems(aBuffer: PItem); override;
    function  DoEnqueue(constref aValue: T): SizeInt;
    function  DoDequeue: T;
    function  GetValue(aNodeIndex: SizeInt): T;
    function  DoRemove(aNodeIndex: SizeInt): T;
    function  EnqueueArray(constref a: array of T): SizeInt;
    function  EnqueueContainer(c: TCustomContainer): SizeInt;
    function  EnqueueEnum(e: IEnumerable): SizeInt;
    procedure BuildHeap; virtual; abstract;
    procedure FixHeap(aIndex: SizeInt); inline;
    procedure FloatUp(aIndex: SizeInt); virtual; abstract;
    procedure SiftDown(aIndex: SizeInt); virtual; abstract;
    procedure DoUpdate(aNodeIndex: SizeInt; constref aValue: T); virtual; abstract;
    function  MergeBinHeap(bh: TGCustomBinHeapPQ): SizeInt;
    function  DoGetEnumerator: TCustomEnumerator; override;
    procedure DoClear; override;
    procedure DoTrimToFit; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    property  ElemCount: SizeInt read FCount;
    property  NodeListCount: SizeInt read FNodeListCount;
    property  StackTop: SizeInt read FStackTop;
    property  StackCount: SizeInt read FStackCount;
  public
    destructor Destroy; override;
    function  Reverse: IEnumerable; override;
    procedure Enqueue(constref aValue: T); inline;        // O(logN)
    function  EnqueueAll(constref a: array of T): SizeInt;
    function  EnqueueAll(e: IEnumerable): SizeInt;
    function  Dequeue: T;                                 // O(logN)
    function  TryDequeue(out aValue: T): Boolean;
    function  Peek: T;                                    // O(1)
    function  TryPeek(out aValue: T): Boolean;
    function  Insert(constref aValue: T): THandle; inline;
    function  PeekHead: THandle; inline;                      // O(1)
    function  TryPeekHead(out aHandle: THandle): Boolean; inline;
    function  Value(aHandle: THandle): T; inline;
    procedure Update(aHandle: THandle; constref aValue: T); inline;// O(logN)
    function  Remove(aHandle: THandle): T; inline;        // O(logN)
  { note: after Merge handles from aQueue will become invalid }
    function  Merge(aQueue: IPriorityQueue): SizeInt; //O(aQueue.Count)
  end;

  { TGBaseBinHeapPQ implements maximizing priority queue (array based);
      functor TCmpRel (comparision relation) must provide
        class function Compare([const[ref]] L, R: T): SizeInt; }
  generic TGBaseBinHeapPQ<T, TCmpRel> = class(specialize TGCustomBinHeapPQ<T>)
  protected
    procedure BuildHeap; override;
    procedure FloatUp(aIndex: SizeInt); override;
    procedure SiftDown(aIndex: SizeInt); override;
    procedure DoUpdate(aIndex: SizeInt; constref aValue: T); override;
    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref A: array of T);
    constructor Create(e: IEnumerable);
  end;

  { TGBinHeapPQ assumes that type T implements TCmpRel}
  generic TGBinHeapPQ<T> = class(specialize TGBaseBinHeapPQ<T, T>);

  generic TGComparableBinHeapPQ<T> = class(specialize TGCustomBinHeapPQ<T>)
  protected
    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
  end;

  { TGComparableBinHeapPQMax: maximizing priority queue (array based),
    it assumes that type T has defined comparision operators }
  generic TGComparableBinHeapPQMax<T> = class(specialize TGComparableBinHeapPQ<T>)
  protected
    procedure BuildHeap; override;
    procedure FloatUp(aIndex: SizeInt); override;
    procedure SiftDown(aIndex: SizeInt); override;
    procedure DoUpdate(aIndex: SizeInt; constref aValue: T); override;
  public
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref A: array of T);
    constructor Create(e: IEnumerable);
  end;

  { TGComparableBinHeapPQMin: minimizing priority queue(array based),
    it assumes that type T has defined comparision operators }
  generic TGComparableBinHeapPQMin<T> = class(specialize TGComparableBinHeapPQ<T>)
  protected
    procedure BuildHeap; override;
    procedure FloatUp(aIndex: SizeInt); override;
    procedure SiftDown(aIndex: SizeInt); override;
    procedure DoUpdate(aIndex: SizeInt; constref aValue: T); override;
  public
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref A: array of T);
    constructor Create(e: IEnumerable);
  end;

  { TGRegularBinHeapPQ: maximizing priority queue with regular comparator(array based) }
  generic TGRegularBinHeapPQ<T> = class(specialize TGCustomBinHeapPQ<T>)
  protected
    FCompare: TCompare;
    procedure BuildHeap; override;
    procedure FloatUp(aIndex: SizeInt); override;
    procedure SiftDown(aIndex: SizeInt); override;
    procedure DoUpdate(aIndex: SizeInt; constref aValue: T); override;
  public
  type
    TComparator = TCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref A: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    function Comparator: TComparator; inline;
  end;

  { TGDelegatedBinHeapPQ: maximizing priority queue with delegated comparator(array based) }
  generic TGDelegatedBinHeapPQ<T> = class(specialize TGCustomBinHeapPQ<T>)
  protected
    FCompare: TOnCompare;
    procedure BuildHeap; override;
    procedure FloatUp(aIndex: SizeInt); override;
    procedure SiftDown(aIndex: SizeInt); override;
    procedure DoUpdate(aIndex: SizeInt; constref aValue: T); override;
  public
  type
    TComparator = TOnCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref A: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    function Comparator: TComparator; inline;
  end;

{.$DEFINE ENABLE_TWOPASSMERGE_RECURSION}  //if uncomment define, will compile recursive TwoPassMerge
{$DEFINE PAIRHEAP_ENABLE_PAGEDNODEMANAGER}//if uncomment define, will use TGJoinablePageNodeManager

  { TGCustomPairingHeap: abstract ancestor class to implement priority queue on top of pairing heap }
  generic TGCustomPairingHeap<T> = class abstract(specialize TGCustomContainer<T>, specialize IGQueue<T>,
    specialize IGPriorityQueue<T>)
  public
  type
    TCustomPairingHeap = specialize TGCustomPairingHeap<T>;
    IPriorityQueue     = specialize IGPriorityQueue<T>;
  protected
  type

    PNode = ^TNode;

    TNode = record
      Child,
      Sibling,
      Prev: PNode;
      Data: T;
      procedure AddChild(aNode: PNode);
      procedure ClearLinks; inline;
      function  Successor: PNode;
      function  Predecessor: PNode;
      //for node manager
      property  NextLink: PNode read Child write Child;
    end;

    TEnumerator = class(TContainerEnumerator)
    private
      FCurrNode,
      FLeftmost: PNode;
      FInCycle: Boolean;
    protected
      function  GetCurrent: T; override;
    public
      constructor Create(aHeap: TCustomPairingHeap);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TReverseEnum = class(TContainerEnumerable)
    protected
      FCurrNode,
      FRightmost: PNode;
      FInCycle: Boolean;
      function  GetCurrent: T; override;
    public
      constructor Create(aHeap: TCustomPairingHeap);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

{$IFDEF PAIRHEAP_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGJoinablePageNodeManager<TNode>;
{$ELSE PAIRHEAP_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGJoinableNodeManager<TNode>;
{$ENDIF PAIRHEAP_ENABLE_PAGEDNODEMANAGER}

  var
    FRoot: PNode;
    FNodeManager: TNodeManager;
    FCount: SizeInt;
    procedure CheckEmpty; inline;
    function  GetCount: SizeInt; override;
    function  GetCapacity: SizeInt; override;
    procedure CopyItems(aBuffer: PItem); override;
    function  DoGetEnumerator: TCustomEnumerator; override;
    procedure DoClear; override;
    procedure DoTrimToFit; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    function  NewNode(constref aValue: T): PNode;
    procedure DisposeNode(aNode: PNode); inline;
    procedure RemoveNodeWithChilds(aNode: PNode);
    procedure ClearTree;
    function  FindLeftmost: PNode;
    function  FindRightmost: PNode;
    function  EnqueueArray(constref a: array of T): SizeInt;
    function  EnqueueContainer(c: TCustomContainer): SizeInt;
    function  EnqueueEnum(e: IEnumerable): SizeInt;
    function  DoEnqueue(constref aValue: T): PNode; virtual; abstract;
    procedure DoUpdate(aNode: PNode; constref aValue: T); virtual; abstract;
    function  DoRemove(aNode: PNode): T; virtual; abstract;
    function  DoDequeue: T; virtual; abstract;
    function  DoMergeHeap(ph: TCustomPairingHeap): SizeInt; virtual; abstract;
    property  ElemCount: SizeInt read FCount;
    class procedure CutNode(aNode: PNode); static;
  public
    destructor Destroy; override;
    function  Reverse: IEnumerable; override;
    procedure Enqueue(constref aValue: T); inline;          // O(1)
    function  EnqueueAll(constref a: array of T): SizeInt;
    function  EnqueueAll(e: IEnumerable): SizeInt;
    function  Dequeue: T;                                   // amortized O(logN)
    function  TryDequeue(out aValue: T): Boolean;
    function  Peek: T;                                      // O(1)
    function  TryPeek(out aValue: T): Boolean;
    function  Insert(constref aValue: T): THandle; inline;  // O(1)
    function  PeekHead: THandle; inline;                    // O(1)
    function  TryPeekHead(out aHandle: THandle): Boolean; inline;
    function  Value(aHandle: THandle): T; inline;
    procedure Update(aHandle: THandle; constref aValue: T); inline; //O(1) IncreaseKey
    function  Remove(aHandle: THandle): T;                  // amortized O(logN)
  { note: after Merge all handles from aQueue will remain valid if aQueue has same ClassType }
    function  Merge(aQueue: IPriorityQueue): SizeInt;       // O(1) if aQueue has same ClassType
  end;

  { TGBasePairingHeap implements maximizing priority queue;
      functor TCmpRel (comparision relation) must provide
        class function Compare([const[ref]] L, R: T): SizeInt; }
  generic TGBasePairingHeap<T, TCmpRel> = class(specialize TGCustomPairingHeap<T>)
  protected
    procedure RootMerge(aNode: PNode); inline;
    procedure DoExtract(aNode: PNode);
    function  DoEnqueue(constref aValue: T): PNode; override;
    procedure DoUpdate(aNode: PNode; constref aValue: T); override;
    function  DoRemove(aNode: PNode): T; override;
    function  DoDequeue: T; override;
    function  DoMergeHeap(ph: TCustomPairingHeap): SizeInt; override;
    class function DoMerge(L, R: PNode): PNode; static; inline;
    class function TwoPassMerge(aNode: PNode): PNode; static;
    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref A: array of T);
    constructor Create(e: IEnumerable);
  end;

  { TGPairingHeap assumes that type T implements TCmpRel}
  generic TGPairingHeap<T> = class(specialize TGBasePairingHeap<T, T>);

  generic TGComparablePairHeap<T> = class(specialize TGCustomPairingHeap<T>)
  protected
    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
  end;

  { TGComparablePairHeapMax: maximizing priority queue, it assumes
    that type T has defined comparision operators }
  generic TGComparablePairHeapMax<T> = class(specialize TGComparablePairHeap<T>)
  protected
    procedure RootMerge(aNode: PNode); inline;
    procedure DoExtract(aNode: PNode);
    function  DoEnqueue(constref aValue: T): PNode; override;
    procedure DoUpdate(aNode: PNode; constref aValue: T); override;
    function  DoRemove(aNode: PNode): T; override;
    function  DoDequeue: T; override;
    function  DoMergeHeap(ph: TCustomPairingHeap): SizeInt; override;
    class function DoMerge(L, R: PNode): PNode; static; inline;
    class function TwoPassMerge(aNode: PNode): PNode; static;
  public
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref A: array of T);
    constructor Create(e: IEnumerable);
  end;

  { TGComparablePairHeapMin: minimizing priority queue, it assumes
    that type T has defined comparision operators }
  generic TGComparablePairHeapMin<T> = class(specialize TGComparablePairHeap<T>)
  protected
    procedure RootMerge(aNode: PNode); inline;
    procedure DoExtract(aNode: PNode);
    function  DoEnqueue(constref aValue: T): PNode; override;
    procedure DoUpdate(aNode: PNode; constref aValue: T); override;
    function  DoRemove(aNode: PNode): T; override;
    function  DoDequeue: T; override;
    function  DoMergeHeap(ph: TCustomPairingHeap): SizeInt; override;
    class function DoMerge(L, R: PNode): PNode; static; inline;
    class function TwoPassMerge(aNode: PNode): PNode; static;
  public
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref A: array of T);
    constructor Create(e: IEnumerable);
  end;

  { TGRegularPairHeap: maximizing priority queue with regular comparator }
  generic TGRegularPairHeap<T> = class(specialize TGCustomPairingHeap<T>)
  protected
    FCompare: TCompare;
    function  DoMerge(L, R: PNode): PNode; inline;
    procedure RootMerge(aNode: PNode); inline;
    function  TwoPassMerge(aNode: PNode): PNode;
    procedure DoExtract(aNode: PNode);
    function  DoEnqueue(constref aValue: T): PNode; override;
    procedure DoUpdate(aNode: PNode; constref aValue: T); override;
    function  DoRemove(aNode: PNode): T; override;
    function  DoDequeue: T; override;
    function  DoMergeHeap(ph: TCustomPairingHeap): SizeInt; override;
  public
  type
    TComparator = TCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref A: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    function Comparator: TComparator; inline;
  end;

  { TGDelegatedPairHeap: maximizing priority queue with delegated comparator }
  generic TGDelegatedPairHeap<T> = class(specialize TGCustomPairingHeap<T>)
  protected
    FCompare: TOnCompare;
    function  DoMerge(L, R: PNode): PNode; inline;
    procedure RootMerge(aNode: PNode); inline;
    function  TwoPassMerge(aNode: PNode): PNode;
    procedure DoExtract(aNode: PNode);
    function  DoEnqueue(constref aValue: T): PNode; override;
    procedure DoUpdate(aNode: PNode; constref aValue: T); override;
    function  DoRemove(aNode: PNode): T; override;
    function  DoDequeue: T; override;
    function  DoMergeHeap(ph: TCustomPairingHeap): SizeInt; override;
  public
  type
    TComparator = TOnCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref A: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    function Comparator: TComparator; inline;
  end;

  { TGLitePairingHeap implements maximizing priority queue;
      functor TCmpRel (comparision relation) must provide
        class function Compare([const[ref]] L, R: T): SizeInt; }
  generic TGLitePairingHeap<T, TCmpRel> = record
  private
  type
    PGLitePairingHeap = ^TGLitePairingHeap;

    PNode = ^TNode;
    TNode = record
      Child,
      Sibling,
      Prev: PNode;
      Data: T;
      procedure AddChild(aNode: PNode); inline;
      procedure ClearLinks; inline;
      function  Successor: PNode;
      function  Predecessor: PNode;
      //for node manager
      property  NextLink: PNode read Child write Child;
    end;

{$IFDEF PAIRHEAP_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGJoinablePageNodeManager<TNode>;
{$ELSE PAIRHEAP_ENABLE_PAGEDNODEMANAGER}
    TNodeManager = specialize TGJoinableNodeManager<TNode>;
{$ENDIF PAIRHEAP_ENABLE_PAGEDNODEMANAGER}

  public
  type
    TArray = array of T;
    PItem  = ^T;

    TEnumerator = record
    private
      FCurrNode,
      FLeftmost: PNode;
      FInCycle: Boolean;
      function  GetCurrent: T; inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

    TReverseEnumerator = record
    private
      FCurrNode,
      FRightmost: PNode;
      FInCycle: Boolean;
      function  GetCurrent: T; inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
    end;

    TReverse = record
    private
      FHeap: PGLitePairingHeap;
    public
      function GetEnumerator: TReverseEnumerator; inline;
    end;

  private
    FRoot: PNode;
    FNodeManager: TNodeManager;
    FCount: SizeInt;
    function  GetCapacity: SizeInt; inline;
    function  GetReverseEnumerator: TReverseEnumerator; inline;
    function  FindLeftmost: PNode;
    function  FindRightmost: PNode;
    procedure RemoveNodeWithChilds(aNode: PNode);
    procedure ClearTree;
    function  NewNode(constref aValue: T): PNode;
    procedure DisposeNode(aNode: PNode); inline;
    procedure RootMerge(aNode: PNode); inline;
    function  DequeueItem: T;
    procedure UpdateNode(aNode: PNode; constref aValue: T);
    procedure ExtractNode(aNode: PNode);
    function  RemoveNode(aNode: PNode): T;
    procedure CheckEmpty; inline;
    procedure AccessEmptyError; inline;
    class operator  Initialize(var h: TGLitePairingHeap);
    class operator  Finalize(var h: TGLitePairingHeap);
    class operator  Copy(constref aSrc: TGLitePairingHeap; var aDst: TGLitePairingHeap);
    class function  NodeMerge(L, R: PNode): PNode; static; inline; //inline ???
    class function  TwoPassMerge(aNode: PNode): PNode; static;
    class procedure CutNode(aNode: PNode); static;
    class function  DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = specialize TGCompare<T>;
    function  Comparator: TComparator;
    function  GetEnumerator: TEnumerator; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    procedure Enqueue(constref aValue: T); inline;          // O(1)
    function  Dequeue: T;                                   // amortized O(logN)
    function  TryDequeue(out aValue: T): Boolean;
    function  Peek: T;                                      // O(1)
    function  TryPeek(out aValue: T): Boolean;
    function  Insert(constref aValue: T): THandle; inline;  // O(1)
    function  PeekHead: THandle; inline;                    // O(1)
    function  TryPeekHead(out aValue: THandle): Boolean; inline;
    function  Value(aHandle: THandle): T; inline;
    procedure Update(aHandle: THandle; constref aValue: T); inline; //O(1)              IncreaseKey
                                                                    //amortized O(logN) DecreaseKey
    function  Remove(aHandle: THandle): T;                  // amortized O(logN)
  { note: after Merge all handles from aHeap will remain valid }
    function  Merge(aHeap: TGLitePairingHeap): SizeInt;     // O(1)
    property  Count: SizeInt read FCount;
    property  Capacity: SizeInt read GetCapacity;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGCustomBinHeap }

procedure TGCustomBinHeap.FixHeap(aFrom: SizeInt);
begin
  for aFrom := aFrom to Pred(ElemCount) do
    FloatUp(aFrom);
end;

function TGCustomBinHeap.DequeueItem: T;
begin
  Result := FItems[0];
  Dec(FCount);
  if ElemCount > 0 then
    begin
      FItems[0] := FItems[ElemCount];
      FItems[ElemCount] := Default(T);
      SiftDown;
    end
  else
    FItems[0] := Default(T);
end;

procedure TGCustomBinHeap.FixAfterEnqueue(aOldCount: SizeInt);
begin
  if aOldCount > 0 then
    FixHeap(aOldCount)
  else
    BuildHeap;
end;

procedure TGCustomBinHeap.AfterConstruction;
begin
  inherited;
  if ElemCount > 1 then
    BuildHeap;
end;

procedure TGCustomBinHeap.Enqueue(constref aValue: T);
var
  InsertPos: SizeInt;
begin
  CheckInIteration;
  InsertPos := ElemCount;
  ItemAdding;
  FItems[InsertPos] := aValue;
  Inc(FCount);
  if InsertPos > 0 then
    FloatUp(InsertPos);
end;

function TGCustomBinHeap.EnqueueAll(constref a: array of T): SizeInt;
var
  OldCount: SizeInt;
begin
  CheckInIteration;
  OldCount := ElemCount;
  Result := AppendArray(a);
  if Result > 0 then
    FixAfterEnqueue(OldCount);
end;

function TGCustomBinHeap.EnqueueAll(e: IEnumerable): SizeInt;
var
  OldCount: SizeInt;
begin
  CheckInIteration;
  OldCount := ElemCount;
  Result := AppendEnumerable(e);
  if Result > 0 then
    FixAfterEnqueue(OldCount);
end;

function TGCustomBinHeap.Dequeue: T;
begin
  CheckInIteration;
  CheckEmpty;
  Result := DequeueItem;
end;

function TGCustomBinHeap.TryDequeue(out aValue: T): Boolean;
begin
  Result := not InIteration and (ElemCount > 0);
  if Result then
    aValue := DequeueItem;
end;

function TGCustomBinHeap.Peek: T;
begin
  CheckEmpty;
  Result := FItems[0];
end;

function TGCustomBinHeap.TryPeek(out aValue: T): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aValue := FItems[0];
end;

{ TGBaseBinHeap }

procedure TGBaseBinHeap.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          v := TFake(FItems[CurrIdx]);
          while NextIdx <= HighIdx do
            begin
              if(Succ(NextIdx) <= HighIdx) and (TCmpRel.Compare(FItems[NextIdx], FItems[Succ(NextIdx)]) < 0)then
                Inc(NextIdx);
              if TCmpRel.Compare(T(v), FItems[NextIdx]) >= 0 then
                break;
              TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          TFake(FItems[CurrIdx]) := v;
        end;
    end;
end;

procedure TGBaseBinHeap.SiftDown;
var
  CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      CurrIdx := 0;
      NextIdx := 1;
      v := TFake(FItems[0]);
      while NextIdx <= HighIdx do
        begin
          if(Succ(NextIdx) <= HighIdx) and (TCmpRel.Compare(FItems[NextIdx], FItems[Succ(NextIdx)]) < 0) then
            Inc(NextIdx);
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(CurrIdx) shr 1;
      while (CurrIdx > 0) and (TCmpRel.Compare(T(v), FItems[NextIdx]) > 0) do
        begin
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      TFake(FItems[CurrIdx]) := v;
    end;
end;

procedure TGBaseBinHeap.FloatUp(aIndex: SizeInt);
var
  ParentIdx: SizeInt;
  v: TFake;
begin
  ParentIdx := Pred(aIndex) shr 1;
  v := TFake(FItems[aIndex]);
  while(aIndex > 0) and (TCmpRel.Compare(T(v), FItems[ParentIdx]) > 0) do
    begin
      TFake(FItems[aIndex]) := TFake(FItems[ParentIdx]);
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  TFake(FItems[aIndex]) := v;
end;

class function TGBaseBinHeap.DoCompare(constref L, R: T): SizeInt;
begin
  Result := TCmpRel.Compare(L, R);
end;

class function TGBaseBinHeap.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

{ TGObjectBinHeap }

procedure TGObjectBinHeap.DoClear;
var
  I: SizeInt;
begin
  if OwnsObjects then
    for I := 0 to Pred(ElemCount) do
      FItems[I].Free;
  inherited;
end;

constructor TGObjectBinHeap.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectBinHeap.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectBinHeap.Create(constref A: array of T; aOwnsObjects: Boolean = True);
begin
  inherited Create(A);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectBinHeap.Create(e: IEnumerable; aOwnsObjects: Boolean = True);
begin
  inherited Create(e);
  FOwnsObjects := aOwnsObjects;
end;

{ TGComparableBinHeapMax }

procedure TGComparableBinHeapMax.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          v := TFake(FItems[CurrIdx]);
          while NextIdx <= HighIdx do
            begin
              if(Succ(NextIdx) <= HighIdx) and (FItems[NextIdx] < FItems[Succ(NextIdx)])then
                Inc(NextIdx);
              if T(v) >= FItems[NextIdx] then
                break;
              TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          TFake(FItems[CurrIdx]) := v;
        end;
    end;
end;

procedure TGComparableBinHeapMax.SiftDown;
var
  CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      CurrIdx := 0;
      NextIdx := 1;
      v := TFake(FItems[0]);
      while NextIdx <= HighIdx do
        begin
          if (Succ(NextIdx) <= HighIdx) and (FItems[NextIdx] < FItems[Succ(NextIdx)]) then
            Inc(NextIdx);
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(CurrIdx) shr 1;
      while (CurrIdx > 0) and (T(v) > FItems[NextIdx]) do
        begin
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      TFake(FItems[CurrIdx]) := v;
    end;
end;

procedure TGComparableBinHeapMax.FloatUp(aIndex: SizeInt);
var
  ParentIdx: SizeInt;
  v: TFake;
begin
  ParentIdx := Pred(aIndex) shr 1;
  v := TFake(FItems[aIndex]);
  while (aIndex > 0) and (T(v) > FItems[ParentIdx]) do
    begin
      TFake(FItems[aIndex]) := TFake(FItems[ParentIdx]);
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  TFake(FItems[aIndex]) := v;
end;

{ TGComparableBinHeap }

class function TGComparableBinHeap.DoCompare(constref L, R: T): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGComparableBinHeap.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

{ TGComparableBinHeapMin }

procedure TGComparableBinHeapMin.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          v := TFake(FItems[CurrIdx]);
          while NextIdx <= HighIdx do
            begin
              if(Succ(NextIdx) <= HighIdx) and (FItems[NextIdx] > FItems[Succ(NextIdx)])then
                Inc(NextIdx);
              if T(v) <= FItems[NextIdx] then
                break;
              TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          TFake(FItems[CurrIdx]) := v;
        end;
    end;
end;

procedure TGComparableBinHeapMin.SiftDown;
var
  CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      CurrIdx := 0;
      NextIdx := 1;
      v := TFake(FItems[0]);
      while NextIdx <= HighIdx do
        begin
          if (Succ(NextIdx) <= HighIdx) and (FItems[NextIdx] > FItems[Succ(NextIdx)]) then
            Inc(NextIdx);
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(CurrIdx) shr 1;
      while (CurrIdx > 0) and (T(v) < FItems[NextIdx]) do
        begin
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      TFake(FItems[CurrIdx]) := v;
    end;
end;

procedure TGComparableBinHeapMin.FloatUp(aIndex: SizeInt);
var
  ParentIdx: SizeInt;
  v: TFake;
begin
  ParentIdx := Pred(aIndex) shr 1;
  v := TFake(FItems[aIndex]);
  while (aIndex > 0) and (T(v) < FItems[ParentIdx]) do
    begin
      TFake(FItems[aIndex]) := TFake(FItems[ParentIdx]);
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  TFake(FItems[aIndex]) := v;
end;

{ TGRegularBinHeap }

procedure TGRegularBinHeap.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          v := TFake(FItems[CurrIdx]);
          while NextIdx <= HighIdx do
            begin
              if (Succ(NextIdx) <= HighIdx) and (FCompare(FItems[NextIdx], FItems[Succ(NextIdx)]) < 0) then
                Inc(NextIdx);
              if FCompare(T(v), FItems[NextIdx]) >= 0 then
                break;
              TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          TFake(FItems[CurrIdx]) := v;
        end;
    end;
end;

procedure TGRegularBinHeap.SiftDown;
var
  CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      CurrIdx := 0;
      NextIdx := 1;
      v := TFake(FItems[0]);
      while NextIdx <= HighIdx do
        begin
          if(Succ(NextIdx) <= HighIdx) and (FCompare(FItems[NextIdx], FItems[Succ(NextIdx)]) < 0) then
            Inc(NextIdx);
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(CurrIdx) shr 1;
      while (CurrIdx > 0) and (FCompare(T(v), FItems[NextIdx]) > 0) do
        begin
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      TFake(FItems[CurrIdx]) := v;
    end;
end;

procedure TGRegularBinHeap.FloatUp(aIndex: SizeInt);
var
  ParentIdx: SizeInt;
  v: TFake;
begin
  ParentIdx := Pred(aIndex) shr 1;
  v := TFake(FItems[aIndex]);
  while(aIndex > 0) and (FCompare(T(v), FItems[ParentIdx]) > 0) do
    begin
      TFake(FItems[aIndex]) := TFake(FItems[ParentIdx]);
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  TFake( FItems[aIndex]) := v;
end;

constructor TGRegularBinHeap.Create;
begin
  Create(TDefaults.Compare);
end;

constructor TGRegularBinHeap.Create(c: TComparator);
begin
  inherited Create;
  FCompare := c;
end;

constructor TGRegularBinHeap.Create(aCapacity: SizeInt; c: TComparator);
begin
  inherited Create(aCapacity);
  FCompare := c;
end;

constructor TGRegularBinHeap.Create(constref A: array of T; c: TComparator);
begin
  inherited Create(A);
  FCompare := c;
end;

constructor TGRegularBinHeap.Create(e: IEnumerable; c: TComparator);
begin
  inherited Create(e);
  FCompare := c;
end;

function TGRegularBinHeap.Comparator: TComparator;
begin
  Result := FCompare;
end;

{ TGDelegatedBinHeap }

procedure TGDelegatedBinHeap.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          v := TFake(FItems[CurrIdx]);
          while NextIdx <= HighIdx do
            begin
              if (Succ(NextIdx) <= HighIdx) and (FCompare(FItems[NextIdx], FItems[Succ(NextIdx)]) < 0) then
                Inc(NextIdx);
              if FCompare(T(v), FItems[NextIdx]) >= 0 then
                break;
              TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          TFake(FItems[CurrIdx]) := v;
        end;
    end;
end;

procedure TGDelegatedBinHeap.SiftDown;
var
  CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      CurrIdx := 0;
      NextIdx := 1;
      v := TFake(FItems[0]);
      while NextIdx <= HighIdx do
        begin
          if(Succ(NextIdx) <= HighIdx) and (FCompare(FItems[NextIdx], FItems[Succ(NextIdx)]) < 0) then
            Inc(NextIdx);
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(CurrIdx) shr 1;
      while (CurrIdx > 0) and (FCompare(T(v), FItems[NextIdx]) > 0) do
        begin
          TFake(FItems[CurrIdx]) := TFake(FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      TFake(FItems[CurrIdx]) := v;
    end;
end;

procedure TGDelegatedBinHeap.FloatUp(aIndex: SizeInt);
var
  ParentIdx: SizeInt;
  v: TFake;
begin
  ParentIdx := Pred(aIndex) shr 1;
  v := TFake(FItems[aIndex]);
  while(aIndex > 0) and (FCompare(T(v), FItems[ParentIdx]) > 0) do
    begin
      TFake(FItems[aIndex]) := TFake(FItems[ParentIdx]);
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  TFake( FItems[aIndex]) := v;
end;

constructor TGDelegatedBinHeap.Create;
begin
  Create(TDefaults.OnCompare);
end;

constructor TGDelegatedBinHeap.Create(c: TComparator);
begin
  inherited Create;
  FCompare := c;
end;

constructor TGDelegatedBinHeap.Create(aCapacity: SizeInt; c: TComparator);
begin
  inherited Create(aCapacity);
  FCompare := c;
end;

constructor TGDelegatedBinHeap.Create(constref A: array of T; c: TComparator);
begin
  inherited Create(A);
  FCompare := c;
end;

constructor TGDelegatedBinHeap.Create(e: IEnumerable; c: TComparator);
begin
  inherited Create(e);
  FCompare := c;
end;

function TGDelegatedBinHeap.Comparator: TOnCompare;
begin
  Result := FCompare;
end;

{ TGBaseLiteBinHeap }

function TGBaseLiteBinHeap.GetCapacity: SizeInt;
begin
  Result := FBuffer.Capacity;
end;

procedure TGBaseLiteBinHeap.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  if Count > 1 then
    begin
      HighIdx := Pred(Count);
      for I := Pred(Count shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          v := TFake(FBuffer.FItems[CurrIdx]);
          while NextIdx <= HighIdx do
            begin
              if(Succ(NextIdx) <= HighIdx) and
                (TCmpRel.Compare(FBuffer.FItems[NextIdx], FBuffer.FItems[Succ(NextIdx)]) < 0)then
                Inc(NextIdx);
              if TCmpRel.Compare(T(v), FBuffer.FItems[NextIdx]) >= 0 then
                break;
              TFake(FBuffer.FItems[CurrIdx]) := TFake(FBuffer.FItems[NextIdx]);
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          TFake(FBuffer.FItems[CurrIdx]) := v;
        end;
    end;
end;

procedure TGBaseLiteBinHeap.SiftDown;
var
  CurrIdx, NextIdx, HighIdx: SizeInt;
  v: TFake;
begin
  HighIdx := Pred(Count);
  if HighIdx > 0 then
    begin
      CurrIdx := 0;
      NextIdx := 1;
      v := TFake(FBuffer.FItems[0]);
      while NextIdx <= HighIdx do
        begin
          if(Succ(NextIdx) <= HighIdx) and
            (TCmpRel.Compare(FBuffer.FItems[NextIdx], FBuffer.FItems[Succ(NextIdx)]) < 0) then
            Inc(NextIdx);
          TFake(FBuffer.FItems[CurrIdx]) := TFake(FBuffer.FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(CurrIdx) shr 1;
      while (CurrIdx > 0) and (TCmpRel.Compare(T(v), FBuffer.FItems[NextIdx]) > 0) do
        begin
          TFake(FBuffer.FItems[CurrIdx]) := TFake(FBuffer.FItems[NextIdx]);
          CurrIdx := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      TFake(FBuffer.FItems[CurrIdx]) := v;
    end;
end;

procedure TGBaseLiteBinHeap.FloatUp(aIndex: SizeInt);
var
  ParentIdx: SizeInt;
  v: TFake;
begin
  if aIndex > 0 then
    begin
      ParentIdx := Pred(aIndex) shr 1;
      v := TFake(FBuffer.FItems[aIndex]);
      while(aIndex > 0) and (TCmpRel.Compare(T(v), FBuffer.FItems[ParentIdx]) > 0) do
        begin
          TFake(FBuffer.FItems[aIndex]) := TFake(FBuffer.FItems[ParentIdx]);
          aIndex := ParentIdx;
          ParentIdx := Pred(ParentIdx) shr 1;
        end;
      TFake(FBuffer.FItems[aIndex]) := v;
    end;
end;

function TGBaseLiteBinHeap.DequeueItem: T;
begin
  Result :=  FBuffer.FItems[0];
  Dec(FBuffer.FCount);
  if Count > 0 then
    begin
      FBuffer.FItems[0] := FBuffer.FItems[Count];
      FBuffer.FItems[Count] := Default(T);
      SiftDown;
    end
  else
    FBuffer.FItems[0] := Default(T);
end;

class function TGBaseLiteBinHeap.DoCompare(constref L, R: T): SizeInt;
begin
  Result := TCmpRel.Compare(L, R);
end;

function TGBaseLiteBinHeap.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

function TGBaseLiteBinHeap.GetEnumerator: TEnumerator;
begin
  Result := FBuffer.GetEnumerator;
end;

function TGBaseLiteBinHeap.Mutable: TMutable;
begin
  Result := FBuffer.Mutable;
end;

function TGBaseLiteBinHeap.Reverse: TReverse;
begin
  Result := FBuffer.Reverse;
end;

function TGBaseLiteBinHeap.ToArray: TArray;
begin
  Result := FBuffer.ToArray;
end;

procedure TGBaseLiteBinHeap.Clear;
begin
  FBuffer.Clear;
end;

procedure TGBaseLiteBinHeap.Modified;
begin
  BuildHeap;
end;

function TGBaseLiteBinHeap.IsEmpty: Boolean;
begin
  Result := FBuffer.Count = 0;
end;

function TGBaseLiteBinHeap.NonEmpty: Boolean;
begin
  Result := FBuffer.Count <> 0;
end;

procedure TGBaseLiteBinHeap.EnsureCapacity(aValue: SizeInt);
begin
  FBuffer.EnsureCapacity(aValue);
end;

procedure TGBaseLiteBinHeap.TrimToFit;
begin
  FBuffer.TrimToFit;
end;

procedure TGBaseLiteBinHeap.Enqueue(constref aValue: T);
begin
  FloatUp(FBuffer.PushLast(aValue));
end;

function TGBaseLiteBinHeap.Dequeue: T;
begin
  FBuffer.CheckEmpty;
  Result := DequeueItem;
end;

function TGBaseLiteBinHeap.TryDequeue(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := DequeueItem;
end;

function TGBaseLiteBinHeap.Peek: T;
begin
  FBuffer.CheckEmpty;
  Result := FBuffer.FItems[0];
end;

function TGBaseLiteBinHeap.TryPeek(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := FBuffer.FItems[0];
end;

{ TGLiteThreadBinHeap }

procedure TGLiteThreadBinHeap.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGLiteThreadBinHeap.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteThreadBinHeap.Destroy;
begin
  DoLock;
  try
    Finalize(FQueue);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGLiteThreadBinHeap.Clear;
begin
  DoLock;
  try
    FQueue.Clear;
  finally
    UnLock;
  end;
end;

procedure TGLiteThreadBinHeap.Enqueue(constref aValue: T);
begin
  DoLock;
  try
    FQueue.Enqueue(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadBinHeap.TryDequeue(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FQueue.TryDequeue(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadBinHeap.TryPeek(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FQueue.TryPeek(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadBinHeap.Lock: PQueue;
begin
  Result := @FQueue;
  DoLock;
end;

procedure TGLiteThreadBinHeap.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

{ TGCustomBinHeapPQ.TEnumerator }

function TGCustomBinHeapPQ.TEnumerator.GetCurrent: T;
begin
  Result := FNodes[FHeap[FCurrIndex]].Data;
end;

constructor TGCustomBinHeapPQ.TEnumerator.Create(aQueue: TCustomBinHeapPQ);
begin
  inherited Create(aQueue);
  FHeap := aQueue.FHeap;
  FNodes := aQueue.FNodeList;
  FLast := Pred(aQueue.ElemCount);
  FCurrIndex := -1;
end;

function TGCustomBinHeapPQ.TEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLast;
  FCurrIndex += Ord(Result);
end;

procedure TGCustomBinHeapPQ.TEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGCustomBinHeapPQ.TReverseEnum }

function TGCustomBinHeapPQ.TReverseEnum.GetCurrent: T;
begin
  Result := FNodes[FHeap[FCurrIndex]].Data;
end;

constructor TGCustomBinHeapPQ.TReverseEnum.Create(aQueue: TGCustomBinHeapPQ);
begin
  inherited Create(aQueue);
  FHeap := aQueue.FHeap;
  FNodes := aQueue.FNodeList;
  FCurrIndex := aQueue.ElemCount;
  FLast := Pred(FCurrIndex);
end;

function TGCustomBinHeapPQ.TReverseEnum.MoveNext: Boolean;
begin
  Result := FCurrIndex > 0;
  FCurrIndex -= Ord(Result);
end;

procedure TGCustomBinHeapPQ.TReverseEnum.Reset;
begin
  FCurrIndex := Succ(FLast);
end;

{ TGCustomBinHeapPQ }

procedure TGCustomBinHeapPQ.CheckEmpty;
begin
  if ElemCount = 0 then
    AccessEmptyError;
end;

function TGCustomBinHeapPQ.GetCount: SizeInt;
begin
  Result := FCount;
end;

function TGCustomBinHeapPQ.GetCapacity: SizeInt;
begin
  Result := HeapCapacity;
end;

function TGCustomBinHeapPQ.NodeListCapacity: SizeInt;
begin
  Result := System.Length(FNodeList);
end;

function TGCustomBinHeapPQ.HeapCapacity: SizeInt;
begin
  Result := System.Length(FHeap);
end;

procedure TGCustomBinHeapPQ.InitialAlloc(aCapacity: SizeInt);
begin
  if aCapacity >= 0 then
    begin
      System.SetLength(FHeap, aCapacity);
      System.SetLength(FNodeList, aCapacity);
    end
  else
    begin
      System.SetLength(FHeap, DEFAULT_CONTAINER_CAPACITY);
      System.SetLength(FNodeList, DEFAULT_CONTAINER_CAPACITY);
    end;
  FStackTop := NULL;
end;

procedure TGCustomBinHeapPQ.HeapExpand(aValue: SizeInt);
begin
  //there aValue > array capacity
  if aValue <= DEFAULT_CONTAINER_CAPACITY then
    System.SetLength(FHeap, DEFAULT_CONTAINER_CAPACITY)
  else
    if aValue <= MAX_CAPACITY then
      begin
        aValue := Math.Min(MAX_CAPACITY, LGUtils.RoundUpTwoPower(aValue));
        System.SetLength(FHeap, aValue);
      end
    else
      CapacityExceedError(aValue);
end;

procedure TGCustomBinHeapPQ.NodeListExpand(aValue: SizeInt);
begin
  //there aValue > FNodeList capacity
  if aValue <= DEFAULT_CONTAINER_CAPACITY then
    System.SetLength(FNodeList, DEFAULT_CONTAINER_CAPACITY)
  else
    if aValue <= MAX_NODELIST_CAPACITY then
      begin
        aValue := Math.Min(MAX_NODELIST_CAPACITY, LGUtils.RoundUpTwoPower(aValue));
        System.SetLength(FNodeList, aValue);
      end
    else
      CapacityExceedError(aValue);
end;

function TGCustomBinHeapPQ.StackPop: SizeInt;
begin
  Result := StackTop;
  if Result <> NULL then
    begin
      FStackTop := FNodeList[Result].HeapIndex;
      FNodeList[Result].HeapIndex := NULL;
    end;
end;

procedure TGCustomBinHeapPQ.StackPush(aValue: SizeInt);
begin
  FNodeList[aValue].HeapIndex := StackTop;
  FStackTop := aValue;
end;

function TGCustomBinHeapPQ.StackEmpty: Boolean;
begin
  Result := StackTop = NULL;
end;

procedure TGCustomBinHeapPQ.ItemAdding;
begin
  if ElemCount = HeapCapacity then
    HeapExpand(Succ(ElemCount));
  if StackEmpty and (NodeListCount = NodeListCapacity) then
    NodeListExpand(Succ(NodeListCount));
end;

function TGCustomBinHeapPQ.AddNode(constref aValue: T; aIndex: SizeInt): SizeInt;
begin
  if not StackEmpty then
    Result := StackPop
  else
    begin
      Result := NodeListCount;
      Inc(FNodeListCount);
    end;
  FNodeList[Result].Data := aValue;
  FNodeList[Result].HeapIndex := aIndex;
  Inc(FCount);
end;

function TGCustomBinHeapPQ.NodeListRemove(aIndex: SizeInt): T;
begin
  StackPush(aIndex);
  Result := FNodeList[aIndex].Data;
  FNodeList[aIndex].Data := Default(T);
end;

procedure TGCustomBinHeapPQ.CopyItems(aBuffer: PItem);
var
  I: SizeInt;
begin
  for I := 0 to Pred(ElemCount) do
    aBuffer[I] := FNodeList[FHeap[I]].Data;
end;

function TGCustomBinHeapPQ.DoEnqueue(constref aValue: T): SizeInt;
var
  InsertPos: SizeInt;
begin
  ItemAdding;
  InsertPos := ElemCount;
  Result := AddNode(aValue, InsertPos);
  FHeap[InsertPos] := Result;
  if InsertPos > 0 then
    FloatUp(InsertPos);
end;

function TGCustomBinHeapPQ.GetValue(aNodeIndex: SizeInt): T;
begin
  if (aNodeIndex >= 0) and (aNodeIndex < NodeListCount) then
    Result := FNodeList[aNodeIndex].Data
  else
    IndexOutOfBoundError(aNodeIndex);
end;

function TGCustomBinHeapPQ.DoDequeue: T;
begin
  Result := NodeListRemove(FHeap[0]);
  Dec(FCount);
  if Count > 0 then
    begin
      FHeap[0] := FHeap[ElemCount];
      SiftDown(0);
    end;
end;

function TGCustomBinHeapPQ.DoRemove(aNodeIndex: SizeInt): T;
var
  I: SizeInt;
begin
  if (aNodeIndex >= 0) and (aNodeIndex < NodeListCount) then
    begin
      I := FNodeList[aNodeIndex].HeapIndex;
      Result := NodeListRemove(aNodeIndex);
      Dec(FCount);
      FHeap[I] := FHeap[ElemCount];
      FNodeList[FHeap[I]].HeapIndex := I;
      SiftDown(I);
    end
  else
    IndexOutOfBoundError(aNodeIndex);
end;

function TGCustomBinHeapPQ.EnqueueArray(constref a: array of T): SizeInt;
var
  OldCount, I: SizeInt;
  v: T;
begin
  Result := System.Length(a);
  if Result > 0 then
    begin
      OldCount := ElemCount;
      DoEnsureCapacity(OldCount + Result);
      I := OldCount;
      for v in a do
        begin
          FHeap[I] := AddNode(v, I);
          Inc(I);
        end;
      if OldCount > 0 then
        FixHeap(OldCount)
      else
        BuildHeap;
    end;
end;

function TGCustomBinHeapPQ.EnqueueContainer(c: TCustomContainer): SizeInt;
var
  OldCount, I: SizeInt;
  v: T;
begin
  if c <> Self then
    begin
      Result := c.Count;
      if Result > 0 then
        begin
          OldCount := ElemCount;
          DoEnsureCapacity(OldCount + Result);
          I := OldCount;
          for v in c do
            begin
              FHeap[I] := AddNode(v, I);
              Inc(I);
            end;
          if OldCount > 0 then
            FixHeap(OldCount)
          else
            BuildHeap;
        end;
    end
  else
    Result := EnqueueArray(c.ToArray);
end;

function TGCustomBinHeapPQ.EnqueueEnum(e: IEnumerable): SizeInt;
var
  OldCount, I: SizeInt;
  v: T;
begin
  OldCount := ElemCount;
  Result := 0;
  I := OldCount;
  for v in e do
    begin
      ItemAdding;
      FHeap[I] := AddNode(v, I);
      Inc(I);
    end;
  Result := I - OldCount;
  if Result > 0 then
    begin
      if OldCount > 0 then
        FixHeap(OldCount)
      else
        BuildHeap;
    end;
end;

procedure TGCustomBinHeapPQ.FixHeap(aIndex: SizeInt);
begin
  for aIndex := aIndex to Pred(ElemCount) do
    FloatUp(aIndex);
end;

function TGCustomBinHeapPQ.MergeBinHeap(bh: TGCustomBinHeapPQ): SizeInt;
var
  OldCount, I, J: SizeInt;
begin
  Result := bh.ElemCount;
  if Result > 0 then
    begin
      OldCount := ElemCount;
      EnsureCapacity(ElemCount + Result);
      J := OldCount;
      for I := 0 to Pred(Result) do
        begin
          FHeap[J] := AddNode(bh.FNodeList[bh.FHeap[I]].Data, J);
          Inc(J);
        end;
      bh.Clear;
      if OldCount > 0 then
        FixHeap(OldCount)
      else
        BuildHeap;
    end;
end;

function TGCustomBinHeapPQ.DoGetEnumerator: TCustomEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

procedure TGCustomBinHeapPQ.DoClear;
begin
  FNodeList := nil;
  FHeap := nil;
  FCount := 0;
  FNodeListCount := 0;
  FStackTop := NULL;
end;

procedure TGCustomBinHeapPQ.DoTrimToFit;
begin
  System.SetLength(FHeap, ElemCount);
  if ElemCount = 0 then
    begin
      FStackTop := NULL;
      FNodeListCount := 0;
    end;
  if StackCount = 0 then
    System.SetLength(FNodeList, ElemCount)
  else
    System.SetLength(FNodeList, NodeListCount);
end;

procedure TGCustomBinHeapPQ.DoEnsureCapacity(aValue: SizeInt);
begin
  if aValue > HeapCapacity then
    HeapExpand(aValue);
  if aValue > NodeListCapacity then
    NodeListExpand(aValue);
end;

destructor TGCustomBinHeapPQ.Destroy;
begin
  DoClear;
  inherited;
end;

function TGCustomBinHeapPQ.Reverse: IEnumerable;
begin
  Result := TReverseEnum.Create(Self);
end;

procedure TGCustomBinHeapPQ.Enqueue(constref aValue: T);
begin
  CheckInIteration;
  DoEnqueue(aValue);
end;

function TGCustomBinHeapPQ.EnqueueAll(constref a: array of T): SizeInt;
begin
  CheckInIteration;
  Result := EnqueueArray(a);
end;

function TGCustomBinHeapPQ.EnqueueAll(e: IEnumerable): SizeInt;
var
  o: TObject;
begin
  CheckInIteration;
  o := e._GetRef;
  if o is TCustomContainer then
    Result := EnqueueContainer(TCustomContainer(o))
  else
    Result := EnqueueEnum(e);
end;

function TGCustomBinHeapPQ.Dequeue: T;
begin
  CheckInIteration;
  CheckEmpty;
  Result := DoDequeue;
end;

function TGCustomBinHeapPQ.TryDequeue(out aValue: T): Boolean;
begin
  Result := not InIteration and (ElemCount > 0);
  if Result then
    aValue := DoDequeue;
end;

function TGCustomBinHeapPQ.Peek: T;
begin
  CheckEmpty;
  Result := FNodeList[FHeap[0]].Data;
end;

function TGCustomBinHeapPQ.TryPeek(out aValue: T): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aValue := FNodeList[FHeap[0]].Data;
end;

function TGCustomBinHeapPQ.Insert(constref aValue: T): THandle;
begin
  CheckInIteration;
  Result := THandle(DoEnqueue(aValue));
end;

function TGCustomBinHeapPQ.PeekHead: THandle;
begin
  CheckEmpty;
  Result := THandle(FHeap[0]);
end;

function TGCustomBinHeapPQ.TryPeekHead(out aHandle: THandle): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aHandle := THandle(FHeap[0]);
end;

function TGCustomBinHeapPQ.Value(aHandle: THandle): T;
begin
  Result := GetValue(SizeInt(aHandle));
end;

procedure TGCustomBinHeapPQ.Update(aHandle: THandle; constref aValue: T);
begin
  CheckInIteration;
  DoUpdate(SizeInt(aHandle), aValue);
end;

function TGCustomBinHeapPQ.Remove(aHandle: THandle): T;
begin
  CheckInIteration;
  Result := DoRemove(SizeInt(aHandle));
end;

function TGCustomBinHeapPQ.Merge(aQueue: IPriorityQueue): SizeInt;
var
  o: TObject;
begin
  o := aQueue._GetRef;
  if o <> Self then
    begin
      CheckInIteration;
      TCustomContainer(o).CheckInIteration;
      if o is TCustomBinHeapPQ then
        Result := MergeBinHeap(TCustomBinHeapPQ(o))
      else
        begin
          Result := EnqueueAll(aQueue);
          aQueue.Clear;
        end;
    end
  else // else nothing to do
    Result := 0;
end;

{ TGBaseBinHeapPQ }

procedure TGBaseBinHeapPQ.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          CurrHandle := FHeap[CurrIdx];
          while NextIdx <= HighIdx do
            begin
              if(Succ(NextIdx) <= HighIdx) and
                (TCmpRel.Compare(FNodeList[FHeap[NextIdx]].Data, FNodeList[FHeap[Succ(NextIdx)]].Data) < 0)then
                  Inc(NextIdx);
              if TCmpRel.Compare(FNodeList[CurrHandle].Data, FNodeList[FHeap[NextIdx]].Data) >= 0 then
                break;
              FHeap[CurrIdx] := FHeap[NextIdx];
              FNodeList[FHeap[CurrIdx]].HeapIndex := CurrIdx;
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          FHeap[CurrIdx] := CurrHandle;
          FNodeList[CurrHandle].HeapIndex := CurrIdx;
        end;
    end;
end;

procedure TGBaseBinHeapPQ.FloatUp(aIndex: SizeInt);
var
  ParentIdx, CurrHandle: SizeInt;
begin
  ParentIdx := Pred(aIndex) shr 1;
  CurrHandle := FHeap[aIndex];
  while(aIndex > 0) and (TCmpRel.Compare(FNodeList[CurrHandle].Data, FNodeList[FHeap[ParentIdx]].Data) > 0) do
    begin
      FHeap[aIndex] := FHeap[ParentIdx];
      FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  FHeap[aIndex] := CurrHandle;
  FNodeList[CurrHandle].HeapIndex := aIndex;
end;

procedure TGBaseBinHeapPQ.SiftDown(aIndex: SizeInt);
var
  NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      NextIdx := Succ(aIndex shl 1);
      CurrHandle := FHeap[aIndex];
      while NextIdx <= HighIdx do
        begin
          if(Succ(NextIdx) <= HighIdx) and
            (TCmpRel.Compare(FNodeList[FHeap[NextIdx]].Data, FNodeList[FHeap[Succ(NextIdx)]].Data) < 0) then
              Inc(NextIdx);
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(aIndex) shr 1;
      while(aIndex > 0)and(TCmpRel.Compare(FNodeList[CurrHandle].Data, FNodeList[FHeap[NextIdx]].Data) > 0) do
        begin
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      FHeap[aIndex] := CurrHandle;
      FNodeList[CurrHandle].HeapIndex := aIndex;
    end;
end;

procedure TGBaseBinHeapPQ.DoUpdate(aIndex: SizeInt; constref aValue: T);
var
  c: SizeInt;
begin
  if (aIndex >= 0) and (aIndex < NodeListCount) then
    begin
      c := TCmpRel.Compare(aValue, FNodeList[aIndex].Data);
      FNodeList[aIndex].Data := aValue;
      if c > 0 then
        FloatUp(FNodeList[aIndex].HeapIndex)
      else
        if c < 0 then
          SiftDown(FNodeList[aIndex].HeapIndex);
    end
  else
    IndexOutOfBoundError(aIndex);
end;

class function TGBaseBinHeapPQ.DoCompare(constref L, R: T): SizeInt;
begin
  Result := TCmpRel.Compare(L, R);
end;

class function TGBaseBinHeapPQ.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

constructor TGBaseBinHeapPQ.Create;
begin
  InitialAlloc(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGBaseBinHeapPQ.Create(aCapacity: SizeInt);
begin
  InitialAlloc(aCapacity);
end;

constructor TGBaseBinHeapPQ.Create(constref A: array of T);
begin
  Create(System.Length(A));
  EnqueueAll(A);
end;

constructor TGBaseBinHeapPQ.Create(e: IEnumerable);
begin
  Create;
  EnqueueAll(e);
end;

{ TGComparableBinHeapPQ }

class function TGComparableBinHeapPQ.DoCompare(constref L, R: T): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGComparableBinHeapPQ.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

{ TGComparableBinHeapPQMax }

procedure TGComparableBinHeapPQMax.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          CurrHandle := FHeap[CurrIdx];
          while NextIdx <= HighIdx do
            begin
              if(Succ(NextIdx) <= HighIdx) and
                (FNodeList[FHeap[NextIdx]].Data < FNodeList[FHeap[Succ(NextIdx)]].Data) then
                  Inc(NextIdx);
              if FNodeList[CurrHandle].Data >= FNodeList[FHeap[NextIdx]].Data then
                break;
              FHeap[CurrIdx] := FHeap[NextIdx];
              FNodeList[FHeap[CurrIdx]].HeapIndex := CurrIdx;
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          FHeap[CurrIdx] := CurrHandle;
          FNodeList[CurrHandle].HeapIndex := CurrIdx;
        end;
    end;
end;

procedure TGComparableBinHeapPQMax.FloatUp(aIndex: SizeInt);
var
  ParentIdx, CurrHandle: SizeInt;
begin
  ParentIdx := Pred(aIndex) shr 1;
  CurrHandle := FHeap[aIndex];
  while (aIndex > 0) and (FNodeList[CurrHandle].Data > FNodeList[FHeap[ParentIdx]].Data) do
    begin
      FHeap[aIndex] := FHeap[ParentIdx];
      FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  FHeap[aIndex] := CurrHandle;
  FNodeList[CurrHandle].HeapIndex := aIndex;
end;

procedure TGComparableBinHeapPQMax.SiftDown(aIndex: SizeInt);
var
  NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      NextIdx := Succ(aIndex shl 1);
      CurrHandle := FHeap[aIndex];
      while NextIdx <= HighIdx do
        begin
          if(Succ(NextIdx) <= HighIdx) and
            (FNodeList[FHeap[NextIdx]].Data < FNodeList[FHeap[Succ(NextIdx)]].Data) then
              Inc(NextIdx);
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(aIndex) shr 1;
      while (aIndex > 0) and (FNodeList[CurrHandle].Data > FNodeList[FHeap[NextIdx]].Data) do
        begin
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      FHeap[aIndex] := CurrHandle;
      FNodeList[CurrHandle].HeapIndex := aIndex;
    end;
end;

procedure TGComparableBinHeapPQMax.DoUpdate(aIndex: SizeInt; constref aValue: T);
begin
  if (aIndex >= 0) and (aIndex < NodeListCount) then
    begin
      if aValue > FNodeList[aIndex].Data then
        begin
          FNodeList[aIndex].Data := aValue;
          FloatUp(FNodeList[aIndex].HeapIndex);
        end
      else
        if aValue < FNodeList[aIndex].Data then
          begin
            FNodeList[aIndex].Data := aValue;
            SiftDown(FNodeList[aIndex].HeapIndex);
          end;
    end
  else
    IndexOutOfBoundError(aIndex);
end;

constructor TGComparableBinHeapPQMax.Create;
begin
  InitialAlloc(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGComparableBinHeapPQMax.Create(aCapacity: SizeInt);
begin
  InitialAlloc(aCapacity);
end;

constructor TGComparableBinHeapPQMax.Create(constref A: array of T);
begin
  Create(System.Length(A));
  EnqueueAll(A);
end;

constructor TGComparableBinHeapPQMax.Create(e: IEnumerable);
begin
  Create;
  EnqueueAll(e);
end;

{ TGComparableBinHeapPQMin }

procedure TGComparableBinHeapPQMin.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          CurrHandle := FHeap[CurrIdx];
          while NextIdx <= HighIdx do
            begin
              if(Succ(NextIdx) <= HighIdx) and
                (FNodeList[FHeap[NextIdx]].Data > FNodeList[FHeap[Succ(NextIdx)]].Data) then
                  Inc(NextIdx);
              if FNodeList[CurrHandle].Data <= FNodeList[FHeap[NextIdx]].Data then
                break;
              FHeap[CurrIdx] := FHeap[NextIdx];
              FNodeList[FHeap[CurrIdx]].HeapIndex := CurrIdx;
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          FHeap[CurrIdx] := CurrHandle;
          FNodeList[CurrHandle].HeapIndex := CurrIdx;
        end;
    end;
end;

procedure TGComparableBinHeapPQMin.FloatUp(aIndex: SizeInt);
var
  ParentIdx, CurrHandle: SizeInt;
begin
  ParentIdx := Pred(aIndex) shr 1;
  CurrHandle := FHeap[aIndex];
  while (aIndex > 0) and (FNodeList[CurrHandle].Data < FNodeList[FHeap[ParentIdx]].Data) do
    begin
      FHeap[aIndex] := FHeap[ParentIdx];
      FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  FHeap[aIndex] := CurrHandle;
  FNodeList[CurrHandle].HeapIndex := aIndex;
end;

procedure TGComparableBinHeapPQMin.SiftDown(aIndex: SizeInt);
var
  NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      NextIdx := Succ(aIndex shl 1);
      CurrHandle := FHeap[aIndex];
      while NextIdx <= HighIdx do
        begin
          if(Succ(NextIdx) <= HighIdx) and
            (FNodeList[FHeap[NextIdx]].Data > FNodeList[FHeap[Succ(NextIdx)]].Data) then
              Inc(NextIdx);
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(aIndex) shr 1;
      while (aIndex > 0) and (FNodeList[CurrHandle].Data < FNodeList[FHeap[NextIdx]].Data) do
        begin
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      FHeap[aIndex] := CurrHandle;
      FNodeList[CurrHandle].HeapIndex := aIndex;
    end;
end;

procedure TGComparableBinHeapPQMin.DoUpdate(aIndex: SizeInt; constref aValue: T);
begin
  if (aIndex >= 0) and (aIndex < NodeListCount) then
    begin
      if aValue < FNodeList[aIndex].Data then
        begin
          FNodeList[aIndex].Data := aValue;
          FloatUp(FNodeList[aIndex].HeapIndex);
        end
      else
        if aValue > FNodeList[aIndex].Data then
          begin
            FNodeList[aIndex].Data := aValue;
            SiftDown(FNodeList[aIndex].HeapIndex);
          end;
    end
  else
    IndexOutOfBoundError(aIndex);
end;

constructor TGComparableBinHeapPQMin.Create;
begin
  InitialAlloc(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGComparableBinHeapPQMin.Create(aCapacity: SizeInt);
begin
  InitialAlloc(aCapacity);
end;

constructor TGComparableBinHeapPQMin.Create(constref A: array of T);
begin
  Create(System.Length(A));
  EnqueueAll(A);
end;

constructor TGComparableBinHeapPQMin.Create(e: IEnumerable);
begin
  Create;
  EnqueueAll(e);
end;

{ TGRegularBinHeapPQ }

procedure TGRegularBinHeapPQ.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          CurrHandle := FHeap[CurrIdx];
          while NextIdx <= HighIdx do
            begin
              if(Succ(NextIdx) <= HighIdx) and
                (FCompare(FNodeList[FHeap[NextIdx]].Data, FNodeList[FHeap[Succ(NextIdx)]].Data) < 0)then
                  Inc(NextIdx);
              if FCompare(FNodeList[CurrHandle].Data, FNodeList[FHeap[NextIdx]].Data) >= 0 then
                break;
              FHeap[CurrIdx] := FHeap[NextIdx];
              FNodeList[FHeap[CurrIdx]].HeapIndex := CurrIdx;
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          FHeap[CurrIdx] := CurrHandle;
          FNodeList[CurrHandle].HeapIndex := CurrIdx;
        end;
    end;
end;

procedure TGRegularBinHeapPQ.FloatUp(aIndex: SizeInt);
var
  ParentIdx, CurrHandle: SizeInt;
begin
  ParentIdx := Pred(aIndex) shr 1;
  CurrHandle := FHeap[aIndex];
  while(aIndex > 0) and (FCompare(FNodeList[CurrHandle].Data, FNodeList[FHeap[ParentIdx]].Data) > 0) do
    begin
      FHeap[aIndex] := FHeap[ParentIdx];
      FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  FHeap[aIndex] := CurrHandle;
  FNodeList[CurrHandle].HeapIndex := aIndex;
end;

procedure TGRegularBinHeapPQ.SiftDown(aIndex: SizeInt);
var
  NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      NextIdx := Succ(aIndex shl 1);
      CurrHandle := FHeap[aIndex];
      while NextIdx <= HighIdx do
        begin
          if(Succ(NextIdx) <= HighIdx) and
            (FCompare(FNodeList[FHeap[NextIdx]].Data, FNodeList[FHeap[Succ(NextIdx)]].Data) < 0) then
              Inc(NextIdx);
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(aIndex) shr 1;
      while (aIndex > 0) and (FCompare(FNodeList[CurrHandle].Data, FNodeList[FHeap[NextIdx]].Data) > 0) do
        begin
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      FHeap[aIndex] := CurrHandle;
      FNodeList[CurrHandle].HeapIndex := aIndex;
    end;
end;

procedure TGRegularBinHeapPQ.DoUpdate(aIndex: SizeInt; constref aValue: T);
var
  c: SizeInt;
begin
  if (aIndex >= 0) and (aIndex < NodeListCount) then
    begin
      c := FCompare(aValue, FNodeList[aIndex].Data);
      FNodeList[aIndex].Data := aValue;
      if c > 0 then
        FloatUp(FNodeList[aIndex].HeapIndex)
      else
        if c < 0 then
          SiftDown(FNodeList[aIndex].HeapIndex);
    end
  else
    IndexOutOfBoundError(aIndex);
end;

constructor TGRegularBinHeapPQ.Create;
begin
  Create(TDefaults.Compare);
end;

constructor TGRegularBinHeapPQ.Create(c: TComparator);
begin
  FCompare := c;
  InitialAlloc(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGRegularBinHeapPQ.Create(aCapacity: SizeInt; c: TComparator);
begin
  FCompare := c;
  InitialAlloc(aCapacity);
end;

constructor TGRegularBinHeapPQ.Create(constref A: array of T; c: TComparator);
begin
  Create(System.Length(A), c);
  EnqueueAll(A);
end;

constructor TGRegularBinHeapPQ.Create(e: IEnumerable; c: TComparator);
begin
  Create(c);
  EnqueueAll(e);
end;

function TGRegularBinHeapPQ.Comparator: TComparator;
begin
  Result := FCompare;
end;

{ TGDelegatedBinHeapPQ }

procedure TGDelegatedBinHeapPQ.BuildHeap;
var
  I, CurrIdx, NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  if ElemCount > 1 then
    begin
      HighIdx := Pred(ElemCount);
      for I := Pred(ElemCount shr 1) downto 0 do
        begin
          CurrIdx := I;
          NextIdx := Succ(I shl 1);
          CurrHandle := FHeap[CurrIdx];
          while NextIdx <= HighIdx do
            begin
              if(Succ(NextIdx) <= HighIdx) and
                (FCompare(FNodeList[FHeap[NextIdx]].Data, FNodeList[FHeap[Succ(NextIdx)]].Data) < 0)then
                  Inc(NextIdx);
              if FCompare(FNodeList[CurrHandle].Data, FNodeList[FHeap[NextIdx]].Data) >= 0 then
                break;
              FHeap[CurrIdx] := FHeap[NextIdx];
              FNodeList[FHeap[CurrIdx]].HeapIndex := CurrIdx;
              CurrIdx := NextIdx;
              NextIdx := Succ(NextIdx shl 1);
            end;
          FHeap[CurrIdx] := CurrHandle;
          FNodeList[CurrHandle].HeapIndex := CurrIdx;
        end;
    end;
end;

procedure TGDelegatedBinHeapPQ.FloatUp(aIndex: SizeInt);
var
  ParentIdx, CurrHandle: SizeInt;
begin
  ParentIdx := Pred(aIndex) shr 1;
  CurrHandle := FHeap[aIndex];
  while(aIndex > 0) and (FCompare(FNodeList[CurrHandle].Data, FNodeList[FHeap[ParentIdx]].Data) > 0) do
    begin
      FHeap[aIndex] := FHeap[ParentIdx];
      FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
      aIndex := ParentIdx;
      ParentIdx := Pred(ParentIdx) shr 1;
    end;
  FHeap[aIndex] := CurrHandle;
  FNodeList[CurrHandle].HeapIndex := aIndex;
end;

procedure TGDelegatedBinHeapPQ.SiftDown(aIndex: SizeInt);
var
  NextIdx, HighIdx, CurrHandle: SizeInt;
begin
  HighIdx := Pred(ElemCount);
  if HighIdx > 0 then
    begin
      NextIdx := Succ(aIndex shl 1);
      CurrHandle := FHeap[aIndex];
      while NextIdx <= HighIdx do
        begin
          if(Succ(NextIdx) <= HighIdx) and
            (FCompare(FNodeList[FHeap[NextIdx]].Data, FNodeList[FHeap[Succ(NextIdx)]].Data) < 0) then
              Inc(NextIdx);
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Succ(NextIdx shl 1);
        end;
      NextIdx := Pred(aIndex) shr 1;
      while (aIndex > 0) and (FCompare(FNodeList[CurrHandle].Data, FNodeList[FHeap[NextIdx]].Data) > 0) do
        begin
          FHeap[aIndex] := FHeap[NextIdx];
          FNodeList[FHeap[aIndex]].HeapIndex := aIndex;
          aIndex := NextIdx;
          NextIdx := Pred(NextIdx) shr 1;
        end;
      FHeap[aIndex] := CurrHandle;
      FNodeList[CurrHandle].HeapIndex := aIndex;
    end;
end;

procedure TGDelegatedBinHeapPQ.DoUpdate(aIndex: SizeInt; constref aValue: T);
var
  c: SizeInt;
begin
  if (aIndex >= 0) and (aIndex < NodeListCount) then
    begin
      c := FCompare(aValue, FNodeList[aIndex].Data);
      FNodeList[aIndex].Data := aValue;
      if c > 0 then
        FloatUp(FNodeList[aIndex].HeapIndex)
      else
        if c < 0 then
          SiftDown(FNodeList[aIndex].HeapIndex);
    end
  else
    IndexOutOfBoundError(aIndex);
end;

constructor TGDelegatedBinHeapPQ.Create;
begin
  Create(TDefaults.OnCompare);
end;

constructor TGDelegatedBinHeapPQ.Create(c: TComparator);
begin
  FCompare := c;
  InitialAlloc(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGDelegatedBinHeapPQ.Create(aCapacity: SizeInt; c: TComparator);
begin
  FCompare := c;
  InitialAlloc(aCapacity);
end;

constructor TGDelegatedBinHeapPQ.Create(constref A: array of T; c: TComparator);
begin
  Create(System.Length(A), c);
  EnqueueAll(A);
end;

constructor TGDelegatedBinHeapPQ.Create(e: IEnumerable; c: TComparator);
begin
  Create(c);
  EnqueueAll(e);
end;

function TGDelegatedBinHeapPQ.Comparator: TComparator;
begin
  Result := FCompare;
end;

{ TGCustomPairingHeap.TNode }

procedure TGCustomPairingHeap.TNode.AddChild(aNode: PNode);
begin
  if aNode <> nil then
    begin
      aNode^.Prev := @Self;
      Sibling :=  aNode^.Sibling;
      if Sibling <> nil then
        Sibling^.Prev := @Self;
      aNode^.Sibling := Child;
      if aNode^.Sibling <> nil then
        aNode^.Sibling^.Prev := aNode;
      Child := aNode;
    end;
end;

procedure TGCustomPairingHeap.TNode.ClearLinks;
begin
  Sibling := nil;
  Child := nil;
  Prev := nil;
end;

function TGCustomPairingHeap.TNode.Successor: PNode;
begin
  Result := Sibling;
  if Result <> nil then
    while Result^.Child <> nil do
      Result := Result^.Child
  else
    begin
      Result := @Self;
      while (Result^.Prev <> nil) and (Result^.Prev^.Sibling = Result) do
        Result := Result^.Prev;
      Result := Result^.Prev;
    end;
end;

function TGCustomPairingHeap.TNode.Predecessor: PNode;
begin
  Result := Child;
  if Result <> nil then
    while Result^.Sibling <> nil do
      Result := Result^.Sibling
  else
    begin
      Result := @Self;
      while (Result^.Prev <> nil) and (Result^.Prev^.Child = Result) do
        Result := Result^.Prev;
      Result := Result^.Prev;
    end;
end;

{ TGCustomPairingHeap.TEnumerator }

function TGCustomPairingHeap.TEnumerator.GetCurrent: T;
begin
  Result := FCurrNode^.Data;
end;

constructor TGCustomPairingHeap.TEnumerator.Create(aHeap: TCustomPairingHeap);
begin
  inherited Create(aHeap);
  FLeftmost := aHeap.FindLeftmost;
end;

function TGCustomPairingHeap.TEnumerator.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Successor
  else
    if not FInCycle then
      begin
        NextNode := FLeftmost;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

procedure TGCustomPairingHeap.TEnumerator.Reset;
begin
  FCurrNode := nil;
  FInCycle := False;
end;

{ TGCustomPairingHeap.TReverseEnum }

function TGCustomPairingHeap.TReverseEnum.GetCurrent: T;
begin
  Result := FCurrNode^.Data;
end;

constructor TGCustomPairingHeap.TReverseEnum.Create(aHeap: TCustomPairingHeap);
begin
  inherited Create(aHeap);
  FRightmost := aHeap.FindRightmost;
end;

function TGCustomPairingHeap.TReverseEnum.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Predecessor
  else
    if not FInCycle then
      begin
        NextNode := FRightmost;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

procedure TGCustomPairingHeap.TReverseEnum.Reset;
begin
  FCurrNode := nil;
  FInCycle := False;
end;

{ TGCustomPairingHeap }

procedure TGCustomPairingHeap.CheckEmpty;
begin
  if ElemCount = 0 then
    AccessEmptyError;
end;

function TGCustomPairingHeap.GetCount: SizeInt;
begin
  Result := FCount;
end;

function TGCustomPairingHeap.GetCapacity: SizeInt;
begin
  Result := ElemCount + FNodeManager.FreeCount;
end;

procedure TGCustomPairingHeap.CopyItems(aBuffer: PItem);
var
  Node: PNode;
  I: SizeInt = 0;
begin
  Node := FindLeftmost;
  while Node <> nil do
    begin
      aBuffer[I] := Node^.Data;
      Inc(I);
      Node := Node^.Successor;
    end;
end;

function TGCustomPairingHeap.DoGetEnumerator: TCustomEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

procedure TGCustomPairingHeap.DoClear;
begin
  ClearTree;
  FNodeManager.Clear;
end;

procedure TGCustomPairingHeap.DoTrimToFit;
begin
  if ElemCount > 0 then
    FNodeManager.ClearFreeList
  else
    FNodeManager.Clear;
end;

procedure TGCustomPairingHeap.DoEnsureCapacity(aValue: SizeInt);
begin
  FNodeManager.EnsureFreeCount(aValue - Capacity);
end;

function TGCustomPairingHeap.NewNode(constref aValue: T): PNode;
begin
  Result := FNodeManager.NewNode;
  Result^.Data := aValue;
  Inc(FCount);
end;

procedure TGCustomPairingHeap.DisposeNode(aNode: PNode);
begin
  if aNode <> nil then
    begin
      aNode^ := Default(TNode);
      FNodeManager.FreeNode(aNode);
      Dec(FCount);
    end;
end;

procedure TGCustomPairingHeap.RemoveNodeWithChilds(aNode: PNode);
var
  OldPrev, OldNode, CurrNode: PNode;
  FromSibling: Boolean = False;
begin
  if aNode <> nil then
    begin
      CurrNode := aNode;
      repeat  //postorder traverse
        while FromSibling do
          begin
            OldPrev := CurrNode^.Prev;
            OldNode := CurrNode;
            /////////////////////////////////
            CurrNode^.Data := Default(T);
            FNodeManager.DisposeNode(CurrNode);
            Dec(FCount);
            ////////////////////////////////
            if CurrNode = aNode then
              exit;
            CurrNode := OldPrev;
            FromSibling := CurrNode^.Sibling = OldNode;
            if not FromSibling and (CurrNode^.Sibling <> nil) then
              CurrNode := CurrNode^.Sibling
            else
              FromSibling := True;
          end;
        while CurrNode^.Child <> nil do
          CurrNode := CurrNode^.Child;
        if CurrNode^.Sibling <> nil then
          CurrNode := CurrNode^.Sibling
        else
          FromSibling := True;
      until False;
    end;
end;

procedure TGCustomPairingHeap.ClearTree;
begin
  RemoveNodeWithChilds(FRoot);
  FRoot := nil;
end;

function TGCustomPairingHeap.FindLeftmost: PNode;
begin
  Result := FRoot;
  if Result <> nil then
    while Result^.Child <> nil do
      Result := Result^.Child;
end;

function TGCustomPairingHeap.FindRightmost: PNode;
begin
  Result := FRoot;
  if Result <> nil then
    while Result^.Sibling <> nil do
      Result := Result^.Sibling;
end;

function TGCustomPairingHeap.EnqueueArray(constref a: array of T): SizeInt;
var
  v: T;
begin
  Result := System.Length(a);
  if Result > 0 then
    begin
      DoEnsureCapacity(ElemCount + Result);
      for v in a do
        DoEnqueue(v);
    end;
end;

function TGCustomPairingHeap.EnqueueContainer(c: TCustomContainer): SizeInt;
var
  v: T;
begin
  if c <> Self then
    begin
      Result := c.Count;
      DoEnsureCapacity(ElemCount + Result);
      for v in c do
        DoEnqueue(v);
    end
  else
    Result := EnqueueArray(c.ToArray);
end;

function TGCustomPairingHeap.EnqueueEnum(e: IEnumerable): SizeInt;
var
  v: T;
begin
  Result := 0;
  for v in e do
    begin
      DoEnqueue(v);
      Inc(Result);
    end;
end;

class procedure TGCustomPairingHeap.CutNode(aNode: PNode);
begin
  if aNode^.Sibling <> nil then
    aNode^.Sibling^.Prev := aNode^.Prev;
  if aNode^.Prev^.Child = aNode then
    aNode^.Prev^.Child := aNode^.Sibling
  else
    aNode^.Prev^.Sibling := aNode^.Sibling;
  aNode^.Sibling := nil;
end;

destructor TGCustomPairingHeap.Destroy;
begin
  DoClear;
  inherited;
end;

function TGCustomPairingHeap.Reverse: IEnumerable;
begin
  Result := TReverseEnum.Create(Self);
end;

procedure TGCustomPairingHeap.Enqueue(constref aValue: T);
begin
  CheckInIteration;
  DoEnqueue(aValue);
end;

function TGCustomPairingHeap.EnqueueAll(constref a: array of T): SizeInt;
begin
  CheckInIteration;
  Result := EnqueueArray(a);
end;

function TGCustomPairingHeap.EnqueueAll(e: IEnumerable): SizeInt;
var
  o: TObject;
begin
  CheckInIteration;
  o := e._GetRef;
  if o is TCustomContainer then
    Result := EnqueueContainer(TCustomContainer(o))
  else
    Result := EnqueueEnum(e);
end;

function TGCustomPairingHeap.Dequeue: T;
begin
  CheckInIteration;
  CheckEmpty;
  Result := DoDequeue;
end;

function TGCustomPairingHeap.TryDequeue(out aValue: T): Boolean;
begin
  Result := not InIteration and (ElemCount > 0);
  if Result then
    aValue := DoDequeue;
end;

function TGCustomPairingHeap.Peek: T;
begin
  CheckEmpty;
  Result := FRoot^.Data;
end;

function TGCustomPairingHeap.TryPeek(out aValue: T): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aValue := FRoot^.Data;
end;

function TGCustomPairingHeap.Insert(constref aValue: T): THandle;
begin
  CheckInIteration;
  Result := {%H-}THandle(DoEnqueue(aValue));
end;

function TGCustomPairingHeap.PeekHead: THandle;
begin
  CheckEmpty;
  Result := {%H-}THandle(FRoot);
end;

function TGCustomPairingHeap.TryPeekHead(out aHandle: THandle): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aHandle := {%H-}THandle(FRoot);
end;

function TGCustomPairingHeap.Value(aHandle: THandle): T;
begin
  Result := {%H-}PNode(aHandle)^.Data;
end;

procedure TGCustomPairingHeap.Update(aHandle: THandle; constref aValue: T);
begin
  CheckInIteration;
  CheckEmpty;
  DoUpdate({%H-}PNode(aHandle), aValue);
end;

function TGCustomPairingHeap.Remove(aHandle: THandle): T;
begin
  CheckInIteration;
  CheckEmpty;
  Result := DoRemove({%H-}PNode(aHandle));
end;

function TGCustomPairingHeap.Merge(aQueue: IPriorityQueue): SizeInt;
var
  o: TObject;
begin
  o := aQueue._GetRef;
  if o <> Self then
    begin
      CheckInIteration;
      TCustomContainer(o).CheckInIteration;
      if o is TCustomPairingHeap then
        Result := DoMergeHeap(TCustomPairingHeap(o))
      else
        begin
          Result := EnqueueAll(aQueue);
          aQueue.Clear;
        end;
    end
  else
    Result := 0;
end;

{ TGBasePairingHeap }

procedure TGBasePairingHeap.RootMerge(aNode: PNode);
begin
  FRoot := DoMerge(FRoot, aNode);
  if FRoot <> nil then
    FRoot^.Prev := nil;
end;

procedure TGBasePairingHeap.DoExtract(aNode: PNode);
begin
  if aNode <> FRoot then
    begin
      CutNode(aNode);
      RootMerge(TwoPassMerge(aNode^.Child));
    end
  else
    begin
      FRoot := TwoPassMerge(FRoot^.Child);
      if FRoot <> nil then
        FRoot^.Prev := nil;
    end;
  aNode^.ClearLinks;
end;

function TGBasePairingHeap.DoEnqueue(constref aValue: T): PNode;
begin
  Result := NewNode(aValue);
  RootMerge(Result);
end;

procedure TGBasePairingHeap.DoUpdate(aNode: PNode; constref aValue: T);
var
  c: SizeInt;
begin
  c := TCmpRel.Compare(aValue, aNode^.Data);
  if c > 0 then
    begin
      aNode^.Data := aValue;
      if aNode <> FRoot then
        begin
          CutNode(aNode);
          RootMerge(aNode);
        end;
    end
  else
    if c < 0 then
      begin
        aNode^.Data := aValue;
        DoExtract(aNode);
        RootMerge(aNode);
      end;
end;

function TGBasePairingHeap.DoRemove(aNode: PNode): T;
begin
  DoExtract(aNode);
  Result := aNode^.Data;
  DisposeNode(aNode);
end;

function TGBasePairingHeap.DoDequeue: T;
var
  OldRoot: PNode;
begin
  OldRoot := FRoot;
  Result := FRoot^.Data;
  FRoot := TwoPassMerge(FRoot^.Child);
  if FRoot <> nil then
    FRoot^.Prev := nil;
  DisposeNode(OldRoot);
end;

function TGBasePairingHeap.DoMergeHeap(ph: TCustomPairingHeap): SizeInt;
begin
  Result := ph.Count;
  if Result > 0 then
    begin
      if ph is TGBasePairingHeap then
        begin
          FNodeManager.Join(ph.FNodeManager);
          RootMerge(ph.FRoot);
          FCount += Result;
          ph.FCount := 0;
          ph.FRoot := nil;
        end
      else
        begin
          EnqueueAll(ph);
          ph.Clear;
        end;
    end;
end;

class function TGBasePairingHeap.DoMerge(L, R: PNode): PNode;
begin
  if L <> nil then
    begin
      if R <> nil then
        begin
          if TCmpRel.Compare(L^.Data, R^.Data) >= 0 then
            begin
              L^.AddChild(R);
              Result := L;
            end
          else
            begin
              R^.AddChild(L);
              Result := R;
            end;
        end
      else
        Result := L;
    end
  else
    Result := R;
end;

{$IFDEF ENABLE_TWOPASSMERGE_RECURSION}
class function TGBasePairingHeap.TwoPassMerge(aNode: PNode): PNode; // recursive
var
  Sibling, NextSibling: PNode;
begin
  if (aNode <> nil) and (aNode^.Sibling <> nil) then
    begin
      Sibling := aNode^.Sibling;
      NextSibling := Sibling^.Sibling;
      aNode^.Sibling := nil;
      Sibling^.Sibling := nil;
      Result := DoMerge(DoMerge(aNode, Sibling), TwoPassMerge(NextSibling));
    end
  else
    Result := aNode;
end;
{$ELSE ENABLE_TWOPASSMERGE_RECURSION}
class function TGBasePairingHeap.TwoPassMerge(aNode: PNode): PNode;
var
  CurrNode, NextNode: PNode;
begin
  Result := nil;
  while (aNode <> nil) and (aNode^.Sibling <> nil) do
    begin
      CurrNode := aNode;
      NextNode := aNode^.Sibling;
      aNode := NextNode^.Sibling;
      CurrNode^.Sibling := nil;
      NextNode^.Sibling := nil;
      Result := DoMerge(Result, DoMerge(CurrNode, NextNode));
    end;
  Result := DoMerge(Result, aNode);
end;
{$ENDIF ENABLE_TWOPASSMERGE_RECURSION}

class function TGBasePairingHeap.DoCompare(constref L, R: T): SizeInt;
begin
  Result := TCmpRel.Compare(L, R);
end;

class function TGBasePairingHeap.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

constructor TGBasePairingHeap.Create;
begin
  FNodeManager.EnsureFreeCount(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGBasePairingHeap.Create(aCapacity: SizeInt);
begin
  if aCapacity > 0 then
    FNodeManager.EnsureFreeCount(aCapacity);
end;

constructor TGBasePairingHeap.Create(constref A: array of T);
begin
  Create;
  EnqueueAll(A);
end;

constructor TGBasePairingHeap.Create(e: IEnumerable);
begin
  Create;
  EnqueueAll(e);
end;

{ TGComparablePairHeap }

class function TGComparablePairHeap.DoCompare(constref L, R: T): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGComparablePairHeap.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

{ TGComparablePairHeapMax }

procedure TGComparablePairHeapMax.RootMerge(aNode: PNode);
begin
  FRoot := DoMerge(FRoot, aNode);
  if FRoot <> nil then
    FRoot^.Prev := nil;
end;

procedure TGComparablePairHeapMax.DoExtract(aNode: PNode);
begin
  if aNode <> FRoot then
    begin
      CutNode(aNode);
      RootMerge(TwoPassMerge(aNode^.Child));
    end
  else
    begin
      FRoot := TwoPassMerge(FRoot^.Child);
      if FRoot <> nil then
        FRoot^.Prev := nil;
    end;
  aNode^.ClearLinks;
end;

function TGComparablePairHeapMax.DoEnqueue(constref aValue: T): PNode;
begin
  Result := NewNode(aValue);
  RootMerge(Result);
end;

procedure TGComparablePairHeapMax.DoUpdate(aNode: PNode; constref aValue: T);
begin
  if aValue > aNode^.Data then
    begin
      aNode^.Data := aValue;
      if aNode <> FRoot then
        begin
          CutNode(aNode);
          RootMerge(aNode);
        end;
    end
  else
    if aValue < aNode^.Data then
      begin
        aNode^.Data := aValue;
        DoExtract(aNode);
        RootMerge(aNode);
      end;
end;

function TGComparablePairHeapMax.DoRemove(aNode: PNode): T;
begin
  DoExtract(aNode);
  Result := aNode^.Data;
  DisposeNode(aNode);
end;

function TGComparablePairHeapMax.DoDequeue: T;
var
  OldRoot: PNode;
begin
  OldRoot := FRoot;
  Result := FRoot^.Data;
  FRoot := TwoPassMerge(FRoot^.Child);
  if FRoot <> nil then
    FRoot^.Prev := nil;
  DisposeNode(OldRoot);
end;

function TGComparablePairHeapMax.DoMergeHeap(ph: TCustomPairingHeap): SizeInt;
begin
  Result := ph.Count;
  if Result > 0 then
    begin
      if ph is TGComparablePairHeapMax then
        begin
          FNodeManager.Join(ph.FNodeManager);
          RootMerge(ph.FRoot);
          FCount += Result;
          ph.FCount := 0;
          ph.FRoot := nil;
        end
      else
        begin
          EnqueueAll(ph);
          ph.Clear;
        end;
    end;
end;

class function TGComparablePairHeapMax.DoMerge(L, R: PNode): PNode;
begin
  if L <> nil then
    begin
      if R <> nil then
        begin
          if L^.Data >= R^.Data then
            begin
              L^.AddChild(R);
              Result := L;
            end
          else
            begin
              R^.AddChild(L);
              Result := R;
            end;
        end
      else
        Result := L;
    end
  else
    Result := R;
end;

{$IFDEF ENABLE_TWOPASSMERGE_RECURSION}
class function TGComparablePairHeapMax.TwoPassMerge(aNode: PNode): PNode; // recursive
var
  Sibling, NextSibling: PNode;
begin
  if (aNode <> nil) and (aNode^.Sibling <> nil) then
    begin
      Sibling := aNode^.Sibling;
      NextSibling := Sibling^.Sibling;
      aNode^.Sibling := nil;
      Sibling^.Sibling := nil;
      Result := DoMerge(DoMerge(aNode, Sibling), TwoPassMerge(NextSibling));
    end
  else
    Result := aNode;
end;
{$ELSE ENABLE_TWOPASSMERGE_RECURSION}
class function TGComparablePairHeapMax.TwoPassMerge(aNode: PNode): PNode;
var
  CurrNode, NextNode: PNode;
begin
  Result := nil;
  while (aNode <> nil) and (aNode^.Sibling <> nil) do
    begin
      CurrNode := aNode;
      NextNode := aNode^.Sibling;
      aNode := NextNode^.Sibling;
      CurrNode^.Sibling := nil;
      NextNode^.Sibling := nil;
      Result := DoMerge(Result, DoMerge(CurrNode, NextNode));
    end;
  Result := DoMerge(Result, aNode);
end;
{$ENDIF ENABLE_TWOPASSMERGE_RECURSION}

constructor TGComparablePairHeapMax.Create;
begin
  FNodeManager.EnsureFreeCount(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGComparablePairHeapMax.Create(aCapacity: SizeInt);
begin
  if aCapacity > 0 then
    FNodeManager.EnsureFreeCount(aCapacity);
end;

constructor TGComparablePairHeapMax.Create(constref A: array of T);
begin
  Create;
  EnqueueAll(A);
end;

constructor TGComparablePairHeapMax.Create(e: IEnumerable);
begin
  Create;
  EnqueueAll(e);
end;

{ TGComparablePairHeapMin }

procedure TGComparablePairHeapMin.RootMerge(aNode: PNode);
begin
  FRoot := DoMerge(FRoot, aNode);
  if FRoot <> nil then
    FRoot^.Prev := nil;
end;

procedure TGComparablePairHeapMin.DoExtract(aNode: PNode);
begin
  if aNode <> FRoot then
    begin
      CutNode(aNode);
      RootMerge(TwoPassMerge(aNode^.Child));
    end
  else
    begin
      FRoot := TwoPassMerge(FRoot^.Child);
      if FRoot <> nil then
        FRoot^.Prev := nil;
    end;
  aNode^.ClearLinks;
end;

function TGComparablePairHeapMin.DoEnqueue(constref aValue: T): PNode;
begin
  Result := NewNode(aValue);
  RootMerge(Result);
end;

procedure TGComparablePairHeapMin.DoUpdate(aNode: PNode; constref aValue: T);
begin
  if aValue < aNode^.Data then
    begin
      aNode^.Data := aValue;
      if aNode <> FRoot then
        begin
          CutNode(aNode);
          RootMerge(aNode);
        end;
    end
  else
    if aValue > aNode^.Data then
      begin
        aNode^.Data := aValue;
        DoExtract(aNode);
        RootMerge(aNode);
      end;
end;

function TGComparablePairHeapMin.DoRemove(aNode: PNode): T;
begin
  DoExtract(aNode);
  Result := aNode^.Data;
  DisposeNode(aNode);
end;

function TGComparablePairHeapMin.DoDequeue: T;
var
  OldRoot: PNode;
begin
  OldRoot := FRoot;
  Result := FRoot^.Data;
  FRoot := TwoPassMerge(FRoot^.Child);
  if FRoot <> nil then
    FRoot^.Prev := nil;
  DisposeNode(OldRoot);
end;

function TGComparablePairHeapMin.DoMergeHeap(ph: TCustomPairingHeap): SizeInt;
begin
  Result := ph.Count;
  if Result > 0 then
    begin
      if ph is TGComparablePairHeapMin then
        begin
          FNodeManager.Join(ph.FNodeManager);
          RootMerge(ph.FRoot);
          FCount += Result;
          ph.FCount := 0;
          ph.FRoot := nil;
        end
      else
        begin
          EnqueueAll(ph);
          ph.Clear;
        end;
    end;
end;

class function TGComparablePairHeapMin.DoMerge(L, R: PNode): PNode;
begin
  if L <> nil then
    begin
      if R <> nil then
        begin
          if L^.Data <= R^.Data then
            begin
              L^.AddChild(R);
              Result := L;
            end
          else
            begin
              R^.AddChild(L);
              Result := R;
            end;
        end
      else
        Result := L;
    end
  else
    Result := R;
end;

{$IFDEF ENABLE_TWOPASSMERGE_RECURSION}
class function TGComparablePairHeapMin.TwoPassMerge(aNode: PNode): PNode; // recursive
var
  Sibling, NextSibling: PNode;
begin
  if (aNode <> nil) and (aNode^.Sibling <> nil) then
    begin
      Sibling := aNode^.Sibling;
      NextSibling := Sibling^.Sibling;
      aNode^.Sibling := nil;
      Sibling^.Sibling := nil;
      Result := DoMerge(DoMerge(aNode, Sibling), TwoPassMerge(NextSibling));
    end
  else
    Result := aNode;
end;
{$ELSE ENABLE_TWOPASSMERGE_RECURSION}
class function TGComparablePairHeapMin.TwoPassMerge(aNode: PNode): PNode; // non recursive
var
  CurrNode, NextNode: PNode;
begin
  Result := nil;
  while (aNode <> nil) and (aNode^.Sibling <> nil) do
    begin
      CurrNode := aNode;
      NextNode := aNode^.Sibling;
      aNode := NextNode^.Sibling;
      CurrNode^.Sibling := nil;
      NextNode^.Sibling := nil;
      Result := DoMerge(Result, DoMerge(CurrNode, NextNode));
    end;
  Result := DoMerge(Result, aNode);
end;
{$ENDIF ENABLE_TWOPASSMERGE_RECURSION}

constructor TGComparablePairHeapMin.Create;
begin
  FNodeManager.EnsureFreeCount(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGComparablePairHeapMin.Create(aCapacity: SizeInt);
begin
  if aCapacity > 0 then
    FNodeManager.EnsureFreeCount(aCapacity);
end;

constructor TGComparablePairHeapMin.Create(constref A: array of T);
begin
  Create;
  EnqueueAll(A);
end;

constructor TGComparablePairHeapMin.Create(e: IEnumerable);
begin
  Create;
  EnqueueAll(e);
end;

{ TGRegularPairHeap }

function TGRegularPairHeap.DoMerge(L, R: PNode): PNode;
begin
  if L <> nil then
    begin
      if R <> nil then
        begin
          if FCompare(L^.Data, R^.Data) >= 0 then
            begin
              L^.AddChild(R);
              Result := L;
            end
          else
            begin
              R^.AddChild(L);
              Result := R;
            end;
        end
      else
        Result := L;
    end
  else
    Result := R;
end;

procedure TGRegularPairHeap.RootMerge(aNode: PNode);
begin
  FRoot := DoMerge(FRoot, aNode);
  if FRoot <> nil then
    FRoot^.Prev := nil;
end;

{$IFDEF ENABLE_TWOPASSMERGE_RECURSION}
function TGRegularPairHeap.TwoPassMerge(aNode: PNode): PNode; // recursive
var
  Sibling, NextSibling: PNode;
begin
  if (aNode <> nil) and (aNode^.Sibling <> nil) then
    begin
      Sibling := aNode^.Sibling;
      NextSibling := Sibling^.Sibling;
      aNode^.Sibling := nil;
      Sibling^.Sibling := nil;
      Result := DoMerge(DoMerge(aNode, Sibling), TwoPassMerge(NextSibling));
    end
  else
    Result := aNode;
end;
{$ELSE ENABLE_TWOPASSMERGE_RECURSION}
function TGRegularPairHeap.TwoPassMerge(aNode: PNode): PNode; // non recursive
var
  CurrNode, NextNode: PNode;
begin
  Result := nil;
  while (aNode <> nil) and (aNode^.Sibling <> nil) do
    begin
      CurrNode := aNode;
      NextNode := aNode^.Sibling;
      aNode := NextNode^.Sibling;
      CurrNode^.Sibling := nil;
      NextNode^.Sibling := nil;
      Result := DoMerge(Result, DoMerge(CurrNode, NextNode));
    end;
  if aNode <> nil then
    Result := DoMerge(Result, aNode);
end;
{$ENDIF ENABLE_TWOPASSMERGE_RECURSION}

procedure TGRegularPairHeap.DoExtract(aNode: PNode);
begin
  if aNode <> FRoot then
    begin
      CutNode(aNode);
      RootMerge(TwoPassMerge(aNode^.Child));
    end
  else
    begin
      FRoot := TwoPassMerge(FRoot^.Child);
      if FRoot <> nil then
        FRoot^.Prev := nil;
    end;
  aNode^.ClearLinks;
end;

function TGRegularPairHeap.DoEnqueue(constref aValue: T): PNode;
begin
  Result := NewNode(aValue);
  RootMerge(Result);
end;

procedure TGRegularPairHeap.DoUpdate(aNode: PNode; constref aValue: T);
var
  c: SizeInt;
begin
  c := FCompare(aValue, aNode^.Data);
  if c > 0 then
    begin
      aNode^.Data := aValue;
      if aNode <> FRoot then
        begin
          CutNode(aNode);
          RootMerge(aNode);
        end;
    end
  else
    if c < 0 then
      begin
        aNode^.Data := aValue;
        DoExtract(aNode);
        RootMerge(aNode);
      end;
end;

function TGRegularPairHeap.DoRemove(aNode: PNode): T;
begin
  DoExtract(aNode);
  Result := aNode^.Data;
  DisposeNode(aNode);
end;

function TGRegularPairHeap.DoDequeue: T;
var
  OldRoot: PNode;
begin
  OldRoot := FRoot;
  Result := FRoot^.Data;
  FRoot := TwoPassMerge(FRoot^.Child);
  if FRoot <> nil then
    FRoot^.Prev := nil;
  DisposeNode(OldRoot);
end;

function TGRegularPairHeap.DoMergeHeap(ph: TCustomPairingHeap): SizeInt;
begin
  Result := ph.Count;
  if Result > 0 then
    begin
      if ph is TGRegularPairHeap then
        begin
          FNodeManager.Join(ph.FNodeManager);
          RootMerge(ph.FRoot);
          FCount += Result;
          ph.FCount := 0;
          ph.FRoot := nil;
        end
      else
        begin
          EnqueueAll(ph);
          ph.Clear;
        end;
    end;
end;

constructor TGRegularPairHeap.Create;
begin
  Create(TDefaults.Compare);
end;

constructor TGRegularPairHeap.Create(c: TComparator);
begin
  FCompare := c;
  FNodeManager.EnsureFreeCount(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGRegularPairHeap.Create(aCapacity: SizeInt; c: TComparator);
begin
  FCompare := c;
  if aCapacity > 0 then
    FNodeManager.EnsureFreeCount(aCapacity);
end;

constructor TGRegularPairHeap.Create(constref A: array of T; c: TComparator);
begin
  Create(System.Length(A), c);
  EnqueueAll(A);
end;

constructor TGRegularPairHeap.Create(e: IEnumerable; c: TComparator);
begin
  Create(c);
  EnqueueAll(e);
end;

function TGRegularPairHeap.Comparator: TComparator;
begin
  Result := FCompare;
end;

{ TGDelegatedPairHeap }

function TGDelegatedPairHeap.DoMerge(L, R: PNode): PNode;
begin
  if L <> nil then
    begin
      if R <> nil then
        begin
          if FCompare(L^.Data, R^.Data) >= 0 then
            begin
              L^.AddChild(R);
              Result := L;
            end
          else
            begin
              R^.AddChild(L);
              Result := R;
            end;
        end
      else
        Result := L;
    end
  else
    Result := R;
end;

procedure TGDelegatedPairHeap.RootMerge(aNode: PNode);
begin
  FRoot := DoMerge(FRoot, aNode);
  if FRoot <> nil then
    FRoot^.Prev := nil;
end;

{$IFDEF ENABLE_TWOPASSMERGE_RECURSION}
function TGDelegatedPairHeap.TwoPassMerge(aNode: PNode): PNode; // recursive
var
  Sibling, NextSibling: PNode;
begin
  if (aNode <> nil) and (aNode^.Sibling <> nil) then
    begin
      Sibling := aNode^.Sibling;
      NextSibling := Sibling^.Sibling;
      aNode^.Sibling := nil;
      Sibling^.Sibling := nil;
      Result := DoMerge(DoMerge(aNode, Sibling), TwoPassMerge(NextSibling));
    end
  else
    Result := aNode;
end;
{$ELSE ENABLE_TWOPASSMERGE_RECURSION}
function TGDelegatedPairHeap.TwoPassMerge(aNode: PNode): PNode; // non recursive
var
  CurrNode, NextNode: PNode;
begin
  Result := nil;
  while (aNode <> nil) and (aNode^.Sibling <> nil) do
    begin
      CurrNode := aNode;
      NextNode := aNode^.Sibling;
      aNode := NextNode^.Sibling;
      CurrNode^.Sibling := nil;
      NextNode^.Sibling := nil;
      Result := DoMerge(Result, DoMerge(CurrNode, NextNode));
    end;
  if aNode <> nil then
    Result := DoMerge(Result, aNode);
end;
{$ENDIF ENABLE_TWOPASSMERGE_RECURSION}

procedure TGDelegatedPairHeap.DoExtract(aNode: PNode);
begin
  if aNode <> FRoot then
    begin
      CutNode(aNode);
      RootMerge(TwoPassMerge(aNode^.Child));
    end
  else
    begin
      FRoot := TwoPassMerge(FRoot^.Child);
      if FRoot <> nil then
        FRoot^.Prev := nil;
    end;
  aNode^.ClearLinks;
end;

function TGDelegatedPairHeap.DoEnqueue(constref aValue: T): PNode;
begin
  Result := NewNode(aValue);
  RootMerge(Result);
end;

procedure TGDelegatedPairHeap.DoUpdate(aNode: PNode; constref aValue: T);
var
  c: SizeInt;
begin
  c := FCompare(aValue, aNode^.Data);
  if c > 0 then
    begin
      aNode^.Data := aValue;
      if aNode <> FRoot then
        begin
          CutNode(aNode);
          RootMerge(aNode);
        end;
    end
  else
    if c < 0 then
      begin
        aNode^.Data := aValue;
        DoExtract(aNode);
        RootMerge(aNode);
      end;
end;

function TGDelegatedPairHeap.DoRemove(aNode: PNode): T;
begin
  DoExtract(aNode);
  Result := aNode^.Data;
  DisposeNode(aNode);
end;

function TGDelegatedPairHeap.DoDequeue: T;
var
  OldRoot: PNode;
begin
  OldRoot := FRoot;
  Result := FRoot^.Data;
  FRoot := TwoPassMerge(FRoot^.Child);
  if FRoot <> nil then
    FRoot^.Prev := nil;
  DisposeNode(OldRoot);
end;

function TGDelegatedPairHeap.DoMergeHeap(ph: TCustomPairingHeap): SizeInt;
begin
  Result := ph.Count;
  if Result > 0 then
    begin
      if ph is TGDelegatedPairHeap then
        begin
          FNodeManager.Join(ph.FNodeManager);
          RootMerge(ph.FRoot);
          FCount += Result;
          ph.FCount := 0;
          ph.FRoot := nil;
        end
      else
        begin
          EnqueueAll(ph);
          ph.Clear;
        end;
    end;
end;

constructor TGDelegatedPairHeap.Create;
begin
  Create(TDefaults.OnCompare);
end;

constructor TGDelegatedPairHeap.Create(c: TComparator);
begin
  FCompare := c;
  FNodeManager.EnsureFreeCount(DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGDelegatedPairHeap.Create(aCapacity: SizeInt; c: TComparator);
begin
  FCompare := c;
  if aCapacity > 0 then
    FNodeManager.EnsureFreeCount(aCapacity);
end;

constructor TGDelegatedPairHeap.Create(constref A: array of T; c: TComparator);
begin
  Create(c);
  EnqueueAll(A);
end;

constructor TGDelegatedPairHeap.Create(e: IEnumerable; c: TComparator);
begin
  Create(c);
  EnqueueAll(e);
end;

function TGDelegatedPairHeap.Comparator: TComparator;
begin
  Result := FCompare;
end;

{ TGLitePairingHeap.TNode }

procedure TGLitePairingHeap.TNode.AddChild(aNode: PNode);
begin
  if aNode <> nil then
    begin
      aNode^.Prev := @Self;
      Sibling :=  aNode^.Sibling;
      if Sibling <> nil then
        Sibling^.Prev := @Self;
      aNode^.Sibling := Child;
      if aNode^.Sibling <> nil then
        aNode^.Sibling^.Prev := aNode;
      Child := aNode;
    end;
end;

procedure TGLitePairingHeap.TNode.ClearLinks;
begin
  Sibling := nil;
  Child := nil;
  Prev := nil;
end;

function TGLitePairingHeap.TNode.Successor: PNode;
begin
  Result := Sibling;
  if Result <> nil then
    while Result^.Child <> nil do
      Result := Result^.Child
  else
    begin
      Result := @Self;
      while (Result^.Prev <> nil) and (Result^.Prev^.Sibling = Result) do
        Result := Result^.Prev;
      Result := Result^.Prev;
    end;
end;

function TGLitePairingHeap.TNode.Predecessor: PNode;
begin
  Result := Child;
  if Result <> nil then
    while Result^.Sibling <> nil do
      Result := Result^.Sibling
  else
    begin
      Result := @Self;
      while (Result^.Prev <> nil) and (Result^.Prev^.Child = Result) do
        Result := Result^.Prev;
      Result := Result^.Prev;
    end;
end;

{ TGLitePairingHeap.TEnumerator }

function TGLitePairingHeap.TEnumerator.GetCurrent: T;
begin
  Result := FCurrNode^.Data;
end;

function TGLitePairingHeap.TEnumerator.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Successor
  else
    if not FInCycle then
      begin
        NextNode := FLeftmost;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

procedure TGLitePairingHeap.TEnumerator.Reset;
begin
  FCurrNode := nil;
  FInCycle := False;
end;

{ TGLitePairingHeap.TReverseEnumerator }

function TGLitePairingHeap.TReverseEnumerator.GetCurrent: T;
begin
  Result := FCurrNode^.Data;
end;

function TGLitePairingHeap.TReverseEnumerator.MoveNext: Boolean;
var
  NextNode: PNode = nil;
begin
  if FCurrNode <> nil then
    NextNode := FCurrNode^.Predecessor
  else
    if not FInCycle then
      begin
        NextNode := FRightmost;
        FInCycle := True;
      end;
  Result := NextNode <> nil;
  if Result then
    FCurrNode := NextNode;
end;

procedure TGLitePairingHeap.TReverseEnumerator.Reset;
begin
  FCurrNode := nil;
  FInCycle := False;
end;

{ TGLitePairingHeap.TReverse }

function TGLitePairingHeap.TReverse.GetEnumerator: TReverseEnumerator;
begin
  Result := FHeap^.GetReverseEnumerator;
end;

{ TGLitePairingHeap }

function TGLitePairingHeap.GetCapacity: SizeInt;
begin
  Result := Count + FNodeManager.FreeCount;
end;

function TGLitePairingHeap.GetReverseEnumerator: TReverseEnumerator;
begin
  Result.FCurrNode := nil;
  Result.FRightmost := FindRightmost;
  Result.FInCycle := False;
end;

function TGLitePairingHeap.FindLeftmost: PNode;
begin
  Result := FRoot;
  if Result <> nil then
    while Result^.Child <> nil do
      Result := Result^.Child;
end;

function TGLitePairingHeap.FindRightmost: PNode;
begin
  Result := FRoot;
  if Result <> nil then
    while Result^.Sibling <> nil do
      Result := Result^.Sibling;
end;

procedure TGLitePairingHeap.RemoveNodeWithChilds(aNode: PNode);
var
  OldPrev, OldNode, CurrNode: PNode;
  FromSibling: Boolean = False;
begin
  if aNode <> nil then
    begin
      CurrNode := aNode;
      repeat  //postorder traverse
        while FromSibling do
          begin
            OldPrev := CurrNode^.Prev;
            OldNode := CurrNode;
            /////////////////////////////////
            CurrNode^.Data := Default(T);
            FNodeManager.DisposeNode(CurrNode);
            Dec(FCount);
            ////////////////////////////////
            if CurrNode = aNode then
              exit;
            CurrNode := OldPrev;
            FromSibling := CurrNode^.Sibling = OldNode;
            if not FromSibling and (CurrNode^.Sibling <> nil) then
              CurrNode := CurrNode^.Sibling
            else
              FromSibling := True;
          end;
        while CurrNode^.Child <> nil do
          CurrNode := CurrNode^.Child;
        if CurrNode^.Sibling <> nil then
          CurrNode := CurrNode^.Sibling
        else
          FromSibling := True;
      until False;
    end;
end;

procedure TGLitePairingHeap.ClearTree;
begin
  RemoveNodeWithChilds(FRoot);
  FRoot := nil;
end;

function TGLitePairingHeap.NewNode(constref aValue: T): PNode;
begin
  Result := FNodeManager.NewNode;
  Result^.Data := aValue;
  Inc(FCount);
end;

procedure TGLitePairingHeap.DisposeNode(aNode: PNode);
begin
  if aNode <> nil then
    begin
      aNode^ := Default(TNode);
      FNodeManager.FreeNode(aNode);
      Dec(FCount);
    end;
end;

procedure TGLitePairingHeap.RootMerge(aNode: PNode);
begin
  FRoot := NodeMerge(FRoot, aNode);
  if FRoot <> nil then
    FRoot^.Prev := nil;
end;

function TGLitePairingHeap.DequeueItem: T;
var
  OldRoot: PNode;
begin
  OldRoot := FRoot;
  Result := FRoot^.Data;
  FRoot := TwoPassMerge(FRoot^.Child);
  if FRoot <> nil then
    FRoot^.Prev := nil;
  DisposeNode(OldRoot);
end;

procedure TGLitePairingHeap.UpdateNode(aNode: PNode; constref aValue: T);
var
  c: SizeInt;
begin
  c := TCmpRel.Compare(aValue, aNode^.Data);
  if c <> 0 then
    begin
      aNode^.Data := aValue;
      if c > 0 then
        begin
          if aNode <> FRoot then
            begin
              CutNode(aNode);
              RootMerge(aNode);
            end;
        end
      else
        begin
          ExtractNode(aNode);
          RootMerge(aNode);
        end;
    end;
end;

procedure TGLitePairingHeap.ExtractNode(aNode: PNode);
begin
  if aNode <> FRoot then
    begin
      CutNode(aNode);
      RootMerge(TwoPassMerge(aNode^.Child));
    end
  else
    begin
      FRoot := TwoPassMerge(FRoot^.Child);
      if FRoot <> nil then
        FRoot^.Prev := nil;
    end;
  aNode^.ClearLinks;
end;

function TGLitePairingHeap.RemoveNode(aNode: PNode): T;
begin
  ExtractNode(aNode);
  Result := aNode^.Data;
  DisposeNode(aNode);
end;

procedure TGLitePairingHeap.CheckEmpty;
begin
  if Count = 0 then
    AccessEmptyError;
end;

procedure TGLitePairingHeap.AccessEmptyError;
begin
  raise ELGAccessEmpty.Create(SECantAccessEmpty);
end;

class operator TGLitePairingHeap.Initialize(var h: TGLitePairingHeap);
begin
  h := Default(TGLitePairingHeap);
end;

class operator TGLitePairingHeap.Finalize(var h: TGLitePairingHeap);
begin
  h.Clear;
end;

class operator TGLitePairingHeap.Copy(constref aSrc: TGLitePairingHeap; var aDst: TGLitePairingHeap);
var
  v: T;
begin
  System.FillChar(aDst, SizeOf(aDst), 0);
  aDst.EnsureCapacity(aSrc.Count);
  for v in aSrc do
    aDst.Enqueue(v);
end;

class function TGLitePairingHeap.NodeMerge(L, R: PNode): PNode;
begin
  if L <> nil then
    if R <> nil then
      if TCmpRel.Compare(L^.Data, R^.Data) >= 0 then
        begin
          L^.AddChild(R);
          Result := L;
        end
      else
        begin
          R^.AddChild(L);
          Result := R;
        end
    else
      Result := L
  else
    Result := R;
end;

{$IFDEF ENABLE_TWOPASSMERGE_RECURSION}
class function TGLitePairingHeap.TwoPassMerge(aNode: PNode): PNode; // recursive
var
  Sibling, NextSibling: PNode;
begin
  if (aNode <> nil) and (aNode^.Sibling <> nil) then
    begin
      Sibling := aNode^.Sibling;
      NextSibling := Sibling^.Sibling;
      aNode^.Sibling := nil;
      Sibling^.Sibling := nil;
      Result := NodeMerge(NodeMerge(aNode, Sibling), TwoPassMerge(NextSibling));
    end
  else
    Result := aNode;
end;
{$ELSE ENABLE_TWOPASSMERGE_RECURSION}
class function TGLitePairingHeap.TwoPassMerge(aNode: PNode): PNode;
var
  CurrNode, NextNode: PNode;
begin
  Result := nil;
  while (aNode <> nil) and (aNode^.Sibling <> nil) do
    begin
      CurrNode := aNode;
      NextNode := aNode^.Sibling;
      aNode := NextNode^.Sibling;
      CurrNode^.Sibling := nil;
      NextNode^.Sibling := nil;
      Result := NodeMerge(Result, NodeMerge(CurrNode, NextNode));
    end;
  Result := NodeMerge(Result, aNode);
end;
{$ENDIF ENABLE_TWOPASSMERGE_RECURSION}

class procedure TGLitePairingHeap.CutNode(aNode: PNode);
begin
  if aNode^.Sibling <> nil then
    aNode^.Sibling^.Prev := aNode^.Prev;
  if aNode^.Prev^.Child = aNode then
    aNode^.Prev^.Child := aNode^.Sibling
  else
    aNode^.Prev^.Sibling := aNode^.Sibling;
  aNode^.Sibling := nil;
end;

class function TGLitePairingHeap.DoCompare(constref L, R: T): SizeInt;
begin
  Result := TCmpRel.Compare(L, R);
end;

function TGLitePairingHeap.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

function TGLitePairingHeap.GetEnumerator: TEnumerator;
begin
  Result.FCurrNode := nil;
  Result.FLeftmost := FindLeftmost;
  Result.FInCycle := False;
end;

function TGLitePairingHeap.Reverse: TReverse;
begin
  Result.FHeap := @Self;
end;

function TGLitePairingHeap.ToArray: TArray;
var
  I: SizeInt = 0;
  v: T;
begin
  System.SetLength(Result, Count);
  for v in Self do
    begin
      Result[I] := v;
      Inc(I);
    end;
end;

procedure TGLitePairingHeap.Clear;
begin
  ClearTree;
  FNodeManager.Clear;
end;

function TGLitePairingHeap.IsEmpty: Boolean;
begin
  Result := Count = 0;
end;

function TGLitePairingHeap.NonEmpty: Boolean;
begin
  Result := Count <> 0;
end;

procedure TGLitePairingHeap.EnsureCapacity(aValue: SizeInt);
begin
  FNodeManager.EnsureFreeCount(aValue - Capacity);
end;

procedure TGLitePairingHeap.TrimToFit;
begin
  if Count > 0 then
    FNodeManager.ClearFreeList
  else
    FNodeManager.Clear;
end;

procedure TGLitePairingHeap.Enqueue(constref aValue: T);
begin
  RootMerge(NewNode(aValue));
end;

function TGLitePairingHeap.Dequeue: T;
begin
  CheckEmpty;
  Result := DequeueItem;
end;

function TGLitePairingHeap.TryDequeue(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := DequeueItem;
end;

function TGLitePairingHeap.Peek: T;
begin
  CheckEmpty;
  Result := FRoot^.Data;
end;

function TGLitePairingHeap.TryPeek(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := FRoot^.Data;
end;

function TGLitePairingHeap.Insert(constref aValue: T): THandle;
var
  p: PNode;
begin
  p := NewNode(aValue);
  RootMerge(p);
  Result := {%H-}THandle(p);
end;

function TGLitePairingHeap.PeekHead: THandle;
begin
  CheckEmpty;
  Result := {%H-}THandle(FRoot);
end;

function TGLitePairingHeap.TryPeekHead(out aValue: THandle): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := {%H-}THandle(FRoot);
end;

function TGLitePairingHeap.Value(aHandle: THandle): T;
begin
  Result := {%H-}PNode(aHandle)^.Data;
end;

procedure TGLitePairingHeap.Update(aHandle: THandle; constref aValue: T);
begin
  CheckEmpty;
  UpdateNode({%H-}PNode(aHandle), aValue);
end;

function TGLitePairingHeap.Remove(aHandle: THandle): T;
begin
  CheckEmpty;
  Result := RemoveNode({%H-}PNode(aHandle));
end;

function TGLitePairingHeap.Merge(aHeap: TGLitePairingHeap): SizeInt;
begin
  Result := aHeap.Count;
  if Result > 0 then
    begin
      FNodeManager.Join(aHeap.FNodeManager);
      RootMerge(aHeap.FRoot);
      FCount += Result;
      aHeap.FCount := 0;
      aHeap.FRoot := nil;
    end;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic queue implementations.                                          *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGQueue;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}

interface

uses
  SysUtils,
  LGUtils,
  LGCustomContainer;

type

  { TGQueue }

  generic TGQueue<T> = class(specialize TGCustomRingArrayBuffer<T>, specialize IGContainer<T>,
    specialize IGQueue<T>)
  public
    procedure Enqueue(constref aValue: T); inline;
    function  EnqueueAll(constref a: array of T): SizeInt;
    function  EnqueueAll(e: IEnumerable): SizeInt; inline;
  { EXTRACTS element from the head of queue }
    function  Dequeue: T; inline;
    function  TryDequeue(out aValue: T): Boolean; inline;
    function  Peek: T; inline;
    function  TryPeek(out aValue: T): Boolean; inline;
  end;

  { TGObjectQueue note:
    TGObjectQueue.Dequeue(or TGObjectQueue.TryDequeue) EXTRACTS object from queue;
    you need to free this object yourself }
  generic TGObjectQueue<T: class> = class(specialize TGQueue<T>)
  private
    FOwnsObjects: Boolean;
  protected
    procedure DoClear; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(constref A: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGThreadQueue }

  generic TGThreadQueue<T> = class
  public
  type
    IQueue = specialize IGQueue<T>;

  private
    FQueue: IQueue;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create(aQueue: IQueue);
    destructor Destroy; override;
    procedure Clear;
    procedure Enqueue(constref aValue: T);
    function  TryDequeue(out aValue: T): Boolean;
    function  TryPeek(out aValue: T): Boolean;
    function  Lock: IQueue;
    procedure Unlock; inline;
  end;

  { TGLiteQueue }

  generic TGLiteQueue<T> = record
  type
    TBuffer     = specialize TGLiteRingDynBuffer<T>;
    TEnumerator = TBuffer.TEnumerator;
    TMutable    = TBuffer.TMutable;
    TReverse    = TBuffer.TReverse;
    TArray      = TBuffer.TArray;

  private
    FBuffer: TBuffer;
    function  GetCapacity: SizeInt; inline;
  public
    function  GetEnumerator: TEnumerator; inline;
    function  Mutable: TMutable; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    procedure Enqueue(constref aValue: T); inline;
  { EXTRACTS element from the head of queue }
    function  Dequeue: T; inline;
    function  TryDequeue(out aValue: T): Boolean; inline;
    function  Peek: T; inline;
    function  TryPeek(out aValue: T): Boolean; inline;
    property  Count: SizeInt read FBuffer.FCount;
    property  Capacity: SizeInt read GetCapacity;
  end;

  { TGLiteThreadQueue }

  generic TGLiteThreadQueue<T> = class
  public
  type
    TQueue = specialize TGLiteQueue<T>;
    PQueue = ^TQueue;

  strict private
    FQueue: TQueue;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    procedure Enqueue(constref aValue: T);
    function  TryDequeue(out aValue: T): Boolean;
    function  TryPeek(out aValue: T): Boolean;
    function  Lock: PQueue;
    procedure Unlock; inline;
  end;

  { TGLiteWaitableQueue }

  generic TGLiteWaitableQueue<T> = class
  public
  type
    TQueue = specialize TGLiteQueue<T>;

  strict private
    FQueue: TQueue;
    FLock: TRTLCriticalSection;
    FReadAwait: PRtlEvent;
    procedure Lock; inline;
    procedure UnLock; inline;
    procedure Signaled; inline;
  public
    constructor Create;
    destructor Destroy; override;
    procedure AfterConstruction; override;
    procedure Clear;
    procedure Enqueue(constref aValue: T);
    function  TryDequeue(out aValue: T): Boolean;
    function  TryWaitDequeue(out aValue: T): Boolean;
    function  TryPeek(out aValue: T): Boolean;
    function  TryWaitPeek(out aValue: T): Boolean;
  end;

  { TGLiteObjectQueue }

  generic TGLiteObjectQueue<T: class> = record
  strict private
  type
    TQueue      = specialize TGLiteQueue<T>;
    TEnumerator = TQueue.TEnumerator;
    TMutable    = TQueue.TMutable;
    TReverse    = TQueue.TReverse;
    TArray      = TQueue.TArray;

  var
    FOwnsObjects: Boolean;
    FQueue: TQueue;
    function  GetCapacity: SizeInt; inline;
    function  GetCount: SizeInt; inline;
    procedure CheckFreeItems;
    class operator Initialize(var q: TGLiteObjectQueue);
    class operator Finalize(var q: TGLiteObjectQueue);
  public
    function  GetEnumerator: TEnumerator; inline;
    function  Mutable: TMutable; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    procedure Enqueue(constref aValue: T);
  { EXTRACTS element from the head of queue }
    function  Dequeue: T; inline;
    function  TryDequeue(out aValue: T): Boolean; inline;
    function  Peek: T; inline;
    function  TryPeek(out aValue: T): Boolean; inline;
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGLiteThreadObjectQueue }

  generic TGLiteThreadObjectQueue<T: class> = class
  public
  type
    TQueue = specialize TGLiteObjectQueue<T>;
    PQueue = ^TQueue;

  private
    FQueue: TQueue;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    procedure Enqueue(constref aValue: T);
    function  TryDequeue(out aValue: T): Boolean;
    function  TryPeek(out aValue: T): Boolean;
    function  Lock: PQueue;
    procedure Unlock; inline;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGQueue }

procedure TGQueue.Enqueue(constref aValue: T);
begin
  CheckInIteration;
  Append(aValue);
end;

function TGQueue.EnqueueAll(constref a: array of T): SizeInt;
begin
  CheckInIteration;
  Result := AppendArray(a);
end;

function TGQueue.EnqueueAll(e: IEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := AppendEnumerable(e);
end;

function TGQueue.Dequeue: T;
begin
  CheckInIteration;
  CheckEmpty;
  Result := ExtractHead;
end;

function TGQueue.TryDequeue(out aValue: T): Boolean;
begin
  Result := not InIteration and (ElemCount > 0);
  if Result then
    aValue := ExtractHead;
end;

function TGQueue.Peek: T;
begin
  CheckEmpty;
  Result := FItems[Head];
end;

function TGQueue.TryPeek(out aValue: T): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aValue := FItems[Head];
end;

{ TGObjectQueue }

procedure TGObjectQueue.DoClear;
var
  I, CurrIdx, c: SizeInt;
begin
  if OwnsObjects and (ElemCount > 0) then
    begin
      CurrIdx := Head;
      c := Capacity;
      for I := 1 to ElemCount do
        begin
          FItems[CurrIdx].Free;
          Inc(CurrIdx);
          if CurrIdx = c then
            CurrIdx := 0;
        end;
    end;
  inherited;
end;

constructor TGObjectQueue.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectQueue.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectQueue.Create(constref A: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(A);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectQueue.Create(e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(e);
  FOwnsObjects := aOwnsObjects;
end;

{ TGThreadQueue }

procedure TGThreadQueue.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGThreadQueue.Create(aQueue: IQueue);
begin
  System.InitCriticalSection(FLock);
  FQueue := aQueue;
end;

destructor TGThreadQueue.Destroy;
begin
  DoLock;
  try
    FQueue._GetRef.Free;
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGThreadQueue.Clear;
begin
  DoLock;
  try
    FQueue.Clear;
  finally
    UnLock;
  end;
end;

procedure TGThreadQueue.Enqueue(constref aValue: T);
begin
  DoLock;
  try
    FQueue.Enqueue(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadQueue.TryDequeue(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FQueue.TryDequeue(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadQueue.TryPeek(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FQueue.TryPeek(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadQueue.Lock: IQueue;
begin
  Result := FQueue;
  DoLock;
end;

procedure TGThreadQueue.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

{ TGLiteQueue }

function TGLiteQueue.GetCapacity: SizeInt;
begin
  Result := FBuffer.Capacity;
end;

function TGLiteQueue.GetEnumerator: TEnumerator;
begin
  Result := FBuffer.GetEnumerator;
end;

function TGLiteQueue.Mutable: TMutable;
begin
  Result := FBuffer.Mutable;
end;

function TGLiteQueue.Reverse: TReverse;
begin
  Result := FBuffer.Reverse;
end;

function TGLiteQueue.ToArray: TArray;
begin
  Result := FBuffer.ToArray;
end;

procedure TGLiteQueue.Clear;
begin
  FBuffer.Clear;
end;

function TGLiteQueue.IsEmpty: Boolean;
begin
  Result := FBuffer.Count = 0;
end;

function TGLiteQueue.NonEmpty: Boolean;
begin
  Result := FBuffer.Count <> 0;
end;

procedure TGLiteQueue.EnsureCapacity(aValue: SizeInt);
begin
  FBuffer.EnsureCapacity(aValue);
end;

procedure TGLiteQueue.TrimToFit;
begin
  FBuffer.TrimToFit;
end;

procedure TGLiteQueue.Enqueue(constref aValue: T);
begin
  FBuffer.PushLast(aValue);
end;

function TGLiteQueue.Dequeue: T;
begin
  Result := FBuffer.PopFirst;
end;

function TGLiteQueue.TryDequeue(out aValue: T): Boolean;
begin
  Result := FBuffer.TryPopFirst(aValue);
end;

function TGLiteQueue.Peek: T;
begin
  Result := FBuffer.PeekFirst;
end;

function TGLiteQueue.TryPeek(out aValue: T): Boolean;
begin
  Result := FBuffer.TryPeekFirst(aValue);
end;

{ TGLiteThreadQueue }

procedure TGLiteThreadQueue.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGLiteThreadQueue.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteThreadQueue.Destroy;
begin
  DoLock;
  try
    Finalize(FQueue);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGLiteThreadQueue.Clear;
begin
  DoLock;
  try
    FQueue.Clear;
  finally
    UnLock;
  end;
end;

procedure TGLiteThreadQueue.Enqueue(constref aValue: T);
begin
  DoLock;
  try
    FQueue.Enqueue(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadQueue.TryDequeue(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FQueue.TryDequeue(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadQueue.TryPeek(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FQueue.TryPeek(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadQueue.Lock: PQueue;
begin
  Result := @FQueue;
  DoLock;
end;

procedure TGLiteThreadQueue.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

{ TGLiteWaitableQueue }

procedure TGLiteWaitableQueue.Lock;
begin
  System.EnterCriticalSection(FLock);
end;

procedure TGLiteWaitableQueue.UnLock;
begin
  System.LeaveCriticalSection(FLock);
end;

procedure TGLiteWaitableQueue.Signaled;
begin
  System.RtlEventSetEvent(FReadAwait);
end;

constructor TGLiteWaitableQueue.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteWaitableQueue.Destroy;
begin
  Lock;
  try
    System.RtlEventDestroy(FReadAwait);
    FReadAwait := nil;
    Finalize(FQueue);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGLiteWaitableQueue.AfterConstruction;
begin
  inherited;
  FReadAwait  := System.RtlEventCreate;
end;

procedure TGLiteWaitableQueue.Clear;
begin
  Lock;
  try
    FQueue.Clear;
  finally
    UnLock;
  end;
end;

procedure TGLiteWaitableQueue.Enqueue(constref aValue: T);
begin
  Lock;
  try
    FQueue.Enqueue(aValue);
    Signaled;
  finally
    UnLock;
  end;
end;

function TGLiteWaitableQueue.TryDequeue(out aValue: T): Boolean;
begin
  Lock;
  try
    Result := FQueue.TryDequeue(aValue);
    if FQueue.NonEmpty then
      Signaled;
  finally
    UnLock;
  end;
end;

function TGLiteWaitableQueue.TryWaitDequeue(out aValue: T): Boolean;
begin
  System.RtlEventWaitFor(FReadAwait);
  Lock;
  try
    Result := FQueue.TryDequeue(aValue);
    if FQueue.NonEmpty then
      Signaled;
  finally
    UnLock;
  end;
end;

function TGLiteWaitableQueue.TryPeek(out aValue: T): Boolean;
begin
  Lock;
  try
    Result := FQueue.TryPeek(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteWaitableQueue.TryWaitPeek(out aValue: T): Boolean;
begin
  System.RtlEventWaitFor(FReadAwait);
  Lock;
  try
    Result := FQueue.TryPeek(aValue);
    if FQueue.NonEmpty then
      Signaled;
  finally
    UnLock;
  end;
end;

{ TGLiteObjectQueue }

function TGLiteObjectQueue.GetCapacity: SizeInt;
begin
  Result := FQueue.Capacity;
end;

function TGLiteObjectQueue.GetCount: SizeInt;
begin
  Result := FQueue.Count;
end;

procedure TGLiteObjectQueue.CheckFreeItems;
var
  v: T;
begin
  if OwnsObjects and (Count > 0) then
    for v in FQueue do
      v.Free;
end;

class operator TGLiteObjectQueue.Initialize(var q: TGLiteObjectQueue);
begin
  q.FOwnsObjects := True;
end;

class operator TGLiteObjectQueue.Finalize(var q: TGLiteObjectQueue);
begin
  q.Clear;
end;

function TGLiteObjectQueue.GetEnumerator: TEnumerator;
begin
  Result := FQueue.GetEnumerator;
end;

function TGLiteObjectQueue.Mutable: TMutable;
begin
  Result := FQueue.Mutable;
end;

function TGLiteObjectQueue.Reverse: TReverse;
begin
  Result := FQueue.Reverse;
end;

function TGLiteObjectQueue.ToArray: TArray;
begin
  Result := FQueue.ToArray;
end;

procedure TGLiteObjectQueue.Clear;
begin
  CheckFreeItems;
  FQueue.Clear;
end;

function TGLiteObjectQueue.IsEmpty: Boolean;
begin
  Result := FQueue.IsEmpty;
end;

function TGLiteObjectQueue.NonEmpty: Boolean;
begin
  Result := FQueue.NonEmpty;
end;

procedure TGLiteObjectQueue.EnsureCapacity(aValue: SizeInt);
begin
  FQueue.EnsureCapacity(aValue);
end;

procedure TGLiteObjectQueue.TrimToFit;
begin
  FQueue.TrimToFit;
end;

procedure TGLiteObjectQueue.Enqueue(constref aValue: T);
begin
  FQueue.Enqueue(aValue);
end;

function TGLiteObjectQueue.Dequeue: T;
begin
  Result := FQueue.Dequeue;
end;

function TGLiteObjectQueue.TryDequeue(out aValue: T): Boolean;
begin
  Result := FQueue.TryDequeue(aValue);
end;

function TGLiteObjectQueue.Peek: T;
begin
  Result := FQueue.Peek;
end;

function TGLiteObjectQueue.TryPeek(out aValue: T): Boolean;
begin
  Result := FQueue.TryPeek(aValue);
end;

{ TGLiteThreadObjectQueue }

procedure TGLiteThreadObjectQueue.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGLiteThreadObjectQueue.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteThreadObjectQueue.Destroy;
begin
  DoLock;
  try
    Finalize(FQueue);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGLiteThreadObjectQueue.Clear;
begin
  DoLock;
  try
    FQueue.Clear;
  finally
    UnLock;
  end;
end;

procedure TGLiteThreadObjectQueue.Enqueue(constref aValue: T);
begin
  DoLock;
  try
    FQueue.Enqueue(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectQueue.TryDequeue(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FQueue.TryDequeue(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectQueue.TryPeek(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FQueue.TryPeek(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectQueue.Lock: PQueue;
begin
  Result := @FQueue;
  DoLock;
end;

procedure TGLiteThreadObjectQueue.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic sorted list implementation.                                     *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGSortedList;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  math,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGArrayHelpers,
  LGStrConst;

type

  { TGBaseSortedList is always sorted ascending;
      functor TCmpRel(column equality relation) must provide:
        class function Compare([const[ref]] L, R: TCol): SizeInt; }
  generic TGBaseSortedList<T, TCmpRel> = class(specialize TGCustomCollection<T>)
  protected
  const
    // MAX_CAPACITY must be <= Succ(SizeInt.MaxValue div 2)
    MAX_CAPACITY: SizeInt = SizeInt(MAX_CONTAINER_SIZE div SizeOf(TItem));

  type
    TSortedList = specialize TGBaseSortedList<T, TCmpRel>;
    THelper     = class(specialize TGBaseArrayHelper<T, TCmpRel>);

    TEnumerator = class(TContainerEnumerator)
    private
      FItems: TArray;
      FCurrIndex,
      FLast: SizeInt;
    protected
      function  GetCurrent: T; override;
    public
      constructor Create(aList: TSortedList);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TReverseEnumerable = class(TContainerEnumerable)
    protected
      FItems: TArray;
      FCurrIndex,
      FCount: SizeInt;
      function  GetCurrent: T; override;
    public
      constructor Create(aList: TSortedList);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    THeadEnumerable = class(TContainerEnumerable)
    protected
      FItems: TArray;
      FCurrIndex,
      FLast: SizeInt;
      function  GetCurrent: T; override;
    public
      constructor Create(aList: TSortedList; aLastIndex: SizeInt); overload;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TTailEnumerable = class(TContainerEnumerable)
    protected
      FItems: TArray;
      FCurrIndex,
      FStart,
      FLast: SizeInt;
      function  GetCurrent: T; override;
    public
      constructor Create(aList: TSortedList; aStartIndex: SizeInt); overload;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  TRangeEnumerable = class(TTailEnumerable)
    constructor Create(aList: TSortedList; aStartIndex, aLastIndex: SizeInt); overload;
  end;

  public
  type
    TRecEnumerator = record
    private
      FItems: TArray;
      FCurrIndex,
      FLast: SizeInt;
      function  GetCurrent: T; inline;
    public
      procedure Init(aList: TSortedList);
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

  protected
  type
    TExtractHelper = object
    private
      FCurrIndex: SizeInt;
      FExtracted: TArray;
    public
      procedure Add(constref aValue: T);
      procedure Init;
      function  Final: TArray;
    end;

  var
    FItems: TArray;
    FCount: SizeInt;
    FRejectDuplicates: Boolean;
    function  GetCount: SizeInt; override;
    function  GetCapacity: SizeInt; override;
    procedure SetRejectDuplicates(aValue: Boolean);
    procedure DoClear; override;
    function  DoGetEnumerator: TCustomEnumerator; override;
    procedure DoTrimToFit; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    procedure CopyItems(aBuffer: PItem); override;
    function  GetItem(aIndex: SizeInt): T; inline;
    procedure SetItem(aIndex: SizeInt; const aValue: T); inline;
    procedure DoSetItem(aIndex: SizeInt; const aValue: T); virtual;
    procedure RemoveDuplicates;
    procedure InsertItem(aIndex: SizeInt; constref aValue: T);
    function  DoAdd(constref aValue: T): Boolean; override;
    function  DoInsert(constref aValue: T): SizeInt;
    function  DoRemove(constref aValue: T): Boolean; override;
    function  DoExtract(constref aValue: T): Boolean; override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
    function  DoExtractIf(aTest: TTest): TArray; override;
    function  DoExtractIf(aTest: TOnTest): TArray; override;
    function  DoExtractIf(aTest: TNestTest): TArray; override;
    function  SelectDistinctArray(constref a: array of T): TArray;
    function  DoAddAll(constref a: array of T): SizeInt; override; overload;
    function  DoAddAll(e: IEnumerable): SizeInt; override; overload;
    function  IndexInRange(aIndex: SizeInt): Boolean; inline;
    procedure CheckIndexRange(aIndex: SizeInt); inline;
    function  ListCapacity: SizeInt; inline;
    function  GetReverse: IEnumerable;
    procedure Expand(aValue: SizeInt);
    procedure ItemAdding; inline;
    function  ExtractItem(aIndex: SizeInt): T;
    function  DeleteItem(aIndex: SizeInt): T; virtual;
    function  DoDeleteRange(aIndex, aCount: SizeInt): SizeInt; virtual;
    function  GetRecEnumerator: TRecEnumerator; inline; //for internal use
    function  NearestLT(constref aValue: T): SizeInt;
    function  RightmostLE(constref aValue: T): SizeInt;
    function  NearestGT(constref aValue: T): SizeInt;
    function  LeftmostGE(constref aValue: T): SizeInt;
    property  ElemCount: SizeInt read FCount;
  public
    constructor CreateEmpty;
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref a: array of T);
    constructor Create(e: IEnumerable);
    constructor Create(aRejectDuplicates: Boolean);
    constructor Create(constref a: array of T; aRejectDuplicates: Boolean);
    constructor Create(e: IEnumerable; aRejectDuplicates: Boolean);
    destructor  Destroy; override;

    function  Reverse: IEnumerable; override;
    function  ToArray: TArray; override;
    function  FindMin(out aValue: T): Boolean;
    function  FindMax(out aValue: T): Boolean;
  { returns insert index, -1 if element is not inserted }
    function  Insert(constref aValue: T): SizeInt;
    function  Contains(constref aValue: T): Boolean; override;
    function  NonContains(constref aValue: T): Boolean; inline;
    procedure Delete(aIndex: SizeInt);
    function  TryDelete(aIndex: SizeInt): Boolean;
    function  DeleteAll(aIndex, aCount: SizeInt): SizeInt;
    function  IndexOf(constref aValue: T): SizeInt; inline;
  { returns index of leftest occurrence of aValue, -1 if there are no such element }
    function  FirstIndexOf(constref aValue: T): SizeInt;
  { returns count of occurrences of aValue, 0 if there are no such element }
    function  CountOf(constref aValue: T): SizeInt;
  { returns index of element whose value greater then or equal to aValue (depend on aInclusive);
    returns -1 if there are no such element }
    function  IndexOfCeil(constref aValue: T; aInclusive: Boolean): SizeInt;
  { returns index of element whose value less then aBound (or equal to aValue depend on aInclusive);
    returns -1 if there are no such element }
    function  IndexOfFloor(constref aValue: T; aInclusive: Boolean): SizeInt;
  { enumerates values whose are strictly less than(if not aInclusive) aHighBound }
    function  Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable;
  { enumerates values whose are greater than or equal to(if aInclusive) aLowBound }
    function  Tail(constref aLowBound: T; aInclusive: Boolean = True): IEnumerable;
  { enumerates values whose are greater than or equal to aLowBound and strictly less than aHighBound(by default)}
    function  Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
    function  HeadList(constref aHighBound: T; aInclusive: Boolean = False): TSortedList;
    function  TailList(constref aLowBound: T; aInclusive: Boolean = True): TSortedList;
    function  SubList(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TSortedList;
    function  Clone: TSortedList; override;
    property  RejectDuplicates: Boolean read FRejectDuplicates write SetRejectDuplicates;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
  end;

  { TGSortedList assumes that type T implements TCmpRel}
  generic TGSortedList<T> = class(specialize TGBaseSortedList<T, T>);

  { TGObjectSortedList }

  generic TGObjectSortedList<T, TCmpRel> = class(specialize TGBaseSortedList<T, TCmpRel>)
  private
    FOwnsObects: Boolean;
  protected
    procedure DoClear; override;
    procedure DoSetItem(aIndex: SizeInt; const aValue: T); override;
    function  DoRemove(constref aValue: T): Boolean; override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
    function  DeleteItem(aIndex: SizeInt): T; override;
    function  DoDeleteRange(aIndex, aCount: SizeInt): SizeInt; override;
  public
  type
    TObjectSortedList = specialize TGObjectSortedList<T, TCmpRel>;

    constructor CreateEmpty(aOwnsObjects: Boolean = True);
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor Create(aRejectDuplicates: Boolean; aOwnsObjects: Boolean = True);
    constructor Create(constref a: array of T; aRejectDuplicates: Boolean; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aRejectDuplicates: Boolean; aOwnsObjects: Boolean = True);
    function  Clone: TObjectSortedList; override;
    property OwnsObjects: Boolean read FOwnsObects write FOwnsObects;
  end;

  { TGObjSortedList uses comparator from LGHelpers }
  generic TGObjSortedList<T> = class(specialize TGObjectSortedList<T, T>);

  { TGSortedList2: minimalistic sorted list }
  generic TGSortedList2<T, TCmpRel> = class
  private
  type
    TArray = array of T;

  public
  type
    TEnumerator = record
    private
      FList: TArray;
      FCurrIndex,
      FLastIndex: SizeInt;
      function  GetCurrent: T; inline;
    public
      procedure Init(aList: TGSortedList2); inline;
      function  MoveNext: Boolean;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

  private
  const
    ITEM_SIZE = SizeOf(T);
    MAX_CAPACITY = MAX_CONTAINER_SIZE div ITEM_SIZE;

  type
    THelper = specialize TGBaseArrayHelper<T, TCmpRel>;

  var
    FItems: TArray;
    FCount: SizeInt;
    FAllowDuplicates: Boolean;
    function  GetCapacity: SizeInt; inline;
    procedure Expand(aValue: SizeInt);
    procedure ItemAdding; inline;
    procedure InsertItem(aIndex: SizeInt; constref aValue: T);
    procedure RemoveItem(aIndex: SizeInt);
    procedure CapacityExceedError(aValue: SizeInt); inline;
  public
    constructor CreateEmpty;
    constructor CreateEmpty(aAllowDuplicates: Boolean);
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(aCapacity: SizeInt; AllowDuplicates: Boolean);
    destructor  Destroy; override;
    function  GetEnumerator: TEnumerator; inline;
    procedure Clear; inline;
    function  EnsureCapacity(aValue: SizeInt): Boolean; inline;
    procedure TrimToFit; inline;
    function  Add(constref aValue: T): Boolean;
    function  Contains(constref aValue: T): Boolean;
    function  Remove(constref aValue: T): Boolean;
    property  Count: SizeInt read FCount;
    property  Capacity: SizeInt read GetCapacity;
  { by default False }
    property  AllowDuplicates: Boolean read FAllowDuplicates;
  end;

  { TGSortedListTable: table on top of sorted list }
  generic TGSortedListTable<TKey, TEntry, TCmpRel> = class
  private
  type
    TEntryList = array of TEntry;

  public
  type
    PEntry = ^TEntry;

    TEntryCmpRel = class
      class function Compare(constref L, R: TEntry): SizeInt; static; inline;
    end;

    TEnumerator = record
    private
      FList: TEntryList;
      FCurrIndex,
      FLastIndex: SizeInt;
      function  GetCurrent: PEntry; inline;
    public
      procedure Init(aTable: TGSortedListTable); inline;
      function  MoveNext: Boolean;
      procedure Reset; inline;
      property  Current: PEntry read GetCurrent;
    end;

  private
  const
    E_SIZE       = SizeOf(TEntry);
    ENTRY_SIZE   = E_SIZE or Ord(E_SIZE = 0);
    MAX_CAPACITY = MAX_CONTAINER_SIZE div ENTRY_SIZE;

  var
    FItems: TEntryList;
    FCount: SizeInt;
    FAllowDuplicates: Boolean;
    function  GetCapacity: SizeInt; inline;
    procedure Expand(aValue: SizeInt);
    procedure ItemAdding; inline;
    procedure InsertItem(aIndex: SizeInt; constref aValue: TEntry);
    procedure RemoveItem(aIndex: SizeInt);
    procedure CapacityExceedError(aValue: SizeInt); inline;
  public
    constructor CreateEmpty;
    constructor CreateEmpty(AllowDuplicates: Boolean);
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(aCapacity: SizeInt; AllowDuplicates: Boolean);
    destructor  Destroy; override;
    function  GetEnumerator: TEnumerator; inline;
    procedure Clear; inline;
    function  EnsureCapacity(aValue: SizeInt): Boolean; inline;
    procedure TrimToFit; inline;
    function  FindOrAdd(constref aKey: TKey; out e: PEntry; out aPos: SizeInt): Boolean;
    function  Find(constref aKey: TKey; out aPos: SizeInt): PEntry;
    function  Add(constref aKey: TKey): PEntry;
    function  Remove(constref aKey: TKey): Boolean;
    procedure RemoveAt(constref aPos: SizeInt); inline;
    property  Count: SizeInt read FCount;
    property  Capacity: SizeInt read GetCapacity;
  { by default False }
    property  AllowDuplicates: Boolean read FAllowDuplicates;
  end;

  { TGLiteSortedList is always sorted ascending;
      functor TCmpRel(column equality relation) must provide:
        class function Compare([const[ref]] L, R: TCol): SizeInt; }
  generic TGLiteSortedList<T, TCmpRel> = record
  private
  type
    TBuffer         = specialize TGLiteDynBuffer<T>;
    THelper         = specialize TGBaseArrayHelper<T, TCmpRel>;
    PLiteSortedList = ^TGLiteSortedList;

  public
  type
    TEnumerator = TBuffer.TEnumerator;
    TReverse    = TBuffer.TReverse;
    PItem       = TBuffer.PItem;
    TArray      = TBuffer.TArray;

    THeadEnumerator = record
    private
      FItems: TArray;
      FCurrIndex,
      FLast: SizeInt;
      function  GetCurrent: T; inline;
      procedure Init(constref aList: TGLiteSortedList; aLastIndex: SizeInt); inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

    THead = record
    private
      FList: PLiteSortedList;
      FHighBound: SizeInt;
      procedure Init(aList: PLiteSortedList; aHighBound: SizeInt); inline;
    public
      function GetEnumerator: THeadEnumerator; inline;
    end;

    TTailEnumerator = record
    private
      FItems: TArray;
      FCurrIndex,
      FStart,
      FLast: SizeInt;
      function  GetCurrent: T; inline;
      procedure Init(constref aList: TGLiteSortedList; aStartIndex: SizeInt);
      procedure Init(constref aList: TGLiteSortedList; aStartIndex, aLastIndex: SizeInt);
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

    TTail = record
    private
      FList: PLiteSortedList;
      FLowBound: SizeInt;
      procedure Init(aList: PLiteSortedList; aLowBound: SizeInt); inline;
    public
      function GetEnumerator: TTailEnumerator;
    end;

    TRange = record
    private
      FList: PLiteSortedList;
      FLowBound,
      FHighBound: SizeInt;
      procedure Init(aList: PLiteSortedList; aLowBound, aHighBound: SizeInt); inline;
    public
      function GetEnumerator: TTailEnumerator;
    end;

  private
    FBuffer: TBuffer;
    FRejectDuplicates: Boolean;
    function  GetCapacity: SizeInt; inline;
    function  GetItem(aIndex: SizeInt): T; inline;
    procedure SetItem(aIndex: SizeInt; aValue: T);
    procedure DoSetItem(aIndex: SizeInt; const aValue: T);
    procedure InsertItem(aIndex: SizeInt; constref aValue: T);
    function  ExtractItem(aIndex: SizeInt): T;
    function  DeleteItem(aIndex: SizeInt): T; inline;
    procedure RemoveDuplicates;
    procedure SetRejectDuplicates(aValue: Boolean);
    function  NearestLT(constref aValue: T): SizeInt;
    function  RightmostLE(constref aValue: T): SizeInt;
    function  NearestGT(constref aValue: T): SizeInt;
    function  LeftmostGE(constref aValue: T): SizeInt;
    function  SelectDistinctArray(constref a: array of T): TArray;
    function  IndexInRange(aIndex: SizeInt): Boolean; inline;
    procedure CheckIndexRange(aIndex: SizeInt); inline;
    procedure IndexOutOfBoundError(aIndex: SizeInt); inline;
    function  GetHeadEnumerator(aHighBound: SizeInt): THeadEnumerator; inline;
    function  GetTailEnumerator(aLowBound: SizeInt): TTailEnumerator; inline;
    function  GetRangeEnumerator(aLowBound, aHighBound: SizeInt): TTailEnumerator; inline;
  public
    function  GetEnumerator: TEnumerator; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    function  FindMin(out aValue: T): Boolean;
    function  FindMax(out aValue: T): Boolean;
    function  Add(constref aValue: T): Boolean;
    function  AddAll(constref a: array of T): SizeInt;
  { returns insert index, -1 if element is not inserted }
    function  Insert(constref aValue: T): SizeInt;
    function  Contains(constref aValue: T): Boolean; inline;
    function  NonContains(constref aValue: T): Boolean; inline;
    procedure Delete(aIndex: SizeInt);
    function  TryDelete(aIndex: SizeInt): Boolean;
    function  IndexOf(constref aValue: T): SizeInt; inline;
  { returns index of leftest occurrence of aValue, -1 if there are no such element }
    function  FirstIndexOf(constref aValue: T): SizeInt;
  { returns count of occurrences of aValue, 0 if there are no such element }
    function  CountOf(constref aValue: T): SizeInt;
  { returns index of element whose value greater then or equal to aValue (depend on aInclusive);
    returns -1 if there are no such element }
    function  IndexOfCeil(constref aValue: T; aInclusive: Boolean): SizeInt; inline;
  { returns index of element whose value less then aBound (or equal to aValue depend on aInclusive);
    returns -1 if there are no such element }
    function  IndexOfFloor(constref aValue: T; aInclusive: Boolean): SizeInt; inline;
  { enumerates values whose are strictly less than(if not aInclusive) aHighBound }
    function  Head(constref aHighBound: T; aInclusive: Boolean = False): THead; inline;
  { enumerates values whose are greater than or equal to(if aInclusive) aLowBound }
    function  Tail(constref aLowBound: T; aInclusive: Boolean = True): TTail;
  { enumerates values whose are greater than or equal to aLowBound and strictly less than aHighBound(by default)}
    function  Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TRange; inline;
    function  HeadList(constref aHighBound: T; aInclusive: Boolean = False): TGLiteSortedList;
    function  TailList(constref aLowBound: T; aInclusive: Boolean = True): TGLiteSortedList;
    function  SubList(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TGLiteSortedList;
    property  Count: SizeInt read FBuffer.FCount;
    property  Capacity: SizeInt read GetCapacity;
    property  RejectDuplicates: Boolean read FRejectDuplicates write SetRejectDuplicates;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
  end;

  { TGLiteComparableSortedList is always sorted ascending;
    it assumes that type T has implemented comparision operators }
  generic TGLiteComparableSortedList<T> = record
  private
  type
    TBuffer     = specialize TGLiteDynBuffer<T>;
    THelper     = specialize TGComparableArrayHelper<T>;
    TSortedList = TGLiteComparableSortedList;
    PSortedList = ^TSortedList;

  public
  type
    TEnumerator = TBuffer.TEnumerator;
    TReverse    = TBuffer.TReverse;
    PItem       = TBuffer.PItem;
    TArray      = TBuffer.TArray;

    THeadEnumerator = record
    private
      FItems: TArray;
      FCurrIndex,
      FLast: SizeInt;
      function  GetCurrent: T; inline;
      procedure Init(constref aList: TSortedList; aLastIndex: SizeInt); inline;
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

    THead = record
    private
      FList: PSortedList;
      FHighBound: SizeInt;
      procedure Init(aList: PSortedList; aHighBound: SizeInt); inline;
    public
      function GetEnumerator: THeadEnumerator; inline;
    end;

    TTailEnumerator = record
    private
      FItems: TArray;
      FCurrIndex,
      FStart,
      FLast: SizeInt;
      function  GetCurrent: T; inline;
      procedure Init(constref aList: TSortedList; aStartIndex: SizeInt);
      procedure Init(constref aList: TSortedList; aStartIndex, aLastIndex: SizeInt);
    public
      function  MoveNext: Boolean; inline;
      procedure Reset; inline;
      property  Current: T read GetCurrent;
    end;

    TTail = record
    private
      FList: PSortedList;
      FLowBound: SizeInt;
      procedure Init(aList: PSortedList; aLowBound: SizeInt); inline;
    public
      function GetEnumerator: TTailEnumerator;
    end;

    TRange = record
    private
      FList: PSortedList;
      FLowBound,
      FHighBound: SizeInt;
      procedure Init(aList: PSortedList; aLowBound, aHighBound: SizeInt); inline;
    public
      function GetEnumerator: TTailEnumerator;
    end;

  private
    FBuffer: TBuffer;
    FRejectDuplicates: Boolean;
    function  GetCapacity: SizeInt; inline;
    function  GetItem(aIndex: SizeInt): T; inline;
    procedure SetItem(aIndex: SizeInt; aValue: T);
    procedure DoSetItem(aIndex: SizeInt; const aValue: T);
    procedure InsertItem(aIndex: SizeInt; constref aValue: T);
    function  ExtractItem(aIndex: SizeInt): T;
    function  DeleteItem(aIndex: SizeInt): T; inline;
    procedure RemoveDuplicates;
    procedure SetRejectDuplicates(aValue: Boolean);
    function  NearestLT(constref aValue: T): SizeInt;
    function  RightmostLE(constref aValue: T): SizeInt;
    function  NearestGT(constref aValue: T): SizeInt;
    function  LeftmostGE(constref aValue: T): SizeInt;
    function  SelectDistinctArray(constref a: array of T): TArray;
    function  IndexInRange(aIndex: SizeInt): Boolean; inline;
    procedure CheckIndexRange(aIndex: SizeInt); inline;
    procedure IndexOutOfBoundError(aIndex: SizeInt); inline;
    function  GetHeadEnumerator(aHighBound: SizeInt): THeadEnumerator; inline;
    function  GetTailEnumerator(aLowBound: SizeInt): TTailEnumerator; inline;
    function  GetRangeEnumerator(aLowBound, aHighBound: SizeInt): TTailEnumerator; inline;
  public
    function  GetEnumerator: TEnumerator; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    function  FindMin(out aValue: T): Boolean;
    function  FindMax(out aValue: T): Boolean;
    function  Add(constref aValue: T): Boolean;
    function  AddAll(constref a: array of T): SizeInt;
  { returns insert index, -1 if element is not inserted }
    function  Insert(constref aValue: T): SizeInt;
    function  Contains(constref aValue: T): Boolean; inline;
    function  NonContains(constref aValue: T): Boolean; inline;
    procedure Delete(aIndex: SizeInt);
    function  TryDelete(aIndex: SizeInt): Boolean;
    function  IndexOf(constref aValue: T): SizeInt; inline;
  { returns index of leftest occurrence of aValue, -1 if there are no such element }
    function  FirstIndexOf(constref aValue: T): SizeInt;
  { returns count of occurrences of aValue, 0 if there are no such element }
    function  CountOf(constref aValue: T): SizeInt;
  { returns index of element whose value greater then or equal to aValue (depend on aInclusive);
    returns -1 if there are no such element }
    function  IndexOfCeil(constref aValue: T; aInclusive: Boolean): SizeInt; inline;
  { returns index of element whose value less then aBound (or equal to aValue depend on aInclusive);
    returns -1 if there are no such element }
    function  IndexOfFloor(constref aValue: T; aInclusive: Boolean): SizeInt; inline;
  { enumerates values whose are strictly less than(if not aInclusive) aHighBound }
    function  Head(constref aHighBound: T; aInclusive: Boolean = False): THead; inline;
  { enumerates values whose are greater than or equal to(if aInclusive) aLowBound }
    function  Tail(constref aLowBound: T; aInclusive: Boolean = True): TTail;
  { enumerates values whose are greater than or equal to aLowBound and strictly less than aHighBound(by default)}
    function  Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TRange; inline;
    function  HeadList(constref aHighBound: T; aInclusive: Boolean = False): TGLiteComparableSortedList;
    function  TailList(constref aLowBound: T; aInclusive: Boolean = True): TGLiteComparableSortedList;
    function  SubList(constref aLowBound, aHighBound: T;
              aIncludeBounds: TRangeBounds = [rbLow]): TGLiteComparableSortedList;
    property  Count: SizeInt read FBuffer.FCount;
    property  Capacity: SizeInt read GetCapacity;
    property  RejectDuplicates: Boolean read FRejectDuplicates write SetRejectDuplicates;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGBaseSortedList.TEnumerator }

function TGBaseSortedList.TEnumerator.GetCurrent: T;
begin
  Result := FItems[FCurrIndex];
end;

constructor TGBaseSortedList.TEnumerator.Create(aList: TSortedList);
begin
  inherited Create(aList);
  FItems := aList.FItems;
  FLast := Pred(aList.ElemCount);
  FCurrIndex := -1;
end;

function TGBaseSortedList.TEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLast;
  FCurrIndex += Ord(Result);
end;

procedure TGBaseSortedList.TEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGBaseSortedList.TReverseEnumerable }

function TGBaseSortedList.TReverseEnumerable.GetCurrent: T;
begin
  Result := FItems[FCurrIndex];
end;

constructor TGBaseSortedList.TReverseEnumerable.Create(aList: TSortedList);
begin
  inherited Create(aList);
  FItems := aList.FItems;
  FCount := aList.ElemCount;
  FCurrIndex := FCount;
end;

function TGBaseSortedList.TReverseEnumerable.MoveNext: Boolean;
begin
  Result := FCurrIndex > 0;
  FCurrIndex -= Ord(Result);
end;

procedure TGBaseSortedList.TReverseEnumerable.Reset;
begin
  FCurrIndex := FCount;
end;

{ TGBaseSortedList.THeadEnumerable }

function TGBaseSortedList.THeadEnumerable.GetCurrent: T;
begin
  Result := FItems[FCurrIndex];
end;

constructor TGBaseSortedList.THeadEnumerable.Create(aList: TSortedList; aLastIndex: SizeInt);
begin
  inherited Create(aList);
  FItems := aList.FItems;
  FLast := aLastIndex;
  FCurrIndex := -1;
end;

function TGBaseSortedList.THeadEnumerable.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLast;
  FCurrIndex += Ord(Result);
end;

procedure TGBaseSortedList.THeadEnumerable.Reset;
begin
  FCurrIndex := -1;
end;

{ TGBaseSortedList.TTailEnumerable }

function TGBaseSortedList.TTailEnumerable.GetCurrent: T;
begin
  Result := FItems[FCurrIndex];
end;

constructor TGBaseSortedList.TTailEnumerable.Create(aList: TSortedList; aStartIndex: SizeInt);
begin
  inherited Create(aList);
  FItems := aList.FItems;
  FLast := Pred(aList.ElemCount);
  FStart := Pred(aStartIndex);
  FCurrIndex := FStart;
end;

function TGBaseSortedList.TTailEnumerable.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLast;
  FCurrIndex += Ord(Result);
end;

procedure TGBaseSortedList.TTailEnumerable.Reset;
begin
  FCurrIndex := FStart;
end;

{ TGBaseSortedList.TRangeEnumerable }

constructor TGBaseSortedList.TRangeEnumerable.Create(aList: TSortedList; aStartIndex, aLastIndex: SizeInt);
begin
  inherited Create(aList, aStartIndex);
  FLast := aLastIndex;
end;

{ TGBaseSortedList.TRecEnumerator }

function TGBaseSortedList.TRecEnumerator.GetCurrent: T;
begin
  Result := FItems[FCurrIndex];
end;

procedure TGBaseSortedList.TRecEnumerator.Init(aList: TSortedList);
begin
  FItems := aList.FItems;
  FLast := Pred(aList.ElemCount);
  FCurrIndex := -1;
end;

function TGBaseSortedList.TRecEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLast;
  FCurrIndex += Ord(Result);
end;

procedure TGBaseSortedList.TRecEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGBaseSortedList.TExtractHelper }

procedure TGBaseSortedList.TExtractHelper.Add(constref aValue: T);
var
  c: SizeInt;
begin
  c := System.Length(FExtracted);
  if FCurrIndex = c then
    System.SetLength(FExtracted, c shl 1);
  FExtracted[FCurrIndex] := aValue;
  Inc(FCurrIndex);
end;

procedure TGBaseSortedList.TExtractHelper.Init;
begin
  FCurrIndex := 0;
  System.SetLength(FExtracted, ARRAY_INITIAL_SIZE);
end;

function TGBaseSortedList.TExtractHelper.Final: TArray;
begin
  System.SetLength(FExtracted, FCurrIndex);
  Result := FExtracted;
end;

{ TGBaseSortedList }

function TGBaseSortedList.GetCount: SizeInt;
begin
  Result := ElemCount;
end;

function TGBaseSortedList.GetCapacity: SizeInt;
begin
  Result := System.Length(FItems);
end;

procedure TGBaseSortedList.SetRejectDuplicates(aValue: Boolean);
begin
  if RejectDuplicates <> aValue then
    begin
      FRejectDuplicates := aValue;
      if RejectDuplicates then
        RemoveDuplicates;
    end;
end;

procedure TGBaseSortedList.DoClear;
begin
  FItems := nil;
  FCount := 0;
end;

function TGBaseSortedList.DoGetEnumerator: TCustomEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

procedure TGBaseSortedList.DoTrimToFit;
begin
  if ListCapacity > ElemCount then
    System.SetLength(FItems, ElemCount);
end;

procedure TGBaseSortedList.DoEnsureCapacity(aValue: SizeInt);
begin
  if aValue > ListCapacity then
    Expand(aValue);
end;

procedure TGBaseSortedList.CopyItems(aBuffer: PItem);
begin
  if ElemCount > 0 then
    THelper.CopyItems(@FItems[0], aBuffer, ElemCount);
end;

function TGBaseSortedList.GetItem(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := FItems[aIndex];
end;

procedure TGBaseSortedList.SetItem(aIndex: SizeInt; const aValue: T);
begin
  CheckIndexRange(aIndex);
  DoSetItem(aIndex, aValue);
end;

procedure TGBaseSortedList.DoSetItem(aIndex: SizeInt; const aValue: T);
var
  sr: THelper.TSearchResult;
  c: SizeInt;
begin
  c := TCmpRel.Compare(aValue, FItems[aIndex]);
  if c <> 0 then
    begin
      CheckInIteration;
      if ElemCount > 1 then
        begin
          sr := THelper.BinarySearchPos(FItems[0..Pred(ElemCount)], aValue);
          if (sr.FoundIndex > -1) and RejectDuplicates then
            exit;
          FItems[aIndex] := Default(T);  ///////////////
          if sr.InsertIndex > aIndex then
            System.Move(FItems[Succ(aIndex)], FItems[aIndex], sr.InsertIndex - aIndex)
          else
            System.Move(FItems[sr.InsertIndex], FItems[Succ(sr.InsertIndex)], aIndex - sr.InsertIndex);
          System.FillChar(FItems[sr.InsertIndex], SizeOf(T), 0);
          FItems[sr.InsertIndex] := aValue;
        end;
    end;
end;

procedure TGBaseSortedList.RemoveDuplicates;
var
  I, J, Hi: SizeInt;
begin
  Hi := Pred(ElemCount);
  if Hi < 1 then
    exit;
  I := 0;
  for J := 1 to Hi do
    begin
      if TCmpRel.Compare(FItems[I], FItems[J]) = 0 then
        continue;
      Inc(I);
      if J > I then
        FItems[I] := FItems[J];
    end;
  FCount := Succ(I);
  for I := ElemCount to Hi do
    FItems[I] := Default(T);
end;

procedure TGBaseSortedList.InsertItem(aIndex: SizeInt; constref aValue: T);
begin
  ItemAdding;
  if aIndex < ElemCount then
    begin
      System.Move(FItems[aIndex], FItems[Succ(aIndex)], SizeOf(T) * (ElemCount - aIndex));
      System.FillChar(FItems[aIndex], SizeOf(T), 0);
    end;
  FItems[aIndex] := aValue;
  Inc(FCount);
end;

function TGBaseSortedList.DoAdd(constref aValue: T): Boolean;
var
  sr: THelper.TSearchResult;
begin
  if ElemCount > 0 then
    begin
      sr := THelper.BinarySearchPos(FItems[0..Pred(ElemCount)], aValue);
      if (sr.FoundIndex > -1) and RejectDuplicates then
        exit(False);
      InsertItem(sr.InsertIndex, aValue);
    end
  else
    InsertItem(ElemCount, aValue);
  Result := True;
end;

function TGBaseSortedList.DoInsert(constref aValue: T): SizeInt;
var
  sr: THelper.TSearchResult;
begin
  if ElemCount > 0 then
    begin
      sr := THelper.BinarySearchPos(FItems[0..Pred(ElemCount)], aValue);
      if (sr.FoundIndex > -1) and RejectDuplicates then
        exit(-1);
      Result := sr.InsertIndex;
    end
  else
    Result := 0;
  InsertItem(Result, aValue);
end;

function TGBaseSortedList.DoRemove(constref aValue: T): Boolean;
var
  Removed: SizeInt;
begin
  Removed := IndexOf(aValue);
  Result := Removed > -1;
  if Result then
    DeleteItem(Removed);
end;

function TGBaseSortedList.DoExtract(constref aValue: T): Boolean;
var
  Extracted: SizeInt;
begin
  Extracted := IndexOf(aValue);
  Result := Extracted > -1;
  if Result then
    ExtractItem(Extracted);
end;

function TGBaseSortedList.DoRemoveIf(aTest: TTest): SizeInt;
var
  I, J: SizeInt;
begin
  Result := ElemCount;
  if Result > 0 then
    begin
      J := 0;
      for I := 0 to Pred(Result) do
        begin
          if aTest(FItems[I]) then
            continue;
          if I > J then
            FItems[J] := FItems[I];
          Inc(J);
        end;
      FCount := J;
      for I := ElemCount to Pred(Result) do
        FItems[I] := Default(T);
      Result := Result - ElemCount;
    end;
end;

function TGBaseSortedList.DoRemoveIf(aTest: TOnTest): SizeInt;
var
  I, J: SizeInt;
begin
  Result := ElemCount;
  if Result > 0 then
    begin
      J := 0;
      for I := 0 to Pred(Result) do
        begin
          if aTest(FItems[I]) then
            continue;
          if I > J then
            FItems[J] := FItems[I];
          Inc(J);
        end;
      FCount := J;
      for I := ElemCount to Pred(Result) do
        FItems[I] := Default(T);
      Result := Result - ElemCount;
    end;
end;

function TGBaseSortedList.DoRemoveIf(aTest: TNestTest): SizeInt;
var
  I, J: SizeInt;
begin
  Result := ElemCount;
  if Result > 0 then
    begin
      J := 0;
      for I := 0 to Pred(Result) do
        begin
          if aTest(FItems[I]) then
            continue;
          if I > J then
            FItems[J] := FItems[I];
          Inc(J);
        end;
      FCount := J;
      for I := ElemCount to Pred(Result) do
        FItems[I] := Default(T);
      Result := Result - ElemCount;
    end;
end;

function TGBaseSortedList.DoExtractIf(aTest: TTest): TArray;
var
  h: TExtractHelper;
  I, J, OldCount: SizeInt;
begin
  if ElemCount = 0 then
    exit(nil);
  OldCount := ElemCount;
  h.Init;
  J := 0;
  for I := 0 to Pred(OldCount) do
    begin
      if aTest(FItems[I]) then
        begin
          h.Add(FItems[I]);
          continue;
        end;
      if I > J then
        FItems[J] := FItems[I];
      Inc(J);
    end;
  FCount := J;
  for I := ElemCount to Pred(OldCount) do
    FItems[I] := Default(T);
  Result := h.Final;
end;

function TGBaseSortedList.DoExtractIf(aTest: TOnTest): TArray;
var
  h: TExtractHelper;
  I, J, OldCount: SizeInt;
begin
  if ElemCount = 0 then
    exit(nil);
  OldCount := ElemCount;
  h.Init;
  J := 0;
  for I := 0 to Pred(OldCount) do
    begin
      if aTest(FItems[I]) then
        begin
          h.Add(FItems[I]);
          continue;
        end;
      if I > J then
        FItems[J] := FItems[I];
      Inc(J);
    end;
  FCount := J;
  for I := ElemCount to Pred(OldCount) do
    FItems[I] := Default(T);
  Result := h.Final;
end;

function TGBaseSortedList.DoExtractIf(aTest: TNestTest): TArray;
var
  h: TExtractHelper;
  I, J, OldCount: SizeInt;
begin
  if ElemCount = 0 then
    exit(nil);
  OldCount := ElemCount;
  h.Init;
  J := 0;
  for I := 0 to Pred(OldCount) do
    begin
      if aTest(FItems[I]) then
        begin
          h.Add(FItems[I]);
          continue;
        end;
      if I > J then
        FItems[J] := FItems[I];
      Inc(J);
    end;
  FCount := J;
  for I := ElemCount to Pred(OldCount) do
    FItems[I] := Default(T);
  Result := h.Final;
end;

function TGBaseSortedList.SelectDistinctArray(constref a: array of T): TArray;
var
  I, J, Hi: SizeInt;
begin
  Result := THelper.SelectDistinct(a);
  if ElemCount = 0 then
    exit;
  Hi := System.High(Result);
  I := -1;
  for J := 0 to Hi do
    begin
      if IndexOf(Result[J]) > -1 then
        continue;
      Inc(I);
      if J > I then
        Result[I] := Result[J];
    end;
  System.SetLength(Result, Succ(I));
end;

function TGBaseSortedList.DoAddAll(constref a: array of T): SizeInt;
var
  OldCount: SizeInt;
  PSrc: PItem;
  da: TArray;
begin
  OldCount := ElemCount;
  if RejectDuplicates then
    begin
      da := SelectDistinctArray(a);
      Result := System.Length(da);
      if Result = 0 then
        exit;
      PSrc := @da[0];
    end
  else
    begin
      Result := System.Length(a);
      if Result = 0 then
        exit;
      PSrc := @a[0];
    end;
  DoEnsureCapacity(OldCount + Result);
  THelper.CopyItems(PSrc, @FItems[OldCount], Result);
  FCount += Result;
  if RejectDuplicates or (OldCount >= Result) then
    THelper.MergeSort(FItems[0..Pred(ElemCount)])
  else
    THelper.Sort(FItems[0..Pred(ElemCount)])
end;

function TGBaseSortedList.DoAddAll(e: IEnumerable): SizeInt;
begin
  if (e._GetRef = Self) and RejectDuplicates then
    exit(0);
  Result := DoAddAll(e.ToArray);
end;

function TGBaseSortedList.IndexInRange(aIndex: SizeInt): Boolean;
begin
  Result := (aIndex >= 0) and (aIndex < ElemCount);
end;

procedure TGBaseSortedList.CheckIndexRange(aIndex: SizeInt);
begin
  if not IndexInRange(aIndex) then
   IndexOutOfBoundError(aIndex);
end;

function TGBaseSortedList.ListCapacity: SizeInt;
begin
  Result := System.Length(FItems);
end;

function TGBaseSortedList.GetReverse: IEnumerable;
begin
  Result := TReverseEnumerable.Create(Self);
end;

procedure TGBaseSortedList.Expand(aValue: SizeInt);
begin
  //there aValue > Capacity
  if aValue <= DEFAULT_CONTAINER_CAPACITY then
    System.SetLength(FItems, DEFAULT_CONTAINER_CAPACITY)
  else
    if aValue <= MAX_CAPACITY then
      begin
        aValue := Math.Min(MAX_CAPACITY, LGUtils.RoundUpTwoPower(aValue));
        System.SetLength(FItems, aValue);
      end
    else
      CapacityExceedError(aValue);
end;

procedure TGBaseSortedList.ItemAdding;
begin
  if ElemCount = ListCapacity then
    Expand(Succ(ElemCount));
end;

function TGBaseSortedList.ExtractItem(aIndex: SizeInt): T;
begin
  Result := FItems[aIndex];
  FItems[aIndex] := Default(T);
  Dec(FCount);
  System.Move(FItems[Succ(aIndex)], FItems[aIndex], SizeOf(T) * (ElemCount - aIndex));
  System.FillChar(FItems[ElemCount], SizeOf(T), 0);
end;

function TGBaseSortedList.DeleteItem(aIndex: SizeInt): T;
begin
  Result := ExtractItem(aIndex);
end;

function TGBaseSortedList.DoDeleteRange(aIndex, aCount: SizeInt): SizeInt;
var
  I: SizeInt;
begin
  if aCount < 0 then
    aCount := 0;
  Result := Math.Min(aCount, ElemCount - aIndex);
  if Result > 0 then
    begin
      for I := aIndex to Pred(aIndex + Result) do
        FItems[I] := Default(T);
      FCount -= Result;
      System.Move(FItems[aIndex + Result], FItems[aIndex], SizeOf(T) * (ElemCount - aIndex));
      System.FillChar(FItems[ElemCount], SizeOf(T) * Result, 0);
    end;
end;

function TGBaseSortedList.GetRecEnumerator: TRecEnumerator;
begin
  Result.Init(Self);
end;

function TGBaseSortedList.NearestLT(constref aValue: T): SizeInt;
begin
  if (ElemCount = 0) or (TCmpRel.Compare(aValue, FItems[0]) <= 0) then
    exit(-1);
  if TCmpRel.Compare(aValue, FItems[Pred(ElemCount)]) > 0 then
     exit(Pred(ElemCount));
  //here such element exist in FItems and not first nor last
  Result := THelper.BinarySearchPos(FItems[0..Pred(ElemCount)], aValue).InsertIndex;
  if TCmpRel.Compare(FItems[Result], aValue) >= 0 then
    repeat
      Dec(Result)
    until TCmpRel.Compare(FItems[Result], aValue) < 0
  else // < 0
    while TCmpRel.Compare(FItems[Succ(Result)], aValue) < 0 do
      Inc(Result);
end;

function TGBaseSortedList.RightmostLE(constref aValue: T): SizeInt;
begin
  if (ElemCount = 0) or (TCmpRel.Compare(aValue, FItems[0]) < 0) then
    exit(-1);
  if TCmpRel.Compare(aValue, FItems[Pred(ElemCount)]) >= 0 then
    exit(Pred(ElemCount));
  //here such element exist in FItems and not first nor last
  Result := THelper.BinarySearchPos(FItems[0..Pred(ElemCount)], aValue).InsertIndex;
  if TCmpRel.Compare(FItems[Result], aValue) > 0 then
    repeat
      Dec(Result)
    until TCmpRel.Compare(FItems[Result], aValue) <= 0
  else // <= 0
    while TCmpRel.Compare(FItems[Succ(Result)], aValue) <= 0 do
      Inc(Result);
end;

function TGBaseSortedList.NearestGT(constref aValue: T): SizeInt;
begin
  if (ElemCount = 0) or (TCmpRel.Compare(aValue, FItems[Pred(ElemCount)]) >= 0) then
    exit(-1);
  if TCmpRel.Compare(aValue, FItems[0]) < 0 then
    exit(0);
  //here such element exist in FItems and not first nor last
  Result := THelper.BinarySearchPos(FItems[0..Pred(ElemCount)], aValue).InsertIndex;
  if TCmpRel.Compare(FItems[Result], aValue) <= 0 then
    repeat
      Inc(Result)
    until TCmpRel.Compare(FItems[Result], aValue) > 0
  else // > 0
    while TCmpRel.Compare(FItems[Pred(Result)], aValue) > 0 do
      Dec(Result);
end;

function TGBaseSortedList.LeftmostGE(constref aValue: T): SizeInt;
begin
  if (ElemCount = 0) or (TCmpRel.Compare(aValue, FItems[Pred(ElemCount)]) > 0) then
    exit(-1);
  if TCmpRel.Compare(aValue, FItems[0]) <= 0 then
    exit(0);
  //here such element exist in FItems and not first nor last
  Result := THelper.BinarySearchPos(FItems[0..Pred(ElemCount)], aValue).InsertIndex;
  if TCmpRel.Compare(FItems[Result], aValue) < 0 then
    repeat
      Inc(Result)
    until TCmpRel.Compare(FItems[Result], aValue) >= 0
  else // >=
    while TCmpRel.Compare(FItems[Pred(Result)], aValue) >= 0 do
      Dec(Result);
end;

constructor TGBaseSortedList.CreateEmpty;
begin
  inherited Create;
end;

constructor TGBaseSortedList.Create;
begin
  System.SetLength(FItems, DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGBaseSortedList.Create(aCapacity: SizeInt);
begin
  if aCapacity <= MAX_CAPACITY then
    begin
      if aCapacity < 0 then
        aCapacity := 0;
      System.SetLength(FItems, aCapacity);
    end
  else
    CapacityExceedError(aCapacity);
end;

constructor TGBaseSortedList.Create(constref a: array of T);
begin
  FItems := THelper.CreateCopy(a);
  FCount := ListCapacity;
  if ElemCount > 0 then
    THelper.Sort(FItems);
end;

constructor TGBaseSortedList.Create(e: IEnumerable);
begin
  FItems := e.ToArray;
  FCount := ListCapacity;
  if ElemCount > 0 then
    THelper.Sort(FItems);
end;

constructor TGBaseSortedList.Create(aRejectDuplicates: Boolean);
begin
  Create;
  FRejectDuplicates := aRejectDuplicates;
end;

constructor TGBaseSortedList.Create(constref a: array of T; aRejectDuplicates: Boolean);
begin
  FRejectDuplicates := aRejectDuplicates;
  if RejectDuplicates then
    begin
      FItems := THelper.SelectDistinct(a);
      FCount := ListCapacity;
    end
  else
    Create(a);
end;

constructor TGBaseSortedList.Create(e: IEnumerable; aRejectDuplicates: Boolean);
begin
  FRejectDuplicates := aRejectDuplicates;
  if RejectDuplicates then
    begin
      FItems := THelper.SelectDistinct(e.ToArray);
      FCount := ListCapacity;
    end
  else
    Create(e);
end;

destructor TGBaseSortedList.Destroy;
begin
  DoClear;
  inherited;
end;

function TGBaseSortedList.Reverse: IEnumerable;
begin
  BeginIteration;
  Result := GetReverse;
end;

function TGBaseSortedList.ToArray: TArray;
begin
  Result := System.Copy(FItems, 0, ElemCount);
end;

function TGBaseSortedList.FindMin(out aValue: T): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aValue := FItems[0];
end;

function TGBaseSortedList.FindMax(out aValue: T): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aValue := FItems[Pred(ElemCount)];
end;

function TGBaseSortedList.Insert(constref aValue: T): SizeInt;
begin
  CheckInIteration;
  Result := DoInsert(aValue);
end;

function TGBaseSortedList.Contains(constref aValue: T): Boolean;
begin
  Result := IndexOf(aValue) >= 0;
end;

function TGBaseSortedList.NonContains(constref aValue: T): Boolean;
begin
  Result := IndexOf(aValue) < 0;
end;

procedure TGBaseSortedList.Delete(aIndex: SizeInt);
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  DeleteItem(aIndex);
end;

function TGBaseSortedList.TryDelete(aIndex: SizeInt): Boolean;
begin
  Result := not InIteration and IndexInRange(aIndex);
  if Result then
    DeleteItem(aIndex);
end;

function TGBaseSortedList.DeleteAll(aIndex, aCount: SizeInt): SizeInt;
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  Result := DoDeleteRange(aIndex, aCount);
end;

function TGBaseSortedList.IndexOf(constref aValue: T): SizeInt;
begin
  if ElemCount > 0 then
    Result := THelper.BinarySearch(FItems[0..Pred(ElemCount)], aValue)
  else
    Result := -1;
end;

function TGBaseSortedList.FirstIndexOf(constref aValue: T): SizeInt;
begin
  if ElemCount = 0 then
    exit(-1);
  Result := THelper.BinarySearch(FItems[0..Pred(ElemCount)], aValue);
  while (Result > 0) and (TCmpRel.Compare(aValue, FItems[Pred(Result)]) = 0) do
    Dec(Result);
end;

function TGBaseSortedList.CountOf(constref aValue: T): SizeInt;
var
  LastIdx, FirstIdx: SizeInt;
begin
  if ElemCount = 0 then
    exit(0);
  LastIdx := THelper.BinarySearch(FItems[0..Pred(ElemCount)], aValue);
  if LastIdx < 0 then
    exit(0);
  FirstIdx := LastIdx;
  while (FirstIdx > 0) and (TCmpRel.Compare(aValue, FItems[Pred(FirstIdx)]) = 0) do
    Dec(FirstIdx);
  while (LastIdx < Pred(ElemCount)) and (TCmpRel.Compare(aValue, FItems[Succ(LastIdx)]) = 0) do
    Inc(LastIdx);
  Result := Succ(LastIdx - FirstIdx);
end;

function TGBaseSortedList.IndexOfCeil(constref aValue: T; aInclusive: Boolean): SizeInt;
begin
  if aInclusive then
    Result := LeftmostGE(aValue)
  else
    Result := NearestGT(aValue);
end;

function TGBaseSortedList.IndexOfFloor(constref aValue: T; aInclusive: Boolean): SizeInt;
begin
  if aInclusive then
    Result := RightmostLE(aValue)
  else
    Result := NearestLT(aValue);
end;

function TGBaseSortedList.Head(constref aHighBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := THeadEnumerable.Create(Self, IndexOfFloor(aHighBound, aInclusive));
end;

function TGBaseSortedList.Tail(constref aLowBound: T; aInclusive: Boolean): IEnumerable;
var
  StartIdx: SizeInt;
begin
  StartIdx := IndexOfCeil(ALowBound, aInclusive);
  if StartIdx < 0 then
    StartIdx := ElemCount;
  BeginIteration;
  Result := TTailEnumerable.Create(Self, StartIdx);
end;

function TGBaseSortedList.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): IEnumerable;
var
  StartIdx: SizeInt;
begin
  StartIdx := IndexOfCeil(ALowBound, rbLow in aIncludeBounds);
  if StartIdx < 0 then
    StartIdx := ElemCount;
  BeginIteration;
  Result := TRangeEnumerable.Create(Self, StartIdx, IndexOfFloor(aHighBound, rbHigh in aIncludeBounds));
end;

function TGBaseSortedList.HeadList(constref aHighBound: T; aInclusive: Boolean): TSortedList;
var
  HeadCount: SizeInt;
begin
  HeadCount := Succ(IndexOfFloor(aHighBound, aInclusive));
  if HeadCount = 0 then
    exit(TSortedList.Create(RejectDuplicates));
  Result := TSortedList.Create(HeadCount);
  Result.RejectDuplicates := RejectDuplicates;
  Result.FCount := HeadCount;
  THelper.CopyItems(@FItems[0], @Result.FItems[0], HeadCount);
end;

function TGBaseSortedList.TailList(constref aLowBound: T; aInclusive: Boolean): TSortedList;
var
  StartIdx: SizeInt;
begin
  StartIdx := IndexOfCeil(ALowBound, aInclusive);
  if StartIdx < 0 then
    exit(TSortedList.Create(RejectDuplicates));
  Result := TSortedList.Create(ElemCount - StartIdx);
  Result.RejectDuplicates := RejectDuplicates;
  Result.FCount := ElemCount - StartIdx;
  THelper.CopyItems(@FItems[StartIdx], @Result.FItems[0], ElemCount - StartIdx);
end;

function TGBaseSortedList.SubList(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): TSortedList;
var
  StartIdx, LastIdx, RangeCount: SizeInt;
begin
  StartIdx := IndexOfCeil(ALowBound, rbLow in aIncludeBounds);
  if StartIdx < 0 then
    exit(TSortedList.Create(RejectDuplicates));
  LastIdx := IndexOfFloor(aHighBound, rbHigh in aIncludeBounds);
  if LastIdx < StartIdx then
    exit(TSortedList.CreateEmpty);
  RangeCount := Succ(LastIdx - StartIdx);
  Result := TSortedList.Create(RangeCount);
  Result.RejectDuplicates := RejectDuplicates;
  Result.FCount := RangeCount;
  THelper.CopyItems(@FItems[StartIdx], @Result.FItems[0], RangeCount);
end;

function TGBaseSortedList.Clone: TSortedList;
begin
  Result := TSortedList.CreateEmpty;
  //Result.FItems := System.Copy(FItems, 0, ListCapacity);
  Result.FItems := ToArray; ///////////////
  Result.FCount := ElemCount;
  Result.FRejectDuplicates := RejectDuplicates;
end;

{ TGObjectSortedList }

procedure TGObjectSortedList.DoClear;
var
  I: SizeInt;
begin
  if OwnsObjects then
    for I := 0 to Pred(ElemCount) do
      FItems[I].Free;
  inherited;
end;

procedure TGObjectSortedList.DoSetItem(aIndex: SizeInt; const aValue: T);
var
  sr: THelper.TSearchResult;
  c: SizeInt;
begin
  c := TCmpRel.Compare(aValue, FItems[aIndex]);
  if c <> 0 then
    begin
      CheckInIteration;
      if ElemCount > 1 then
        begin
          sr := THelper.BinarySearchPos(Self.FItems[0..Pred(ElemCount)], aValue);
          if (sr.FoundIndex > -1) and RejectDuplicates then
            exit;
          if OwnsObjects then
            FItems[aIndex].Free;
          if sr.InsertIndex > aIndex then
            System.Move(FItems[Succ(aIndex)], FItems[aIndex], sr.InsertIndex - aIndex)
          else
            System.Move(FItems[sr.InsertIndex], FItems[Succ(sr.InsertIndex)], aIndex - sr.InsertIndex);
          //System.FillChar(FItems[sr.InsertIndex], SizeOf(T), 0);
          FItems[sr.InsertIndex] := aValue;
        end;
    end;
end;

function TGObjectSortedList.DoRemove(constref aValue: T): Boolean;
begin
  Result := inherited DoRemove(aValue);
  if Result and OwnsObjects then
    aValue.Free;
end;

function TGObjectSortedList.DoRemoveIf(aTest: TTest): SizeInt;
var
  I, J: SizeInt;
begin
  Result := ElemCount;
  if Result > 0 then
    begin
      J := 0;
      for I := 0 to Pred(Result) do
        begin
          if aTest(FItems[I]) then
            continue;
          if I > J then
            begin
              if OwnsObjects then
                FItems[J].Free;
              FItems[J] := FItems[I];
            end;
          Inc(J);
        end;
      FCount := J;
      if OwnsObjects then
        for I := ElemCount to Pred(Result) do
          FItems[I].Free;
      Result := Result - ElemCount;
    end;
end;

function TGObjectSortedList.DoRemoveIf(aTest: TOnTest): SizeInt;
var
  I, J: SizeInt;
begin
  Result := ElemCount;
  if Result > 0 then
    begin
      J := 0;
      for I := 0 to Pred(Result) do
        begin
          if aTest(FItems[I]) then
            continue;
          if I > J then
            begin
              if OwnsObjects then
                FItems[J].Free;
              FItems[J] := FItems[I];
            end;
          Inc(J);
        end;
      FCount := J;
      if OwnsObjects then
        for I := ElemCount to Pred(Result) do
          FItems[I].Free;
      Result := Result - ElemCount;
    end;
end;

function TGObjectSortedList.DoRemoveIf(aTest: TNestTest): SizeInt;
var
  I, J: SizeInt;
begin
  Result := ElemCount;
  if Result > 0 then
    begin
      J := 0;
      for I := 0 to Pred(Result) do
        begin
          if aTest(FItems[I]) then
            continue;
          if I > J then
            begin
              if OwnsObjects then
                FItems[J].Free;
              FItems[J] := FItems[I];
            end;
          Inc(J);
        end;
      FCount := J;
      if OwnsObjects then
        for I := ElemCount to Pred(Result) do
          FItems[I].Free;
      Result := Result - ElemCount;
    end;
end;

function TGObjectSortedList.DeleteItem(aIndex: SizeInt): T;
begin
  Result := inherited DeleteItem(aIndex);
  if OwnsObjects then
    Result.Free;
end;

function TGObjectSortedList.DoDeleteRange(aIndex, aCount: SizeInt): SizeInt;
var
  I: SizeInt;
begin
  if aCount < 0 then
    aCount := 0;
  Result := Math.Min(aCount, ElemCount - aIndex);
  if Result > 0 then
    begin
      if OwnsObjects then
        for I := aIndex to Pred(aIndex + Result) do
          FItems[I].Free;
      FCount -= Result;
      System.Move(FItems[aIndex + Result], FItems[aIndex], SizeOf(T) * (ElemCount - aIndex));
      //System.FillChar(FItems[ElemCount], SizeOf(T) * Result, 0);
    end;
end;

constructor TGObjectSortedList.CreateEmpty(aOwnsObjects: Boolean);
begin
  inherited CreateEmpty;
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectSortedList.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectSortedList.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectSortedList.Create(constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(a);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectSortedList.Create(e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(e);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectSortedList.Create(aRejectDuplicates: Boolean; aOwnsObjects: Boolean);
begin
  inherited Create(aRejectDuplicates);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectSortedList.Create(constref a: array of T; aRejectDuplicates: Boolean; aOwnsObjects: Boolean);
begin
  inherited Create(a, aRejectDuplicates);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectSortedList.Create(e: IEnumerable; aRejectDuplicates: Boolean; aOwnsObjects: Boolean);
begin
  inherited Create(e, aRejectDuplicates);
  OwnsObjects := aOwnsObjects;
end;

function TGObjectSortedList.Clone: TObjectSortedList;
begin
  Result := TObjectSortedList.CreateEmpty(OwnsObjects);
  //Result.FItems := System.Copy(FItems, 0, ListCapacity);
  Result.FItems := ToArray; ///////////////
  Result.FCount := ElemCount;
  Result.FRejectDuplicates := RejectDuplicates;
end;

{ TGSortedList2.TEnumerator }

function TGSortedList2.TEnumerator.GetCurrent: T;
begin
  Result := FList[FCurrIndex];
end;

procedure TGSortedList2.TEnumerator.Init(aList: TGSortedList2);
begin
  FList := aList.FItems;
  FLastIndex := Pred(aList.Count);
  FCurrIndex := -1;
end;

function TGSortedList2.TEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLastIndex;
  FCurrIndex += Ord(Result);
end;

procedure TGSortedList2.TEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGSortedList2 }

function TGSortedList2.GetCapacity: SizeInt;
begin
  Result := System.Length(FItems);
end;

procedure TGSortedList2.Expand(aValue: SizeInt);
begin
  //there aValue > Capacity
  if aValue <= DEFAULT_CONTAINER_CAPACITY then
    System.SetLength(FItems, DEFAULT_CONTAINER_CAPACITY)
  else
    if aValue <= MAX_CAPACITY then
      begin
        aValue := Math.Min(MAX_CAPACITY, LGUtils.RoundUpTwoPower(aValue));
        System.SetLength(FItems, aValue);
      end
    else
      CapacityExceedError(aValue);
end;

procedure TGSortedList2.ItemAdding;
begin
  if Count = Capacity then
    Expand(Succ(Count));
end;

procedure TGSortedList2.InsertItem(aIndex: SizeInt; constref aValue: T);
begin
  ItemAdding;
  if aIndex < Count then
    begin
      System.Move(FItems[aIndex], FItems[Succ(aIndex)], SizeOf(T) * (Count - aIndex));
      System.FillChar(FItems[aIndex], SizeOf(T), 0);
    end;
  FItems[aIndex] := aValue;
  Inc(FCount);
end;

procedure TGSortedList2.RemoveItem(aIndex: SizeInt);
begin
  FItems[aIndex] := Default(T);
  Dec(FCount);
  System.Move(FItems[Succ(aIndex)], FItems[aIndex], SizeOf(T) * (Count - aIndex));
  System.FillChar(FItems[Count], SizeOf(T), 0);
end;

procedure TGSortedList2.CapacityExceedError(aValue: SizeInt);
begin
  raise ELGCapacityExceed.CreateFmt(SEClassCapacityExceedFmt, [ClassName, aValue]);
end;

constructor TGSortedList2.CreateEmpty;
begin
  inherited Create;
end;

constructor TGSortedList2.CreateEmpty(aAllowDuplicates: Boolean);
begin
  inherited Create;
  FAllowDuplicates := aAllowDuplicates;
end;

constructor TGSortedList2.Create;
begin
  System.SetLength(FItems, DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGSortedList2.Create(aCapacity: SizeInt);
begin
  if aCapacity <= MAX_CAPACITY then
    begin
      if aCapacity < 0 then
        aCapacity := 0;
      System.SetLength(FItems, aCapacity);
    end
  else
    CapacityExceedError(aCapacity);
end;

constructor TGSortedList2.Create(aCapacity: SizeInt; AllowDuplicates: Boolean);
begin
  Create(aCapacity);
  FAllowDuplicates := AllowDuplicates;
end;

destructor TGSortedList2.Destroy;
begin
  Clear;
  inherited;
end;

function TGSortedList2.GetEnumerator: TEnumerator;
begin
  Result.Init(Self);
end;

procedure TGSortedList2.Clear;
begin
  FItems := nil;
  FCount := 0;
end;

function TGSortedList2.EnsureCapacity(aValue: SizeInt): Boolean;
begin
  try
    if aValue > Capacity then
      Expand(aValue);
    Result := True;
  except
    Result := False;
  end;
end;

procedure TGSortedList2.TrimToFit;
begin
  System.SetLength(FItems, Count);
end;

function TGSortedList2.Add(constref aValue: T): Boolean;
var
  sr: THelper.TSearchResult;
begin
  if Count > 0 then
    begin
      sr := THelper.BinarySearchPos(FItems[0..Pred(Count)], aValue);
      if (sr.FoundIndex >= 0) and not AllowDuplicates then
        exit(False);
      InsertItem(sr.InsertIndex, aValue);
    end
  else
    InsertItem(Count, aValue);
  Result := True;
end;

function TGSortedList2.Contains(constref aValue: T): Boolean;
begin
  if Count > 0 then
    Result := THelper.BinarySearch(FItems[0..Pred(Count)], aValue) >= 0
  else
    Result := False;
end;

function TGSortedList2.Remove(constref aValue: T): Boolean;
var
  RemoveIdx: SizeInt;
begin
  if Count > 0 then
    begin
      RemoveIdx := THelper.BinarySearch(FItems[0..Pred(Count)], aValue);
      Result := RemoveIdx >= 0;
      if Result then
        RemoveItem(RemoveIdx);
    end
  else
    Result := False;
end;

{ TGSortedListTable.TEntryCmpRel }

class function TGSortedListTable.TEntryCmpRel.Compare(constref L, R: TEntry): SizeInt;
begin
  Result := TCmpRel.Compare(L.Key, R.Key);
end;

{ TGSortedListTable.TEnumerator }

function TGSortedListTable.TEnumerator.GetCurrent: PEntry;
begin
  Result := @FList[FCurrIndex];
end;

procedure TGSortedListTable.TEnumerator.Init(aTable: TGSortedListTable);
begin
  FList := aTable.FItems;
  FLastIndex := Pred(aTable.Count);
  FCurrIndex := -1;
end;

function TGSortedListTable.TEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLastIndex;
  FCurrIndex += Ord(Result);
end;

procedure TGSortedListTable.TEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGSortedListTable }

function TGSortedListTable.GetCapacity: SizeInt;
begin
  Result := System.Length(FItems);
end;

procedure TGSortedListTable.Expand(aValue: SizeInt);
begin
  //there aValue > Capacity
  if aValue <= DEFAULT_CONTAINER_CAPACITY then
    System.SetLength(FItems, DEFAULT_CONTAINER_CAPACITY)
  else
    if aValue <= MAX_CAPACITY then
      begin
        aValue := Math.Min(MAX_CAPACITY, LGUtils.RoundUpTwoPower(aValue));
        System.SetLength(FItems, aValue);
      end
    else
      CapacityExceedError(aValue);
end;

procedure TGSortedListTable.ItemAdding;
begin
  if Count = Capacity then
    Expand(Succ(Count));
end;

procedure TGSortedListTable.InsertItem(aIndex: SizeInt; constref aValue: TEntry);
begin
  ItemAdding;
  if aIndex < Count then
    begin
      System.Move(FItems[aIndex], FItems[Succ(aIndex)], SizeOf(TEntry) * (Count - aIndex));
      System.FillChar(FItems[aIndex], SizeOf(TEntry), 0);
    end;
  FItems[aIndex] := aValue;
  Inc(FCount);
end;

procedure TGSortedListTable.RemoveItem(aIndex: SizeInt);
begin
  FItems[aIndex] := Default(TEntry);
  Dec(FCount);
  System.Move(FItems[Succ(aIndex)], FItems[aIndex], SizeOf(TEntry) * (Count - aIndex));
  System.FillChar(FItems[Count], SizeOf(TEntry), 0);
end;

procedure TGSortedListTable.CapacityExceedError(aValue: SizeInt);
begin
  raise ELGCapacityExceed.CreateFmt(SEClassCapacityExceedFmt, [ClassName, aValue]);
end;

constructor TGSortedListTable.CreateEmpty;
begin
  inherited Create;
end;

constructor TGSortedListTable.CreateEmpty(AllowDuplicates: Boolean);
begin
  inherited Create;
  FAllowDuplicates := AllowDuplicates;
end;

constructor TGSortedListTable.Create;
begin
  System.SetLength(FItems, DEFAULT_CONTAINER_CAPACITY);
end;

constructor TGSortedListTable.Create(aCapacity: SizeInt);
begin
  if aCapacity <= MAX_CAPACITY then
    begin
      if aCapacity < 0 then
        aCapacity := 0;
      System.SetLength(FItems, aCapacity);
    end
  else
    CapacityExceedError(aCapacity);
end;

constructor TGSortedListTable.Create(aCapacity: SizeInt; AllowDuplicates: Boolean);
begin
  Create(aCapacity);
  FAllowDuplicates := AllowDuplicates;
end;

destructor TGSortedListTable.Destroy;
begin
  Clear;
  inherited;
end;

function TGSortedListTable.GetEnumerator: TEnumerator;
begin
  Result.Init(Self);
end;

procedure TGSortedListTable.Clear;
begin
  FItems := nil;
  FCount := 0;
end;

function TGSortedListTable.EnsureCapacity(aValue: SizeInt): Boolean;
begin
  try
    if aValue > Capacity then
      Expand(aValue);
    Result := True;
  except
    Result := False;
  end;
end;

procedure TGSortedListTable.TrimToFit;
begin
  System.SetLength(FItems, Count);
end;

function TGSortedListTable.FindOrAdd(constref aKey: TKey; out e: PEntry; out aPos: SizeInt): Boolean;
var
  sr: specialize TGBaseArrayHelper<TEntry, TEntryCmpRel>.TSearchResult;
  Entry: TEntry;
begin
  Entry.Key := aKey;
  if Count > 0 then
    begin
      sr := specialize TGBaseArrayHelper<TEntry, TEntryCmpRel>.BinarySearchPos(FItems[0..Pred(Count)], Entry);
      Result := sr.FoundIndex >= 0;
      if Result then
        aPos := sr.FoundIndex
      else
        begin
          aPos := sr.InsertIndex;
          InsertItem(aPos, Entry);
        end;
    end
  else
    begin
      Result := False;
      aPos := 0;
      InsertItem(aPos, Entry);
    end;
  e := @FItems[aPos];
end;

function TGSortedListTable.Find(constref aKey: TKey; out aPos: SizeInt): PEntry;
var
  e: TEntry;
begin
  e.Key := aKey;
  Result := nil;
  if Count > 0 then
    begin
      aPos := specialize TGBaseArrayHelper<TEntry, TEntryCmpRel>.BinarySearch(FItems[0..Pred(Count)], e);
      if aPos >= 0 then
        Result := @FItems[aPos];
    end;
end;

function TGSortedListTable.Add(constref aKey: TKey): PEntry;
var
  sr: specialize TGBaseArrayHelper<TEntry, TEntryCmpRel>.TSearchResult;
  Entry: TEntry;
begin
  Result := nil;
  Entry.Key := aKey;
  if Count > 0 then
    begin
      sr := specialize TGBaseArrayHelper<TEntry, TEntryCmpRel>.BinarySearchPos(FItems[0..Pred(Count)], Entry);
      if (sr.FoundIndex < 0) or AllowDuplicates then
        begin
          InsertItem(sr.InsertIndex, Entry);
          Result := @FItems[sr.InsertIndex];
        end;
    end
  else
    begin
      InsertItem(0, Entry);
      Result := @FItems[0];
    end;
end;

function TGSortedListTable.Remove(constref aKey: TKey): Boolean;
var
  e: TEntry;
  RemoveIdx: SizeInt;
begin
  e.Key := aKey;
  RemoveIdx := specialize TGBaseArrayHelper<TEntry, TEntryCmpRel>.BinarySearch(FItems[0..Pred(Count)], e);
  Result := RemoveIdx >= 0;
  if Result then
    RemoveItem(RemoveIdx);
end;

procedure TGSortedListTable.RemoveAt(constref aPos: SizeInt);
begin
  if (aPos >= 0) and (aPos < Count) then
    RemoveItem(aPos);
end;

{ TGLiteSortedList.THeadEnumerator }

function TGLiteSortedList.THeadEnumerator.GetCurrent: T;
begin
  Result := FItems[FCurrIndex];
end;

procedure TGLiteSortedList.THeadEnumerator.Init(constref aList: TGLiteSortedList; aLastIndex: SizeInt);
begin
  FItems := aList.FBuffer.FItems;
  FLast := aLastIndex;
  FCurrIndex := -1;
end;

function TGLiteSortedList.THeadEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLast;
  FCurrIndex += Ord(Result);
end;

procedure TGLiteSortedList.THeadEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGLiteSortedList.THead }

procedure TGLiteSortedList.THead.Init(aList: PLiteSortedList; aHighBound: SizeInt);
begin
  FList := aList;
  FHighBound := aHighBound;
end;

function TGLiteSortedList.THead.GetEnumerator: THeadEnumerator;
begin
  Result := FList^.GetHeadEnumerator(FHighBound);
end;

{ TGLiteSortedList.TTailEnumerator }

function TGLiteSortedList.TTailEnumerator.GetCurrent: T;
begin
  Result := FItems[FCurrIndex];
end;

procedure TGLiteSortedList.TTailEnumerator.Init(constref aList: TGLiteSortedList; aStartIndex: SizeInt);
begin
  FItems := aList.FBuffer.FItems;
  FLast := Pred(aList.Count);
  FStart := Pred(aStartIndex);
  FCurrIndex := FStart;
end;

procedure TGLiteSortedList.TTailEnumerator.Init(constref aList: TGLiteSortedList; aStartIndex,
  aLastIndex: SizeInt);
begin
  FItems := aList.FBuffer.FItems;
  FLast := aLastIndex;
  FStart := Pred(aStartIndex);
  FCurrIndex := FStart;
end;

function TGLiteSortedList.TTailEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLast;
  FCurrIndex += Ord(Result);
end;

procedure TGLiteSortedList.TTailEnumerator.Reset;
begin
  FCurrIndex := FStart;
end;

{ TGLiteSortedList.TTail }

procedure TGLiteSortedList.TTail.Init(aList: PLiteSortedList; aLowBound: SizeInt);
begin
  FList := aList;
  FLowBound := aLowBound;
end;

function TGLiteSortedList.TTail.GetEnumerator: TTailEnumerator;
begin
  Result := FList^.GetTailEnumerator(FLowBound);
end;

{ TGLiteSortedList.TRange }

procedure TGLiteSortedList.TRange.Init(aList: PLiteSortedList; aLowBound, aHighBound: SizeInt);
begin
  FList := aList;
  FLowBound := aLowBound;
  FHighBound := aHighBound;
end;

function TGLiteSortedList.TRange.GetEnumerator: TTailEnumerator;
begin
  Result := FList^.GetRangeEnumerator(FLowBound, FHighBound);
end;

{ TGLiteSortedList }

function TGLiteSortedList.GetCapacity: SizeInt;
begin
  Result := FBuffer.Capacity;
end;

function TGLiteSortedList.GetItem(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := FBuffer.FItems[aIndex];
end;

procedure TGLiteSortedList.SetItem(aIndex: SizeInt; aValue: T);
begin
  CheckIndexRange(aIndex);
  DoSetItem(aIndex, aValue);
end;

procedure TGLiteSortedList.DoSetItem(aIndex: SizeInt; const aValue: T);
var
  sr: THelper.TSearchResult;
  c: SizeInt;
begin
  c := TCmpRel.Compare(aValue, FBuffer.FItems[aIndex]);
  if c <> 0 then
    begin
      if Count > 1 then
        begin
          sr := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue);
          if (sr.FoundIndex >= 0) and RejectDuplicates then
            exit;
          FBuffer.FItems[aIndex] := Default(T);  ///////////////
          if sr.InsertIndex > aIndex then
            System.Move(FBuffer.FItems[Succ(aIndex)], FBuffer.FItems[aIndex], sr.InsertIndex - aIndex)
          else
            System.Move(FBuffer.FItems[sr.InsertIndex], FBuffer.FItems[Succ(sr.InsertIndex)], aIndex - sr.InsertIndex);
          System.FillChar(FBuffer.FItems[sr.InsertIndex], SizeOf(T), 0);
          FBuffer.FItems[sr.InsertIndex] := aValue;
        end;
    end;
end;

procedure TGLiteSortedList.InsertItem(aIndex: SizeInt; constref aValue: T);
begin
  FBuffer.ItemAdding;
  if aIndex < Count then
    begin
      System.Move(FBuffer.FItems[aIndex], FBuffer.FItems[Succ(aIndex)], SizeOf(T) * (Count - aIndex));
      System.FillChar(FBuffer.FItems[aIndex], SizeOf(T), 0);
    end;
  FBuffer.FItems[aIndex] := aValue;
  Inc(FBuffer.FCount);
end;

function TGLiteSortedList.ExtractItem(aIndex: SizeInt): T;
begin
  Result := FBuffer.FItems[aIndex];
  FBuffer.FItems[aIndex] := Default(T);
  Dec(FBuffer.FCount);
  System.Move(FBuffer.FItems[Succ(aIndex)], FBuffer.FItems[aIndex], SizeOf(T) * (Count - aIndex));
  System.FillChar(FBuffer.FItems[Count], SizeOf(T), 0);
end;

function TGLiteSortedList.DeleteItem(aIndex: SizeInt): T;
begin
  Result := ExtractItem(aIndex);
end;

procedure TGLiteSortedList.RemoveDuplicates;
var
  I, J, Hi: SizeInt;
begin
  Hi := Pred(Count);
  if Hi < 1 then
    exit;
  I := 0;
  for J := 1 to Hi do
    begin
      if TCmpRel.Compare(FBuffer.FItems[I], FBuffer.FItems[J]) = 0 then
        continue;
      Inc(I);
      if J > I then
        FBuffer.FItems[I] := FBuffer.FItems[J];
    end;
  FBuffer.FCount := Succ(I);
  for I := Count to Hi do
    FBuffer.FItems[I] := Default(T);
end;

procedure TGLiteSortedList.SetRejectDuplicates(aValue: Boolean);
begin
  if RejectDuplicates <> aValue then
    begin
      FRejectDuplicates := aValue;
      if RejectDuplicates then
        RemoveDuplicates;
    end;
end;

function TGLiteSortedList.NearestLT(constref aValue: T): SizeInt;
begin
  if IsEmpty or (TCmpRel.Compare(aValue, FBuffer.FItems[0]) <= 0) then
    exit(-1);
  if TCmpRel.Compare(aValue, FBuffer.FItems[Pred(Count)]) > 0 then
     exit(Pred(Count));
  //here such element exist in FBuffer.FItems and not first nor last
  Result := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue).InsertIndex;
  if TCmpRel.Compare(FBuffer.FItems[Result], aValue) >= 0 then
    repeat
      Dec(Result)
    until TCmpRel.Compare(FBuffer.FItems[Result], aValue) < 0
  else // < 0
    while TCmpRel.Compare(FBuffer.FItems[Succ(Result)], aValue) < 0 do
      Inc(Result);
end;

function TGLiteSortedList.RightmostLE(constref aValue: T): SizeInt;
begin
  if IsEmpty or (TCmpRel.Compare(aValue, FBuffer.FItems[0]) < 0) then
    exit(-1);
  if TCmpRel.Compare(aValue, FBuffer.FItems[Pred(Count)]) >= 0 then
    exit(Pred(Count));
  //here such element exist in FBuffer.FItems and not first nor last
  Result := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue).InsertIndex;
  if TCmpRel.Compare(FBuffer.FItems[Result], aValue) > 0 then
    repeat
      Dec(Result)
    until TCmpRel.Compare(FBuffer.FItems[Result], aValue) <= 0
  else // <= 0
    while TCmpRel.Compare(FBuffer.FItems[Succ(Result)], aValue) <= 0 do
      Inc(Result);
end;

function TGLiteSortedList.NearestGT(constref aValue: T): SizeInt;
begin
  if IsEmpty or (TCmpRel.Compare(aValue, FBuffer.FItems[Pred(Count)]) >= 0) then
    exit(-1);
  if TCmpRel.Compare(aValue, FBuffer.FItems[0]) < 0 then
    exit(0);
  //here such element exist in FBuffer.FItems and not first nor last
  Result := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue).InsertIndex;
  if TCmpRel.Compare(FBuffer.FItems[Result], aValue) <= 0 then
    repeat
      Inc(Result)
    until TCmpRel.Compare(FBuffer.FItems[Result], aValue) > 0
  else // > 0
    while TCmpRel.Compare(FBuffer.FItems[Pred(Result)], aValue) > 0 do
      Dec(Result);
end;

function TGLiteSortedList.LeftmostGE(constref aValue: T): SizeInt;
begin
  if IsEmpty or (TCmpRel.Compare(aValue, FBuffer.FItems[Pred(Count)]) > 0) then
    exit(-1);
  if TCmpRel.Compare(aValue, FBuffer.FItems[0]) <= 0 then
    exit(0);
  //here such element exist in FBuffer.FItems and not first nor last
  Result := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue).InsertIndex;
  if TCmpRel.Compare(FBuffer.FItems[Result], aValue) < 0 then
    repeat
      Inc(Result)
    until TCmpRel.Compare(FBuffer.FItems[Result], aValue) >= 0
  else
    while TCmpRel.Compare(FBuffer.FItems[Pred(Result)], aValue) >= 0 do
      Dec(Result);
end;

function TGLiteSortedList.SelectDistinctArray(constref a: array of T): TArray;
var
  I, J, Hi: SizeInt;
begin
  Result := THelper.SelectDistinct(a);
  if IsEmpty then
    exit;
  Hi := System.High(Result);
  I := -1;
  for J := 0 to Hi do
    begin
      if IndexOf(Result[J]) > -1 then
        continue;
      Inc(I);
      if J > I then
        Result[I] := Result[J];
    end;
  System.SetLength(Result, Succ(I));
end;

function TGLiteSortedList.IndexInRange(aIndex: SizeInt): Boolean;
begin
  Result := (aIndex >= 0) and (aIndex < Count);
end;

procedure TGLiteSortedList.CheckIndexRange(aIndex: SizeInt);
begin
  if not IndexInRange(aIndex) then
    IndexOutOfBoundError(aIndex);
end;

procedure TGLiteSortedList.IndexOutOfBoundError(aIndex: SizeInt);
begin
  raise ELGListError.CreateFmt(SEIndexOutOfBoundsFmt, [aIndex]);
end;

function TGLiteSortedList.GetHeadEnumerator(aHighBound: SizeInt): THeadEnumerator;
begin
  Result.Init(Self, aHighBound);
end;

function TGLiteSortedList.GetTailEnumerator(aLowBound: SizeInt): TTailEnumerator;
begin
  Result.Init(Self, aLowBound);
end;

function TGLiteSortedList.GetRangeEnumerator(aLowBound, aHighBound: SizeInt): TTailEnumerator;
begin
  Result.Init(Self, aLowBound, aHighBound);
end;

function TGLiteSortedList.GetEnumerator: TEnumerator;
begin
  Result := FBuffer.GetEnumerator;
end;

function TGLiteSortedList.Reverse: TReverse;
begin
  Result := FBuffer.Reverse;
end;

function TGLiteSortedList.ToArray: TArray;
begin
  Result := FBuffer.ToArray;
end;

procedure TGLiteSortedList.Clear;
begin
  FBuffer.Clear;
end;

function TGLiteSortedList.IsEmpty: Boolean;
begin
  Result := FBuffer.Count = 0;
end;

function TGLiteSortedList.NonEmpty: Boolean;
begin
  Result := FBuffer.Count <> 0;
end;

procedure TGLiteSortedList.EnsureCapacity(aValue: SizeInt);
begin
  FBuffer.EnsureCapacity(aValue);
end;

procedure TGLiteSortedList.TrimToFit;
begin
  FBuffer.TrimToFit;
end;

function TGLiteSortedList.FindMin(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := FBuffer.FItems[0];
end;

function TGLiteSortedList.FindMax(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := FBuffer.FItems[Pred(FBuffer.Count)];
end;

function TGLiteSortedList.Add(constref aValue: T): Boolean;
var
  sr: THelper.TSearchResult;
begin
  if NonEmpty then
    begin
      sr := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue);
      if (sr.FoundIndex > -1) and RejectDuplicates then
        exit(False);
      InsertItem(sr.InsertIndex, aValue);
    end
  else
    InsertItem(Count, aValue);
  Result := True;
end;

function TGLiteSortedList.AddAll(constref a: array of T): SizeInt;
var
  OldCount: SizeInt;
  PSrc: PItem;
  da: TArray;
begin
  OldCount := Count;
  if RejectDuplicates then
    begin
      da := SelectDistinctArray(a);
      Result := System.Length(da);
      if Result = 0 then
        exit;
      PSrc := @da[0];
    end
  else
    begin
      Result := System.Length(a);
      if Result = 0 then
        exit;
      PSrc := @a[0];
    end;
  EnsureCapacity(OldCount + Result);
  THelper.CopyItems(PSrc, @FBuffer.FItems[OldCount], Result);
  FBuffer.FCount += Result;
  if RejectDuplicates or (OldCount >= Result) then
    THelper.MergeSort(FBuffer.FItems[0..Pred(Count)])
  else
    THelper.Sort(FBuffer.FItems[0..Pred(Count)])
end;

function TGLiteSortedList.Insert(constref aValue: T): SizeInt;
var
  sr: THelper.TSearchResult;
begin
  if NonEmpty then
    begin
      sr := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue);
      if (sr.FoundIndex > -1) and RejectDuplicates then
        exit(-1);
      Result := sr.InsertIndex;
    end
  else
    Result := 0;
  InsertItem(Result, aValue);
end;

function TGLiteSortedList.Contains(constref aValue: T): Boolean;
begin
  Result := IndexOf(aValue) >= 0;
end;

function TGLiteSortedList.NonContains(constref aValue: T): Boolean;
begin
  Result := IndexOf(aValue) < 0;
end;

procedure TGLiteSortedList.Delete(aIndex: SizeInt);
begin
  CheckIndexRange(aIndex);
  DeleteItem(aIndex);
end;

function TGLiteSortedList.TryDelete(aIndex: SizeInt): Boolean;
begin
  Result := IndexInRange(aIndex);
  if Result then
    DeleteItem(aIndex);
end;

function TGLiteSortedList.IndexOf(constref aValue: T): SizeInt;
begin
  if NonEmpty then
    Result := THelper.BinarySearch(FBuffer.FItems[0..Pred(Count)], aValue)
  else
    Result := -1;
end;

function TGLiteSortedList.FirstIndexOf(constref aValue: T): SizeInt;
begin
  if IsEmpty then
    exit(-1);
  Result := THelper.BinarySearch(FBuffer.FItems[0..Pred(Count)], aValue);
  while (Result > 0) and (TCmpRel.Compare(aValue, FBuffer.FItems[Pred(Result)]) = 0) do
    Dec(Result);
end;

function TGLiteSortedList.CountOf(constref aValue: T): SizeInt;
var
  LastIdx, FirstIdx: SizeInt;
begin
  if IsEmpty then
    exit(0);
  LastIdx := THelper.BinarySearch(FBuffer.FItems[0..Pred(Count)], aValue);
  if LastIdx < 0 then
    exit(0);
  FirstIdx := LastIdx;
  while (FirstIdx > 0) and (TCmpRel.Compare(aValue, FBuffer.FItems[Pred(FirstIdx)]) = 0) do
    Dec(FirstIdx);
  while (LastIdx < Pred(Count)) and (TCmpRel.Compare(aValue, FBuffer.FItems[Succ(LastIdx)]) = 0) do
    Inc(LastIdx);
  Result := Succ(LastIdx - FirstIdx);
end;

function TGLiteSortedList.IndexOfCeil(constref aValue: T; aInclusive: Boolean): SizeInt;
begin
  if aInclusive then
    Result := LeftmostGE(aValue)
  else
    Result := NearestGT(aValue);
end;

function TGLiteSortedList.IndexOfFloor(constref aValue: T; aInclusive: Boolean): SizeInt;
begin
  if aInclusive then
    Result := RightmostLE(aValue)
  else
    Result := NearestLT(aValue);
end;

function TGLiteSortedList.Head(constref aHighBound: T; aInclusive: Boolean): THead;
begin
  Result{%H-}.Init(@Self, IndexOfFloor(aHighBound, aInclusive));
end;

function TGLiteSortedList.Tail(constref aLowBound: T; aInclusive: Boolean): TTail;
var
  StartIdx: SizeInt;
begin
  StartIdx := IndexOfCeil(ALowBound, aInclusive);
  if StartIdx < 0 then
    StartIdx := Count;
  Result{%H-}.Init(@Self, StartIdx);
end;

function TGLiteSortedList.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): TRange;
var
  StartIdx: SizeInt;
begin
  StartIdx := IndexOfCeil(ALowBound, rbLow in aIncludeBounds);
  if StartIdx < 0 then
    StartIdx := Count;
  Result{%H-}.Init(@Self, StartIdx, IndexOfFloor(aHighBound, rbHigh in aIncludeBounds));
end;

function TGLiteSortedList.HeadList(constref aHighBound: T; aInclusive: Boolean): TGLiteSortedList;
var
  HeadCount: SizeInt;
begin
  Result.RejectDuplicates := RejectDuplicates;
  HeadCount := Succ(IndexOfFloor(aHighBound, aInclusive));
  if HeadCount = 0 then
    exit;
  Result.EnsureCapacity(HeadCount);
  Result.FBuffer.FCount := HeadCount;
  THelper.CopyItems(@FBuffer.FItems[0], @Result.FBuffer.FItems[0], HeadCount);
end;

function TGLiteSortedList.TailList(constref aLowBound: T; aInclusive: Boolean): TGLiteSortedList;
var
  StartIdx, TailCount: SizeInt;
begin
  Result.RejectDuplicates := RejectDuplicates;
  StartIdx := IndexOfCeil(ALowBound, aInclusive);
  if StartIdx < 0 then
    exit;
  TailCount := Count - StartIdx;
  Result.EnsureCapacity(TailCount);
  Result.FBuffer.FCount := TailCount;
  THelper.CopyItems(@FBuffer.FItems[StartIdx], @Result.FBuffer.FItems[0], TailCount);
end;

function TGLiteSortedList.SubList(constref aLowBound, aHighBound: T;
  aIncludeBounds: TRangeBounds): TGLiteSortedList;
var
  StartIdx, LastIdx, RangeCount: SizeInt;
begin
  Result.RejectDuplicates := RejectDuplicates;
  StartIdx := IndexOfCeil(ALowBound, rbLow in aIncludeBounds);
  if StartIdx < 0 then
    exit;
  LastIdx := IndexOfFloor(aHighBound, rbHigh in aIncludeBounds);
  if LastIdx < StartIdx then
    exit;
  RangeCount := Succ(LastIdx - StartIdx);
  Result.EnsureCapacity(RangeCount);
  Result.FBuffer.FCount := RangeCount;
  THelper.CopyItems(@FBuffer.FItems[StartIdx], @Result.FBuffer.FItems[0], RangeCount);
end;

{ TGLiteComparableSortedList.THeadEnumerator }

function TGLiteComparableSortedList.THeadEnumerator.GetCurrent: T;
begin
  Result := FItems[FCurrIndex];
end;

procedure TGLiteComparableSortedList.THeadEnumerator.Init(constref aList: TSortedList; aLastIndex: SizeInt);
begin
  FItems := aList.FBuffer.FItems;
  FLast := aLastIndex;
  FCurrIndex := -1;
end;

function TGLiteComparableSortedList.THeadEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLast;
  FCurrIndex += Ord(Result);
end;

procedure TGLiteComparableSortedList.THeadEnumerator.Reset;
begin
  FCurrIndex := -1;
end;

{ TGLiteComparableSortedList.THead }

procedure TGLiteComparableSortedList.THead.Init(aList: PSortedList; aHighBound: SizeInt);
begin
  FList := aList;
  FHighBound := aHighBound;
end;

function TGLiteComparableSortedList.THead.GetEnumerator: THeadEnumerator;
begin
  Result := FList^.GetHeadEnumerator(FHighBound);
end;

{ TGLiteComparableSortedList.TTailEnumerator }

function TGLiteComparableSortedList.TTailEnumerator.GetCurrent: T;
begin
  Result := FItems[FCurrIndex];
end;

procedure TGLiteComparableSortedList.TTailEnumerator.Init(constref aList: TSortedList; aStartIndex: SizeInt);
begin
  FItems := aList.FBuffer.FItems;
  FLast := Pred(aList.Count);
  FStart := Pred(aStartIndex);
  FCurrIndex := FStart;
end;

procedure TGLiteComparableSortedList.TTailEnumerator.Init(constref aList: TSortedList; aStartIndex,
  aLastIndex: SizeInt);
begin
  FItems := aList.FBuffer.FItems;
  FLast := aLastIndex;
  FStart := Pred(aStartIndex);
  FCurrIndex := FStart;
end;

function TGLiteComparableSortedList.TTailEnumerator.MoveNext: Boolean;
begin
  Result := FCurrIndex < FLast;
  FCurrIndex += Ord(Result);
end;

procedure TGLiteComparableSortedList.TTailEnumerator.Reset;
begin
  FCurrIndex := FStart;
end;

{ TGLiteComparableSortedList.TTail }

procedure TGLiteComparableSortedList.TTail.Init(aList: PSortedList; aLowBound: SizeInt);
begin
  FList := aList;
  FLowBound := aLowBound;
end;

function TGLiteComparableSortedList.TTail.GetEnumerator: TTailEnumerator;
begin
  Result := FList^.GetTailEnumerator(FLowBound);
end;

{ TGLiteComparableSortedList.TRange }

procedure TGLiteComparableSortedList.TRange.Init(aList: PSortedList; aLowBound, aHighBound: SizeInt);
begin
  FList := aList;
  FLowBound := aLowBound;
  FHighBound := aHighBound;
end;

function TGLiteComparableSortedList.TRange.GetEnumerator: TTailEnumerator;
begin
  Result := FList^.GetRangeEnumerator(FLowBound, FHighBound);
end;

{ TGLiteComparableSortedList }

function TGLiteComparableSortedList.GetCapacity: SizeInt;
begin
  Result := FBuffer.Capacity;
end;

function TGLiteComparableSortedList.GetItem(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := FBuffer.FItems[aIndex];
end;

procedure TGLiteComparableSortedList.SetItem(aIndex: SizeInt; aValue: T);
begin
  CheckIndexRange(aIndex);
  DoSetItem(aIndex, aValue);
end;

procedure TGLiteComparableSortedList.DoSetItem(aIndex: SizeInt; const aValue: T);
var
  sr: THelper.TSearchResult;
begin
  if aValue <> FBuffer.FItems[aIndex] then
    begin
      if Count > 1 then
        begin
          sr := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue);
          if (sr.FoundIndex >= 0) and RejectDuplicates then
            exit;
          FBuffer.FItems[aIndex] := Default(T);  ///////////////
          if sr.InsertIndex > aIndex then
            System.Move(FBuffer.FItems[Succ(aIndex)], FBuffer.FItems[aIndex], sr.InsertIndex - aIndex)
          else
            System.Move(FBuffer.FItems[sr.InsertIndex], FBuffer.FItems[Succ(sr.InsertIndex)], aIndex - sr.InsertIndex);
          System.FillChar(FBuffer.FItems[sr.InsertIndex], SizeOf(T), 0);
          FBuffer.FItems[sr.InsertIndex] := aValue;
        end;
    end;
end;

procedure TGLiteComparableSortedList.InsertItem(aIndex: SizeInt; constref aValue: T);
begin
  FBuffer.ItemAdding;
  if aIndex < Count then
    begin
      System.Move(FBuffer.FItems[aIndex], FBuffer.FItems[Succ(aIndex)], SizeOf(T) * (Count - aIndex));
      System.FillChar(FBuffer.FItems[aIndex], SizeOf(T), 0);
    end;
  FBuffer.FItems[aIndex] := aValue;
  Inc(FBuffer.FCount);
end;

function TGLiteComparableSortedList.ExtractItem(aIndex: SizeInt): T;
begin
  Result := FBuffer.FItems[aIndex];
  FBuffer.FItems[aIndex] := Default(T);
  Dec(FBuffer.FCount);
  System.Move(FBuffer.FItems[Succ(aIndex)], FBuffer.FItems[aIndex], SizeOf(T) * (Count - aIndex));
  System.FillChar(FBuffer.FItems[Count], SizeOf(T), 0);
end;

function TGLiteComparableSortedList.DeleteItem(aIndex: SizeInt): T;
begin
  Result := ExtractItem(aIndex);
end;

procedure TGLiteComparableSortedList.RemoveDuplicates;
var
  I, J, Hi: SizeInt;
begin
  Hi := Pred(Count);
  if Hi < 1 then
    exit;
  I := 0;
  for J := 1 to Hi do
    begin
      if FBuffer.FItems[I] = FBuffer.FItems[J] then
        continue;
      Inc(I);
      if J > I then
        FBuffer.FItems[I] := FBuffer.FItems[J];
    end;
  FBuffer.FCount := Succ(I);
  for I := Count to Hi do
    FBuffer.FItems[I] := Default(T);
end;

procedure TGLiteComparableSortedList.SetRejectDuplicates(aValue: Boolean);
begin
  if RejectDuplicates <> aValue then
    begin
      FRejectDuplicates := aValue;
      if RejectDuplicates then
        RemoveDuplicates;
    end;
end;

function TGLiteComparableSortedList.NearestLT(constref aValue: T): SizeInt;
begin
  if IsEmpty or (aValue <= FBuffer.FItems[0]) then
    exit(-1);
  if aValue > FBuffer.FItems[Pred(Count)] then
     exit(Pred(Count));
  //here such element exist in FBuffer.FItems and not first nor last
  Result := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue).InsertIndex;
  if FBuffer.FItems[Result] >= aValue then
    repeat
      Dec(Result)
    until FBuffer.FItems[Result] < aValue
  else // < 0
    while FBuffer.FItems[Succ(Result)] < aValue do
      Inc(Result);
end;

function TGLiteComparableSortedList.RightmostLE(constref aValue: T): SizeInt;
begin
  if IsEmpty or (aValue < FBuffer.FItems[0]) then
    exit(-1);
  if aValue >= FBuffer.FItems[Pred(Count)] then
    exit(Pred(Count));
  //here such element exist in FBuffer.FItems and not first nor last
  Result := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue).InsertIndex;
  if FBuffer.FItems[Result] > aValue then
    repeat
      Dec(Result)
    until FBuffer.FItems[Result] <= aValue
  else // <= 0
    while FBuffer.FItems[Succ(Result)] <= aValue do
      Inc(Result);
end;

function TGLiteComparableSortedList.NearestGT(constref aValue: T): SizeInt;
begin
  if IsEmpty or (aValue >= FBuffer.FItems[Pred(Count)]) then
    exit(-1);
  if aValue < FBuffer.FItems[0] then
    exit(0);
  //here such element exist in FBuffer.FItems and not first nor last
  Result := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue).InsertIndex;
  if FBuffer.FItems[Result] <= aValue then
    repeat
      Inc(Result)
    until FBuffer.FItems[Result] > aValue
  else // > 0
    while FBuffer.FItems[Pred(Result)] > aValue do
      Dec(Result);
end;

function TGLiteComparableSortedList.LeftmostGE(constref aValue: T): SizeInt;
begin
  if IsEmpty or (aValue > FBuffer.FItems[Pred(Count)]) then
    exit(-1);
  if aValue <= FBuffer.FItems[0] then
    exit(0);
  //here such element exist in FBuffer.FItems and not first nor last
  Result := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue).InsertIndex;
  if FBuffer.FItems[Result] < aValue then
    repeat
      Inc(Result)
    until FBuffer.FItems[Result] >= aValue
  else //>=
    while FBuffer.FItems[Pred(Result)] >= aValue do
      Dec(Result);
end;

function TGLiteComparableSortedList.SelectDistinctArray(constref a: array of T): TArray;
var
  I, J, Hi: SizeInt;
begin
  Result := THelper.SelectDistinct(a);
  if IsEmpty then
    exit;
  Hi := System.High(Result);
  I := -1;
  for J := 0 to Hi do
    begin
      if IndexOf(Result[J]) > -1 then
        continue;
      Inc(I);
      if J > I then
        Result[I] := Result[J];
    end;
  System.SetLength(Result, Succ(I));
end;

function TGLiteComparableSortedList.IndexInRange(aIndex: SizeInt): Boolean;
begin
  Result := (aIndex >= 0) and (aIndex < Count);
end;

procedure TGLiteComparableSortedList.CheckIndexRange(aIndex: SizeInt);
begin
  if not IndexInRange(aIndex) then
    IndexOutOfBoundError(aIndex);
end;

procedure TGLiteComparableSortedList.IndexOutOfBoundError(aIndex: SizeInt);
begin
  raise ELGListError.CreateFmt(SEIndexOutOfBoundsFmt, [aIndex]);
end;

function TGLiteComparableSortedList.GetHeadEnumerator(aHighBound: SizeInt): THeadEnumerator;
begin
  Result.Init(Self, aHighBound);
end;

function TGLiteComparableSortedList.GetTailEnumerator(aLowBound: SizeInt): TTailEnumerator;
begin
  Result.Init(Self, aLowBound);
end;

function TGLiteComparableSortedList.GetRangeEnumerator(aLowBound, aHighBound: SizeInt): TTailEnumerator;
begin
  Result.Init(Self, aLowBound, aHighBound);
end;

function TGLiteComparableSortedList.GetEnumerator: TEnumerator;
begin
  Result := FBuffer.GetEnumerator;
end;

function TGLiteComparableSortedList.Reverse: TReverse;
begin
  Result := FBuffer.Reverse;
end;

function TGLiteComparableSortedList.ToArray: TArray;
begin
  Result := FBuffer.ToArray;
end;

procedure TGLiteComparableSortedList.Clear;
begin
  FBuffer.Clear;
end;

function TGLiteComparableSortedList.IsEmpty: Boolean;
begin
  Result := FBuffer.Count = 0;
end;

function TGLiteComparableSortedList.NonEmpty: Boolean;
begin
  Result := FBuffer.Count <> 0;
end;

procedure TGLiteComparableSortedList.EnsureCapacity(aValue: SizeInt);
begin
  FBuffer.EnsureCapacity(aValue);
end;

procedure TGLiteComparableSortedList.TrimToFit;
begin
  FBuffer.TrimToFit;
end;

function TGLiteComparableSortedList.FindMin(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := FBuffer.FItems[0];
end;

function TGLiteComparableSortedList.FindMax(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := FBuffer.FItems[Pred(FBuffer.Count)];
end;

function TGLiteComparableSortedList.Add(constref aValue: T): Boolean;
var
  sr: THelper.TSearchResult;
begin
  if NonEmpty then
    begin
      sr := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue);
      if (sr.FoundIndex > -1) and RejectDuplicates then
        exit(False);
      InsertItem(sr.InsertIndex, aValue);
    end
  else
    InsertItem(Count, aValue);
  Result := True;
end;

function TGLiteComparableSortedList.AddAll(constref a: array of T): SizeInt;
var
  OldCount: SizeInt;
  PSrc: PItem;
  da: TArray;
begin
  OldCount := Count;
  if RejectDuplicates then
    begin
      da := SelectDistinctArray(a);
      Result := System.Length(da);
      if Result = 0 then
        exit;
      PSrc := @da[0];
    end
  else
    begin
      Result := System.Length(a);
      if Result = 0 then
        exit;
      PSrc := @a[0];
    end;
  EnsureCapacity(OldCount + Result);
  THelper.CopyItems(PSrc, @FBuffer.FItems[OldCount], Result);
  FBuffer.FCount += Result;
  if RejectDuplicates or (OldCount >= Result) then
    THelper.MergeSort(FBuffer.FItems[0..Pred(Count)])
  else
    THelper.Sort(FBuffer.FItems[0..Pred(Count)])
end;

function TGLiteComparableSortedList.Insert(constref aValue: T): SizeInt;
var
  sr: THelper.TSearchResult;
begin
  if NonEmpty then
    begin
      sr := THelper.BinarySearchPos(FBuffer.FItems[0..Pred(Count)], aValue);
      if (sr.FoundIndex > -1) and RejectDuplicates then
        exit(-1);
      Result := sr.InsertIndex;
    end
  else
    Result := 0;
  InsertItem(Result, aValue);
end;

function TGLiteComparableSortedList.Contains(constref aValue: T): Boolean;
begin
  Result := IndexOf(aValue) >= 0;
end;

function TGLiteComparableSortedList.NonContains(constref aValue: T): Boolean;
begin
  Result := IndexOf(aValue) < 0;
end;

procedure TGLiteComparableSortedList.Delete(aIndex: SizeInt);
begin
  CheckIndexRange(aIndex);
  DeleteItem(aIndex);
end;

function TGLiteComparableSortedList.TryDelete(aIndex: SizeInt): Boolean;
begin
  Result := IndexInRange(aIndex);
  if Result then
    DeleteItem(aIndex);
end;

function TGLiteComparableSortedList.IndexOf(constref aValue: T): SizeInt;
begin
  if NonEmpty then
    Result := THelper.BinarySearch(FBuffer.FItems[0..Pred(Count)], aValue)
  else
    Result := -1;
end;

function TGLiteComparableSortedList.FirstIndexOf(constref aValue: T): SizeInt;
begin
  if IsEmpty then
    exit(-1);
  Result := THelper.BinarySearch(FBuffer.FItems[0..Pred(Count)], aValue);
  while (Result > 0) and (aValue = FBuffer.FItems[Pred(Result)]) do
    Dec(Result);
end;

function TGLiteComparableSortedList.CountOf(constref aValue: T): SizeInt;
var
  LastIdx, FirstIdx: SizeInt;
begin
  if IsEmpty then
    exit(0);
  LastIdx := THelper.BinarySearch(FBuffer.FItems[0..Pred(Count)], aValue);
  if LastIdx < 0 then
    exit(0);
  FirstIdx := LastIdx;
  while (FirstIdx > 0) and (aValue = FBuffer.FItems[Pred(FirstIdx)]) do
    Dec(FirstIdx);
  while (LastIdx < Pred(Count)) and (aValue = FBuffer.FItems[Succ(LastIdx)]) do
    Inc(LastIdx);
  Result := Succ(LastIdx - FirstIdx);
end;

function TGLiteComparableSortedList.IndexOfCeil(constref aValue: T; aInclusive: Boolean): SizeInt;
begin
  if aInclusive then
    Result := LeftmostGE(aValue)
  else
    Result := NearestGT(aValue);
end;

function TGLiteComparableSortedList.IndexOfFloor(constref aValue: T; aInclusive: Boolean): SizeInt;
begin
  if aInclusive then
    Result := RightmostLE(aValue)
  else
    Result := NearestLT(aValue);
end;

function TGLiteComparableSortedList.Head(constref aHighBound: T; aInclusive: Boolean): THead;
begin
  Result{%H-}.Init(@Self, IndexOfFloor(aHighBound, aInclusive));
end;

function TGLiteComparableSortedList.Tail(constref aLowBound: T; aInclusive: Boolean): TTail;
var
  StartIdx: SizeInt;
begin
  StartIdx := IndexOfCeil(ALowBound, aInclusive);
  if StartIdx < 0 then
    StartIdx := Count;
  Result{%H-}.Init(@Self, StartIdx);
end;

function TGLiteComparableSortedList.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): TRange;
var
  StartIdx: SizeInt;
begin
  StartIdx := IndexOfCeil(ALowBound, rbLow in aIncludeBounds);
  if StartIdx < 0 then
    StartIdx := Count;
  Result{%H-}.Init(@Self, StartIdx, IndexOfFloor(aHighBound, rbHigh in aIncludeBounds));
end;

function TGLiteComparableSortedList.HeadList(constref aHighBound: T; aInclusive: Boolean): TGLiteComparableSortedList;
var
  HeadCount: SizeInt;
begin
  Result.RejectDuplicates := RejectDuplicates;
  HeadCount := Succ(IndexOfFloor(aHighBound, aInclusive));
  if HeadCount = 0 then
    exit;
  Result.EnsureCapacity(HeadCount);
  Result.FBuffer.FCount := HeadCount;
  THelper.CopyItems(@FBuffer.FItems[0], @Result.FBuffer.FItems[0], HeadCount);
end;

function TGLiteComparableSortedList.TailList(constref aLowBound: T; aInclusive: Boolean): TGLiteComparableSortedList;
var
  StartIdx, TailCount: SizeInt;
begin
  Result.RejectDuplicates := RejectDuplicates;
  StartIdx := IndexOfCeil(ALowBound, aInclusive);
  if StartIdx < 0 then
    exit;
  TailCount := Count - StartIdx;
  Result.EnsureCapacity(TailCount);
  Result.FBuffer.FCount := TailCount;
  THelper.CopyItems(@FBuffer.FItems[StartIdx], @Result.FBuffer.FItems[0], TailCount);
end;

function TGLiteComparableSortedList.SubList(constref aLowBound, aHighBound: T;
  aIncludeBounds: TRangeBounds): TGLiteComparableSortedList;
var
  StartIdx, LastIdx, RangeCount: SizeInt;
begin
  Result.RejectDuplicates := RejectDuplicates;
  StartIdx := IndexOfCeil(ALowBound, rbLow in aIncludeBounds);
  if StartIdx < 0 then
    exit;
  LastIdx := IndexOfFloor(aHighBound, rbHigh in aIncludeBounds);
  if LastIdx < StartIdx then
    exit;
  RangeCount := Succ(LastIdx - StartIdx);
  Result.EnsureCapacity(RangeCount);
  Result.FBuffer.FCount := RangeCount;
  THelper.CopyItems(@FBuffer.FItems[StartIdx], @Result.FBuffer.FItems[0], RangeCount);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic stack implementations.                                          *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGStack;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}

interface

uses

  SysUtils,
  LGUtils,
  LGCustomContainer;

type

  { TGStack }

  generic TGStack<T> = class(specialize TGCustomArrayContainer<T>, specialize IGStack<T>)
  strict private
    function  PopItem: T; inline;
  public
    procedure Push(constref aValue: T);
    function  PushAll(constref a: array of T): SizeInt;
    function  PushAll(e: IEnumerable): SizeInt;
  { EXTRACTS element from the top of stack }
    function  Pop: T;
    function  TryPop(out aValue: T): Boolean;
    function  Peek: T; inline;
    function  TryPeek(out aValue: T): Boolean;
  end;

  { TGObjectStack note:
    TGObjectStack.Pop(or TGObjectStack.TryPop) EXTRACTS object from stack;
    one need to free this object yourself }
  generic TGObjectStack<T: class> = class(specialize TGStack<T>)
  strict private
    FOwnsObjects: Boolean;
  protected
    procedure DoClear; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(constref A: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGThreadStack }

  generic TGThreadStack<T> = class
  public
  type
    IStack = specialize IGStack<T>;

  private
    FStack: IStack;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create(aStack: IStack);
    destructor Destroy; override;
    procedure Clear;
    procedure Push(constref aValue: T);
    function  TryPop(out aValue: T): Boolean;
    function  TryPeek(out aValue: T): Boolean;
    function  Lock: IStack;
    procedure Unlock; inline;
  end;

  { TGLiteStack }

  generic TGLiteStack<T> = record
  private
  type
    TBuffer = specialize TGLiteDynBuffer<T>;

  public
  type
    TEnumerator = TBuffer.TEnumerator;
    TMutable    = TBuffer.TMutable;
    TReverse    = TBuffer.TReverse;
    PItem       = TBuffer.PItem;
    TArray      = TBuffer.TArray;

  private
    FBuffer: TBuffer;
    function  GetCapacity: SizeInt; inline;
    function  PopItem: T; inline;
  public
    function  GetEnumerator: TEnumerator; inline;
    function  Mutable: TMutable; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    procedure Push(constref aValue: T); inline;
    function  Pop: T; inline;
    function  TryPop(out aValue: T): Boolean; inline;
    function  Peek: T; inline;
    function  TryPeek(out aValue: T): Boolean; inline;
    property  Count: SizeInt read FBuffer.FCount;
    property  Capacity: SizeInt read GetCapacity;
  end;

  { TGLiteThreadStack }

  generic TGLiteThreadStack<T> = class
  public
  type
    TStack = specialize TGLiteStack<T>;
    PStack = ^TStack;

  strict private
    FStack: TStack;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    procedure Push(constref aValue: T);
    function  TryPop(out aValue: T): Boolean;
    function  TryPeek(out aValue: T): Boolean;
    function  Lock: PStack;
    procedure Unlock; inline;
  end;

  { TGLiteObjectStack }

  generic TGLiteObjectStack<T: class> = record
  strict private
  type
    TStack = specialize TGLiteStack<T>;
    TArray = TStack.TArray;

  var
    FOwnsObjects: Boolean;
    FStack: TStack;
    function GetCapacity: SizeInt; inline;
    function GetCount: SizeInt; inline;
    procedure CheckFreeItems;
  private
    class operator Initialize(var s: TGLiteObjectStack);
    class operator Finalize(var s: TGLiteObjectStack);
  public
  type
    TEnumerator = TStack.TEnumerator;
    TMutable    = TStack.TMutable;
    TReverse    = TStack.TReverse;

    function  GetEnumerator: TEnumerator; inline;
    function  Mutable: TMutable; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
    procedure Push(constref aValue: T); inline;
    function  Pop: T; inline;
    function  TryPop(out aValue: T): Boolean; inline;
    function  Peek: T; inline;
    function  TryPeek(out aValue: T): Boolean; inline;
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGLiteThreadObjectStack }

  generic TGLiteThreadObjectStack<T: class> = class
  public
  type
    TStack = specialize TGLiteObjectStack<T>;
    PStack = ^TStack;

  strict private
    FStack: TStack;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Clear;
    procedure Push(constref aValue: T);
    function  TryPop(out aValue: T): Boolean;
    function  TryPeek(out aValue: T): Boolean;
    function  Lock: PStack;
    procedure Unlock; inline;
  end;


implementation
{$B-}{$COPERATORS ON}

{ TGStack }

function TGStack.PopItem: T;
begin
  Dec(FCount);
  Result := FItems[ElemCount];
  FItems[ElemCount] := Default(T);
end;

procedure TGStack.Push(constref aValue: T);
begin
  CheckInIteration;
  Append(aValue);
end;

function TGStack.PushAll(constref a: array of T): SizeInt;
begin
  CheckInIteration;
  Result := AppendArray(a);
end;

function TGStack.PushAll(e: IEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := AppendEnumerable(e);
end;

function TGStack.Pop: T;
begin
  CheckInIteration;
  CheckEmpty;
  Result := PopItem;
end;

function TGStack.TryPop(out aValue: T): Boolean;
begin
  Result := not InIteration and (ElemCount > 0);
  if Result then
    aValue := PopItem;
end;

function TGStack.Peek: T;
begin
  CheckEmpty;
  Result := FItems[Pred(ElemCount)];
end;

function TGStack.TryPeek(out aValue: T): Boolean;
begin
  Result := ElemCount > 0;
  if Result then
    aValue := FItems[Pred(ElemCount)];
end;

{ TGObjectStack }

procedure TGObjectStack.DoClear;
var
  I: SizeInt;
begin
  if OwnsObjects and (ElemCount > 0) then
    for I := 0 to Pred(ElemCount) do
      FItems[I].Free;
  inherited;
end;

constructor TGObjectStack.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectStack.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectStack.Create(constref A: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(A);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectStack.Create(e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(e);
  FOwnsObjects := aOwnsObjects;
end;

{ TGThreadStack }

procedure TGThreadStack.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGThreadStack.Create(aStack: IStack);
begin
  System.InitCriticalSection(FLock);
  FStack := aStack;
end;

destructor TGThreadStack.Destroy;
begin
  DoLock;
  try
    FStack._GetRef.Free;
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGThreadStack.Clear;
begin
  DoLock;
  try
    FStack.Clear;
  finally
    UnLock;
  end;
end;

procedure TGThreadStack.Push(constref aValue: T);
begin
  DoLock;
  try
    FStack.Push(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadStack.TryPop(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FStack.TryPop(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadStack.TryPeek(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FStack.TryPeek(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadStack.Lock: IStack;
begin
  Result := FStack;
  DoLock;
end;

procedure TGThreadStack.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

{ TGLiteStack }

function TGLiteStack.PopItem: T;
begin
  Dec(FBuffer.FCount);
  Result := FBuffer.FItems[Count];
  FBuffer.FItems[Count] := Default(T);
end;

function TGLiteStack.GetEnumerator: TEnumerator;
begin
  Result := FBuffer.GetEnumerator;
end;

function TGLiteStack.Mutable: TMutable;
begin
  Result := FBuffer.Mutable;
end;

function TGLiteStack.Reverse: TReverse;
begin
  Result := FBuffer.Reverse;
end;

function TGLiteStack.ToArray: TArray;
begin
  Result := FBuffer.ToArray;
end;

function TGLiteStack.GetCapacity: SizeInt;
begin
  Result := FBuffer.Capacity;
end;

procedure TGLiteStack.Clear;
begin
  FBuffer.Clear;
end;

function TGLiteStack.IsEmpty: Boolean;
begin
  Result := FBuffer.Count = 0;
end;

function TGLiteStack.NonEmpty: Boolean;
begin
  Result := FBuffer.Count <> 0;
end;

procedure TGLiteStack.EnsureCapacity(aValue: SizeInt);
begin
  FBuffer.EnsureCapacity(aValue);
end;

procedure TGLiteStack.TrimToFit;
begin
  FBuffer.TrimToFit;
end;

procedure TGLiteStack.Push(constref aValue: T);
begin
  FBuffer.PushLast(aValue);
end;

function TGLiteStack.Pop: T;
begin
  FBuffer.CheckEmpty;
  Result := PopItem;
end;

function TGLiteStack.TryPop(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := PopItem;
end;

function TGLiteStack.Peek: T;
begin
  FBuffer.CheckEmpty;
  Result := FBuffer.FItems[Pred(Count)];
end;

function TGLiteStack.TryPeek(out aValue: T): Boolean;
begin
  Result := NonEmpty;
  if Result then
    aValue := FBuffer.FItems[Pred(Count)];
end;

{ TGLiteThreadStack }

procedure TGLiteThreadStack.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGLiteThreadStack.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteThreadStack.Destroy;
begin
  DoLock;
  try
    Finalize(FStack);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGLiteThreadStack.Clear;
begin
  DoLock;
  try
    FStack.Clear;
  finally
    UnLock;
  end;
end;

procedure TGLiteThreadStack.Push(constref aValue: T);
begin
  DoLock;
  try
    FStack.Push(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadStack.TryPop(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FStack.TryPop(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadStack.TryPeek(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FStack.TryPeek(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadStack.Lock: PStack;
begin
  Result := @FStack;
  DoLock;
end;

procedure TGLiteThreadStack.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

{ TGLiteObjectStack }

function TGLiteObjectStack.GetCapacity: SizeInt;
begin
  Result := FStack.Capacity;
end;

function TGLiteObjectStack.GetCount: SizeInt;
begin
  Result := FStack.Count;
end;

procedure TGLiteObjectStack.CheckFreeItems;
var
  I: Integer;
begin
  if OwnsObjects then
    for I := 0 to Pred(Count) do
      FStack.FBuffer.FItems[I].Free;
end;

class operator TGLiteObjectStack.Initialize(var s: TGLiteObjectStack);
begin
  s.FOwnsObjects := True;
end;

class operator TGLiteObjectStack.Finalize(var s: TGLiteObjectStack);
begin
  s.Clear;
end;

function TGLiteObjectStack.GetEnumerator: TEnumerator;
begin
  Result := FStack.GetEnumerator;
end;

function TGLiteObjectStack.Mutable: TMutable;
begin
  Result := FStack.Mutable;
end;

function TGLiteObjectStack.Reverse: TReverse;
begin
  Result := FStack.Reverse;
end;

function TGLiteObjectStack.ToArray: TArray;
begin
  Result := FStack.ToArray;
end;

procedure TGLiteObjectStack.Clear;
begin
  CheckFreeItems;
  FStack.Clear;
end;

function TGLiteObjectStack.IsEmpty: Boolean;
begin
  Result := FStack.IsEmpty;
end;

function TGLiteObjectStack.NonEmpty: Boolean;
begin
  Result := FStack.NonEmpty;
end;

procedure TGLiteObjectStack.EnsureCapacity(aValue: SizeInt);
begin
  FStack.EnsureCapacity(aValue);
end;

procedure TGLiteObjectStack.TrimToFit;
begin
  FStack.TrimToFit;
end;

procedure TGLiteObjectStack.Push(constref aValue: T);
begin
  FStack.Push(aValue);
end;

function TGLiteObjectStack.Pop: T;
begin
  Result := FStack.Pop;
end;

function TGLiteObjectStack.TryPop(out aValue: T): Boolean;
begin
  Result := FStack.TryPop(aValue);
end;

function TGLiteObjectStack.Peek: T;
begin
  Result := FStack.Peek;
end;

function TGLiteObjectStack.TryPeek(out aValue: T): Boolean;
begin
  Result := FStack.TryPeek(aValue);
end;

{ TGLiteThreadObjectStack }

procedure TGLiteThreadObjectStack.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGLiteThreadObjectStack.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteThreadObjectStack.Destroy;
begin
  DoLock;
  try
    Finalize(FStack);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

procedure TGLiteThreadObjectStack.Clear;
begin
  DoLock;
  try
    FStack.Clear;
  finally
    UnLock;
  end;
end;

procedure TGLiteThreadObjectStack.Push(constref aValue: T);
begin
  DoLock;
  try
    FStack.Push(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectStack.TryPop(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FStack.TryPop(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectStack.TryPeek(out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FStack.TryPeek(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectStack.Lock: PStack;
begin
  Result := @FStack;
  DoLock;
end;

procedure TGLiteThreadObjectStack.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Common string resources.                                                *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGStrConst;

{$mode objfpc}{$H+}

interface


resourcestring

  SEOptionalValueEmpty     = 'Optional value is empty';
  SEArgumentTooBigFmt      = 'Argument of %s is too big(%d)';
  SEClassAccessEmptyFmt    = 'Can not access element of empty %s';
  SECantAccessEmpty        = 'Can not access element of empty container';
  SEClassCapacityExceedFmt = '%s maximum capacity exceeded(%d)';
  SECapacityExceedFmt      = 'Maximum capacity exceeded(%d)';
  SECantUpdDuringIterFmt   = 'Can not update %s during enumeration';
  SEArrIndexOutOfBoundsFmt = 'Array index out of bounds(%d)';
  SEClassIdxOutOfBoundsFmt = '%s index out of bounds(%d)';
  SEIndexOutOfBoundsFmt    = 'Index out of bounds(%d)';
  SEKeyNotFound            = 'Key not found';
  SEValueNotFound          = 'Value not found';
  SEUnknownSortAlgoFmt     = 'Unknown sort algprithm(%u)';
  SECantAcceptNegCountFmt  = 'The %s''s TEntry.Count can not accept negative value';
  SECantAcceptNegCount     = 'Can not accept negative TEntry.Count value';
  SEInternalDataInconsist  = 'Internal data inconsistency';
  SEValueAlreadyExist      = 'Value already exists';
  SEKeyAlreadyExist        = 'Key already exists';
  SEThreadTimeOut          = 'Thread timeout exceeded';
  SEResultUnknown          = 'Result is unknown';
  SECellNotFoundFmt        = 'Specified cell of %s not found';

implementation

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Some useful string helpers.                                             *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGStrHelpers;

{$mode objfpc}{$H+}
{$INTERFACES CORBA}
{$MODESWITCH TYPEHELPERS}
{$MODESWITCH ADVANCEDRECORDS}
{$INLINE ON}

interface

uses

  SysUtils,
  LGUtils,
  LGHelpers,
  LGCustomContainer,
  regexpr;

type

  { TAnsiStrHelper }

  TAnsiStrHelper = type helper(TAStrHelper) for ansistring
  private
  type

    TEnumerable = class(specialize TGAutoEnumerable<string>)
    private
      FString: string;
      FStartIndex,
      FCurrIndex: SizeInt;
      FDelimiters: TSysCharSet;
      FFound: Boolean;
    protected
      function  GetCurrent: string; override;
    public
      constructor Create(const aValue: string; const aDelimiters: TSysCharSet);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  public
  type
    IStrEnumerable = specialize IGEnumerable<string>;
  const
    WhiteSpaces = [#0..' '];
    AsciiDelimiters = [#0..#255] - ['a'..'z', 'A'..'Z', '0'..'9', '_'];
    function StripWhiteSpaces: ansistring; inline;
    function StripChar(aChar: AnsiChar): ansistring;
    function StripChars(constref aChars: TSysCharSet): ansistring;
    // only single byte delimiters allowed
    function SplitSB(constref aDelimiters: TSysCharSet = AsciiDelimiters): IStrEnumerable; inline;
  end;

  { TRegexMatch }

  TRegexMatch = class
  protected
  type

    TEnumerable = class(specialize TGAutoEnumerable<string>)
    private
      FRegex: TRegExpr;
      FInputString: string;
      FInCycle: Boolean;
    protected
      function  GetCurrent: string; override;
    public
      constructor Create(aRegex: TRegExpr; const s: string);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FRegex: TRegExpr;
    function  GetExpression: string;
    function  GetModifierStr: string;
    procedure SetExpression(aValue: string);
    procedure SetModifierStr(aValue: string);
  public
  type
    IStrEnumerable = specialize IGEnumerable<string>;
    constructor Create;
    constructor Create(const aRegExpression: string);
    constructor Create(const aRegExpression, aModifierStr: string);
    destructor Destroy; override;
    function Matches(const aValue: string): IStrEnumerable; inline;
    property Expression: string read GetExpression write SetExpression;
    property ModifierStr: string read GetModifierStr write SetModifierStr;
  end;

implementation
{$Q-}{$B-}{$COPERATORS ON}

{ TAnsiStrHelper.TEnumerable }

function TAnsiStrHelper.TEnumerable.GetCurrent: string;
begin
  if FFound then
    Result := System.Copy(FString, FStartIndex, FCurrIndex - FStartIndex)
  else
    Result := '';
end;

constructor TAnsiStrHelper.TEnumerable.Create(const aValue: string; const aDelimiters: TSysCharSet);
begin
  inherited Create;
  FString := aValue;
  FDelimiters := aDelimiters;
  FStartIndex := 1;
  FCurrIndex := 1;
end;

function TAnsiStrHelper.TEnumerable.MoveNext: Boolean;
var
  I, Len: SizeInt;
  WordFound: Boolean;
begin
  Len := System.Length(FString);
  if FCurrIndex <= Len then
    begin
      WordFound := False;
      I := FCurrIndex;
      repeat
        if FString[I] in FDelimiters then
          begin
            if WordFound then
              break;
          end
        else
          if not WordFound then
            begin
              WordFound := True;
              FStartIndex := I;
            end;
        Inc(I);
      until I > Len;
      FCurrIndex := I;
      Result := WordFound;
      FFound := WordFound;
    end
  else
    Result := False;
end;

procedure TAnsiStrHelper.TEnumerable.Reset;
begin
  FStartIndex := 1;
  FCurrIndex := 1;
  FFound := False;
end;

{ TAnsiStrHelper }

function TAnsiStrHelper.StripWhiteSpaces: ansistring;
begin
  Result := StripChars(WhiteSpaces);
end;

function TAnsiStrHelper.StripChar(aChar: AnsiChar): ansistring;
var
  I, J: SizeInt;
  pRes, pSelf: PAnsiChar;
  c: AnsiChar;
begin
  if Self = '' then
    exit('');
  SetLength(Result, System.Length(Self));
  pSelf := PAnsiChar(Self);
  pRes := PAnsiChar(Result);
  J := 0;
  for I := 0 to Pred(System.Length(Self)) do
    begin
      c := pSelf[I];
      if c <> aChar then
        begin
          pRes[J] := c;
          Inc(J);
        end;
    end;
  SetLength(Result, J);
end;

function TAnsiStrHelper.StripChars(constref aChars: TSysCharSet): ansistring;
var
  I, J: SizeInt;
  pRes, pSelf: PAnsiChar;
  c: AnsiChar;
begin
  if Self = '' then
    exit('');
  SetLength(Result, System.Length(Self));
  pSelf := PAnsiChar(Self);
  pRes := PAnsiChar(Result);
  J := 0;
  for I := 0 to Pred(System.Length(Self)) do
    begin
      c := pSelf[I];
      if not (c in aChars) then
        begin
          pRes[J] := c;
          Inc(J);
        end;
    end;
  SetLength(Result, J);
end;

function TAnsiStrHelper.SplitSB(constref aDelimiters: TSysCharSet): IStrEnumerable;
begin
  Result := TEnumerable.Create(Self, aDelimiters);
end;

{ TRegexMatch.TEnumerable }

function TRegexMatch.TEnumerable.GetCurrent: string;
begin
  Result := FRegex.Match[0];
end;

constructor TRegexMatch.TEnumerable.Create(aRegex: TRegExpr; const s: string);
begin
  inherited Create;
  FRegex := aRegex;
  FInputString := s;
end;

function TRegexMatch.TEnumerable.MoveNext: Boolean;
begin
  if FInCycle then
    Result := FRegex.ExecNext
  else
    begin
      FInCycle := True;
      Result := FRegex.Exec(FInputString);
    end;
end;

procedure TRegexMatch.TEnumerable.Reset;
begin
  FInCycle := False;
end;

{ TRegexMatch }

function TRegexMatch.GetExpression: string;
begin
  Result := FRegex.Expression;
end;

function TRegexMatch.GetModifierStr: string;
begin
  Result := FRegex.ModifierStr;
end;

procedure TRegexMatch.SetExpression(aValue: string);
begin
  FRegex.Expression := aValue;
end;

procedure TRegexMatch.SetModifierStr(aValue: string);
begin
  FRegex.ModifierStr := aValue;
end;

constructor TRegexMatch.Create;
begin
  FRegex := TRegExpr.Create;
end;

constructor TRegexMatch.Create(const aRegExpression: string);
begin
  FRegex := TRegExpr.Create(aRegExpression);
end;

constructor TRegexMatch.Create(const aRegExpression, aModifierStr: string);
begin
  FRegex := TRegExpr.Create(aRegExpression);
  FRegex.ModifierStr := aModifierStr;
end;

destructor TRegexMatch.Destroy;
begin
  FRegex.Free;
  inherited;
end;

function TRegexMatch.Matches(const aValue: string): IStrEnumerable;
begin
  Result := TEnumerable.Create(FRegex, aValue);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic sparse table implementations.                                   *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGTable2D;

{$mode objfpc}{$H+}
{$INLINE ON}

interface

uses
  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGHashTable,
  LGAvlTree,
  LGSortedList;

type

  { TGCustomHashTable2D: implements rows as as linear probing hashmap }
  generic TGCustomHashTable2D<TRow, TCol, TValue, TRowEqRel> = class abstract(
    specialize TGCustomTable2D<TRow, TCol, TValue>)
  protected
  type
    TRowHashTable = specialize TGHashTableLP<TRow, TRowEntry, TRowEqRel>;

    TColEnumerable = class(TCustomColDataEnumerable)
    protected
      FEnum: TRowHashTable.TEnumerator;
      FCurrValue: TValue;
      FCol: TCol;
      function GetCurrent: TColData; override;
    public
      constructor Create(aTable: TGCustomHashTable2D; constref ACol: TCol);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TCellEnumerable = class(TCustomCellDataEnumerable)
    protected
      FEnum: TRowHashTable.TEnumerator;
      FRowEnum: TRowDataEnumerator;
      FCurrRowEntry: TRowData;
      function GetCurrent: TCellData; override;
    public
      constructor Create(aTable: TGCustomHashTable2D);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRowEnumerable = class(specialize TGAutoEnumerable<TRow>)
    protected
      FEnum: TRowHashTable.TEnumerator;
      function GetCurrent: TRow; override;
    public
      constructor Create(aTable: TGCustomHashTable2D);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRowMapEnumerable = class(specialize TGAutoEnumerable<IRowMap>)
    protected
      FEnum: TRowHashTable.TEnumerator;
      function GetCurrent: IRowMap; override;
    public
      constructor Create(aTable: TGCustomHashTable2D);
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FRowTable: TRowHashTable;
    function  CreateRowMap: TCustomRowMap; virtual; abstract;
    function  GetFillRatio: Single; inline;
    function  GetLoadFactor: Single; inline;
    procedure SetLoadFactor(aValue: Single); inline;
    procedure ClearItems;
    function  GetRowCount: SizeInt; override;
    function  DoFindRow(constref aRow: TRow): PRowEntry; override;
  { returns True if row found, False otherwise }
    function  DoFindOrAddRow(constref aRow: TRow; out p: PRowEntry): Boolean; override;
    function  DoRemoveRow(constref aRow: TRow): SizeInt; override;
    function  GetColumn(const aCol: TCol): IColDataEnumerable; override;
    function  GetCellData: ICellDataEnumerable; override;
  public
    constructor Create;
    constructor Create(aRowCapacity: SizeInt);
    constructor Create(aLoadFactor: Single);
    constructor Create(aRowCapacity: SizeInt; aLoadFactor: Single);
    procedure Clear; override;
    procedure EnsureRowCapacity(aValue: SizeInt); override;
    function  RowEnum: IRowEnumerable; override;
    function  RowMapEnum: IRowMapEnumerable; override;
    property  LoadFactor: Single read GetLoadFactor write SetLoadFactor;
    property  FillRatio: Single read GetFillRatio;
  end;

  { TGHashTable2D implements table with row map as linear probing hashmap;

      functor TRowEqRel(row equality relation) must provide:
        class function HashCode([const[ref]] r: TRow): SizeInt;
        class function Equal([const[ref]] L, R: TRow): Boolean;

      functor TColEqRel(column equality relation) must provide:
        class function HashCode([const[ref]] c: TCol): SizeInt;
        class function Equal([const[ref]] L, R: TCol): Boolean; }
  generic TGHashTable2D<TRow, TCol, TValue, TRowEqRel, TColEqRel> = class(
    specialize TGCustomHashTable2D<TRow, TCol, TValue, TRowEqRel>)
  protected
  type

    TRowMap = class(TCustomRowMap)
    private
    type
      TEntry = record
        Key: TCol;
        Value:  TValue;
      end;
      PEntry = ^TEntry;

      TRowMapTable = specialize TGHashTableLP<TCol, TEntry, TColEqRel>;

      TEnumerator = class(TRowDataEnumerator)
      protected
        FEnum: TRowMapTable.TEnumerator;
        function GetCurrent: TRowData; override;
      public
        constructor Create(aMap: TRowMapTable);
        function  MoveNext: Boolean; override;
        procedure Reset; override;
      end;

    const
      INITIAL_CAPACITY = 8;
      LOAD_FACTOR    = 0.65; //todo: why ???

    var
      FTable: TCustomTable2D;
      FMap: TRowMapTable;
    protected
      function  GetCount: SizeInt; override;
    public
      constructor Create(aTable: TCustomTable2D);
      destructor Destroy; override;
      function  GetEnumerator: TRowDataEnumerator; override;
      procedure TrimToFit; inline;
      function  Contains(constref aCol: TCol): Boolean; override;
      function  TryGetValue(constref aCol: TCol; out aValue: TValue): Boolean; override;
    { returns True if not contains aCol was added, False otherwise }
      function  Add(constref aCol: TCol; constref aValue: TValue): Boolean; override;
      procedure AddOrSetValue(const aCol: TCol; const aValue: TValue); override;
      function  Remove(constref aCol: TCol): Boolean; override;
    end;

    function  CreateRowMap: TCustomRowMap; override;
  public
    destructor Destroy; override;
    procedure TrimToFit; override;
  end;

  { TGHashTable2DR assumes that TRow implements TRowEqRel }
  generic TGHashTable2DR<TRow, TCol, TValue, TColEqRel> = class(
    specialize TGHashTable2D<TRow, TCol, TValue, TRow, TColEqRel>);

  { TGHashTable2DC assumes that TCol implements TColEqRel }
  generic TGHashTable2DC<TRow, TCol, TValue, TRowEqRel> = class(
    specialize TGHashTable2D<TRow, TCol, TValue, TRowEqRel, TCol>);

  { TGHashTable2D2 assumes that TRow implements TRowEqRel and TCol implements TColEqRel }
  generic TGHashTable2D2<TRow, TCol, TValue> = class(
    specialize TGHashTable2D<TRow, TCol, TValue, TRow, TCol>);

  { TGTreeTable2D implements table with row map as avl_tree map;

      functor TRowEqRel(row equality relation) must provide:
        class function HashCode([const[ref]] r: TRow): SizeInt;
        class function Equal([const[ref]] L, R: TRow): Boolean;

      functor TColCmpRel(column equality relation) must provide:
        class function Compare([const[ref]] L, R: TCol): SizeInt; }
  generic TGTreeTable2D<TRow, TCol, TValue, TRowEqRel, TColCmpRel> = class(
    specialize TGCustomHashTable2D<TRow, TCol, TValue, TRowEqRel>)
  protected
  type
    TEntry = record
      Key: TCol;
      Value:  TValue;
    end;
    PEntry = ^TEntry;

    TNode        = specialize TGAvlTreeNode<TEntry>;
    PNode        = ^TNode;
    TNodeManager = specialize TGPageNodeManager<TNode>;
    PNodeManager = ^TNodeManager;

    TRowMap = class(TCustomRowMap)
    private
    type
      TRowMapTable = specialize TGAvlTree2<TCol, TEntry, TNodeManager, TColCmpRel>;

      TEnumerator = class(TRowDataEnumerator)
      protected
        FEnum: TRowMapTable.TEnumerator;
        function GetCurrent: TRowData; override;
      public
        constructor Create(aMap: TRowMapTable);
        function  MoveNext: Boolean; override;
        procedure Reset; override;
      end;

    var
      FTable: TCustomTable2D;
      FMap: TRowMapTable;
    protected
      function  GetCount: SizeInt; override;
    public
      constructor Create(aTable: TGTreeTable2D);
      destructor Destroy; override;
      function  GetEnumerator: TRowDataEnumerator; override;
      function  Contains(constref aCol: TCol): Boolean; override;
      function  TryGetValue(constref aCol: TCol; out aValue: TValue): Boolean; override;
    { returns True if not contains aCol was added, False otherwise }
      function  Add(constref aCol: TCol; constref aValue: TValue): Boolean; override;
      procedure AddOrSetValue(const aCol: TCol; const aValue: TValue); override;
      function  Remove(constref aCol: TCol): Boolean; override;
    end;

  var
    FNodeManager: TNodeManager;
    function  CreateRowMap: TCustomRowMap; override;
  public
    constructor Create;
    constructor Create(aRowCapacity: SizeInt);
    constructor Create(aLoadFactor: Single);
    constructor Create(aRowCapacity: SizeInt; aLoadFactor: Single);
    destructor Destroy; override;
    procedure Clear; override;
    procedure TrimToFit; override;
  end;

  { TGTreeTable2DR assumes that TRow implements TRowEqRel }
  generic TGTreeTable2DR<TRow, TCol, TValue, TColCmpRel> = class(
    specialize TGTreeTable2D<TRow, TCol, TValue, TRow, TColCmpRel>);

  { TGTreeTable2DC assumes that TCol implements TColCmpRel }
  generic TGTreeTable2DC<TRow, TCol, TValue, TRowEqRel> = class(
    specialize TGTreeTable2D<TRow, TCol, TValue, TRowEqRel, TCol>);

  { TGTreeTable2D2 assumes that TRow implements TRowEqRel and TCol implements TColCmpRel }
  generic TGTreeTable2D2<TRow, TCol, TValue> = class(
    specialize TGTreeTable2D<TRow, TCol, TValue, TRow, TCol>);


  { TGListTable2D implements table with row map as listmap ;

      functor TRowEqRel(row equality relation) must provide:
        class function HashCode([const[ref]] r: TRow): SizeInt;
        class function Equal([const[ref]] L, R: TRow): Boolean;

      functor TColCmpRel(column equality relation) must provide:
        class function Compare([const[ref]] L, R: TCol): SizeInt; }
  generic TGListTable2D<TRow, TCol, TValue, TRowEqRel, TColCmpRel> = class(
    specialize TGCustomHashTable2D<TRow, TCol, TValue, TRowEqRel>)
  protected
  type
    TEntry = record
      Key: TCol;
      Value:  TValue;
    end;
    PEntry = ^TEntry;

    TRowMap = class(TCustomRowMap)
    private
    type
      TRowMapTable = specialize TGSortedListTable<TCol, TEntry, TColCmpRel>;

      TEnumerator = class(TRowDataEnumerator)
      protected
        FEnum: TRowMapTable.TEnumerator;
        function GetCurrent: TRowData; override;
      public
        constructor Create(aMap: TRowMapTable);
        function  MoveNext: Boolean; override;
        procedure Reset; override;
      end;

    const
      INITIAL_CAPACITY = 8;

    var
      FTable: TCustomTable2D;
      FMap: TRowMapTable;
    protected
      function  GetCount: SizeInt; override;
    public
      constructor Create(aTable: TCustomTable2D);
      destructor Destroy; override;
      function  GetEnumerator: TRowDataEnumerator; override;
      procedure TrimToFit; inline;
      function  Contains(constref aCol: TCol): Boolean; override;
      function  TryGetValue(constref aCol: TCol; out aValue: TValue): Boolean; override;
    { returns True if not contains aCol was added, False otherwise }
      function  Add(constref aCol: TCol; constref aValue: TValue): Boolean; override;
      procedure AddOrSetValue(const aCol: TCol; const aValue: TValue); override;
      function  Remove(constref aCol: TCol): Boolean; override;
    end;

   function  CreateRowMap: TCustomRowMap; override;
  public
    destructor Destroy; override;
    procedure TrimToFit; override;
  end;

  { TGListTable2DR assumes that TRow implements TRowEqRel }
  generic TGListTable2DR<TRow, TCol, TValue, TColCmpRel> = class(
    specialize TGListTable2D<TRow, TCol, TValue, TRow, TColCmpRel>);

  { TGListTable2DC assumes that TCol implements TColCmpRel }
  generic TGListTable2DC<TRow, TCol, TValue, TRowEqRel> = class(
    specialize TGListTable2D<TRow, TCol, TValue, TRowEqRel, TCol>);

  { TGListTable2D2 assumes that TRow implements TRowEqRel and TCol implements TColCmpRel }
  generic TGListTable2D2<TRow, TCol, TValue> = class(
    specialize TGListTable2D<TRow, TCol, TValue, TRow, TCol>);

implementation
{$B-}{$COPERATORS ON}

{ TGCustomHashTable2D.TColEnumerable }

function TGCustomHashTable2D.TColEnumerable.GetCurrent: TColData;
begin
  Result.Row := FEnum.Current^.Key;
  Result.Value := FCurrValue;
end;

constructor TGCustomHashTable2D.TColEnumerable.Create(aTable: TGCustomHashTable2D; constref ACol: TCol);
begin
  inherited Create;
  FEnum := aTable.FRowTable.GetEnumerator;
  FCol := aCol;
  FCurrValue := Default(TValue);
end;

function TGCustomHashTable2D.TColEnumerable.MoveNext: Boolean;
begin
  repeat
    if not FEnum.MoveNext then
      exit(False);
    Result := FEnum.Current^.Columns.TryGetValue(FCol, FCurrValue);
  until Result;
end;

procedure TGCustomHashTable2D.TColEnumerable.Reset;
begin
  FEnum.Reset;
  FCurrValue := Default(TValue);
end;

{ TGCustomHashTable2D.TCellEnumerable }

function TGCustomHashTable2D.TCellEnumerable.GetCurrent: TCellData;
begin
  Result.Row := FEnum.Current^.Key;
  Result.Column := FCurrRowEntry.Column;
  Result.Value := FCurrRowEntry.Value;
end;

constructor TGCustomHashTable2D.TCellEnumerable.Create(aTable: TGCustomHashTable2D);
begin
  inherited Create;
  FEnum :=  aTable.FRowTable.GetEnumerator;
  FCurrRowEntry := Default(TRowData);
end;

destructor TGCustomHashTable2D.TCellEnumerable.Destroy;
begin
  FRowEnum.Free;
  inherited;
end;

function TGCustomHashTable2D.TCellEnumerable.MoveNext: Boolean;
begin
  repeat
    if not Assigned(FRowEnum) then
      begin
        if not FEnum.MoveNext then
          exit(False);
        FRowEnum := FEnum.Current^.Columns.GetEnumerator;
      end;
    Result := FRowEnum.MoveNext;
    if not Result then
      FreeAndNil(FRowEnum)
    else
      FCurrRowEntry := FRowEnum.Current;
  until Result;
end;

procedure TGCustomHashTable2D.TCellEnumerable.Reset;
begin
  FEnum.Reset;
  FreeAndNil(FRowEnum);
  FCurrRowEntry := Default(TRowData);
end;

{ TGCustomHashTable2D.TRowEnumerable }

function TGCustomHashTable2D.TRowEnumerable.GetCurrent: TRow;
begin
  Result := FEnum.Current^.Key;
end;

constructor TGCustomHashTable2D.TRowEnumerable.Create(aTable: TGCustomHashTable2D);
begin
  inherited Create;
  FEnum := aTable.FRowTable.GetEnumerator;
end;

function TGCustomHashTable2D.TRowEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomHashTable2D.TRowEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomHashTable2D.TRowMapEnumerable }

function TGCustomHashTable2D.TRowMapEnumerable.GetCurrent: IRowMap;
begin
  Result := FEnum.Current^.Columns;
end;

constructor TGCustomHashTable2D.TRowMapEnumerable.Create(aTable: TGCustomHashTable2D);
begin
  inherited Create;
  FEnum := aTable.FRowTable.GetEnumerator;
end;

function TGCustomHashTable2D.TRowMapEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomHashTable2D.TRowMapEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomHashTable2D }

function TGCustomHashTable2D.GetFillRatio: Single;
begin
  Result := FRowTable.FillRatio;
end;

function TGCustomHashTable2D.GetLoadFactor: Single;
begin
  Result := FRowTable.LoadFactor;
end;

procedure TGCustomHashTable2D.SetLoadFactor(aValue: Single);
begin
  FRowTable.LoadFactor := aValue;
end;

procedure TGCustomHashTable2D.ClearItems;
var
  p: TRowHashTable.PEntry;
begin
  for p in FRowTable do
    p^.Columns.Free;
end;

function TGCustomHashTable2D.GetRowCount: SizeInt;
begin
  Result := FRowTable.Count;
end;

function TGCustomHashTable2D.DoFindRow(constref aRow: TRow): PRowEntry;
var
  Pos: SizeInt;
begin
  Result := FRowTable.Find(aRow, Pos);
end;

function TGCustomHashTable2D.DoFindOrAddRow(constref aRow: TRow; out p: PRowEntry): Boolean;
var
  Pos: SizeInt;
begin
  Result := FRowTable.FindOrAdd(aRow, p, Pos);
  if not Result then
    begin
      p^.Key := aRow;
      p^.Columns := CreateRowMap;
    end;
end;

function TGCustomHashTable2D.DoRemoveRow(constref aRow: TRow): SizeInt;
var
  Pos: SizeInt;
  p: PRowEntry;
begin
  p := FRowTable.Find(aRow, Pos);
  if p <> nil then
    begin
      Result := p^.Columns.Count;
      p^.Columns.Free;
      FRowTable.RemoveAt(Pos);
    end
  else
    Result := 0;
end;

function TGCustomHashTable2D.GetColumn(const aCol: TCol): IColDataEnumerable;
begin
  Result := TColEnumerable.Create(Self, aCol);
end;

function TGCustomHashTable2D.GetCellData: ICellDataEnumerable;
begin
  Result := TCellEnumerable.Create(Self);
end;

constructor TGCustomHashTable2D.Create;
begin
  FRowTable := TRowHashTable.Create;
end;

constructor TGCustomHashTable2D.Create(aRowCapacity: SizeInt);
begin
  FRowTable := TRowHashTable.Create(aRowCapacity);
end;

constructor TGCustomHashTable2D.Create(aLoadFactor: Single);
begin
  FRowTable := TRowHashTable.Create(aLoadFactor);
end;

constructor TGCustomHashTable2D.Create(aRowCapacity: SizeInt; aLoadFactor: Single);
begin
  FRowTable := TRowHashTable.Create(aRowCapacity, aLoadFactor);
end;

procedure TGCustomHashTable2D.Clear;
begin
  ClearItems;
  FRowTable.Clear;
end;

procedure TGCustomHashTable2D.EnsureRowCapacity(aValue: SizeInt);
begin
  FRowTable.EnsureCapacity(aValue);
end;

function TGCustomHashTable2D.RowEnum: IRowEnumerable;
begin
  Result := TRowEnumerable.Create(Self);
end;

function TGCustomHashTable2D.RowMapEnum: IRowMapEnumerable;
begin
  Result := TRowMapEnumerable.Create(Self);
end;

{ TGHashTable2D.TRowMap.TEnumerator }

function TGHashTable2D.TRowMap.TEnumerator.GetCurrent: TRowData;
begin
  Result.Column := FEnum.Current^.Key;
  Result.Value := FEnum.Current^.Value;
end;

constructor TGHashTable2D.TRowMap.TEnumerator.Create(aMap: TRowMapTable);
begin
  FEnum := aMap.GetEnumerator;
end;

function TGHashTable2D.TRowMap.TEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGHashTable2D.TRowMap.TEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGHashTable2D.TRowMap }

function TGHashTable2D.TRowMap.GetCount: SizeInt;
begin
  Result := FMap.Count;
end;

constructor TGHashTable2D.TRowMap.Create(aTable: TCustomTable2D);
begin
  FMap := TRowMapTable.Create(INITIAL_CAPACITY, LOAD_FACTOR);
  FTable := aTable;
end;

destructor TGHashTable2D.TRowMap.Destroy;
begin
  FTable.FCellCount -= FMap.Count;
  FMap.Free;
  inherited;
end;

function TGHashTable2D.TRowMap.GetEnumerator: TRowDataEnumerator;
begin
  Result := TEnumerator.Create(Self.FMap);
end;

procedure TGHashTable2D.TRowMap.TrimToFit;
begin
  FMap.TrimToFit;
end;

function TGHashTable2D.TRowMap.Contains(constref aCol: TCol): Boolean;
var
  p: SizeInt;
begin
  Result := FMap.Find(aCol, p) <> nil;
end;

function TGHashTable2D.TRowMap.TryGetValue(constref aCol: TCol; out aValue: TValue): Boolean;
var
  Pos: SizeInt;
  p: PEntry;
begin
  p := FMap.Find(aCol, Pos);
  Result := p <> nil;
  if Result then
    aValue := p^.Value;
end;

function TGHashTable2D.TRowMap.Add(constref aCol: TCol; constref aValue: TValue): Boolean;
var
  Pos: SizeInt;
  p: PEntry;
begin
  Result := not FMap.FindOrAdd(aCol, p, Pos);
  if Result then
    begin
      p^.Key := aCol;
      p^.Value := aValue;
      Inc(FTable.FCellCount);
    end;
end;

procedure TGHashTable2D.TRowMap.AddOrSetValue(const aCol: TCol; const aValue: TValue);
var
  Pos: SizeInt;
  p: PEntry;
begin
  if FMap.FindOrAdd(aCol, p, Pos) then
    p^.Value := aValue
  else
    begin
      p^.Key := aCol;
      p^.Value := aValue;
      Inc(FTable.FCellCount);
    end;
end;

function TGHashTable2D.TRowMap.Remove(constref aCol: TCol): Boolean;
begin
  Result := FMap.Remove(aCol);
  FTable.FCellCount -= Ord(Result);
end;

{ TGHashTable2D }

function TGHashTable2D.CreateRowMap: TCustomRowMap;
begin
  Result := TRowMap.Create(Self);
end;

destructor TGHashTable2D.Destroy;
begin
  Clear;
  FRowTable.Free;
  inherited;
end;

procedure TGHashTable2D.TrimToFit;
var
  p: PRowEntry;
begin
  for p in FRowTable do
    if p^.Columns.IsEmpty then
      FRowTable.Remove(p^.Key)
    else
      TRowMap(p^.Columns).TrimToFit;
  FRowTable.TrimToFit;
end;

{ TGTreeTable2D.TRowMap.TEnumerator }

function TGTreeTable2D.TRowMap.TEnumerator.GetCurrent: TRowData;
begin
  Result.Column := FEnum.Current^.Key;
  Result.Value := FEnum.Current^.Value;
end;

constructor TGTreeTable2D.TRowMap.TEnumerator.Create(aMap: TRowMapTable);
begin
  FEnum := aMap.GetEnumerator;
end;

function TGTreeTable2D.TRowMap.TEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGTreeTable2D.TRowMap.TEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGTreeTable2D.TRowMap }

function TGTreeTable2D.TRowMap.GetCount: SizeInt;
begin
  Result := FMap.Count;
end;

constructor TGTreeTable2D.TRowMap.Create(aTable: TGTreeTable2D);
begin
  FMap := TRowMapTable.Create(aTable.FNodeManager);
  FTable := aTable;
end;

destructor TGTreeTable2D.TRowMap.Destroy;
begin
  FTable.FCellCount -= FMap.Count;
  FMap.Free;
  inherited;
end;

function TGTreeTable2D.TRowMap.GetEnumerator: TRowDataEnumerator;
begin
  Result := TEnumerator.Create(Self.FMap);
end;

function TGTreeTable2D.TRowMap.Contains(constref aCol: TCol): Boolean;
begin
  Result := FMap.Find(aCol) <> nil;
end;

function TGTreeTable2D.TRowMap.TryGetValue(constref aCol: TCol; out aValue: TValue): Boolean;
var
  Pos: SizeInt;
  p: PNode;
begin
  p := FMap.Find(aCol);
  Result := p <> nil;
  if Result then
    aValue := p^.Data.Value;
end;

function TGTreeTable2D.TRowMap.Add(constref aCol: TCol; constref aValue: TValue): Boolean;
var
  Pos: SizeInt;
  p: PNode;
begin
  Result := not FMap.FindOrAdd(aCol, p);
  if Result then
    begin
      p^.Data.Value := aValue;
      Inc(FTable.FCellCount);
    end;
end;

procedure TGTreeTable2D.TRowMap.AddOrSetValue(const aCol: TCol; const aValue: TValue);
var
  Pos: SizeInt;
  p: PNode;
begin
  if not FMap.FindOrAdd(aCol, p) then
    Inc(FTable.FCellCount);
  p^.Data.Value := aValue;
end;

function TGTreeTable2D.TRowMap.Remove(constref aCol: TCol): Boolean;
begin
  Result := FMap.Remove(aCol);
  FTable.FCellCount -= Ord(Result);
end;

{ TGTreeTable2D }

function TGTreeTable2D.CreateRowMap: TCustomRowMap;
begin
  Result := TRowMap.Create(Self);
end;

constructor TGTreeTable2D.Create;
begin
  inherited Create;
  FNodeManager := TNodeManager.Create;
end;

constructor TGTreeTable2D.Create(aRowCapacity: SizeInt);
begin
  inherited Create(aRowCapacity);
  FNodeManager := TNodeManager.Create;
end;

constructor TGTreeTable2D.Create(aLoadFactor: Single);
begin
  inherited Create(aLoadFactor);
  FNodeManager := TNodeManager.Create;
end;

constructor TGTreeTable2D.Create(aRowCapacity: SizeInt; aLoadFactor: Single);
begin
  inherited Create(aRowCapacity, aLoadFactor);
  FNodeManager := TNodeManager.Create;
end;

destructor TGTreeTable2D.Destroy;
begin
  Clear;
  FRowTable.Free;
  FNodeManager.Free;
  inherited;
end;

procedure TGTreeTable2D.Clear;
begin
  inherited;
  FNodeManager.Clear;
end;

procedure TGTreeTable2D.TrimToFit;
var
  p: PRowEntry;
begin
  for p in FRowTable do
    if p^.Columns.IsEmpty then
      FRowTable.Remove(p^.Key);
  FRowTable.TrimToFit;
  if CellCount = 0 then
    FNodeManager.Clear;
end;

{ TGListTable2D.TRowMap.TEnumerator }

function TGListTable2D.TRowMap.TEnumerator.GetCurrent: TRowData;
begin
  Result.Column := FEnum.Current^.Key;
  Result.Value := FEnum.Current^.Value;
end;

constructor TGListTable2D.TRowMap.TEnumerator.Create(aMap: TRowMapTable);
begin
  FEnum := aMap.GetEnumerator;
end;

function TGListTable2D.TRowMap.TEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGListTable2D.TRowMap.TEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGListTable2D.TRowMap }

function TGListTable2D.TRowMap.GetCount: SizeInt;
begin
  Result := FMap.Count;
end;

constructor TGListTable2D.TRowMap.Create(aTable: TCustomTable2D);
begin
  FMap := TRowMapTable.Create(INITIAL_CAPACITY);
  FTable := aTable;
end;

destructor TGListTable2D.TRowMap.Destroy;
begin
  FTable.FCellCount -= FMap.Count;
  FMap.Free;
  inherited;
end;

function TGListTable2D.TRowMap.GetEnumerator: TRowDataEnumerator;
begin
  Result := TEnumerator.Create(Self.FMap);
end;

procedure TGListTable2D.TRowMap.TrimToFit;
begin
  FMap.TrimToFit;
end;

function TGListTable2D.TRowMap.Contains(constref aCol: TCol): Boolean;
var
  I: SizeInt;
begin
  Result := FMap.Find(aCol, I) <> nil;
end;

function TGListTable2D.TRowMap.TryGetValue(constref aCol: TCol; out aValue: TValue): Boolean;
var
  I: SizeInt;
  p: PEntry;
begin
  p := FMap.Find(aCol, I);
  Result := p <> nil;
  if Result then
    aValue := p^.Value;
end;

function TGListTable2D.TRowMap.Add(constref aCol: TCol; constref aValue: TValue): Boolean;
var
  I: SizeInt;
  p: PEntry;
begin
  Result := not FMap.FindOrAdd(aCol, p, I);
  if Result then
    begin
      p^.Value := aValue;
      Inc(FTable.FCellCount);
    end;
end;

procedure TGListTable2D.TRowMap.AddOrSetValue(const aCol: TCol; const aValue: TValue);
var
  I: SizeInt;
  p: PEntry;
begin
  if not FMap.FindOrAdd(aCol, p, I) then
    Inc(FTable.FCellCount);
  p^.Value := aValue;
end;

function TGListTable2D.TRowMap.Remove(constref aCol: TCol): Boolean;
begin
  Result := FMap.Remove(aCol);
  FTable.FCellCount -= Ord(Result);
end;

{ TGListTable2D }

function TGListTable2D.CreateRowMap: TCustomRowMap;
begin
  Result := TRowMap.Create(Self);
end;

destructor TGListTable2D.Destroy;
begin
  Clear;
  FRowTable.Free;
  inherited;
end;

procedure TGListTable2D.TrimToFit;
var
  p: PRowEntry;
begin
  for p in FRowTable do
    if p^.Columns.IsEmpty then
      FRowTable.Remove(p^.Key)
    else
      TRowMap(p^.Columns).TrimToFit;
  FRowTable.TrimToFit;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic sorted map implementations on top of AVL tree.                  *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGTreeMap;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGAvlTree;

type

  { TGCustomTreeMap:  common abstract tree map ancestor }
  generic TGCustomTreeMap<TKey, TValue> = class abstract(specialize TGCustomMap<TKey, TValue>)
  public
  type
    TCustomTreeMap = specialize TGCustomTreeMap<TKey, TValue>;

  protected
  type
    TTree          = specialize TGCustomAvlTree<TKey, TEntry>;
    PNode          = TTree.PNode;

    TKeyEnumerable = class(TCustomKeyEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      function  GetCurrent: TKey; override;
    public
      constructor Create(aMap: TCustomTreeMap; aReverse: Boolean = False);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TValueEnumerable = class(TCustomValueEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      function  GetCurrent: TValue; override;
    public
      constructor Create(aMap: TCustomTreeMap; aReverse: Boolean = False);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TEntryEnumerable = class(TCustomEntryEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      function  GetCurrent: TEntry; override;
    public
      constructor Create(aMap: TCustomTreeMap; aReverse: Boolean = False);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TKeyTailEnumerable = class(TCustomKeyEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      function  GetCurrent: TKey; override;
    public
      constructor Create(constref aLowBound: TKey; aMap: TCustomTreeMap; aInclusive: Boolean);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FTree: TTree;
    function  GetCount: SizeInt; override;
    function  GetCapacity: SizeInt; override;
    function  Find(constref aKey: TKey): PEntry; override;
    //return True if aKey found, otherwise insert (garbage) pair and return False;
    function  FindOrAdd(constref aKey: TKey; out p: PEntry): Boolean; override;
    function  DoExtract(constref aKey: TKey; out v: TValue): Boolean; override;
    function  DoRemoveIf(aTest: TKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestKeyTest): SizeInt; override;
    function  DoExtractIf(aTest: TKeyTest): TEntryArray; override;
    function  DoExtractIf(aTest: TOnKeyTest): TEntryArray; override;
    function  DoExtractIf(aTest: TNestKeyTest): TEntryArray; override;
    procedure DoClear; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    procedure DoTrimToFit; override;
    function  GetKeys: IKeyEnumerable; override;
    function  GetValues: IValueEnumerable; override;
    function  GetEntries: IEntryEnumerable; override;
    function  FindNearestLT(constref aPattern: TKey; out aKey: TKey): Boolean;
    function  FindNearestLE(constref aPattern: TKey; out aKey: TKey): Boolean;
    function  FindNearestGT(constref aPattern: TKey; out aKey: TKey): Boolean;
    function  FindNearestGE(constref aPattern: TKey; out aKey: TKey): Boolean;
  public
    destructor Destroy; override;
    function ReverseKeys: IKeyEnumerable;
    function ReverseValues: IValueEnumerable;
    function ReverseEntries: IEntryEnumerable;
    function FindFirstKey(out aKey: TKey): Boolean;
    function FirstKey: TKeyOptional;
    function FindLastKey(out aKey: TKey): Boolean;
    function LastKey: TKeyOptional;
    function FindFirstValue(out aValue: TValue): Boolean;
    function FirstValue: TValueOptional;
    function FindLastValue(out aValue: TValue): Boolean;
    function LastValue: TValueOptional;
    function FindMin(out aKey: TKey): Boolean; inline;
    function Min: TKeyOptional; inline;
    function FindMax(out aKey: TKey): Boolean; inline;
    function Max: TKeyOptional; inline;
  { returns True if exists key whose value greater then or equal to aKey (depend on aInclusive) }
    function FindCeilKey(constref aKey: TKey; out aCeil: TKey; aInclusive: Boolean = True): Boolean;
  { returns True if exists key whose value less then aBound (or equal to aKey depend on aInclusive) }
    function FindFloorKey(constref aKey: TKey; out aFloor: TKey; aInclusive: Boolean = False): Boolean;
  { enumerates keys which are strictly less than(if not aInclusive) aHighBound }
    function Head(constref aHighBound: TKey; aInclusive: Boolean = False): IKeyEnumerable; virtual; abstract;
  { enumerates keys whose are greater than or equal to aLowBound(if aInclusive) }
    function Tail(constref aLowBound: TKey; aInclusive: Boolean = True): IKeyEnumerable;
  { enumerates keys which are greater than or equal to aLowBound and strictly less than aHighBound(by default) }
    function Range(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): IKeyEnumerable;
      virtual; abstract;
  { returns sorted map whose keys are strictly less than(if not aInclusive) aHighBound }
    function HeadMap(constref aHighBound: TKey; aInclusive: Boolean = False): TCustomTreeMap; virtual; abstract;
  { returns sorted map whose keys are greater than or equal to(if aInclusive) aLowBound }
    function TailMap(constref aLowBound: TKey; aInclusive: Boolean = True): TCustomTreeMap; virtual; abstract;
  { returns sorted map whose keys are greater than or equal to aLowBound and strictly less than
    aHighBound(by default) }
    function SubMap(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): TCustomTreeMap;
      virtual; abstract;
  end;


  { TGBaseTreeMap implements sorted map;
     functor TKeyCmpRel (key comparision relation) must provide:
       class function Compare([const[ref]] L, R: TKey): SizeInt;  }
  generic TGBaseTreeMap<TKey, TValue, TKeyCmpRel> = class(specialize TGCustomTreeMap<TKey, TValue>)
  protected
  type
    TBaseTree  = specialize TGAvlTree<TKey, TEntry, TKeyCmpRel>;

    TKeyHeadEnumerable = class(TCustomKeyEnumerable)
    private
      FEnum: TTree.TEnumerator;
      FHighBound: TKey;
      FInclusive,
      FDone: Boolean;
    protected
      function  GetCurrent: TKey; override;
    public
      constructor Create(constref aHighBound: TKey; aMap: TCustomTreeMap; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TKeyRangeEnumerable = class(TKeyHeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: TKey; aMap: TCustomTreeMap; aBounds: TRangeBounds); overload;
    end;

    class function DoCompare(constref L, R: TKey): SizeInt; static;
  public
  type
    TComparator = specialize TGCompare<TKey>;
    class function Comparator: TComparator; static; inline;
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref a: array of TEntry);
    constructor Create(e: IEntryEnumerable);
    constructor CreateCopy(aMap: TGBaseTreeMap);
    function Clone: TGBaseTreeMap; override;
    function Head(constref aHighBound: TKey; aInclusive: Boolean = False): IKeyEnumerable; override;
    function Range(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): IKeyEnumerable;
      override;
    function HeadMap(constref aHighBound: TKey; aInclusive: Boolean = False): TGBaseTreeMap; override;
    function TailMap(constref aLowBound: TKey; aInclusive: Boolean = True): TGBaseTreeMap; override;
    function SubMap(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): TGBaseTreeMap;
      override;
  end;

  { TGTreeMap implements sorted map; it assumes that type TKey implements TKeyCmpRel}
  generic TGTreeMap<TKey, TValue> = class(specialize TGBaseTreeMap<TKey, TValue, TKey>);

  { TGObjectTreeMap
    note: for equality comparision of Values used TObjectHelper from LGHelpers }
  generic TGObjectTreeMap<TKey, TValue, TKeyCmpRel> = class(specialize TGBaseTreeMap<TKey, TValue, TKeyCmpRel>)
  protected
    FOwnsKeys: Boolean;
    FOwnsValues: Boolean;
    procedure EntryRemoving(p: PEntry);
    procedure SetOwnership(aOwns: TMapObjOwnership);
    function  DoRemove(constref aKey: TKey): Boolean; override;
    function  DoRemoveIf(aTest: TKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestKeyTest): SizeInt; override;
    procedure DoClear; override;
    function  DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean; override;
    function  DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean; override;
  public
    constructor Create(aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(constref a: array of TEntry; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(e: IEntryEnumerable; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor CreateCopy(aMap: TGObjectTreeMap);
    function  Clone: TGObjectTreeMap; override;
    property  OwnsKeys: Boolean read FOwnsKeys write FOwnsKeys;
    property  OwnsValues: Boolean read FOwnsValues write FOwnsValues;
  end;

  generic TGObjTreeMap<TKey, TValue> = class(specialize TGObjectTreeMap<TKey, TValue, TKey>);

  { TGComparableTreeMap implements sorted map; it assumes that type T has defined comparision operators }
  generic TGComparableTreeMap<TKey, TValue> = class(specialize TGCustomTreeMap<TKey, TValue>)
  protected
  type
    TComparableTree = specialize TGComparableAvlTree<TKey, TEntry>;

    TKeyHeadEnumerable = class(TCustomKeyEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FHighBound: TKey;
      FInclusive,
      FDone: Boolean;
      function  GetCurrent: TKey; override;
    public
      constructor Create(constref aHighBound: TKey; aMap: TCustomTreeMap; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TKeyRangeEnumerable = class(TKeyHeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: TKey; aMap: TCustomTreeMap; aBounds: TRangeBounds); overload;
    end;

    class function DoCompare(constref L, R: TKey): SizeInt; static;
  public
  type
    TComparator = specialize TGCompare<TKey>;
    class function Comparator: TComparator; static; inline;
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref a: array of TEntry);
    constructor Create(e: IEntryEnumerable);
    constructor CreateCopy(aMap: TGComparableTreeMap);
    function Clone: TGComparableTreeMap; override;
    function Head(constref aHighBound: TKey; aInclusive: Boolean = False): IKeyEnumerable; override;
    function Range(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): IKeyEnumerable;
      override;
    function HeadMap(constref aHighBound: TKey; aInclusive: Boolean = False): TGComparableTreeMap; override;
    function TailMap(constref aLowBound: TKey; aInclusive: Boolean = True): TGComparableTreeMap; override;
    function SubMap(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): TGComparableTreeMap;
      override;
  end;

  { TGRegularTreeMap implements sorted map with regular comparator }
  generic TGRegularTreeMap<TKey, TValue> = class(specialize TGCustomTreeMap<TKey, TValue>)
  public
  type
    TComparator = specialize TGCompare<TKey>;

  protected
  type
    TRegularTree  = specialize TGRegularAvlTree<TKey, TEntry>;

    TKeyHeadEnumerable = class(TCustomKeyEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FCompare: TComparator;
      FHighBound: TKey;
      FInclusive,
      FDone: Boolean;
      function  GetCurrent: TKey; override;
    public
      constructor Create(constref aHighBound: TKey; aMap: TCustomTreeMap; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TKeyRangeEnumerable = class(TKeyHeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: TKey; aMap: TCustomTreeMap; aBounds: TRangeBounds); overload;
    end;

  public
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref a: array of TEntry; c: TComparator);
    constructor Create(e: IEntryEnumerable; c: TComparator);
    constructor CreateCopy(aMap: TGRegularTreeMap);
    function Comparator: TComparator; inline;
    function Clone: TGRegularTreeMap; override;
    function Head(constref aHighBound: TKey; aInclusive: Boolean = False): IKeyEnumerable; override;
    function Range(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): IKeyEnumerable;
      override;
    function HeadMap(constref aHighBound: TKey; aInclusive: Boolean = False): TGRegularTreeMap; override;
    function TailMap(constref aLowBound: TKey; aInclusive: Boolean = True): TGRegularTreeMap; override;
    function SubMap(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): TGRegularTreeMap;
      override;
  end;

  { TGObjectRegularTreeMap
    note: for equality comparision of Values used TObjectHelper from LGHelpers }
  generic TGObjectRegularTreeMap<TKey, TValue> = class(specialize TGRegularTreeMap<TKey, TValue>)
  protected
    FOwnsKeys: Boolean;
    FOwnsValues: Boolean;
    procedure EntryRemoving(p: PEntry);
    procedure SetOwnership(aOwns: TMapObjOwnership);
    function  DoRemove(constref aKey: TKey): Boolean; override;
    function  DoRemoveIf(aTest: TKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestKeyTest): SizeInt; override;
    procedure DoClear; override;
    function  DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean; override;
    function  DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean; override;
  public
    constructor Create(aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(c: TComparator; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; c: TComparator; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(constref a: array of TEntry; c: TComparator; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(e: IEntryEnumerable; c: TComparator; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor CreateCopy(aMap: TGObjectRegularTreeMap);
    function  Clone: TGObjectRegularTreeMap; override;
    property  OwnsKeys: Boolean read FOwnsKeys write FOwnsKeys;
    property  OwnsValues: Boolean read FOwnsValues write FOwnsValues;
  end;

  { TGDelegatedTreeMap implements sorted map with delegated comparator }
  generic TGDelegatedTreeMap<TKey, TValue> = class(specialize TGCustomTreeMap<TKey, TValue>)
  public
  type
    TComparator = specialize TGOnCompare<TKey>;

  protected
  type
    TDelegatedTree  = specialize TGDelegatedAvlTree<TKey, TEntry>;

    TKeyHeadEnumerable = class(TCustomKeyEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FCompare: TComparator;
      FHighBound: TKey;
      FInclusive,
      FDone: Boolean;
      function  GetCurrent: TKey; override;
    public
      constructor Create(constref aHighBound: TKey; aMap: TCustomTreeMap; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TKeyRangeEnumerable = class(TKeyHeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: TKey; aMap: TCustomTreeMap; aBounds: TRangeBounds); overload;
    end;

  public
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref a: array of TEntry; c: TComparator);
    constructor Create(e: IEntryEnumerable; c: TComparator);
    constructor CreateCopy(aMap: TGDelegatedTreeMap);
    function Comparator: TComparator;
    function Clone: TGDelegatedTreeMap; override;

    function Head(constref aHighBound: TKey; aInclusive: Boolean = False): IKeyEnumerable; override;
    function Range(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): IKeyEnumerable;
      override;
    function HeadMap(constref aHighBound: TKey; aInclusive: Boolean = False): TGDelegatedTreeMap; override;
    function TailMap(constref aLowBound: TKey; aInclusive: Boolean = True): TGDelegatedTreeMap; override;
    function SubMap(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds = [rbLow]): TGDelegatedTreeMap;
      override;
  end;

  { TGObjectDelegatedTreeMap
    note: for equality comparision of Values used TObjectHelper from LGHelpers }
  generic TGObjectDelegatedTreeMap<TKey, TValue> = class(specialize TGDelegatedTreeMap<TKey, TValue>)
  protected
    FOwnsKeys: Boolean;
    FOwnsValues: Boolean;
    procedure EntryRemoving(p: PEntry);
    procedure SetOwnership(aOwns: TMapObjOwnership);
    function  DoRemove(constref aKey: TKey): Boolean; override;
    function  DoRemoveIf(aTest: TKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnKeyTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestKeyTest): SizeInt; override;
    procedure DoClear; override;
    function  DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean; override;
    function  DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean; override;
  public
    constructor Create(aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(c: TComparator; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(aCapacity: SizeInt; c: TComparator; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(constref a: array of TEntry; c: TComparator; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor Create(e: IEntryEnumerable; c: TComparator; aOwns: TMapObjOwnership = OWNS_BOTH);
    constructor CreateCopy(aMap: TGObjectDelegatedTreeMap);
    function  Clone: TGObjectDelegatedTreeMap; override;
    property  OwnsKeys: Boolean read FOwnsKeys write FOwnsKeys;
    property  OwnsValues: Boolean read FOwnsValues write FOwnsValues;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGCustomTreeMap.TKeyEnumerable }

function TGCustomTreeMap.TKeyEnumerable.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGCustomTreeMap.TKeyEnumerable.Create(aMap: TCustomTreeMap; aReverse: Boolean);
begin
  inherited Create(aMap);
  if aReverse then
    FEnum := aMap.FTree.GetReverseEnumerator
  else
    FEnum := aMap.FTree.GetEnumerator;
end;

destructor TGCustomTreeMap.TKeyEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeMap.TKeyEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomTreeMap.TKeyEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomTreeMap.TValueEnumerable }

function TGCustomTreeMap.TValueEnumerable.GetCurrent: TValue;
begin
  Result := FEnum.Current^.Data.Value;
end;

constructor TGCustomTreeMap.TValueEnumerable.Create(aMap: TCustomTreeMap; aReverse: Boolean);
begin
  inherited Create(aMap);
  if aReverse then
    FEnum := aMap.FTree.GetReverseEnumerator
  else
    FEnum := aMap.FTree.GetEnumerator;
end;

destructor TGCustomTreeMap.TValueEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeMap.TValueEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomTreeMap.TValueEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGBaseTreeMap.TEntryEnumerable }

function TGCustomTreeMap.TEntryEnumerable.GetCurrent: TEntry;
begin
  Result := FEnum.Current^.Data;
end;

constructor TGCustomTreeMap.TEntryEnumerable.Create(aMap: TCustomTreeMap; aReverse: Boolean);
begin
  inherited Create(aMap);
  if aReverse then
    FEnum := aMap.FTree.GetReverseEnumerator
  else
    FEnum := aMap.FTree.GetEnumerator;
end;

destructor TGCustomTreeMap.TEntryEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeMap.TEntryEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomTreeMap.TEntryEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomTreeMap.TKeyTailEnumerable }

function TGCustomTreeMap.TKeyTailEnumerable.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGCustomTreeMap.TKeyTailEnumerable.Create(constref aLowBound: TKey; aMap: TCustomTreeMap;
  aInclusive: Boolean);
begin
  inherited Create(aMap);
  FEnum := aMap.FTree.GetEnumeratorAt(aLowBound, aInclusive);
end;

destructor TGCustomTreeMap.TKeyTailEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeMap.TKeyTailEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomTreeMap.TKeyTailEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomTreeMap }

function TGCustomTreeMap.GetCount: SizeInt;
begin
  Result := FTree.Count;
end;

function TGCustomTreeMap.GetCapacity: SizeInt;
begin
  Result := FTree.Capacity;
end;

function TGCustomTreeMap.Find(constref aKey: TKey): PEntry;
var
  Node: PNode;
begin
  Node := FTree.Find(aKey);
  if Node <> nil then
    Result := @Node^.Data
  else
    Result := nil;
end;

function TGCustomTreeMap.FindOrAdd(constref aKey: TKey; out p: PEntry): Boolean;
var
  Node: PNode;
begin
  Result := FTree.FindOrAdd(aKey, Node);
  p := @Node^.Data;
end;

function TGCustomTreeMap.DoExtract(constref aKey: TKey; out v: TValue): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Find(aKey);
  Result := Node <> nil;
  if Result then
    begin
      v := Node^.Data.Value;
      FTree.RemoveNode(Node);
    end;
end;

function TGCustomTreeMap.DoRemoveIf(aTest: TKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest);
end;

function TGCustomTreeMap.DoRemoveIf(aTest: TOnKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest);
end;

function TGCustomTreeMap.DoRemoveIf(aTest: TNestKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest);
end;

function TGCustomTreeMap.DoExtractIf(aTest: TKeyTest): TEntryArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTree.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

function TGCustomTreeMap.DoExtractIf(aTest: TOnKeyTest): TEntryArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTree.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

function TGCustomTreeMap.DoExtractIf(aTest: TNestKeyTest): TEntryArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTree.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

procedure TGCustomTreeMap.DoClear;
begin
  FTree.Clear;
end;

procedure TGCustomTreeMap.DoEnsureCapacity(aValue: SizeInt);
begin
  FTree.EnsureCapacity(aValue);
end;

procedure TGCustomTreeMap.DoTrimToFit;
begin
  FTree.TrimToFit;
end;

function TGCustomTreeMap.GetKeys: IKeyEnumerable;
begin
  Result := TKeyEnumerable.Create(Self);
end;

function TGCustomTreeMap.GetValues: IValueEnumerable;
begin
  Result := TValueEnumerable.Create(Self);
end;

function TGCustomTreeMap.GetEntries: IEntryEnumerable;
begin
  Result := TEntryEnumerable.Create(Self);
end;

function TGCustomTreeMap.FindNearestLT(constref aPattern: TKey; out aKey: TKey): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindLess(aPattern);
  Result := Node <> nil;
  if Result then
    aKey := Node^.Data.Key;
end;

function TGCustomTreeMap.FindNearestLE(constref aPattern: TKey; out aKey: TKey): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindLessOrEqual(aPattern);
  Result := Node <> nil;
  if Result then
    aKey := Node^.Data.Key;
end;

function TGCustomTreeMap.FindNearestGT(constref aPattern: TKey; out aKey: TKey): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindGreater(aPattern);
  Result := Node <> nil;
  if Result then
    aKey := Node^.Data.Key;
end;

function TGCustomTreeMap.FindNearestGE(constref aPattern: TKey; out aKey: TKey): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindGreaterOrEqual(aPattern);
  Result := Node <> nil;
  if Result then
    aKey := Node^.Data.Key;
end;

destructor TGCustomTreeMap.Destroy;
begin
  DoClear;
  FTree.Free;
  inherited;
end;

function TGCustomTreeMap.ReverseKeys: IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyEnumerable.Create(Self, True);
end;

function TGCustomTreeMap.ReverseValues: IValueEnumerable;
begin
  BeginIteration;
  Result := TValueEnumerable.Create(Self, True);
end;

function TGCustomTreeMap.ReverseEntries: IEntryEnumerable;
begin
  BeginIteration;
  Result := TEntryEnumerable.Create(Self, True);
end;

function TGCustomTreeMap.FindFirstKey(out aKey: TKey): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Lowest;
  Result := Node <> nil;
  if Result then
    aKey := Node^.Data.Key;
end;

function TGCustomTreeMap.FirstKey: TKeyOptional;
var
  k: TKey;
begin
  if FindFirstKey(k) then
    Result.Assign(k);
end;

function TGCustomTreeMap.FindLastKey(out aKey: TKey): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Highest;
  Result := Node <> nil;
  if Result then
    aKey := Node^.Data.Key;
end;

function TGCustomTreeMap.LastKey: TKeyOptional;
var
  k: TKey;
begin
  if FindLastKey(k) then
    Result.Assign(k);
end;

function TGCustomTreeMap.FindFirstValue(out aValue: TValue): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Lowest;
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Value;
end;

function TGCustomTreeMap.FirstValue: TValueOptional;
var
  v: TValue;
begin
  if FindFirstValue(v) then
    Result.Assign(v);
end;

function TGCustomTreeMap.FindLastValue(out aValue: TValue): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Highest;
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Value;
end;

function TGCustomTreeMap.LastValue: TValueOptional;
var
  v: TValue;
begin
  if FindLastValue(v) then
    Result.Assign(v);
end;

function TGCustomTreeMap.FindMin(out aKey: TKey): Boolean;
begin
  Result := FindFirstKey(aKey);
end;

function TGCustomTreeMap.Min: TKeyOptional;
begin
  Result := FirstKey;
end;

function TGCustomTreeMap.FindMax(out aKey: TKey): Boolean;
begin
  Result := FindLastKey(aKey);
end;

function TGCustomTreeMap.Max: TKeyOptional;
begin
  Result := LastKey;
end;

function TGCustomTreeMap.FindCeilKey(constref aKey: TKey; out aCeil: TKey; aInclusive: Boolean): Boolean;
begin
  if aInclusive then
    Result := FindNearestGE(aKey, aCeil)
  else
    Result := FindNearestGT(aKey, aCeil);
end;

function TGCustomTreeMap.FindFloorKey(constref aKey: TKey; out aFloor: TKey; aInclusive: Boolean): Boolean;
begin
  if aInclusive then
    Result := FindNearestLE(aKey, aFloor)
  else
    Result := FindNearestLT(aKey, aFloor);
end;

function TGCustomTreeMap.Tail(constref aLowBound: TKey; aInclusive: Boolean): IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyTailEnumerable.Create(aLowBound, Self, aInclusive);
end;

{ TGBaseTreeMap.TKeyHeadEnumerable }

function TGBaseTreeMap.TKeyHeadEnumerable.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGBaseTreeMap.TKeyHeadEnumerable.Create(constref aHighBound: TKey; aMap: TCustomTreeMap;
  aInclusive: Boolean);
begin
  inherited Create(aMap);
  FEnum := aMap.FTree.GetEnumerator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGBaseTreeMap.TKeyHeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGBaseTreeMap.TKeyHeadEnumerable.MoveNext: Boolean;
begin
  if FDone or not FEnum.MoveNext then
    exit(False);
  if FInclusive then
    Result := TKeyCmpRel.Compare(FEnum.Current^.Data.Key, FHighBound) <= 0
  else
    Result := TKeyCmpRel.Compare(FEnum.Current^.Data.Key, FHighBound) < 0;
  FDone := not Result;
end;

procedure TGBaseTreeMap.TKeyHeadEnumerable.Reset;
begin
  FEnum.Reset;
  FDone := False;
end;

{ TGBaseTreeMap.TKeyRangeEnumerable }

constructor TGBaseTreeMap.TKeyRangeEnumerable.Create(constref aLowBound, aHighBound: TKey;
  aMap: TCustomTreeMap; aBounds: TRangeBounds);
begin
  inherited Create(aMap);
  FEnum := aMap.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGBaseTreeMap }

class function TGBaseTreeMap.DoCompare(constref L, R: TKey): SizeInt;
begin
  Result := TKeyCmpRel.Compare(L, R);
end;

class function TGBaseTreeMap.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

constructor TGBaseTreeMap.Create;
begin
  FTree := TBaseTree.Create;
end;

constructor TGBaseTreeMap.Create(aCapacity: SizeInt);
begin
  FTree := TBaseTree.Create(aCapacity);
end;

constructor TGBaseTreeMap.Create(constref a: array of TEntry);
begin
  FTree := TBaseTree.Create;
  DoAddAll(a);
end;

constructor TGBaseTreeMap.Create(e: IEntryEnumerable);
begin
  FTree := TBaseTree.Create;
  DoAddAll(e);
end;

constructor TGBaseTreeMap.CreateCopy(aMap: TGBaseTreeMap);
begin
  FTree := TBaseTree(aMap.FTree).Clone;
end;

function TGBaseTreeMap.Clone: TGBaseTreeMap;
begin
  Result := TGBaseTreeMap.CreateCopy(Self);
end;

function TGBaseTreeMap.Head(constref aHighBound: TKey; aInclusive: Boolean): IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyHeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGBaseTreeMap.Range(constref aLowBound, aHighBound: TKey; aIncludeBounds: TRangeBounds): IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGBaseTreeMap.HeadMap(constref aHighBound: TKey; aInclusive: Boolean): TGBaseTreeMap;
begin
  Result := TGBaseTreeMap.Create;
  with TKeyHeadEnumerable.Create(aHighBound, Self, aInclusive) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

function TGBaseTreeMap.TailMap(constref aLowBound: TKey; aInclusive: Boolean): TGBaseTreeMap;
begin
  Result := TGBaseTreeMap.Create;
  with TKeyTailEnumerable.Create(aLowBound, Self, aInclusive) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

function TGBaseTreeMap.SubMap(constref aLowBound, aHighBound: TKey;
  aIncludeBounds: TRangeBounds): TGBaseTreeMap;
begin
  Result := TGBaseTreeMap.Create;
  with TKeyRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

{ TGObjectTreeMap }

procedure TGObjectTreeMap.EntryRemoving(p: PEntry);
begin
  if OwnsKeys then
    TObject(p^.Key).Free;
  if OwnsValues then
    TObject(p^.Value).Free;
end;

procedure TGObjectTreeMap.SetOwnership(aOwns: TMapObjOwnership);
begin
  FOwnsKeys := moOwnsKeys in aOwns;
  FOwnsValues := moOwnsValues in aOwns;
end;

function TGObjectTreeMap.DoRemove(constref aKey: TKey): Boolean;
var
  v: TValue;
begin
  Result := DoExtract(aKey, v);
  if Result then
    begin
      if OwnsKeys then
        TObject(aKey).Free;
      if OwnsValues then
        TObject(v).Free;
    end;
end;

function TGObjectTreeMap.DoRemoveIf(aTest: TKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest, @EntryRemoving);
end;

function TGObjectTreeMap.DoRemoveIf(aTest: TOnKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest, @EntryRemoving);
end;

function TGObjectTreeMap.DoRemoveIf(aTest: TNestKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest, @EntryRemoving);
end;

procedure TGObjectTreeMap.DoClear;
var
  Node: PNode;
begin
  if OwnsKeys or OwnsValues then
    for Node in FTree do
      begin
        if OwnsKeys then
          TObject(Node^.Data.Key).Free;
        if OwnsValues then
          TObject(Node^.Data.Value).Free;
      end;
  inherited;
end;

function TGObjectTreeMap.DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean;
var
  p: PEntry;
begin
  p := Find(aKey);
  Result := p <> nil;
  if Result then
    begin
      if OwnsValues and not TObject.Equal(TObject(p^.Value), TObject(aNewValue)) then
        TObject(p^.Value).Free;
      p^.Value := aNewValue;
    end;
end;

function TGObjectTreeMap.DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean;
var
  p: PEntry;
begin
  Result := not FindOrAdd(aKey, p);
  if not Result then
    begin
      if OwnsValues and not TObject.Equal(TObject(p^.Value), TObject(aValue)) then
        TObject(p^.Value).Free;
    end;
  p^.Value := aValue;
end;

constructor TGObjectTreeMap.Create(aOwns: TMapObjOwnership);
begin
  inherited Create;
  SetOwnership(aOwns);
end;

constructor TGObjectTreeMap.Create(aCapacity: SizeInt; aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity);
  SetOwnership(aOwns);
end;

constructor TGObjectTreeMap.Create(constref a: array of TEntry; aOwns: TMapObjOwnership);
begin
  inherited Create(a);
  SetOwnership(aOwns);
end;

constructor TGObjectTreeMap.Create(e: IEntryEnumerable; aOwns: TMapObjOwnership);
begin
  inherited Create(e);
  SetOwnership(aOwns);
end;

constructor TGObjectTreeMap.CreateCopy(aMap: TGObjectTreeMap);
begin
  inherited CreateCopy(aMap);
  OwnsKeys := aMap.OwnsKeys;
  OwnsValues := aMap.OwnsValues;
end;

function TGObjectTreeMap.Clone: TGObjectTreeMap;
begin
  Result := TGObjectTreeMap.CreateCopy(Self)
end;


{ TGComparableTreeMap.TKeyHeadEnumerable }

function TGComparableTreeMap.TKeyHeadEnumerable.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGComparableTreeMap.TKeyHeadEnumerable.Create(constref aHighBound: TKey; aMap: TCustomTreeMap;
  aInclusive: Boolean);
begin
  inherited Create(aMap);
  FEnum := aMap.FTree.GetEnumerator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGComparableTreeMap.TKeyHeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGComparableTreeMap.TKeyHeadEnumerable.MoveNext: Boolean;
begin
  if FDone or not FEnum.MoveNext then
    exit(False);
  if FInclusive then
    Result := FEnum.Current^.Data.Key <= FHighBound
  else
    Result := FEnum.Current^.Data.Key < FHighBound;
  FDone := not Result;
end;

procedure TGComparableTreeMap.TKeyHeadEnumerable.Reset;
begin
  FEnum.Reset;
  FDone := False;
end;

{ TGComparableTreeMap.TKeyRangeEnumerable }

constructor TGComparableTreeMap.TKeyRangeEnumerable.Create(constref aLowBound, aHighBound: TKey;
  aMap: TCustomTreeMap; aBounds: TRangeBounds);
begin
  inherited Create(aMap);
  FEnum := aMap.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGComparableTreeMap }

class function TGComparableTreeMap.DoCompare(constref L, R: TKey): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGComparableTreeMap.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

constructor TGComparableTreeMap.Create;
begin
  FTree := TComparableTree.Create;
end;

constructor TGComparableTreeMap.Create(aCapacity: SizeInt);
begin
  FTree := TComparableTree.Create(aCapacity);
end;

constructor TGComparableTreeMap.Create(constref a: array of TEntry);
begin
  Create;
  DoAddAll(a);
end;

constructor TGComparableTreeMap.Create(e: IEntryEnumerable);
begin
  Create;
  DoAddAll(e);
end;

constructor TGComparableTreeMap.CreateCopy(aMap: TGComparableTreeMap);
begin
  inherited Create;
  FTree := TComparableTree(aMap.FTree).Clone;
end;

function TGComparableTreeMap.Clone: TGComparableTreeMap;
begin
  Result := TGComparableTreeMap.CreateCopy(Self);
end;

function TGComparableTreeMap.Head(constref aHighBound: TKey; aInclusive: Boolean): IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyHeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGComparableTreeMap.Range(constref aLowBound, aHighBound: TKey;
  aIncludeBounds: TRangeBounds): IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGComparableTreeMap.HeadMap(constref aHighBound: TKey; aInclusive: Boolean): TGComparableTreeMap;
begin
  Result := TGComparableTreeMap.Create;
  with TKeyHeadEnumerable.Create(aHighBound, Self, aInclusive) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
      finally
        Free;
      end;
end;

function TGComparableTreeMap.TailMap(constref aLowBound: TKey; aInclusive: Boolean): TGComparableTreeMap;
begin
  Result := TGComparableTreeMap.Create;
  with TKeyTailEnumerable.Create(aLowBound, Self, aInclusive) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

function TGComparableTreeMap.SubMap(constref aLowBound, aHighBound: TKey;
  aIncludeBounds: TRangeBounds): TGComparableTreeMap;
begin
  Result := TGComparableTreeMap.Create;
  with TKeyRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

{ TGRegularTreeMap.TKeyHeadEnumerable }

function TGRegularTreeMap.TKeyHeadEnumerable.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGRegularTreeMap.TKeyHeadEnumerable.Create(constref aHighBound: TKey; aMap: TCustomTreeMap;
  aInclusive: Boolean);
begin
  inherited Create(aMap);
  FEnum := aMap.FTree.GetEnumerator;
  FCompare := TRegularTree(aMap.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGRegularTreeMap.TKeyHeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGRegularTreeMap.TKeyHeadEnumerable.MoveNext: Boolean;
begin
  if FDone or not FEnum.MoveNext then
    exit(False);
  if FInclusive then
    Result := FCompare(FEnum.Current^.Data.Key, FHighBound) <= 0
  else
    Result := FCompare(FEnum.Current^.Data.Key, FHighBound) < 0;
  FDone := not Result;
end;

procedure TGRegularTreeMap.TKeyHeadEnumerable.Reset;
begin
  FEnum.Reset;
  FDone := False;
end;

{ TGRegularTreeMap.TKeyRangeEnumerable }

constructor TGRegularTreeMap.TKeyRangeEnumerable.Create(constref aLowBound, aHighBound: TKey;
  aMap: TCustomTreeMap; aBounds: TRangeBounds);
begin
  inherited Create(aMap);
  FEnum := aMap.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FCompare := TRegularTree(aMap.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGRegularTreeMap }

function TGRegularTreeMap.Comparator: TComparator;
begin
  Result := TRegularTree(FTree).Comparator;
end;

constructor TGRegularTreeMap.Create;
begin
  FTree := TRegularTree.Create(specialize TGDefaults<TKey>.Compare);
end;

constructor TGRegularTreeMap.Create(c: TComparator);
begin
  FTree := TRegularTree.Create(c);
end;

constructor TGRegularTreeMap.Create(aCapacity: SizeInt; c: TComparator);
begin
  FTree := TRegularTree.Create(aCapacity, c);
end;

constructor TGRegularTreeMap.Create(constref a: array of TEntry; c: TComparator);
begin
  Create(c);
  DoAddAll(a);
end;

constructor TGRegularTreeMap.Create(e: IEntryEnumerable; c: TComparator);
begin
  Create(c);
  DoAddAll(e);
end;

constructor TGRegularTreeMap.CreateCopy(aMap: TGRegularTreeMap);
begin
  FTree := TRegularTree(aMap.FTree).Clone;
end;

function TGRegularTreeMap.Clone: TGRegularTreeMap;
begin
  Result := TGRegularTreeMap.CreateCopy(Self);
end;

function TGRegularTreeMap.Head(constref aHighBound: TKey; aInclusive: Boolean): IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyHeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGRegularTreeMap.Range(constref aLowBound, aHighBound: TKey;
  aIncludeBounds: TRangeBounds): IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGRegularTreeMap.HeadMap(constref aHighBound: TKey; aInclusive: Boolean): TGRegularTreeMap;
begin
  Result := TGRegularTreeMap.Create(Comparator);
  with TKeyHeadEnumerable.Create(aHighBound, Self, aInclusive) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

function TGRegularTreeMap.TailMap(constref aLowBound: TKey; aInclusive: Boolean): TGRegularTreeMap;
begin
  Result := TGRegularTreeMap.Create(Comparator);
  with TKeyTailEnumerable.Create(aLowBound, Self, aInclusive) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

function TGRegularTreeMap.SubMap(constref aLowBound, aHighBound: TKey;
  aIncludeBounds: TRangeBounds): TGRegularTreeMap;
begin
  Result := TGRegularTreeMap.Create(Comparator);
  with TKeyRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

{ TGObjectRegularTreeMap }

procedure TGObjectRegularTreeMap.EntryRemoving(p: PEntry);
begin
  if OwnsKeys then
    TObject(p^.Key).Free;
  if OwnsValues then
    TObject(p^.Value).Free;
end;

procedure TGObjectRegularTreeMap.SetOwnership(aOwns: TMapObjOwnership);
begin
  OwnsKeys := moOwnsKeys in aOwns;
  OwnsValues := moOwnsValues in aOwns;
end;

function TGObjectRegularTreeMap.DoRemove(constref aKey: TKey): Boolean;
var
  v: TValue;
begin
  Result := DoExtract(aKey, v);
  if Result then
    begin
      if OwnsKeys then
        TObject(aKey).Free;
      if OwnsValues then
        TObject(v).Free;
    end;
end;

function TGObjectRegularTreeMap.DoRemoveIf(aTest: TKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest, @EntryRemoving);
end;

function TGObjectRegularTreeMap.DoRemoveIf(aTest: TOnKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest, @EntryRemoving);
end;

function TGObjectRegularTreeMap.DoRemoveIf(aTest: TNestKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest, @EntryRemoving);
end;

procedure TGObjectRegularTreeMap.DoClear;
var
  Node: PNode;
begin
  if OwnsKeys or OwnsValues then
    for Node in FTree do
      begin
        if OwnsKeys then
          TObject(Node^.Data.Key).Free;
        if OwnsValues then
          TObject(Node^.Data.Value).Free;
      end;
  inherited;
end;

function TGObjectRegularTreeMap.DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean;
var
  p: PEntry;
begin
  p := Find(aKey);
  Result := p <> nil;
  if Result then
    begin
      if OwnsValues and not TObject.Equal(TObject(p^.Value), TObject(aNewValue)) then
        TObject(p^.Value).Free;
      p^.Value := aNewValue;
    end;
end;

function TGObjectRegularTreeMap.DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean;
var
  p: PEntry;
begin
  Result := not FindOrAdd(aKey, p);
  if not Result then
    begin
      if OwnsValues and not TObject.Equal(TObject(p^.Value), TObject(aValue)) then
        TObject(p^.Value).Free;
    end;
  p^.Value := aValue;
end;

constructor TGObjectRegularTreeMap.Create(aOwns: TMapObjOwnership);
begin
  inherited Create;
  SetOwnership(aOwns);
end;

constructor TGObjectRegularTreeMap.Create(c: TComparator; aOwns: TMapObjOwnership);
begin
  inherited Create(c);
  SetOwnership(aOwns);
end;

constructor TGObjectRegularTreeMap.Create(aCapacity: SizeInt; c: TComparator; aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity, c);
  SetOwnership(aOwns);
end;

constructor TGObjectRegularTreeMap.Create(constref a: array of TEntry; c: TComparator; aOwns: TMapObjOwnership);
begin
  inherited Create(a, c);
  SetOwnership(aOwns);
end;

constructor TGObjectRegularTreeMap.Create(e: IEntryEnumerable; c: TComparator; aOwns: TMapObjOwnership);
begin
  inherited Create(e, c);
  SetOwnership(aOwns);
end;

constructor TGObjectRegularTreeMap.CreateCopy(aMap: TGObjectRegularTreeMap);
begin
  inherited CreateCopy(aMap);
  OwnsKeys := aMap.OwnsKeys;
  OwnsValues := aMap.OwnsValues;
end;

function TGObjectRegularTreeMap.Clone: TGObjectRegularTreeMap;
begin
  Result := TGObjectRegularTreeMap.CreateCopy(Self);
end;

{ TGDelegatedTreeMap.TKeyHeadEnumerable }

function TGDelegatedTreeMap.TKeyHeadEnumerable.GetCurrent: TKey;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGDelegatedTreeMap.TKeyHeadEnumerable.Create(constref aHighBound: TKey; aMap: TCustomTreeMap;
  aInclusive: Boolean);
begin
  inherited Create(aMap);
  FEnum := aMap.FTree.GetEnumerator;
  FCompare := TDelegatedTree(aMap.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGDelegatedTreeMap.TKeyHeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGDelegatedTreeMap.TKeyHeadEnumerable.MoveNext: Boolean;
begin
  if FDone or not FEnum.MoveNext then
    exit(False);
  if FInclusive then
    Result := FCompare(FEnum.Current^.Data.Key, FHighBound) <= 0
  else
    Result := FCompare(FEnum.Current^.Data.Key, FHighBound) < 0;
  FDone := not Result;
end;

procedure TGDelegatedTreeMap.TKeyHeadEnumerable.Reset;
begin
  FEnum.Reset;
  FDone := False;
end;

{ TGDelegatedTreeMap.TKeyRangeEnumerable }

constructor TGDelegatedTreeMap.TKeyRangeEnumerable.Create(constref aLowBound, aHighBound: TKey;
  aMap: TCustomTreeMap; aBounds: TRangeBounds);
begin
  inherited Create(aMap);
  FEnum := aMap.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FCompare := TDelegatedTree(aMap.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGDelegatedTreeMap }

constructor TGDelegatedTreeMap.Create;
begin
  FTree := TDelegatedTree.Create(specialize TGDefaults<TKey>.OnCompare);
end;

constructor TGDelegatedTreeMap.Create(c: TComparator);
begin
  FTree := TDelegatedTree.Create(c);
end;

constructor TGDelegatedTreeMap.Create(aCapacity: SizeInt; c: TComparator);
begin
  FTree := TDelegatedTree.Create(aCapacity, c);
end;

constructor TGDelegatedTreeMap.Create(constref a: array of TEntry; c: TComparator);
begin
  Create(c);
  DoAddAll(a);
end;

constructor TGDelegatedTreeMap.Create(e: IEntryEnumerable; c: TComparator);
begin
  Create(c);
  DoAddAll(e);
end;

constructor TGDelegatedTreeMap.CreateCopy(aMap: TGDelegatedTreeMap);
begin
  FTree := TDelegatedTree(aMap.FTree).Clone;
end;

function TGDelegatedTreeMap.Comparator: TComparator;
begin
  Result := TDelegatedTree(FTree).Comparator;
end;

function TGDelegatedTreeMap.Clone: TGDelegatedTreeMap;
begin
  Result := TGDelegatedTreeMap.CreateCopy(Self);
end;

function TGDelegatedTreeMap.Head(constref aHighBound: TKey; aInclusive: Boolean): IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyHeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGDelegatedTreeMap.Range(constref aLowBound, aHighBound: TKey;
  aIncludeBounds: TRangeBounds): IKeyEnumerable;
begin
  BeginIteration;
  Result := TKeyRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGDelegatedTreeMap.HeadMap(constref aHighBound: TKey; aInclusive: Boolean): TGDelegatedTreeMap;
begin
  Result := TGDelegatedTreeMap.Create(Comparator);
  with TKeyHeadEnumerable.Create(aHighBound, Self, aInclusive) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

function TGDelegatedTreeMap.TailMap(constref aLowBound: TKey; aInclusive: Boolean): TGDelegatedTreeMap;
begin
  Result := TGDelegatedTreeMap.Create(Comparator);
  with TKeyTailEnumerable.Create(aLowBound, Self, aInclusive) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

function TGDelegatedTreeMap.SubMap(constref aLowBound, aHighBound: TKey;
  aIncludeBounds: TRangeBounds): TGDelegatedTreeMap;
var
  k: TKey;
begin
  Result := TGDelegatedTreeMap.Create(Comparator);
  with TKeyRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds) do
    try
      while MoveNext do
        Result.Add(FEnum.Current^.Data);
    finally
      Free;
    end;
end;

{ TGObjectDelegatedTreeMap }

procedure TGObjectDelegatedTreeMap.EntryRemoving(p: PEntry);
begin
  if OwnsKeys then
    TObject(p^.Key).Free;
  if OwnsValues then
    TObject(p^.Value).Free;
end;

procedure TGObjectDelegatedTreeMap.SetOwnership(aOwns: TMapObjOwnership);
begin
  OwnsKeys := moOwnsKeys in aOwns;
  OwnsValues := moOwnsValues in aOwns;
end;

function TGObjectDelegatedTreeMap.DoRemove(constref aKey: TKey): Boolean;
var
  v: TValue;
begin
  Result := DoExtract(aKey, v);
  if Result then
    begin
      if OwnsKeys then
        TObject(aKey).Free;
      if OwnsValues then
        TObject(v).Free;
    end;
end;

function TGObjectDelegatedTreeMap.DoRemoveIf(aTest: TKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest, @EntryRemoving);
end;

function TGObjectDelegatedTreeMap.DoRemoveIf(aTest: TOnKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest, @EntryRemoving);
end;

function TGObjectDelegatedTreeMap.DoRemoveIf(aTest: TNestKeyTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest, @EntryRemoving);
end;

procedure TGObjectDelegatedTreeMap.DoClear;
var
  Node: PNode;
begin
  if OwnsKeys or OwnsValues then
    for Node in FTree do
      begin
        if OwnsKeys then
          TObject(Node^.Data.Key).Free;
        if OwnsValues then
          TObject(Node^.Data.Value).Free;
      end;
  inherited;
end;

function TGObjectDelegatedTreeMap.DoSetValue(constref aKey: TKey; constref aNewValue: TValue): Boolean;
var
  p: PEntry;
begin
  p := Find(aKey);
  Result := p <> nil;
  if Result then
    begin
      if OwnsValues and not TObject.Equal(TObject(p^.Value), TObject(aNewValue)) then
        TObject(p^.Value).Free;
      p^.Value := aNewValue;
    end;
end;

function TGObjectDelegatedTreeMap.DoAddOrSetValue(const aKey: TKey; const aValue: TValue): Boolean;
var
  p: PEntry;
begin
  Result := not FindOrAdd(aKey, p);
  if not Result then
    begin
      if OwnsValues and not TObject.Equal(TObject(p^.Value), TObject(aValue)) then
        TObject(p^.Value).Free;
    end;
  p^.Value := aValue;
end;

constructor TGObjectDelegatedTreeMap.Create(aOwns: TMapObjOwnership);
begin
  inherited Create;
  SetOwnership(aOwns);
end;

constructor TGObjectDelegatedTreeMap.Create(c: TComparator; aOwns: TMapObjOwnership);
begin
  inherited Create(c);
  SetOwnership(aOwns);
end;

constructor TGObjectDelegatedTreeMap.Create(aCapacity: SizeInt; c: TComparator; aOwns: TMapObjOwnership);
begin
  inherited Create(aCapacity, c);
  SetOwnership(aOwns);
end;

constructor TGObjectDelegatedTreeMap.Create(constref a: array of TEntry; c: TComparator; aOwns: TMapObjOwnership);
begin
  inherited Create(a, c);
  SetOwnership(aOwns);
end;

constructor TGObjectDelegatedTreeMap.Create(e: IEntryEnumerable; c: TComparator; aOwns: TMapObjOwnership);
begin
  inherited Create(e, c);
  SetOwnership(aOwns);
end;

constructor TGObjectDelegatedTreeMap.CreateCopy(aMap: TGObjectDelegatedTreeMap);
begin
  inherited CreateCopy(aMap);
  OwnsKeys := aMap.OwnsKeys;
  OwnsValues := aMap.OwnsValues;
end;

function TGObjectDelegatedTreeMap.Clone: TGObjectDelegatedTreeMap;
begin
  Result := TGObjectDelegatedTreeMap.CreateCopy(Self);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic sorted multiset implementations on top of AVL tree.             *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGTreeMultiSet;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGAvlTree;

type

  { TGCustomTreeMultiSet: common multiset abstract ancestor class }
  generic TGCustomTreeMultiSet<T> = class abstract(specialize TGCustomMultiSet<T>)
  public
  type
    TCustomTreeMultiSet = specialize TGCustomTreeMultiSet<T>;

  protected
  type

    TTree = specialize TGCustomAvlTree<T, TEntry>;
    PNode = TTree.PNode;

    TEnumerator = class(TContainerEnumerator)
    protected
      FEnum: TTree.TEnumerator;
      FCurrKeyCount: SizeInt;
      function  GetCurrent: T; override;
    public
      constructor Create(tms: TCustomTreeMultiSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TReverseEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FCurrKeyCount: SizeInt;
      function  GetCurrent: T; override;
    public
      constructor Create(tms: TCustomTreeMultiSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TDistinctEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      function  GetCurrent: T; override;
    public
      constructor Create(tms: TCustomTreeMultiSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TEntryEnumerable = class(specialize TGAutoEnumerable<TEntry>)
    protected
      FOwner: TCustomTreeMultiSet;
      FEnum: TTree.TEnumerator;
      function  GetCurrent: TEntry; override;
    public
      constructor Create(tms: TCustomTreeMultiSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TTailEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumeratorAt;
      FCurrKeyCount: SizeInt;
      function  GetCurrent: T; override;
    public
      constructor Create(constref aLowBound: T; tms: TCustomTreeMultiSet; aInclusive: Boolean);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FTree: TTree;
    procedure EntryRemoved(p: PEntry);
    function  GetCapacity: SizeInt; override;
    function  DoGetEnumerator: TCustomEnumerator; override;
    procedure DoClear; override;
    procedure DoTrimToFit; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    function  FindEntry(constref aKey: T): PEntry; override;
    function  FindOrAdd(constref aKey: T; out p: PEntry): Boolean; override;
    function  DoSubEntry(constref e: TEntry): Boolean; override;
    function  DoSymmSubEntry(constref e: TEntry): Boolean; override;
    function  DoExtract(constref aKey: T): Boolean; override;
    function  GetEntryCount: SizeInt; override;
    function  DoDoubleEntryCounters: SizeInt; override;
    function  GetDistinct: IEnumerable; override;
    function  GetEntries: IEntryEnumerable; override;
    procedure DoIntersect(aSet: TCustomMultiSet); override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
    function  DoExtractIf(aTest: TTest): TArray; override;
    function  DoExtractIf(aTest: TOnTest): TArray; override;
    function  DoExtractIf(aTest: TNestTest): TArray; override;
    function  FindNearestLT(constref aPattern: T; out aValue: T): Boolean;
    function  FindNearestLE(constref aPattern: T; out aValue: T): Boolean;
    function  FindNearestGT(constref aPattern: T; out aValue: T): Boolean;
    function  FindNearestGE(constref aPattern: T; out aValue: T): Boolean;
  public
    destructor Destroy; override;
    function  Reverse: IEnumerable; override;
    function  FindMin(out aValue: T): Boolean;
    function  FindMax(out aValue: T): Boolean;
  { returns True if exists element whose value greater then or equal to aValue (depend on aInclusive) }
    function FindCeil(constref aValue: T; out aCeil: T; aInclusive: Boolean = True): Boolean;
  { returns True if exists element whose value less then aBound (or equal to aValue depend on aInclusive) }
    function FindFloor(constref aValue: T; out aFloor: T; aInclusive: Boolean = False): Boolean;
  { enumerates values whose are strictly less than(if not aInclusive) aHighBound }
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; virtual; abstract;
  { enumerates values whose are greater than or equal to(if aInclusive) aLowBound }
    function  Tail(constref aLowBound: T; aInclusive: Boolean = True): IEnumerable;
  { enumerates values whose are greater than or equal to aLowBound and strictly less than aHighBound(by default)}
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
      virtual; abstract;
  { returns sorted multiset whose items are strictly less than(if not aInclusive) aHighBound }
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TCustomTreeMultiSet;
      virtual; abstract;
  { returns sorted multiset whose items are greater than or equal(if aInclusive) to aLowBound }
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TCustomTreeMultiSet; virtual; abstract;
  { returns sorted multiset whose items are greater than or equal to aLowBound and strictly less than
    aHighBound(by default) }
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]):
      TCustomTreeMultiSet; virtual; abstract;
  end;

  { TGBaseTreeMultiSet implements sorted multiset;
      functor TCmpRel (comparision relation) must provide:
        class function Compare([const[ref]] L, R: T): SizeInt; }
  generic TGBaseTreeMultiSet<T, TCmpRel> = class abstract(specialize TGCustomTreeMultiSet<T>)
  protected
  type
    TBaseTree = specialize TGAvlTree<T, TEntry, TCmpRel>;

    THeadEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FHighBound: T;
      FCurrKeyCount: SizeInt;
      FInclusive,
      FDone: Boolean;
      function  GetCurrent: T; override;
    public
      constructor Create(constref aHighBound: T; tms: TCustomTreeMultiSet; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRangeEnumerable = class(THeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: T; tms: TCustomTreeMultiSet; aBounds: TRangeBounds);
                  overload;
    end;

    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref a: array of T);
    constructor Create(e: IEnumerable);
    constructor CreateCopy(aMultiSet: TGBaseTreeMultiSet);
    function Clone: TGBaseTreeMultiSet; override;
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; override;
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
      override;
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TGBaseTreeMultiSet; override;
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TGBaseTreeMultiSet; override;
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TGBaseTreeMultiSet;
      override;
  end;

  { TGTreeMultiSet implements set, it assumes that type T implements TCmpRel }
  generic TGTreeMultiSet<T> = class(specialize TGBaseTreeMultiSet<T, T>);

  { TGComparableTreeMultiSet implements sorted multiset;
      it assumes that type T has defined comparision operators }
  generic TGComparableTreeMultiSet<T> = class(specialize TGCustomTreeMultiSet<T>)
  protected
  type
    TComparableTree = specialize TGComparableAvlTree<T, TEntry>;

    THeadEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FHighBound: T;
      FCurrKeyCount: SizeInt;
      FInclusive,
      FDone: Boolean;
      function  GetCurrent: T; override;
    public
      constructor Create(constref aHighBound: T; tms: TCustomTreeMultiSet; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRangeEnumerable = class(THeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: T; tms: TCustomTreeMultiSet; aBounds: TRangeBounds);
                  overload;
    end;

    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref a: array of T);
    constructor Create(e: IEnumerable);
    constructor CreateCopy(aMultiSet: TGComparableTreeMultiSet);
    function Clone: TGComparableTreeMultiSet; override;
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; override;
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
      override;
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TGComparableTreeMultiSet; override;
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TGComparableTreeMultiSet; override;
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TGComparableTreeMultiSet;
      override;
  end;

  { TGObjectTreeMultiSet }

  generic TGObjectTreeMultiSet<T: class; TCmpRel> = class(specialize TGBaseTreeMultiSet<T, TCmpRel>)
  private
    FOwnsObjects: Boolean;
  protected
    function  DoSubEntry(constref e: TEntry): Boolean; override;
    function  DoSymmSubEntry(constref e: TEntry): Boolean; override;
    function  DoRemove(constref aKey: T): Boolean; override;
    procedure DoClear; override;
    procedure EntryRemoved(p: PEntry);
    procedure DoIntersect(aSet: TCustomMultiSet); override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
    class function DoCompare(constref L, R: T): SizeInt; static;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor CreateCopy(aMultiSet: TGObjectTreeMultiSet);
    function  Clone: TGObjectTreeMultiSet; override;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  generic TGObjTreeMultiSet<T: class> = class(specialize TGObjectTreeMultiSet<T, T>);

  { TGRegularTreeMultiSet implements sorted multiset with regular comparator }
  generic TGRegularTreeMultiSet<T> = class(specialize TGCustomTreeMultiSet<T>)
  protected
  type
    TRegularTree = specialize TGRegularAvlTree<T, TEntry>;

    THeadEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FHighBound: T;
      FCompare: TCompare;
      FCurrKeyCount: SizeInt;
      FInclusive,
      FDone: Boolean;
      function  GetCurrent: T; override;
    public
      constructor Create(constref aHighBound: T; tms: TCustomTreeMultiSet; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRangeEnumerable = class(THeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: T; tms: TCustomTreeMultiSet; aBounds: TRangeBounds);
                  overload;
    end;

  public
  type
    TComparator = TCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref a: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    constructor CreateCopy(aMultiSet: TGRegularTreeMultiSet);
    function Comparator: TComparator; inline;
    function Clone: TGRegularTreeMultiSet; override;
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; override;
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
      override;
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TGRegularTreeMultiSet; override;
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TGRegularTreeMultiSet; override;
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TGRegularTreeMultiSet;
      override;
  end;

  { TGDelegatedTreeMultiSet implements (sorted) multiset with regular comparator }
  generic TGDelegatedTreeMultiSet<T> = class(specialize TGCustomTreeMultiSet<T>)
  protected
  type
    TDelegatedTree = specialize TGDelegatedAvlTree<T, TEntry>;

    THeadEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FHighBound: T;
      FCompare: TOnCompare;
      FCurrKeyCount: SizeInt;
      FInclusive,
      FDone: Boolean;
      function  GetCurrent: T; override;
    public
      constructor Create(constref aHighBound: T; tms: TCustomTreeMultiSet; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRangeEnumerable = class(THeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: T; tms: TCustomTreeMultiSet; aBounds: TRangeBounds);
                  overload;
    end;

  public
  type
    TComparator = TOnCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref a: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    constructor CreateCopy(aMultiSet: TGDelegatedTreeMultiSet);
    function Comparator: TComparator; inline;
    function Clone: TGDelegatedTreeMultiSet; override;
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; override;
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
      override;
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TGDelegatedTreeMultiSet; override;
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TGDelegatedTreeMultiSet; override;
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TGDelegatedTreeMultiSet;
      override;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGCustomTreeMultiSet.TEnumerator }

function TGCustomTreeMultiSet.TEnumerator.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGCustomTreeMultiSet.TEnumerator.Create(tms: TCustomTreeMultiSet);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumerator;
end;

destructor TGCustomTreeMultiSet.TEnumerator.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeMultiSet.TEnumerator.MoveNext: Boolean;
begin
  Result := FCurrKeyCount > 0;
  FCurrKeyCount -= Ord(Result);
  if not Result then
    begin
      Result := FEnum.MoveNext;
      if Result then
        FCurrKeyCount := Pred(FEnum.Current^.Data.Count);
    end;
end;

procedure TGCustomTreeMultiSet.TEnumerator.Reset;
begin
  FEnum.Reset;
  FCurrKeyCount := 0;
end;

{ TGCustomTreeMultiSet.TReverseEnumerable }

function TGCustomTreeMultiSet.TReverseEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGCustomTreeMultiSet.TReverseEnumerable.Create(tms: TCustomTreeMultiSet);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetReverseEnumerator;
end;

destructor TGCustomTreeMultiSet.TReverseEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeMultiSet.TReverseEnumerable.MoveNext: Boolean;
begin
  Result := FCurrKeyCount > 0;
  FCurrKeyCount -= Ord(Result);
  if not Result then
    begin
      Result := FEnum.MoveNext;
      if Result then
        FCurrKeyCount := Pred(FEnum.Current^.Data.Count);
    end;
end;

procedure TGCustomTreeMultiSet.TReverseEnumerable.Reset;
begin
  FEnum.Reset;
  FCurrKeyCount := 0;
end;

{ TGCustomTreeMultiSet.TDistinctEnumerable }

function TGCustomTreeMultiSet.TDistinctEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGCustomTreeMultiSet.TDistinctEnumerable.Create(tms: TCustomTreeMultiSet);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumerator;
end;

destructor TGCustomTreeMultiSet.TDistinctEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeMultiSet.TDistinctEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomTreeMultiSet.TDistinctEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomTreeMultiSet.TEntryEnumerable }

function TGCustomTreeMultiSet.TEntryEnumerable.GetCurrent: TEntry;
begin
  Result := FEnum.Current^.Data;
end;

constructor TGCustomTreeMultiSet.TEntryEnumerable.Create(tms: TCustomTreeMultiSet);
begin
  inherited Create;
  FOwner := tms;
  FEnum := tms.FTree.GetEnumerator;
end;

destructor TGCustomTreeMultiSet.TEntryEnumerable.Destroy;
begin
  FEnum.Free;
  FOwner.EndIteration;
  inherited;
end;

function TGCustomTreeMultiSet.TEntryEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomTreeMultiSet.TEntryEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomTreeMultiSet.TTailEnumerable }

function TGCustomTreeMultiSet.TTailEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGCustomTreeMultiSet.TTailEnumerable.Create(constref aLowBound: T; tms: TCustomTreeMultiSet;
  aInclusive: Boolean);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumeratorAt(aLowBound, aInclusive);
end;

destructor TGCustomTreeMultiSet.TTailEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeMultiSet.TTailEnumerable.MoveNext: Boolean;
begin
  Result := FCurrKeyCount > 0;
  FCurrKeyCount -= Ord(Result);
  if not Result then
    begin
      Result := FEnum.MoveNext;
      if Result then
        FCurrKeyCount := Pred(FEnum.Current^.Data.Count);
    end;
end;

procedure TGCustomTreeMultiSet.TTailEnumerable.Reset;
begin
  FEnum.Reset;
  FCurrKeyCount := 0;
end;

{ TGCustomTreeMultiSet }

procedure TGCustomTreeMultiSet.EntryRemoved(p: PEntry);
begin
  FCount -= p^.Count;
end;

function TGCustomTreeMultiSet.GetCapacity: SizeInt;
begin
  Result := FTree.Capacity;
end;

function TGCustomTreeMultiSet.DoGetEnumerator: TCustomEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

procedure TGCustomTreeMultiSet.DoClear;
begin
  FTree.Clear;
  FCount := 0;
end;

procedure TGCustomTreeMultiSet.DoTrimToFit;
begin
  FTree.TrimToFit;
end;

procedure TGCustomTreeMultiSet.DoEnsureCapacity(aValue: SizeInt);
begin
  FTree.EnsureCapacity(aValue);
end;

function TGCustomTreeMultiSet.FindEntry(constref aKey: T): PEntry;
var
  Node: PNode;
begin
  Node := FTree.Find(aKey);
  if Node <> nil then
    Result := @Node^.Data
  else
    Result := nil;
end;

function TGCustomTreeMultiSet.FindOrAdd(constref aKey: T; out p: PEntry): Boolean;
var
  Node: PNode;
begin
  Result := FTree.FindOrAdd(aKey, Node);
  p := @Node^.Data;
  if not Result then
    p^.Count := 1;
end;

function TGCustomTreeMultiSet.DoSubEntry(constref e: TEntry): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Find(e.Key);
  if Node <> nil then
   begin
     if Node^.Data.Count > e.Count then
       begin
         FCount -= e.Count;
         Node^.Data.Count -= e.Count;
       end
     eLse
       begin
         FCount -= Node^.Data.Count;
         FTree.RemoveNode(Node);
         exit(True);
       end;
   end;
  Result := False;
end;

function TGCustomTreeMultiSet.DoSymmSubEntry(constref e: TEntry): Boolean;
var
  Node: PNode;
begin
  if FTree.FindOrAdd(e.Key, Node) then
    begin
      if Node^.Data.Count > e.Count then
        begin
          FCount -= e.Count;
          Node^.Data.Count -= e.Count;
        end
      else
        if Node^.Data.Count < e.Count then
          begin
           {$PUSH}{$Q+}
            FCount -= Node^.Data.Count shl 1 - e.Count;
           {$POP}
            Node^.Data.Count := e.Count - Node^.Data.Count;
          end
        else  // counts equals
          begin
            FCount -= Node^.Data.Count;
            FTree.Remove(e.Key);
            exit(True);
          end;
    end
  else
    begin
      //Node^.Data.Key := e.Key;
      Node^.Data.Count := e.Count;
      {$PUSH}{$Q+}
      FCount += e.Count;
      {$POP}
    end;
  Result := False;
end;

function TGCustomTreeMultiSet.DoExtract(constref aKey: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Find(aKey);
  Result := Node <> nil;
  if Result then
    begin
      Dec(Node^.Data.Count);
      Dec(FCount);
      if Node^.Data.Count = 0 then
        FTree.RemoveNode(Node);
    end;
end;

function TGCustomTreeMultiSet.GetEntryCount: SizeInt;
begin
  Result := FTree.Count;
end;

function TGCustomTreeMultiSet.DoDoubleEntryCounters: SizeInt;
var
  Node: PNode;
begin
  Result := ElemCount;
{$PUSH}{$Q+}
  FCount += Result;
{$POP}
with FTree.GetEnumerator do
  try
    while MoveNext do
      begin
        Node := Current;
        Node^.Data.Count += Node^.Data.Count;
      end;
  finally
    Free;
  end;
end;

function TGCustomTreeMultiSet.GetDistinct: IEnumerable;
begin
  Result := TDistinctEnumerable.Create(Self);
end;

function TGCustomTreeMultiSet.GetEntries: IEntryEnumerable;
begin
  Result := TEntryEnumerable.Create(Self);
end;

procedure TGCustomTreeMultiSet.DoIntersect(aSet: TCustomMultiSet);
var
  {%H-}I: TIntersectHelper;
begin
  I.FSet := Self;
  I.FOtherSet := aSet;
  FTree.RemoveIf(@I.OnIntersect, @EntryRemoved);
end;

function TGCustomTreeMultiSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  Result := ElemCount;
  FTree.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGCustomTreeMultiSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  Result := ElemCount;
  FTree.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGCustomTreeMultiSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  Result := ElemCount;
  FTree.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGCustomTreeMultiSet.DoExtractIf(aTest: TTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTree.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
  FCount -= System.Length(Result);
end;

function TGCustomTreeMultiSet.DoExtractIf(aTest: TOnTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTree.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
  FCount -= System.Length(Result);
end;

function TGCustomTreeMultiSet.DoExtractIf(aTest: TNestTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTree.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
  FCount -= System.Length(Result);
end;

function TGCustomTreeMultiSet.FindNearestLT(constref aPattern: T; out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindLess(aPattern);
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

function TGCustomTreeMultiSet.FindNearestLE(constref aPattern: T; out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindLessOrEqual(aPattern);
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

function TGCustomTreeMultiSet.FindNearestGT(constref aPattern: T; out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindGreater(aPattern);
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

function TGCustomTreeMultiSet.FindNearestGE(constref aPattern: T; out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindGreaterOrEqual(aPattern);
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

destructor TGCustomTreeMultiSet.Destroy;
begin
  DoClear;
  FTree.Free;
  inherited;
end;

function TGCustomTreeMultiSet.Reverse: IEnumerable;
begin
  BeginIteration;
  Result := TReverseEnumerable.Create(Self);
end;

function TGCustomTreeMultiSet.FindMin(out aValue: T): Boolean;
var
  p: PNode;
begin
  p := FTree.Lowest;
  Result := p <> nil;
  if Result then
    aValue := p^.Data.Key;
end;

function TGCustomTreeMultiSet.FindMax(out aValue: T): Boolean;
var
  p: PNode;
begin
  p := FTree.Highest;
  Result := p <> nil;
  if Result then
    aValue := p^.Data.Key;
end;

function TGCustomTreeMultiSet.FindCeil(constref aValue: T; out aCeil: T; aInclusive: Boolean): Boolean;
begin
  if aInclusive then
    Result := FindNearestGE(aValue, aCeil)
  else
    Result := FindNearestGT(aValue, aCeil);
end;

function TGCustomTreeMultiSet.FindFloor(constref aValue: T; out aFloor: T; aInclusive: Boolean): Boolean;
begin
  if aInclusive then
    Result := FindNearestLE(aValue, aFloor)
  else
    Result := FindNearestLT(aValue, aFloor);
end;

function TGCustomTreeMultiSet.Tail(constref aLowBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := TTailEnumerable.Create(aLowBound, Self, aInclusive);
end;

{ TGBaseTreeMultiSet.THeadEnumerable }

function TGBaseTreeMultiSet.THeadEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGBaseTreeMultiSet.THeadEnumerable.Create(constref aHighBound: T; tms: TCustomTreeMultiSet;
  aInclusive: Boolean);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumerator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGBaseTreeMultiSet.THeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGBaseTreeMultiSet.THeadEnumerable.MoveNext: Boolean;
begin
  if FDone then
    exit(False);
  Result := FCurrKeyCount > 0;
  FCurrKeyCount -= Ord(Result);
  if not Result then
    begin
      if not FEnum.MoveNext then
        exit(False);
      if FInclusive then
        Result := TCmpRel.Compare(FEnum.Current^.Data.Key, FHighBound) <= 0
      else
        Result := TCmpRel.Compare(FEnum.Current^.Data.Key, FHighBound) < 0;
      if Result then
        FCurrKeyCount := Pred(FEnum.Current^.Data.Count);
    end;
  FDone := not Result;
end;

procedure TGBaseTreeMultiSet.THeadEnumerable.Reset;
begin
  FEnum.Reset;
  FCurrKeyCount := 0;
end;

{ TGBaseTreeMultiSet.TRangeEnumerable }

constructor TGBaseTreeMultiSet.TRangeEnumerable.Create(constref aLowBound, aHighBound: T;
  tms: TCustomTreeMultiSet; aBounds: TRangeBounds);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGBaseTreeMultiSet }

class function TGBaseTreeMultiSet.DoCompare(constref L, R: T): SizeInt;
begin
  Result := TCmpRel.Compare(L, R);
end;

class function TGBaseTreeMultiSet.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

constructor TGBaseTreeMultiSet.Create;
begin
  FTree := TBaseTree.Create;
end;

constructor TGBaseTreeMultiSet.Create(aCapacity: SizeInt);
begin
  FTree := TBaseTree.Create(aCapacity);
end;

constructor TGBaseTreeMultiSet.Create(constref a: array of T);
begin
  FTree := TBaseTree.Create;
  DoAddAll(a);
end;

constructor TGBaseTreeMultiSet.Create(e: IEnumerable);
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TGBaseTreeMultiSet then
    CreateCopy(TGBaseTreeMultiSet(o))
  else
    begin
      if o is TCustomMultiSet then
        Create(TCustomMultiSet(o).EntryCount)
      else
        Create;
      DoAddAll(e);
    end;
end;

constructor TGBaseTreeMultiSet.CreateCopy(aMultiSet: TGBaseTreeMultiSet);
begin
  FTree := TBaseTree(aMultiSet.FTree).Clone;
  FCount := aMultiSet.Count;
end;

function TGBaseTreeMultiSet.Clone: TGBaseTreeMultiSet;
begin
  Result := TGBaseTreeMultiSet.CreateCopy(Self);
end;

function TGBaseTreeMultiSet.Head(constref aHighBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := THeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGBaseTreeMultiSet.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): IEnumerable;
begin
  BeginIteration;
  Result := TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGBaseTreeMultiSet.HeadSet(constref aHighBound: T; aInclusive: Boolean): TGBaseTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGBaseTreeMultiSet.Create;
  with THeadEnumerable.Create(aHighBound, Self, aInclusive) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

function TGBaseTreeMultiSet.TailSet(constref aLowBound: T; aInclusive: Boolean): TGBaseTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGBaseTreeMultiSet.Create;
  with TTailEnumerable.Create(aLowBound, Self, aInclusive) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

function TGBaseTreeMultiSet.SubSet(constref aLowBound, aHighBound: T;
  aIncludeBounds: TRangeBounds): TGBaseTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGBaseTreeMultiSet.Create;
  with TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

{ TGComparableTreeMultiSet.THeadEnumerable }

function TGComparableTreeMultiSet.THeadEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGComparableTreeMultiSet.THeadEnumerable.Create(constref aHighBound: T; tms: TCustomTreeMultiSet;
  aInclusive: Boolean);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumerator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGComparableTreeMultiSet.THeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGComparableTreeMultiSet.THeadEnumerable.MoveNext: Boolean;
begin
  if FDone then
    exit(False);
  Result := FCurrKeyCount > 0;
  FCurrKeyCount -= Ord(Result);
  if not Result then
    begin
      if not FEnum.MoveNext then
        exit(False);
      if FInclusive then
        Result := FEnum.Current^.Data.Key <= FHighBound
      else
        Result := FEnum.Current^.Data.Key < FHighBound;
      if Result then
        FCurrKeyCount := Pred(FEnum.Current^.Data.Count);
    end;
  FDone := not Result;
end;

procedure TGComparableTreeMultiSet.THeadEnumerable.Reset;
begin
  FEnum.Reset;
  FCurrKeyCount := 0;
end;

{ TGComparableTreeMultiSet.TRangeEnumerable }

constructor TGComparableTreeMultiSet.TRangeEnumerable.Create(constref aLowBound, aHighBound: T;
  tms: TCustomTreeMultiSet; aBounds: TRangeBounds);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGComparableTreeMultiSet }

class function TGComparableTreeMultiSet.DoCompare(constref L, R: T): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGComparableTreeMultiSet.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

constructor TGComparableTreeMultiSet.Create;
begin
  FTree := TComparableTree.Create;
end;

constructor TGComparableTreeMultiSet.Create(aCapacity: SizeInt);
begin
  FTree := TComparableTree.Create(aCapacity);
end;

constructor TGComparableTreeMultiSet.Create(constref a: array of T);
begin
  FTree := TComparableTree.Create;
  DoAddAll(a);
end;

constructor TGComparableTreeMultiSet.Create(e: IEnumerable);
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TGComparableTreeMultiSet then
    CreateCopy(TGComparableTreeMultiSet(o))
  else
    begin
      if o is TCustomMultiSet then
        Create(TCustomMultiSet(o).EntryCount)
      else
        Create;
      DoAddAll(e);
    end;
end;

constructor TGComparableTreeMultiSet.CreateCopy(aMultiSet: TGComparableTreeMultiSet);
begin
  FTree := TComparableTree(aMultiSet.FTree).Clone;
  FCount := aMultiSet.Count;
end;

function TGComparableTreeMultiSet.Clone: TGComparableTreeMultiSet;
begin
  Result := TGComparableTreeMultiSet.CreateCopy(Self);
end;

function TGComparableTreeMultiSet.Head(constref aHighBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := THeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGComparableTreeMultiSet.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): IEnumerable;
begin
  BeginIteration;
  Result := TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGComparableTreeMultiSet.HeadSet(constref aHighBound: T; aInclusive: Boolean): TGComparableTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGComparableTreeMultiSet.Create;
  with THeadEnumerable.Create(aHighBound, Self, aInclusive) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

function TGComparableTreeMultiSet.TailSet(constref aLowBound: T; aInclusive: Boolean): TGComparableTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGComparableTreeMultiSet.Create;
  with TTailEnumerable.Create(aLowBound, Self, aInclusive) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

function TGComparableTreeMultiSet.SubSet(constref aLowBound, aHighBound: T;
  aIncludeBounds: TRangeBounds): TGComparableTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGComparableTreeMultiSet.Create;
  with TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

{ TGObjectTreeMultiSet }

function TGObjectTreeMultiSet.DoSubEntry(constref e: TEntry): Boolean;
begin
  Result := inherited DoSubEntry(e);
  if Result and OwnsObjects then
    e.Key.Free;
end;

function TGObjectTreeMultiSet.DoSymmSubEntry(constref e: TEntry): Boolean;
begin
  Result := inherited DoSymmSubEntry(e);
  if Result and OwnsObjects then
    e.Key.Free;
end;

function TGObjectTreeMultiSet.DoRemove(constref aKey: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Find(aKey);
  Result := Node <> nil;
  if Result then
    begin
      Dec(Node^.Data.Count);
      Dec(FCount);
      if Node^.Data.Count = 0 then
        begin
          FTree.RemoveNode(Node);
          if OwnsObjects then
            aKey.Free;
        end;
    end;
end;

procedure TGObjectTreeMultiSet.DoClear;
var
  Node: PNode;
begin
  if OwnsObjects then
    for Node in FTree do
      Node^.Data.Key.Free;
  inherited;
end;

procedure TGObjectTreeMultiSet.EntryRemoved(p: PEntry);
begin
  FCount -= p^.Count;
  if OwnsObjects then
    p^.Key.Free;
end;

procedure TGObjectTreeMultiSet.DoIntersect(aSet: TCustomMultiSet);
var
  {%H-}I: TIntersectHelper;
begin
  I.FSet := Self;
  I.FOtherSet := aSet;
  FTree.RemoveIf(@I.OnIntersect, @EntryRemoved);
end;

function TGObjectTreeMultiSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  Result := ElemCount;
  FTree.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGObjectTreeMultiSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  Result := ElemCount;
  FTree.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

function TGObjectTreeMultiSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  Result := ElemCount;
  FTree.RemoveIf(aTest, @EntryRemoved);
  Result -= ElemCount;
end;

class function TGObjectTreeMultiSet.DoCompare(constref L, R: T): SizeInt;
begin
  Result := TCmpRel.Compare(L, R);
end;

constructor TGObjectTreeMultiSet.Create(aOwnsObjects: Boolean);
begin
  FTree := TBaseTree.Create;
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectTreeMultiSet.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  FTree := TBaseTree.Create(aCapacity);
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectTreeMultiSet.Create(constref a: array of T; aOwnsObjects: Boolean);
begin
  FTree := TBaseTree.Create;
  OwnsObjects := aOwnsObjects;
  DoAddAll(a);
end;

constructor TGObjectTreeMultiSet.Create(e: IEnumerable; aOwnsObjects: Boolean);
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TGObjectTreeMultiSet then
    CreateCopy(TGObjectTreeMultiSet(o))
  else
    begin
      OwnsObjects := aOwnsObjects;
      if o is TCustomMultiSet then
        Create(TCustomMultiSet(o).EntryCount)
      else
        Create;
      DoAddAll(e);
    end;
end;

constructor TGObjectTreeMultiSet.CreateCopy(aMultiSet: TGObjectTreeMultiSet);
begin
  FTree := TBaseTree(aMultiSet.FTree).Clone;
  FCount := aMultiSet.Count;
  OwnsObjects := aMultiSet.OwnsObjects;
end;

function TGObjectTreeMultiSet.Clone: TGObjectTreeMultiSet;
begin
  Result := TGObjectTreeMultiSet.CreateCopy(Self);
end;

{ TGRegularTreeMultiSet.THeadEnumerable }

function TGRegularTreeMultiSet.THeadEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGRegularTreeMultiSet.THeadEnumerable.Create(constref aHighBound: T; tms: TCustomTreeMultiSet;
  aInclusive: Boolean);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumerator;
  FCompare := TRegularTree(tms.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGRegularTreeMultiSet.THeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGRegularTreeMultiSet.THeadEnumerable.MoveNext: Boolean;
begin
  if FDone then
    exit(False);
  Result := FCurrKeyCount > 0;
  FCurrKeyCount -= Ord(Result);
  if not Result then
    begin
      if not FEnum.MoveNext then
        exit(False);
      if FInclusive then
        Result := FCompare(FEnum.Current^.Data.Key, FHighBound) <= 0
      else
        Result := FCompare(FEnum.Current^.Data.Key, FHighBound) < 0;
      if Result then
        FCurrKeyCount := Pred(FEnum.Current^.Data.Count);
    end;
  FDone := not Result;
end;

procedure TGRegularTreeMultiSet.THeadEnumerable.Reset;
begin
  FEnum.Reset;
  FCurrKeyCount := 0;
end;

{ TGRegularTreeMultiSet.TRangeEnumerable }

constructor TGRegularTreeMultiSet.TRangeEnumerable.Create(constref aLowBound, aHighBound: T;
  tms: TCustomTreeMultiSet; aBounds: TRangeBounds);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FCompare := TRegularTree(tms.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGRegularTreeMultiSet }

constructor TGRegularTreeMultiSet.Create;
begin
  FTree := TRegularTree.Create(TDefaults.Compare);
end;

constructor TGRegularTreeMultiSet.Create(c: TComparator);
begin
  FTree := TRegularTree.Create(c);
end;

constructor TGRegularTreeMultiSet.Create(aCapacity: SizeInt; c: TComparator);
begin
  FTree := TRegularTree.Create(aCapacity, c);
end;

constructor TGRegularTreeMultiSet.Create(constref a: array of T; c: TComparator);
begin
  FTree := TRegularTree.Create(c);
  DoAddAll(a);
end;

constructor TGRegularTreeMultiSet.Create(e: IEnumerable; c: TComparator);
begin
  FTree := TRegularTree.Create(c);
  DoAddAll(e);
end;

constructor TGRegularTreeMultiSet.CreateCopy(aMultiSet: TGRegularTreeMultiSet);
begin
  FTree := TRegularTree(aMultiSet.FTree).Clone;
  FCount := aMultiSet.Count;
end;

function TGRegularTreeMultiSet.Comparator: TComparator;
begin
  Result := TRegularTree(FTree).Comparator;
end;

function TGRegularTreeMultiSet.Clone: TGRegularTreeMultiSet;
begin
  Result := TGRegularTreeMultiSet.CreateCopy(Self);
end;

function TGRegularTreeMultiSet.Head(constref aHighBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := THeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGRegularTreeMultiSet.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): IEnumerable;
begin
  BeginIteration;
  Result := TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGRegularTreeMultiSet.HeadSet(constref aHighBound: T; aInclusive: Boolean): TGRegularTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGRegularTreeMultiSet.Create(Comparator);
  with THeadEnumerable.Create(aHighBound, Self, aInclusive) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

function TGRegularTreeMultiSet.TailSet(constref aLowBound: T; aInclusive: Boolean): TGRegularTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGRegularTreeMultiSet.Create(Comparator);
  with TTailEnumerable.Create(aLowBound, Self, aInclusive) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

function TGRegularTreeMultiSet.SubSet(constref aLowBound, aHighBound: T;
  aIncludeBounds: TRangeBounds): TGRegularTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGRegularTreeMultiSet.Create(Comparator);
  with TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

{ TGDelegatedTreeMultiSet.THeadEnumerable }

function TGDelegatedTreeMultiSet.THeadEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGDelegatedTreeMultiSet.THeadEnumerable.Create(constref aHighBound: T; tms: TCustomTreeMultiSet;
  aInclusive: Boolean);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumerator;
  FCompare := TDelegatedTree(tms.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGDelegatedTreeMultiSet.THeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGDelegatedTreeMultiSet.THeadEnumerable.MoveNext: Boolean;
begin
  if FDone then
    exit(False);
  Result := FCurrKeyCount > 0;
  FCurrKeyCount -= Ord(Result);
  if not Result then
    begin
      if not FEnum.MoveNext then
        exit(False);
      if FInclusive then
        Result := FCompare(FEnum.Current^.Data.Key, FHighBound) <= 0
      else
        Result := FCompare(FEnum.Current^.Data.Key, FHighBound) < 0;
      if Result then
        FCurrKeyCount := Pred(FEnum.Current^.Data.Count);
    end;
  FDone := not Result;
end;

procedure TGDelegatedTreeMultiSet.THeadEnumerable.Reset;
begin
  FEnum.Reset;
  FCurrKeyCount := 0;
end;

{ TGDelegatedTreeMultiSet.TRangeEnumerable }

constructor TGDelegatedTreeMultiSet.TRangeEnumerable.Create(constref aLowBound, aHighBound: T;
  tms: TCustomTreeMultiSet; aBounds: TRangeBounds);
begin
  inherited Create(tms);
  FEnum := tms.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FCompare := TDelegatedTree(tms.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGDelegatedTreeMultiSet }

constructor TGDelegatedTreeMultiSet.Create;
begin
  FTree := TDelegatedTree.Create(TDefaults.OnCompare);
end;

constructor TGDelegatedTreeMultiSet.Create(c: TComparator);
begin
  FTree := TDelegatedTree.Create(c);
end;

constructor TGDelegatedTreeMultiSet.Create(aCapacity: SizeInt; c: TComparator);
begin
  FTree := TDelegatedTree.Create(aCapacity, c);
end;

constructor TGDelegatedTreeMultiSet.Create(constref a: array of T; c: TComparator);
begin
  FTree := TDelegatedTree.Create(c);
  DoAddAll(a);
end;

constructor TGDelegatedTreeMultiSet.Create(e: IEnumerable; c: TComparator);
begin
  FTree := TDelegatedTree.Create(c);
  DoAddAll(e);
end;

constructor TGDelegatedTreeMultiSet.CreateCopy(aMultiSet: TGDelegatedTreeMultiSet);
begin
  FTree := TDelegatedTree(aMultiSet.FTree).Clone;
  FCount := aMultiSet.Count;
end;

function TGDelegatedTreeMultiSet.Comparator: TComparator;
begin
  Result := TDelegatedTree(FTree).Comparator;
end;

function TGDelegatedTreeMultiSet.Clone: TGDelegatedTreeMultiSet;
begin
  Result := TGDelegatedTreeMultiSet.CreateCopy(Self);
end;

function TGDelegatedTreeMultiSet.Head(constref aHighBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := THeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGDelegatedTreeMultiSet.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): IEnumerable;
begin
  BeginIteration;
  Result := TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGDelegatedTreeMultiSet.HeadSet(constref aHighBound: T; aInclusive: Boolean): TGDelegatedTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGDelegatedTreeMultiSet.Create(Comparator);
  with THeadEnumerable.Create(aHighBound, Self, aInclusive) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

function TGDelegatedTreeMultiSet.TailSet(constref aLowBound: T; aInclusive: Boolean): TGDelegatedTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGDelegatedTreeMultiSet.Create(Comparator);
  with TTailEnumerable.Create(aLowBound, Self, aInclusive) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

function TGDelegatedTreeMultiSet.SubSet(constref aLowBound, aHighBound: T;
  aIncludeBounds: TRangeBounds): TGDelegatedTreeMultiSet;
var
  e: TEntry;
begin
  Result := TGDelegatedTreeMultiSet.Create(Comparator);
  with TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds) do
    try
      while MoveNext do
        begin
          e := FEnum.Current^.Data;
          Result[e.Key] := e.Count;
        end;
    finally
      Free;
    end;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic sorted set implementations on the top of AVL tree.              *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGTreeSet;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGAvlTree;

type

  { TGCustomTreeSet: common abstract ancestor set class }
  generic TGCustomTreeSet<T> = class abstract(specialize TGCustomSet<T>)
  public
  type
    TCustomTreeSet = specialize TGCustomTreeSet<T>;

  protected
  type
    TTree = specialize TGCustomAvlTree<T, TEntry>;
    PNode = TTree.PNode;

    TEnumerator = class(TContainerEnumerator)
    protected
      FEnum: TTree.TEnumerator;
      function  GetCurrent: T; override;
    public
      constructor Create(aSet: TCustomTreeSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TReverseEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      function  GetCurrent: T; override;
    public
      constructor Create(aSet: TCustomTreeSet);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TTailEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumeratorAt;
      function  GetCurrent: T; override;
    public
      constructor Create(constref aLowBound: T; aSet: TCustomTreeSet; aInclusive: Boolean);
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

  var
    FTree: TTree;
    function  GetCount: SizeInt; override;
    function  GetCapacity: SizeInt; override;
    function  DoGetEnumerator: TCustomEnumerator; override;
    procedure DoClear; override;
    procedure DoTrimToFit; override;
    procedure DoEnsureCapacity(aValue: SizeInt); override;
    function  DoAdd(constref aValue: T): Boolean; override;
    function  DoExtract(constref aValue: T): Boolean; override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
    function  DoExtractIf(aTest: TTest): TArray; override;
    function  DoExtractIf(aTest: TOnTest): TArray; override;
    function  DoExtractIf(aTest: TNestTest): TArray; override;
    function  FindNearestLT(constref aPattern: T; out aValue: T): Boolean;
    function  FindNearestLE(constref aPattern: T; out aValue: T): Boolean;
    function  FindNearestGT(constref aPattern: T; out aValue: T): Boolean;
    function  FindNearestGE(constref aPattern: T; out aValue: T): Boolean;
  public
    destructor Destroy; override;
    function Reverse: IEnumerable; override;
    function Contains(constref aValue: T): Boolean; override;
    function FindMin(out aValue: T): Boolean;
    function FindMax(out aValue: T): Boolean;
  { returns True if exists element whose value greater then or equal to aValue (depend on aInclusive) }
    function FindCeil(constref aValue: T; out aCeil: T; aInclusive: Boolean = True): Boolean;
  { returns True if exists element whose value less then aBound (or equal to aValue depend on aInclusive) }
    function FindFloor(constref aValue: T; out aFloor: T; aInclusive: Boolean = False): Boolean;
  { enumerates values whose are strictly less than(if not aInclusive) aHighBound }
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; virtual; abstract;
  { enumerates values whose are greater than or equal to(if aInclusive) aLowBound }
    function Tail(constref aLowBound: T; aInclusive: Boolean = True): IEnumerable;
  { enumerates values whose are greater than or equal to aLowBound and strictly less than aHighBound(by default)}
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
       virtual; abstract;
  { returns sorted set whose items are strictly less than(if not aInclusive) aHighBound }
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TCustomTreeSet; virtual; abstract;
  { returns sorted set whose items are greater than or equal(if aInclusive) to aLowBound}
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TCustomTreeSet; virtual; abstract;
  { returns sorted set whose items are greater than or equal to aLowBound and strictly less than
    aHighBound(by default) }
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TCustomTreeSet;
       virtual; abstract;
  end;

  { TGBaseTreeSet implements sorted set;
      functor TCmpRel (comparision relation) must provide:
        class function Compare([const[ref]] L, R: T): SizeInt; }
  generic TGBaseTreeSet<T, TCmpRel> = class(specialize TGCustomTreeSet<T>)
  protected
  type
    TBaseTree = specialize TGAvlTree<T, TEntry, TCmpRel>;

    THeadEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FHighBound: T;
      FInclusive,
      FDone: Boolean;
      function  GetCurrent: T; override;
    public
      constructor Create(constref aHighBound: T; aSet: TCustomTreeSet; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRangeEnumerable = class(THeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: T; aSet: TCustomTreeSet; aBounds: TRangeBounds); overload;
    end;

    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref a: array of T);
    constructor Create(e: IEnumerable);
    constructor CreateCopy(aSet: TGBaseTreeSet);
    function Clone: TGBaseTreeSet; override;
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; override;
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
      override;
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TGBaseTreeSet; override;
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TGBaseTreeSet; override;
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TGBaseTreeSet;
      override;
  end;

  { TGTreeSet implements sorded set, it assumes that type T implements TCmpRel }
  generic TGTreeSet<T> = class(specialize TGBaseTreeSet<T, T>);

  { TGComparableTreeSet implements sorted set; it assumes that type T has defined comparision operators }
  generic TGComparableTreeSet<T> = class(specialize TGCustomTreeSet<T>)
  protected
  type
    TComparableTree = specialize TGComparableAvlTree<T, TEntry>;

    THeadEnumerable = class(TContainerEnumerable)
    private
      FEnum: TTree.TEnumerator;
      FHighBound: T;
      FInclusive,
      FDone: Boolean;
    protected
      function  GetCurrent: T; override;
    public
      constructor Create(constref aHighBound: T; aSet: TCustomTreeSet; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRangeEnumerable = class(THeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: T; aSet: TCustomTreeSet; aBounds: TRangeBounds); overload;
    end;

    class function DoCompare(constref L, R: T): SizeInt; static;
  public
  type
    TComparator = TCompare;
    class function Comparator: TComparator; static; inline;
    constructor Create;
    constructor Create(aCapacity: SizeInt);
    constructor Create(constref a: array of T);
    constructor Create(e: IEnumerable);
    constructor CreateCopy(aSet: TGComparableTreeSet);
    function Clone: TGComparableTreeSet; override;
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; override;
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
      override;
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TGComparableTreeSet; override;
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TGComparableTreeSet; override;
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TGComparableTreeSet;
      override;
  end;

  { TGObjectTreeSet }

  generic TGObjectTreeSet<T: class; TCmpRel> = class(specialize TGBaseTreeSet<T, TCmpRel>)
  private
    FOwnsObjects: Boolean;
  protected
    procedure NodeRemoved(p: PEntry);
    procedure DoClear; override;
    function  DoRemove(constref aValue: T): Boolean; override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(constref a: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
    constructor CreateCopy(aSet: TGObjectTreeSet);
    function  Clone: TGObjectTreeSet; override;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGObjTreeSet assumes that type T implements TCmpRel}
  generic TGObjTreeSet<T: class> = class(specialize TGObjectTreeSet<T, T>);

  { TGRegularTreeSet implements sorted set with regular comparator }
  generic TGRegularTreeSet<T> = class(specialize TGCustomTreeSet<T>)
  protected
  type
    TRegularTree = specialize TGRegularAvlTree<T, TEntry>;

    THeadEnumerable = class(TContainerEnumerable)
    private
      FEnum: TTree.TEnumerator;
      FHighBound: T;
      FCompare: TCompare;
      FInclusive,
      FDone: Boolean;
    protected
      function  GetCurrent: T; override;
    public
      constructor Create(constref aHighBound: T; aSet: TCustomTreeSet; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRangeEnumerable = class(THeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: T; aSet: TCustomTreeSet; aBounds: TRangeBounds); overload;
    end;

  public
  type
    TComparator = TCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref a: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    constructor CreateCopy(aSet: TGRegularTreeSet);
    function Comparator: TComparator; inline;
    function Clone: TGRegularTreeSet; override;
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; override;
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
      override;
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TGRegularTreeSet; override;
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TGRegularTreeSet; override;
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TGRegularTreeSet;
      override;
  end;

  { TGObjectRegularTreeSet }

  generic TGObjectRegularTreeSet<T: class> = class(specialize TGRegularTreeSet<T>)
  private
    FOwnsObjects: Boolean;
  protected
    procedure NodeRemoved(p: PEntry);
    procedure DoClear; override;
    function  DoRemove(constref aValue: T): Boolean; override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(c: TComparator; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; c: TComparator; aOwnsObjects: Boolean = True);
    constructor Create(constref a: array of T; c: TComparator; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; c: TComparator; aOwnsObjects: Boolean = True);
    constructor CreateCopy(aSet: TGObjectRegularTreeSet);
    function  Clone: TGObjectRegularTreeSet; override;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGDelegatedTreeSet implements sorted set with delegated comparator }
  generic TGDelegatedTreeSet<T> = class(specialize TGCustomTreeSet<T>)
  protected
  type
    TDelegatedTree = specialize TGDelegatedAvlTree<T, TEntry>;

    THeadEnumerable = class(TContainerEnumerable)
    protected
      FEnum: TTree.TEnumerator;
      FHighBound: T;
      FCompare: TOnCompare;
      FInclusive,
      FDone: Boolean;
      function  GetCurrent: T; override;
    public
      constructor Create(constref aHighBound: T; aSet: TCustomTreeSet; aInclusive: Boolean); overload;
      destructor Destroy; override;
      function  MoveNext: Boolean; override;
      procedure Reset; override;
    end;

    TRangeEnumerable = class(THeadEnumerable)
      constructor Create(constref aLowBound, aHighBound: T; aSet: TCustomTreeSet; aBounds: TRangeBounds); overload;
    end;

  public
  type
    TComparator = TOnCompare;
    constructor Create;
    constructor Create(c: TComparator);
    constructor Create(aCapacity: SizeInt; c: TComparator);
    constructor Create(constref a: array of T; c: TComparator);
    constructor Create(e: IEnumerable; c: TComparator);
    constructor CreateCopy(aSet: TGDelegatedTreeSet);
    function Comparator: TComparator; inline;
    function Clone: TGDelegatedTreeSet; override;
    function Head(constref aHighBound: T; aInclusive: Boolean = False): IEnumerable; override;
    function Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): IEnumerable;
      override;
    function HeadSet(constref aHighBound: T; aInclusive: Boolean = False): TGDelegatedTreeSet; override;
    function TailSet(constref aLowBound: T; aInclusive: Boolean = True): TGDelegatedTreeSet; override;
    function SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds = [rbLow]): TGDelegatedTreeSet;
      override;
  end;

  { TGObjectDelegatedTreeSet }

  generic TGObjectDelegatedTreeSet<T: class> = class(specialize TGDelegatedTreeSet<T>)
  protected
    FOwnsObjects: Boolean;
    procedure NodeRemoved(p: PEntry);
    procedure DoClear; override;
    function  DoRemove(constref aValue: T): Boolean; override;
    function  DoRemoveIf(aTest: TTest): SizeInt; override;
    function  DoRemoveIf(aTest: TOnTest): SizeInt; override;
    function  DoRemoveIf(aTest: TNestTest): SizeInt; override;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(aCompare: TOnCompare; aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aCompare: TOnCompare; aOwnsObjects: Boolean = True);
    constructor Create(constref a: array of T; aCompare: TOnCompare; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aCompare: TOnCompare; aOwnsObjects: Boolean = True);
    constructor CreateCopy(aSet: TGObjectDelegatedTreeSet);
    function  Clone: TGObjectDelegatedTreeSet; override;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGCustomTreeSet.TEnumerator }

function TGCustomTreeSet.TEnumerator.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGCustomTreeSet.TEnumerator.Create(aSet: TCustomTreeSet);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumerator;
end;

destructor TGCustomTreeSet.TEnumerator.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeSet.TEnumerator.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomTreeSet.TEnumerator.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomTreeSet.TReverseEnumerable }

function TGCustomTreeSet.TReverseEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGCustomTreeSet.TReverseEnumerable.Create(aSet: TCustomTreeSet);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetReverseEnumerator;
end;

destructor TGCustomTreeSet.TReverseEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeSet.TReverseEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomTreeSet.TReverseEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomTreeSet.TTailEnumerable }

function TGCustomTreeSet.TTailEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGCustomTreeSet.TTailEnumerable.Create(constref aLowBound: T; aSet: TCustomTreeSet;
  aInclusive: Boolean);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumeratorAt(aLowBound, aInclusive);
end;

destructor TGCustomTreeSet.TTailEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGCustomTreeSet.TTailEnumerable.MoveNext: Boolean;
begin
  Result := FEnum.MoveNext;
end;

procedure TGCustomTreeSet.TTailEnumerable.Reset;
begin
  FEnum.Reset;
end;

{ TGCustomTreeSet }

function TGCustomTreeSet.GetCount: SizeInt;
begin
  Result := FTree.Count;
end;

function TGCustomTreeSet.GetCapacity: SizeInt;
begin
  Result := FTree.Capacity;
end;

function TGCustomTreeSet.DoGetEnumerator: TCustomEnumerator;
begin
  Result := TEnumerator.Create(Self);
end;

procedure TGCustomTreeSet.DoClear;
begin
  FTree.Clear;
end;

procedure TGCustomTreeSet.DoTrimToFit;
begin
  FTree.TrimToFit;
end;

procedure TGCustomTreeSet.DoEnsureCapacity(aValue: SizeInt);
begin
  FTree.EnsureCapacity(aValue);
end;

function TGCustomTreeSet.DoAdd(constref aValue: T): Boolean;
var
  p: PNode;
begin
  Result := not FTree.FindOrAdd(aValue, p);
end;

function TGCustomTreeSet.DoExtract(constref aValue: T): Boolean;
begin
  Result := FTree.Remove(aValue);
end;

function TGCustomTreeSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest);
end;

function TGCustomTreeSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest);
end;

function TGCustomTreeSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  Result := FTree.RemoveIf(aTest);
end;

function TGCustomTreeSet.DoExtractIf(aTest: TTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTree.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

function TGCustomTreeSet.DoExtractIf(aTest: TOnTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTree.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

function TGCustomTreeSet.DoExtractIf(aTest: TNestTest): TArray;
var
  e: TExtractHelper;
begin
  e.Init;
  FTree.RemoveIf(aTest, @e.OnExtract);
  Result := e.Final;
end;

function TGCustomTreeSet.FindNearestLT(constref aPattern: T; out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindLess(aPattern);
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

function TGCustomTreeSet.FindNearestLE(constref aPattern: T; out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindLessOrEqual(aPattern);
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

function TGCustomTreeSet.FindNearestGT(constref aPattern: T; out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindGreater(aPattern);
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

function TGCustomTreeSet.FindNearestGE(constref aPattern: T; out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.FindGreaterOrEqual(aPattern);
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

destructor TGCustomTreeSet.Destroy;
begin
  DoClear;
  FTree.Free;
  inherited;
end;

function TGCustomTreeSet.Reverse: IEnumerable;
begin
  BeginIteration;
  Result := TReverseEnumerable.Create(Self);
end;

function TGCustomTreeSet.Contains(constref aValue: T): Boolean;
begin
  Result := FTree.Find(aValue) <> nil;
end;

function TGCustomTreeSet.FindMin(out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Lowest;
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

function TGCustomTreeSet.FindMax(out aValue: T): Boolean;
var
  Node: PNode;
begin
  Node := FTree.Highest;
  Result := Node <> nil;
  if Result then
    aValue := Node^.Data.Key;
end;

function TGCustomTreeSet.FindCeil(constref aValue: T; out aCeil: T; aInclusive: Boolean): Boolean;
begin
  if aInclusive then
    Result := FindNearestGE(aValue, aCeil)
  else
    Result := FindNearestGT(aValue, aCeil);
end;

function TGCustomTreeSet.FindFloor(constref aValue: T; out aFloor: T; aInclusive: Boolean): Boolean;
begin
  if aInclusive then
    Result := FindNearestLE(aValue, aFloor)
  else
    Result := FindNearestLT(aValue, aFloor);
end;

function TGCustomTreeSet.Tail(constref aLowBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := TTailEnumerable.Create(aLowBound, Self, aInclusive);
end;

{ TGBaseTreeSet.THeadEnumerable }

function TGBaseTreeSet.THeadEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGBaseTreeSet.THeadEnumerable.Create(constref aHighBound: T; aSet: TCustomTreeSet;
  aInclusive: Boolean);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumerator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGBaseTreeSet.THeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGBaseTreeSet.THeadEnumerable.MoveNext: Boolean;
begin
  if FDone or not FEnum.MoveNext then
    exit(False);
  if FInclusive then
    Result := TCmpRel.Compare(FEnum.Current^.Data.Key, FHighBound) <= 0
  else
    Result := TCmpRel.Compare(FEnum.Current^.Data.Key, FHighBound) < 0;
  FDone := not Result;
end;

procedure TGBaseTreeSet.THeadEnumerable.Reset;
begin
  FEnum.Reset;
  FDone := False;
end;

{ TGBaseTreeSet.TRangeEnumerable }

constructor TGBaseTreeSet.TRangeEnumerable.Create(constref aLowBound, aHighBound: T; aSet: TCustomTreeSet;
  aBounds: TRangeBounds);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGBaseTreeSet }

class function TGBaseTreeSet.DoCompare(constref L, R: T): SizeInt;
begin
  Result := TCmpRel.Compare(L, R);
end;

class function TGBaseTreeSet.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

constructor TGBaseTreeSet.Create;
begin
  FTree := TBaseTree.Create;
end;

constructor TGBaseTreeSet.Create(aCapacity: SizeInt);
begin
  FTree := TBaseTree.Create(aCapacity);
end;

constructor TGBaseTreeSet.Create(constref a: array of T);
begin
  FTree := TBaseTree.Create;
  DoAddAll(a);
end;

constructor TGBaseTreeSet.Create(e: IEnumerable);
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TGBaseTreeSet then
    CreateCopy(TGBaseTreeSet(o))
  else
    begin
      if o is TCustomSet then
        Create(TCustomSet(o).Count)
      else
        Create;
      DoAddAll(e);
    end;
end;

constructor TGBaseTreeSet.CreateCopy(aSet: TGBaseTreeSet);
begin
  FTree := TBaseTree(aSet.FTree).Clone;
end;

function TGBaseTreeSet.Clone: TGBaseTreeSet;
begin
  Result := TGBaseTreeSet.CreateCopy(Self);
end;

function TGBaseTreeSet.Head(constref aHighBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := THeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGBaseTreeSet.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): IEnumerable;
begin
  BeginIteration;
  Result := TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGBaseTreeSet.HeadSet(constref aHighBound: T; aInclusive: Boolean): TGBaseTreeSet;
var
  v: T;
begin
  Result := TGBaseTreeSet.Create;
  for v in Head(aHighBound, aInclusive) do
    Result.Add(v);
end;

function TGBaseTreeSet.TailSet(constref aLowBound: T; aInclusive: Boolean): TGBaseTreeSet;
var
  v: T;
begin
  Result := TGBaseTreeSet.Create;
  for v in Tail(aLowBound, aInclusive) do
    Result.Add(v);
end;

function TGBaseTreeSet.SubSet(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): TGBaseTreeSet;
var
  v: T;
begin
    Result := TGBaseTreeSet.Create;
  for v in Range(aLowBound, aHighBound, aIncludeBounds) do
    Result.Add(v);
end;

{ TGComparableTreeSet.THeadEnumerable }

function TGComparableTreeSet.THeadEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGComparableTreeSet.THeadEnumerable.Create(constref aHighBound: T; aSet: TCustomTreeSet;
  aInclusive: Boolean);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumerator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGComparableTreeSet.THeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGComparableTreeSet.THeadEnumerable.MoveNext: Boolean;
begin
  if FDone or not FEnum.MoveNext then
    exit(False);
  if FInclusive then
    Result := FEnum.Current^.Data.Key <= FHighBound
  else
    Result := FEnum.Current^.Data.Key < FHighBound;
  FDone := not Result;
end;

procedure TGComparableTreeSet.THeadEnumerable.Reset;
begin
  FEnum.Reset;
  FDone := False;
end;

{ TGComparableTreeSet.TRangeEnumerable }

constructor TGComparableTreeSet.TRangeEnumerable.Create(constref aLowBound, aHighBound: T;
  aSet: TCustomTreeSet; aBounds: TRangeBounds);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGComparableTreeSet }

class function TGComparableTreeSet.DoCompare(constref L, R: T): SizeInt;
begin
  if L > R then
    Result := 1
  else
    if R > L then
      Result := -1
    else
      Result := 0;
end;

class function TGComparableTreeSet.Comparator: TComparator;
begin
  Result := @DoCompare;
end;

constructor TGComparableTreeSet.Create;
begin
  FTree := TComparableTree.Create;
end;

constructor TGComparableTreeSet.Create(aCapacity: SizeInt);
begin
  FTree := TComparableTree.Create(aCapacity);
end;

constructor TGComparableTreeSet.Create(constref a: array of T);
begin
  FTree := TComparableTree.Create;
  DoAddAll(a);
end;

constructor TGComparableTreeSet.Create(e: IEnumerable);
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TGComparableTreeSet then
    CreateCopy(TGComparableTreeSet(o))
  else
    begin
      if o is TCustomSet then
        Create(TCustomSet(o).Count)
      else
        Create;
      DoAddAll(e);
    end;
end;

constructor TGComparableTreeSet.CreateCopy(aSet: TGComparableTreeSet);
begin
  FTree := TComparableTree(aSet.FTree).Clone;
end;

function TGComparableTreeSet.Clone: TGComparableTreeSet;
begin
  Result := TGComparableTreeSet.CreateCopy(Self);
end;

function TGComparableTreeSet.Head(constref aHighBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := THeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGComparableTreeSet.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): IEnumerable;
begin
  BeginIteration;
  Result := TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGComparableTreeSet.HeadSet(constref aHighBound: T; aInclusive: Boolean): TGComparableTreeSet;
var
  v: T;
begin
  Result := TGComparableTreeSet.Create;
  for v in Head(aHighBound, aInclusive) do
    Result.Add(v);
end;

function TGComparableTreeSet.TailSet(constref aLowBound: T; aInclusive: Boolean): TGComparableTreeSet;
var
  v: T;
begin
  Result := TGComparableTreeSet.Create;
  for v in Tail(aLowBound, aInclusive) do
    Result.Add(v);
end;

function TGComparableTreeSet.SubSet(constref aLowBound, aHighBound: T;
  aIncludeBounds: TRangeBounds): TGComparableTreeSet;
var
  v: T;
begin
  Result := TGComparableTreeSet.Create;
  for v in Range(aLowBound, aHighBound, aIncludeBounds) do
    Result.Add(v);
end;

{ TGObjectTreeSet }

procedure TGObjectTreeSet.NodeRemoved(p: PEntry);
begin
  p^.Key.Free;
end;

procedure TGObjectTreeSet.DoClear;
var
  p: PNode;
begin
  if OwnsObjects then
    for p in FTree do
      p^.Data.Key.Free;
  inherited;
end;

function TGObjectTreeSet.DoRemove(constref aValue: T): Boolean;
begin
  Result := inherited DoRemove(aValue);
  if Result and OwnsObjects then
    aValue.Free;
end;

function TGObjectTreeSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTree.RemoveIf(aTest, @NodeRemoved)
  else
    Result := FTree.RemoveIf(aTest);
end;

function TGObjectTreeSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTree.RemoveIf(aTest, @NodeRemoved)
  else
    Result := FTree.RemoveIf(aTest);
end;

function TGObjectTreeSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTree.RemoveIf(aTest, @NodeRemoved)
  else
    Result := FTree.RemoveIf(aTest);
end;

constructor TGObjectTreeSet.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectTreeSet.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectTreeSet.Create(constref a: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(a);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectTreeSet.Create(e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(e);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectTreeSet.CreateCopy(aSet: TGObjectTreeSet);
begin
  FTree := TBaseTree(aSet.FTree).Clone;
  OwnsObjects := aSet.OwnsObjects;
end;

function TGObjectTreeSet.Clone: TGObjectTreeSet;
begin
  Result := TGObjectTreeSet.CreateCopy(Self);
end;

{ TGRegularTreeSet.THeadEnumerable }

function TGRegularTreeSet.THeadEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGRegularTreeSet.THeadEnumerable.Create(constref aHighBound: T; aSet: TCustomTreeSet;
  aInclusive: Boolean);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumerator;
  FCompare := TRegularTree(aSet.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGRegularTreeSet.THeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGRegularTreeSet.THeadEnumerable.MoveNext: Boolean;
begin
  if FDone or not FEnum.MoveNext then
    exit(False);
  if FInclusive then
    Result := FCompare(FEnum.Current^.Data.Key, FHighBound) <= 0
  else
    Result := FCompare(FEnum.Current^.Data.Key, FHighBound) < 0;
  FDone := not Result;
end;

procedure TGRegularTreeSet.THeadEnumerable.Reset;
begin
  FEnum.Reset;
  FDone := False;
end;

{ TGRegularTreeSet.TRangeEnumerable }

constructor TGRegularTreeSet.TRangeEnumerable.Create(constref aLowBound, aHighBound: T; aSet: TCustomTreeSet;
  aBounds: TRangeBounds);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FCompare := TRegularTree(aSet.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGRegularTreeSet }

constructor TGRegularTreeSet.Create;
begin
  FTree := TRegularTree.Create(TDefaults.Compare);
end;

constructor TGRegularTreeSet.Create(c: TComparator);
begin
  FTree := TRegularTree.Create(c);
end;

constructor TGRegularTreeSet.Create(aCapacity: SizeInt; c: TComparator);
begin
  FTree := TRegularTree.Create(aCapacity, c);
end;

constructor TGRegularTreeSet.Create(constref a: array of T; c: TComparator);
begin
  FTree := TRegularTree.Create(c);
  DoAddAll(a);
end;

constructor TGRegularTreeSet.Create(e: IEnumerable; c: TComparator);
begin
  FTree := TRegularTree.Create(c);
  DoAddAll(e);
end;

constructor TGRegularTreeSet.CreateCopy(aSet: TGRegularTreeSet);
begin
  FTree := TRegularTree(aSet.FTree).Clone;
end;

function TGRegularTreeSet.Comparator: TComparator;
begin
  Result := TRegularTree(FTree).Comparator;
end;

function TGRegularTreeSet.Clone: TGRegularTreeSet;
begin
  Result := TGRegularTreeSet.Create(Self, Comparator);
end;

function TGRegularTreeSet.Head(constref aHighBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := THeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGRegularTreeSet.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): IEnumerable;
begin
  BeginIteration;
  Result := TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGRegularTreeSet.HeadSet(constref aHighBound: T; aInclusive: Boolean): TGRegularTreeSet;
var
  v: T;
begin
  Result := TGRegularTreeSet.Create(Comparator);
  for v in Head(aHighBound, aInclusive) do
    Result.Add(v);
end;

function TGRegularTreeSet.TailSet(constref aLowBound: T; aInclusive: Boolean): TGRegularTreeSet;
var
  v: T;
begin
  Result := TGRegularTreeSet.Create(Comparator);
  for v in Tail(aLowBound, aInclusive) do
    Result.Add(v);
end;

function TGRegularTreeSet.SubSet(constref aLowBound, aHighBound: T;
  aIncludeBounds: TRangeBounds): TGRegularTreeSet;
var
  v: T;
begin
  Result := TGRegularTreeSet.Create(Comparator);
  for v in Range(aLowBound, aHighBound, aIncludeBounds) do
    Result.Add(v);
end;

{ TGObjectRegularTreeSet }

procedure TGObjectRegularTreeSet.NodeRemoved(p: PEntry);
begin
  p^.Key.Free;
end;

procedure TGObjectRegularTreeSet.DoClear;
var
  p: PNode;
begin
  if OwnsObjects then
    for p in FTree do
      p^.Data.Key.Free;
  inherited;
end;

function TGObjectRegularTreeSet.DoRemove(constref aValue: T): Boolean;
begin
  Result := inherited DoRemove(aValue);
  if Result and OwnsObjects then
    aValue.Free;
end;

function TGObjectRegularTreeSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTree.RemoveIf(aTest, @NodeRemoved)
  else
    Result := FTree.RemoveIf(aTest);
end;

function TGObjectRegularTreeSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTree.RemoveIf(aTest, @NodeRemoved)
  else
    Result := FTree.RemoveIf(aTest);
end;

function TGObjectRegularTreeSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTree.RemoveIf(aTest, @NodeRemoved)
  else
    Result := FTree.RemoveIf(aTest);
end;

constructor TGObjectRegularTreeSet.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectRegularTreeSet.Create(c: TComparator; aOwnsObjects: Boolean);
begin
  inherited Create(c);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectRegularTreeSet.Create(aCapacity: SizeInt; c: TComparator; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, c);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectRegularTreeSet.Create(constref a: array of T; c: TComparator; aOwnsObjects: Boolean);
begin
  inherited Create(a, c);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectRegularTreeSet.Create(e: IEnumerable; c: TComparator; aOwnsObjects: Boolean);
begin
  inherited Create(e, c);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectRegularTreeSet.CreateCopy(aSet: TGObjectRegularTreeSet);
begin
  FTree := TRegularTree(aSet.FTree).Clone;
  FOwnsObjects := aSet.OwnsObjects;
end;

function TGObjectRegularTreeSet.Clone: TGObjectRegularTreeSet;
begin
  Result := TGObjectRegularTreeSet.CreateCopy(Self);
end;

{ TGDelegatedTreeSet.THeadEnumerable }

function TGDelegatedTreeSet.THeadEnumerable.GetCurrent: T;
begin
  Result := FEnum.Current^.Data.Key;
end;

constructor TGDelegatedTreeSet.THeadEnumerable.Create(constref aHighBound: T; aSet: TCustomTreeSet;
  aInclusive: Boolean);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumerator;
  FCompare := TDelegatedTree(aSet.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := aInclusive;
end;

destructor TGDelegatedTreeSet.THeadEnumerable.Destroy;
begin
  FEnum.Free;
  inherited;
end;

function TGDelegatedTreeSet.THeadEnumerable.MoveNext: Boolean;
begin
  if FDone or not FEnum.MoveNext then
    exit(False);
  if FInclusive then
    Result := FCompare(FEnum.Current^.Data.Key, FHighBound) <= 0
  else
    Result := FCompare(FEnum.Current^.Data.Key, FHighBound) < 0;
  FDone := not Result;
end;

procedure TGDelegatedTreeSet.THeadEnumerable.Reset;
begin
  FEnum.Reset;
  FDone := False;
end;

{ TGDelegatedTreeSet.TRangeEnumerable }

constructor TGDelegatedTreeSet.TRangeEnumerable.Create(constref aLowBound, aHighBound: T; aSet: TCustomTreeSet;
  aBounds: TRangeBounds);
begin
  inherited Create(aSet);
  FEnum := aSet.FTree.GetEnumeratorAt(aLowBound, rbLow in aBounds);
  FCompare := TDelegatedTree(aSet.FTree).Comparator;
  FHighBound := aHighBound;
  FInclusive := rbHigh in aBounds;
end;

{ TGDelegatedTreeSet }

constructor TGDelegatedTreeSet.Create;
begin
  FTree := TDelegatedTree.Create(TDefaults.OnCompare);
end;

constructor TGDelegatedTreeSet.Create(c: TComparator);
begin
  FTree := TDelegatedTree.Create(c);
end;

constructor TGDelegatedTreeSet.Create(aCapacity: SizeInt; c: TComparator);
begin
  FTree := TDelegatedTree.Create(aCapacity, c);
end;

constructor TGDelegatedTreeSet.Create(constref a: array of T; c: TComparator);
begin
  FTree := TDelegatedTree.Create(c);
  DoAddAll(a);
end;

constructor TGDelegatedTreeSet.Create(e: IEnumerable; c: TComparator);
begin
  FTree := TDelegatedTree.Create(c);
  DoAddAll(e);
end;

constructor TGDelegatedTreeSet.CreateCopy(aSet: TGDelegatedTreeSet);
begin
  FTree := TDelegatedTree(aSet.FTree).Clone;
end;

function TGDelegatedTreeSet.Comparator: TComparator;
begin
  Result := TDelegatedTree(FTree).Comparator;
end;

function TGDelegatedTreeSet.Clone: TGDelegatedTreeSet;
begin
  Result := TGDelegatedTreeSet.CreateCopy(Self);
end;

function TGDelegatedTreeSet.Head(constref aHighBound: T; aInclusive: Boolean): IEnumerable;
begin
  BeginIteration;
  Result := THeadEnumerable.Create(aHighBound, Self, aInclusive);
end;

function TGDelegatedTreeSet.Range(constref aLowBound, aHighBound: T; aIncludeBounds: TRangeBounds): IEnumerable;
begin
  BeginIteration;
  Result := TRangeEnumerable.Create(aLowBound, aHighBound, Self, aIncludeBounds);
end;

function TGDelegatedTreeSet.HeadSet(constref aHighBound: T; aInclusive: Boolean): TGDelegatedTreeSet;
var
  v: T;
begin
  Result := TGDelegatedTreeSet.Create(Comparator);
  for v in Head(aHighBound, aInclusive) do
    Result.Add(v);
end;

function TGDelegatedTreeSet.TailSet(constref aLowBound: T; aInclusive: Boolean): TGDelegatedTreeSet;
var
  v: T;
begin
  Result := TGDelegatedTreeSet.Create(Comparator);
  for v in Tail(aLowBound, aInclusive) do
    Result.Add(v);
end;

function TGDelegatedTreeSet.SubSet(constref aLowBound, aHighBound: T;
  aIncludeBounds: TRangeBounds): TGDelegatedTreeSet;
var
  v: T;
begin
  Result := TGDelegatedTreeSet.Create(Comparator);
  for v in Range(aLowBound, aHighBound, aIncludeBounds) do
    Result.Add(v);
end;

{ TGObjectDelegatedTreeSet }

procedure TGObjectDelegatedTreeSet.NodeRemoved(p: PEntry);
begin
  p^.Key.Free;
end;

procedure TGObjectDelegatedTreeSet.DoClear;
var
  p: PNode;
begin
  if OwnsObjects then
    for p in FTree do
      p^.Data.Key.Free;
  inherited;
end;

function TGObjectDelegatedTreeSet.DoRemove(constref aValue: T): Boolean;
begin
  Result := inherited DoRemove(aValue);
  if Result and OwnsObjects then
    aValue.Free;
end;

function TGObjectDelegatedTreeSet.DoRemoveIf(aTest: TTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTree.RemoveIf(aTest, @NodeRemoved)
  else
    Result := FTree.RemoveIf(aTest);
end;

function TGObjectDelegatedTreeSet.DoRemoveIf(aTest: TOnTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTree.RemoveIf(aTest, @NodeRemoved)
  else
    Result := FTree.RemoveIf(aTest);
end;

function TGObjectDelegatedTreeSet.DoRemoveIf(aTest: TNestTest): SizeInt;
begin
  if OwnsObjects then
    Result := FTree.RemoveIf(aTest, @NodeRemoved)
  else
    Result := FTree.RemoveIf(aTest);
end;

constructor TGObjectDelegatedTreeSet.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  OwnsObjects := aOwnsObjects;
end;

constructor TGObjectDelegatedTreeSet.Create(aCompare: TOnCompare; aOwnsObjects: Boolean);
begin
  inherited Create(aCompare);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectDelegatedTreeSet.Create(aCapacity: SizeInt; aCompare: TOnCompare; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity, aCompare);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectDelegatedTreeSet.Create(constref a: array of T;
  aCompare: TOnCompare; aOwnsObjects: Boolean);
begin
  inherited Create(a, aCompare);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectDelegatedTreeSet.Create(e: IEnumerable;
  aCompare: TOnCompare; aOwnsObjects: Boolean);
begin
  inherited Create(e, aCompare);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectDelegatedTreeSet.CreateCopy(aSet: TGObjectDelegatedTreeSet);
begin
  FTree := TDelegatedTree(aSet.FTree).Clone;
  FOwnsObjects := aSet.OwnsObjects;
end;

function TGObjectDelegatedTreeSet.Clone: TGObjectDelegatedTreeSet;
begin
  Result := TGObjectDelegatedTreeSet.CreateCopy(Self);
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Most common types and utils.                                            *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGUtils;

{$MODE DELPHI}
{$INLINE ON}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  typinfo,
  LGStrConst;

type

  TSortOrder            = (soAsc, soDesc);
  TRangeBound           = (rbLow, rbHigh);
  TRangeBounds          = set of TRangeBound;
  TGArray<T>            = array of T;
  TGCompare<T>          = function(constref L, R: T): SizeInt;
  TGOnCompare<T>        = function(constref L, R: T): SizeInt of object;
  TGNestCompare<T>      = function(constref L, R: T): SizeInt is nested;
  TGEqualCompare<T>     = function(constref L, R: T): Boolean;
  TGOnEqualCompare<T>   = function(constref L, R: T): Boolean of object;
  TGNestEqualCompare<T> = function(constref L, R: T): Boolean is nested;
{ predicates }
  TGTest<T>             = function(constref aValue: T): Boolean;
  TGOnTest<T>           = function(constref aValue: T): Boolean of object;
  TGNestTest<T>         = function(constref aValue: T): Boolean is nested;
{ mappings }
  TGMapFunc<X, Y>       = function(constref aValue: X): Y;
  TGOnMap<X, Y>         = function(constref aValue: X): Y of object;
  TGNestMap<X, Y>       = function(constref aValue: X): Y is nested;
{ foldings; note: accumulator on second position }
  TGFold<X, Y>          = function(constref L: X; constref R: Y): Y;
  TGOnFold<X, Y>        = function(constref L: X; constref R: Y): Y of object;
  TGNestFold<X, Y>      = function(constref L: X; constref R: Y): Y is nested;

  ELGPanic              = class(Exception);
  ELGCapacityExceed     = class(Exception);
  ELGAccessEmpty        = class(Exception);
  ELGOptional           = class(Exception);
  ELGFuture             = class(Exception);
  ELGUpdateLock         = class(Exception);
  ELGListError          = class(Exception);
  ELGMapError           = class(Exception);
  ELGTableError         = class(Exception);

const
  MAX_CONTAINER_SIZE         = Succ(SizeInt.MaxValue shr 2);
  ARRAY_INITIAL_SIZE         = 32;// * must be power of 2 *
  DEFAULT_CONTAINER_CAPACITY = 32;// * must be power of 2 *
  BOUNDS_BOTH                = TRangeBounds([rbLow, rbHigh]);
  WAIT_INFINITE              = -1;

type

  TGOptional<T> = record
  private
  var
    FValue: T;
    FAssigned: Boolean;
  class var
    CFTypeKind: System.TTypeKind;
    CFNilable: Boolean;
  const
    NilableKinds = [System.tkMethod, System.tkInterface, System.tkClass, System.tkDynArray,
                    System.tkInterfaceRaw, System.tkProcVar, System.tkClassRef, System.tkPointer];
    function GetValue: T;
    class constructor InitTypeInfo;
    class function ValueIsNil(constref aValue): Boolean; static;
    class operator Initialize(var o: TGOptional<T>); inline;
  public
    class function Construct(constref aValue: T): TGOptional<T>; overload; static; inline;
    procedure Assign(constref aValue: T); inline;
    function  OrElseDefault: T; inline;
    function  OrElse(constref aValue: T): T; inline;
    function  OrElseRaise(e: ExceptClass; const aMsg: string = ''): T; inline;
    property  Assigned: Boolean read FAssigned;
    property  Value: T read GetValue;
    class property Nilable: Boolean read CFNilable;
  end;

  { TGAutoRef: the simplest way to get a class instance with limited lifetime;
      instance will be destroyed automatically when it leaves the scope;
      class T must have default constructor without parameters }
  TGAutoRef<T: class> = record
  private
    FInstance: T;
    function  GetInstance: T; inline;
    procedure SetInstance(aValue: T); inline;
    class operator Initialize(var a: TGAutoRef<T>); inline;
    class operator Finalize(var a: TGAutoRef<T>); inline;
  public
  type
    TInstance = T;
    class operator Implicit(var a: TGAutoRef<T>): T; inline;
    property Instance: T read GetInstance write SetInstance;
  end;

  TGCustomEnumerator<T> = class abstract
  protected
    function  GetCurrent: T; virtual; abstract;
  public
    function  MoveNext: Boolean; virtual; abstract;
    procedure Reset; virtual; abstract;
    property  Current: T read GetCurrent;
  end;

{$PUSH}{$INTERFACES COM}
  IExecutable = interface
  ['{896FB5A3-4993-4698-9C33-D538A3BEE876}']
    procedure Execute;
  end;

  IGCallable<T> = interface
  ['{EF605AA3-4E0F-4C52-9A75-5068D94ECDAF}']
    function Call: T;
  end;
{$POP}

{$PUSH}{$INTERFACES CORBA}
  IObjInstance = interface
  ['{B5EABEA2-FF39-4B4A-AF2B-3B8603F0C575}']
    function _GetRef: TObject;
  end;

  IGEnumerable<T> = interface(IObjInstance)
  ['{92F9FDFC-BEA4-4968-A033-7A90C05DDA60}']
    function GetEnumerator: TGCustomEnumerator<T>;
  { enumerates elements in reverse order }
    function Reverse: IGEnumerable<T>;
    function ToArray: TGArray<T>;
    function Any: Boolean; overload;
    function None: Boolean;  overload;
    function Total: SizeInt; overload;
    function FindFirst(out aValue: T): Boolean;
    function First: TGOptional<T>;
    function FindLast(out aValue: T): Boolean;
    function Last: TGOptional<T>;
    function FindMin(out aValue: T; c: TGCompare<T>): Boolean; overload;
    function FindMin(out aValue: T; c: TGOnCompare<T>): Boolean; overload;
    function FindMin(out aValue: T; c: TGNestCompare<T>): Boolean; overload;
    function Min(c: TGCompare<T>): TGOptional<T>; overload;
    function Min(c: TGOnCompare<T>): TGOptional<T>; overload;
    function Min(c: TGNestCompare<T>): TGOptional<T>; overload;
    function FindMax(out aValue: T; c: TGCompare<T>): Boolean; overload;
    function FindMax(out aValue: T; c: TGOnCompare<T>): Boolean; overload;
    function FindMax(out aValue: T; c: TGNestCompare<T>): Boolean; overload;
    function Max(c: TGCompare<T>): TGOptional<T>; overload;
    function Max(c: TGOnCompare<T>): TGOptional<T>; overload;
    function Max(c: TGNestCompare<T>): TGOptional<T>; overload;
    function Skip(aCount: SizeInt): IGEnumerable<T>;
    function Limit(aCount: SizeInt): IGEnumerable<T>;
    function Sorted(c: TGCompare<T>): IGEnumerable<T>; overload;
    function Sorted(c: TGOnCompare<T>): IGEnumerable<T>; overload;
    function Sorted(c: TGNestCompare<T>): IGEnumerable<T>; overload;
    function Select(p: TGTest<T>): IGEnumerable<T>; overload;
    function Select(p: TGOnTest<T>): IGEnumerable<T>; overload;
    function Select(p: TGNestTest<T>): IGEnumerable<T>; overload;
    function Any(p: TGTest<T>): Boolean; overload;
    function Any(p: TGOnTest<T>): Boolean; overload;
    function Any(p: TGNestTest<T>): Boolean; overload;
    function None(p: TGTest<T>): Boolean; overload;
    function None(p: TGOnTest<T>): Boolean; overload;
    function None(p: TGNestTest<T>): Boolean; overload;
    function All(p: TGTest<T>): Boolean; overload;
    function All(p: TGOnTest<T>): Boolean; overload;
    function All(p: TGNestTest<T>): Boolean; overload;
    function Total(p: TGTest<T>): SizeInt; overload;
    function Total(p: TGOnTest<T>): SizeInt; overload;
    function Total(p: TGNestTest<T>): SizeInt; overload;
    function Distinct(c: TGCompare<T>): IGEnumerable<T>; overload;
    function Distinct(c: TGOnCompare<T>): IGEnumerable<T>; overload;
    function Distinct(c: TGNestCompare<T>): IGEnumerable<T>; overload;
    function Map(f: TGMapFunc<T, T>): IGEnumerable<T>; overload;
    function Map(f: TGOnMap<T, T>): IGEnumerable<T>; overload;
    function Map(f: TGNestMap<T, T>): IGEnumerable<T>; overload;
  { left-associative linear fold }
    function Fold(f: TGFold<T, T>; constref v0: T): T; overload;
    function Fold(f: TGFold<T, T>): TGOptional<T>; overload;
    function Fold(f: TGOnFold<T, T>; constref v0: T): T; overload;
    function Fold(f: TGOnFold<T, T>): TGOptional<T>; overload;
    function Fold(f: TGNestFold<T, T>; constref v0: T): T; overload;
    function Fold(f: TGNestFold<T, T>): TGOptional<T>; overload;
  end;

  IGContainer<T> = interface(IGEnumerable<T>)
  ['{A3F04344-421D-4678-8A88-42AF65647525}']
    function  GetCount: SizeInt;
    function  GetCapacity: SizeInt;
    function  IsEmpty: Boolean;
    function  NonEmpty: Boolean;
    procedure Clear;
    procedure EnsureCapacity(aValue: SizeInt);
  { free unused memory if possible }
    procedure TrimToFit;
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
  end;

  IGStack<T> = interface(IGContainer<T>)
  ['{6057A96E-1953-49CE-A81A-DF5633BCB38C}']
    procedure Push(constref aValue: T);
    function  PushAll(constref a: array of T): SizeInt; overload;
    function  PushAll(e: IGEnumerable<T>): SizeInt; overload;
  { EXTRACTS element from the top of stack }
    function  Pop: T;
    function  TryPop(out aValue: T): Boolean;
    function  Peek: T;
    function  TryPeek(out aValue: T): Boolean;
  end;

  IGQueue<T> = interface(IGContainer<T>)
  ['{913AFB4A-7D2C-46D8-A4FD-DAEC1F80D6C2}']
  { puts element in the tail of the queue }
    procedure Enqueue(constref aValue: T);
    function  EnqueueAll(constref a: array of T): SizeInt; overload;
    function  EnqueueAll(e: IGEnumerable<T>): SizeInt; overload;
  { EXTRACTS element from the head of queue }
    function  Dequeue: T;
    function  TryDequeue(out aValue: T): Boolean;
  { examines element in the head of queue }
    function  Peek: T;
    function  TryPeek(out aValue: T): Boolean;
  end;

  THandle = SysUtils.THandle;

  IGPriorityQueue<T> = interface(IGQueue<T>)
  ['{39ADFF1D-018D-423B-A16A-8942B06D0A76}']
    function  Insert(constref aValue: T): THandle;
    function  PeekHead: THandle;
    function  TryPeekHead(out aValue: THandle): Boolean;
    function  Value(h: THandle): T;
    procedure Update(h: THandle; constref aValue: T);
    function  Remove(h: THandle): T;
  { only another entity can be merged, aQueue will be cleared after Merge }
    function  Merge(aQueue: IGPriorityQueue<T>): SizeInt;
  end;

  IGDeque<T> = interface(IGContainer<T>)
  ['{0D127C9E-9706-4D9A-A64C-A70844DC1F55}']
    function  GetItem(aIndex: SizeInt): T;
    procedure SetItem(aIndex: SizeInt; const aValue: T);
    procedure PushFirst(constref aValue: T);
    function  PushAllFirst(constref a: array of T): SizeInt; overload;
    function  PushAllFirst(e: IGEnumerable<T>): SizeInt; overload;
    procedure PushLast(constref aValue: T);
    function  PushAllLast(constref a: array of T): SizeInt; overload;
    function  PushAllLast(e: IGEnumerable<T>): SizeInt; overload;
  { EXTRACTS element from the head of deque }
    function  PopFirst: T;
    function  TryPopFirst(out aValue: T): Boolean;
  { EXTRACTS element from the tail of deque }
    function  PopLast: T;
    function  TryPopLast(out aValue: T): Boolean;
  { examines element in the head of deque }
    function  PeekFirst: T;
    function  TryPeekFirst(out aValue: T): Boolean;
  { examines element in the tail of deque }
    function  PeekLast: T;
    function  TryPeekLast(out aValue: T): Boolean;
  { inserts aValue into position aIndex }
    procedure Insert(aIndex: SizeInt; constref aValue: T);
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
  { extracts value from position aIndex }
    function  Extract(aIndex: SizeInt): T;
    function  TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
  { deletes value in position aIndex }
    procedure Delete(aIndex: SizeInt);
    function  TryDelete(aIndex: SizeInt): Boolean;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
  end;

  IGCollection<T> = interface(IGContainer<T>)
  ['{53197613-B1FC-46BD-923A-A602D0545330}']
  { returns True if element added }
    function  Add(constref aValue: T): Boolean;
    function  Contains(constref aValue: T): Boolean;
    function  NonContains(constref aValue: T): Boolean;
    function  ContainsAny(constref a: array of T): Boolean; overload;
    function  ContainsAny(e: IGEnumerable<T>): Boolean; overload;
    function  ContainsAll(constref a: array of T): Boolean; overload;
    function  ContainsAll(e: IGEnumerable<T>): Boolean; overload;
    function  Extract(constref aValue: T): Boolean;
  { returns True if element removed }
    function  Remove(constref aValue: T): Boolean;
  { returns count of removed elements }
    function  RemoveAll(constref a: array of T): SizeInt; overload;
  { returns count of removed elements }
    function  RemoveAll(e: IGEnumerable<T>): SizeInt; overload;
  { will contain only those elements that are simultaneously contained in self and aCollection }
    procedure RetainAll(c: IGCollection<T>);
  end;

  TGMapEntry<TKey, TValue> = record
    Key: TKey;
    Value: TValue;
  end;

  IGMap<TKey, TValue> = interface{(IGContainer<TGMapEntry<TKey, TValue>>)}
  ['{67DBDBD2-D54C-4E6E-9BE6-ACDA0A40B63F}']
    function  _GetRef: TObject;
    function  GetCount: SizeInt;
    function  GetCapacity: SizeInt;
    function  GetValue(const aKey: TKey): TValue;
    function  IsEmpty: Boolean;
    function  NonEmpty: Boolean;
    procedure Clear;
    procedure EnsureCapacity(aValue: SizeInt);
  { free unused memory if possible }
    procedure TrimToFit;
  { returns True and add TEntry(aKey, aValue) only if not contains aKey }
    function  Add(constref aKey: TKey; constref aValue: TValue): Boolean;
    procedure AddOrSetValue(const aKey: TKey; const aValue: TValue);
    function  TryGetValue(constref aKey: TKey; out aValue: TValue): Boolean;
    function  GetValueDef(constref aKey: TKey; constref aDefault: TValue = Default(TValue)): TValue;
  { returns True and map aNewValue to aKey only if contains aKey, False otherwise }
    function  Replace(constref aKey: TKey; constref aNewValue: TValue): Boolean;
    function  Contains(constref aKey: TKey): Boolean;
    function  Extract(constref aKey: TKey; out v: TValue): Boolean;
    function  Remove(constref aKey: TKey): Boolean;
    procedure RetainAll(c: IGCollection<TKey>);
    function  Keys: IGEnumerable<TKey>;
    function  Values: IGEnumerable<TValue>;
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
  { reading will raise ELGMapError if an aKey is not present in map }
    property  Items[const aKey: TKey]: TValue read GetValue write AddOrSetValue; default;
  end;
{$POP}

  { TGNodeManager: TNode must provide read-write property NextLink: PNode }
  TGNodeManager<TNode> = class
  public
  type
    PNode = ^TNode;
  private
    FHead: PNode;
    FFreeCount: SizeInt;
    procedure Put2FreeList(aNode: PNode); inline;
    class function CreateNode: PNode; static; inline;
    property Head: PNode read FHead;
  public
    destructor Destroy; override;
    function  NewNode: PNode;
    procedure DisposeNode(aNode: PNode); inline;
    procedure FreeNode(aNode: PNode); inline;
    procedure EnsureFreeCount(aCount: SizeInt);
    procedure ClearFreeList;
    procedure Clear; inline;
    property  FreeCount: SizeInt read FFreeCount;
  end;

  { TGPageNodeManager: TNode must provide read-write property NextLink: PNode}
  TGPageNodeManager<TNode> = class
  public
  type
    PNode = ^TNode;

  private
  const
    PAGE_SIZE      = 4096;
    NODE_SIZE      = SizeOf(TNode);
    NODES_PER_PAGE = (PAGE_SIZE - SizeOf(Pointer)) div NODE_SIZE;

  type
    PPage = ^TPage;
    TPage = record
      Nodes: array[1..NODES_PER_PAGE] of TNode;
      NextPage: PPage;
    end;

  var
    FPageListHead: PPage;
    FFreeListHead: PNode;
    FFreeCount,
    FPageCount: SizeInt;
    procedure NewPage;
  public
    destructor Destroy; override;
    function  NewNode: PNode;
    procedure DisposeNode(aNode: PNode); inline;
    procedure FreeNode(aNode: PNode); inline;
    procedure EnsureFreeCount(aCount: SizeInt);
    procedure ClearFreeList;
    procedure Clear;
    property  FreeCount: SizeInt read FFreeCount;
    property  PagesAllocated: SizeInt read FPageCount;
  end;

  { TGJoinableNodeManager: TNode must provide read-write property NextLink: PNode }
  TGJoinableNodeManager<TNode> = record
  public
  type
    PNode = ^TNode;

  private
    FHead,
    FTail: PNode;
    FFreeCount: SizeInt;
    procedure Put2FreeList(aNode: PNode); inline;
    class function CreateNode: PNode; static; inline;
    class operator Finalize(var nm: TGJoinableNodeManager<TNode>);
  public
    function  NewNode: PNode;
    procedure DisposeNode(aNode: PNode); inline;
    procedure FreeNode(aNode: PNode); inline;
    procedure EnsureFreeCount(aCount: SizeInt);
    procedure ClearFreeList;
    procedure Clear; inline;
    procedure Join(var nm: TGJoinableNodeManager<TNode>);
    property  FreeCount: SizeInt read FFreeCount;
  end;

  { TGJoinablePageNodeManager: TNode must provide read-write property NextLink: PNode}
  TGJoinablePageNodeManager<TNode> = record
  public
  type
    PNode = ^TNode;

  private
  const
    PAGE_SIZE      = 4096;
    NODE_SIZE      = SizeOf(TNode);
    NODES_PER_PAGE = (PAGE_SIZE - SizeOf(Pointer)) div NODE_SIZE;

  type
    PPage = ^TPage;
    TPage = record
      Nodes: array[1..NODES_PER_PAGE] of TNode;
      NextPage: PPage;
    end;

  var
    FPageListHead,
    FPageListTail: PPage;
    FFreeListHead,
    FFreeListTail: PNode;
    FFreeCount,
    FPageCount: SizeInt;
    procedure NewPage;
    class operator Finalize(var nm: TGJoinablePageNodeManager<TNode>);
  public
    function  NewNode: PNode;
    procedure DisposeNode(aNode: PNode); inline;
    procedure FreeNode(aNode: PNode); inline;
    procedure EnsureFreeCount(aCount: SizeInt);
    procedure ClearFreeList;
    procedure Clear;
    procedure Join(var nm: TGJoinablePageNodeManager<TNode>);
    property  FreeCount: SizeInt read FFreeCount;
    property  PagesAllocated: SizeInt read FPageCount;
  end;

  { returns number of significant bits of aValue }
  function NSB(aValue: SizeUInt): SizeInt; inline;
  function IsTwoPower(aValue: SizeUInt): Boolean; inline;
  { note: if aValue > Succ(SizeInt.MaxValue shr 1) then function will return wrong result }
  function RoundUpTwoPower(aValue: SizeInt): SizeInt;

implementation
{$B-}{$COPERATORS ON}

{$PUSH}{$Q-}{$R-}
function NSB(aValue: SizeUInt): SizeInt;
begin
{$IF DEFINED(CPU64)}
  Result := Succ(ShortInt(BsrQWord(aValue)));
{$ELSEIF DEFINED(CPU32)}
  Result := Succ(ShortInt(BsrDWord(aValue)));
{$ELSE}
  Result := Succ(ShortInt(BsrWord(aValue)));
{$ENDIF}
end;

function IsTwoPower(aValue: SizeUInt): Boolean;
begin
  if aValue <> 0 then
    Result := aValue and Pred(aValue) = 0
  else
    Result := False;
end;

function RoundUpTwoPower(aValue: SizeInt): SizeInt;
const
  MAX_ROUND_VALUE = Succ(SizeInt.MaxValue shr 1);
begin
  Assert(aValue <= MAX_ROUND_VALUE, Format(SEArgumentTooBigFmt, [{$I %CURRENTROUTINE%}, aValue]));
  if aValue > 1 then
    begin
      if not LGUtils.IsTwoPower(aValue) then
        Result := SizeInt(1) shl LGUtils.NSB(aValue)
      else
        Result := aValue; // round not needed ???
    end
  else
    Result := 2;
end;
{$POP}

{ TGOptional }

function TGOptional<T>.GetValue: T;
begin
  if Assigned then
    Result := FValue
  else
    raise ELGOptional.Create(SEOptionalValueEmpty);
end;

class constructor TGOptional<T>.InitTypeInfo;
var
  p: typinfo.PTypeInfo;
begin
  p := System.TypeInfo(T);
  if p <> nil then
    begin
      CFTypeKind := p^.Kind;
      CFNilable := CFTypeKind in NilableKinds;
    end
  else
    begin
      CFNilable := False;
      CFTypeKind := System.tkUnknown;
    end;
end;

class function TGOptional<T>.ValueIsNil(constref aValue): Boolean;
begin
  if Nilable then
    case CFTypeKind of
      System.tkMethod:       Result := Pointer(aValue) = nil;
      System.tkInterface:    Result := Pointer(aValue) = nil;
      System.tkClass:        Result := TObject(aValue) = nil;
      System.tkDynArray:     Result := Pointer(aValue) = nil;
      System.tkInterfaceRaw: Result := Pointer(aValue) = nil;
      System.tkProcVar:      Result := Pointer(aValue) = nil;
      System.tkClassRef:     Result := TClass(aValue)  = nil;
      System.tkPointer:      Result := Pointer(aValue) = nil;
    else //todo: what about Variants ?
      Result := False;
    end
  else
    Result := False;
end;

class operator TGOptional<T>.Initialize(var o: TGOptional<T>);
begin
  o.FAssigned := False;
end;

class function TGOptional<T>.Construct(constref aValue: T): TGOptional<T>;
begin
  Result.Assign(aValue);
end;

procedure TGOptional<T>.Assign(constref aValue: T);
begin
  if not ValueIsNil((@aValue)^) then
    begin
      FAssigned := True;
      FValue := aValue;
    end;
end;

function TGOptional<T>.OrElseDefault: T;
begin
  if Assigned then
    Result := FValue
  else
    Result := Default(T);
end;

function TGOptional<T>.OrElse(constref aValue: T): T;
begin
  if Assigned then
    Result := FValue
  else
    Result := aValue;
end;

function TGOptional<T>.OrElseRaise(e: ExceptClass; const aMsg: string): T;
begin
  if not Assigned then
    raise e.Create(aMsg);
  Result := FValue;
end;

{ TGAutoRef<T> }

function TGAutoRef<T>.GetInstance: T;
begin
  if not Assigned(FInstance) then
    FInstance := T.Create;
  Result := FInstance;
end;

procedure TGAutoRef<T>.SetInstance(aValue: T);
begin
  FInstance.Free;
  FInstance := aValue;
end;

class operator TGAutoRef<T>.Initialize(var a: TGAutoRef<T>);
begin
  a.FInstance := Default(T);
end;

class operator TGAutoRef<T>.Finalize(var a: TGAutoRef<T>);
begin
  a.FInstance.Free;
end;

class operator TGAutoRef<T>.Implicit(var a: TGAutoRef<T>): T;
begin
  Result := a.Instance;
end;

{ TGNodeManager }

procedure TGNodeManager<TNode>.Put2FreeList(aNode: PNode);
begin
  aNode^.NextLink := Head;
  FHead := aNode;
  Inc(FFreeCount);
end;

class function TGNodeManager<TNode>.CreateNode: PNode;
begin
  System.New(Result);
  System.FillChar(Result^, SizeOf(TNode), 0);
end;

destructor TGNodeManager<TNode>.Destroy;
begin
  ClearFreeList;
  inherited;
end;

function TGNodeManager<TNode>.NewNode: PNode;
begin
  if Head <> nil then
    begin
      Result := Head;
      FHead := Result^.NextLink;
      Result^.NextLink := nil;
      Dec(FFreeCount);
    end
  else
    Result := CreateNode;
end;

procedure TGNodeManager<TNode>.DisposeNode(aNode: PNode);
begin
  System.Dispose(aNode);
end;

procedure TGNodeManager<TNode>.FreeNode(aNode: PNode);
begin
  Put2FreeList(aNode);
end;

procedure TGNodeManager<TNode>.EnsureFreeCount(aCount: SizeInt);
begin
  while aCount > FreeCount do
    Put2FreeList(CreateNode);
end;

procedure TGNodeManager<TNode>.ClearFreeList;
var
  CurrNode, NextNode: PNode;
begin
  CurrNode := Head;
  while CurrNode <> nil do
    begin
      NextNode := CurrNode^.NextLink;
      System.Dispose(CurrNode);
      CurrNode := NextNode;
      Dec(FFreeCount);
    end;
  FHead := nil;
  Assert(FFreeCount = 0, Format('Inconsistent FFreeCount value(%d)', [FFreeCount]));
end;

procedure TGNodeManager<TNode>.Clear;
begin
  ClearFreeList;
end;

{ TGPageNodeManager }

procedure TGPageNodeManager<TNode>.NewPage;
var
  CurrPage: PPage;
  LastNode: PNode;
  I: Integer;
begin
  System.New(CurrPage);
  System.FillChar(CurrPage^, SizeOf(TPage), 0);
  CurrPage^.NextPage := FPageListHead;
  FPageListHead := CurrPage;
  with CurrPage^ do
    begin
      LastNode := FFreeListHead;
      I := 1;
      while I <= NODES_PER_PAGE - 4 do
        begin
          Nodes[I  ].NextLink := LastNode;
          Nodes[I+1].NextLink := @Nodes[I  ];
          Nodes[I+2].NextLink := @Nodes[I+1];
          Nodes[I+3].NextLink := @Nodes[I+2];
          LastNode := @Nodes[I+3];
          I += 4;
        end;
      for I := I to NODES_PER_PAGE do
        begin
          Nodes[I].NextLink := LastNode;
          LastNode := @Nodes[I];
        end;
      FFreeListHead := LastNode;
    end;
  Inc(FPageCount);
  FFreeCount += NODES_PER_PAGE;
end;

destructor TGPageNodeManager<TNode>.Destroy;
begin
  Clear;
  inherited;
end;

function TGPageNodeManager<TNode>.NewNode: PNode;
begin
  if FFreeListHead = nil then
    NewPage;
  Result := FFreeListHead;
  FFreeListHead := Result^.NextLink;
  Result^.NextLink := nil;
  Dec(FFreeCount);
end;

procedure TGPageNodeManager<TNode>.DisposeNode(aNode: PNode);
begin
  FreeNode(aNode);
end;

procedure TGPageNodeManager<TNode>.FreeNode(aNode: PNode);
begin
  aNode^.NextLink := FFreeListHead;
  FFreeListHead := aNode;
  Inc(FFreeCount);
end;

procedure TGPageNodeManager<TNode>.EnsureFreeCount(aCount: SizeInt);
begin
  while FreeCount < aCount do
    NewPage;
end;

procedure TGPageNodeManager<TNode>.ClearFreeList;
begin
  // do nothing
end;

procedure TGPageNodeManager<TNode>.Clear;
var
  CurrPage, NextPage: PPage;
begin
  FFreeListHead := nil;
  CurrPage := FPageListHead;
  while CurrPage <> nil do
    begin
      NextPage := CurrPage^.NextPage;
      System.Dispose(CurrPage);
      CurrPage := NextPage;
      Dec(FPageCount);
    end;
  FPageListHead := nil;
  FFreeCount := 0;
  Assert(FPageCount = 0, Format('Inconsistent FPageCount value(%d)', [FPageCount]));
end;

{ TGJoinableNodeManager }

procedure TGJoinableNodeManager<TNode>.Put2FreeList(aNode: PNode);
begin
  aNode^.NextLink := FHead;
  FHead := aNode;
  Inc(FFreeCount);
  if FTail = nil then
    FTail := aNode;
end;

class function TGJoinableNodeManager<TNode>.CreateNode: PNode;
begin
  System.New(Result);
  System.FillChar(Result^, SizeOf(TNode), 0);
end;

class operator TGJoinableNodeManager<TNode>.Finalize(var nm: TGJoinableNodeManager<TNode>);
begin
  nm.Clear;
end;

function TGJoinableNodeManager<TNode>.NewNode: PNode;
begin
  if FHead <> nil then
    begin
      Result := FHead;
      FHead := Result^.NextLink;
      Result^.NextLink := nil;
      Dec(FFreeCount);
      if FHead = nil then
        FTail := nil;
    end
  else
    Result := CreateNode;
end;

procedure TGJoinableNodeManager<TNode>.DisposeNode(aNode: PNode);
begin
  System.Dispose(aNode);
end;

procedure TGJoinableNodeManager<TNode>.FreeNode(aNode: PNode);
begin
  Put2FreeList(aNode);
end;

procedure TGJoinableNodeManager<TNode>.EnsureFreeCount(aCount: SizeInt);
begin
  while aCount > FreeCount do
    Put2FreeList(CreateNode);
end;

procedure TGJoinableNodeManager<TNode>.ClearFreeList;
var
  CurrNode, NextNode: PNode;
begin
  CurrNode := FHead;
  while CurrNode <> nil do
    begin
      NextNode := CurrNode^.NextLink;
      System.Dispose(CurrNode);
      CurrNode := NextNode;
      Dec(FFreeCount);
    end;
  FHead := nil;
  FTail := nil;
  Assert(FFreeCount = 0, Format('Inconsistent FFreeCount value(%d)', [FFreeCount]));
end;

procedure TGJoinableNodeManager<TNode>.Clear;
begin
  ClearFreeList;
end;

procedure TGJoinableNodeManager<TNode>.Join(var nm: TGJoinableNodeManager<TNode>);
begin
  if nm.FreeCount > 0 then
    begin
      if FreeCount > 0 then
        FTail^.NextLink := nm.FHead
      else
        FHead := nm.FHead;
      FTail := nm.FTail;
      FFreeCount += nm.FreeCount;
      nm.FFreeCount := 0;
      nm.FHead := nil;
      nm.FTail := nil;
    end;
end;

{ TGJoinablePageNodeManager }

procedure TGJoinablePageNodeManager<TNode>.NewPage;
var
  CurrPage: PPage;
  LastNode: PNode;
  I: Integer;
begin
  System.New(CurrPage);
  System.FillChar(CurrPage^, SizeOf(TPage), 0);
  CurrPage^.NextPage := FPageListHead;
  FPageListHead := CurrPage;
  if FPageListTail = nil then
    FPageListTail := CurrPage;
  if FFreeListTail = nil then
    FFreeListTail := @CurrPage^.Nodes[1];
  with CurrPage^ do
    begin
      LastNode := FFreeListHead;
      I := 1;
      while I <= NODES_PER_PAGE - 4 do
        begin
          Nodes[I  ].NextLink := LastNode;
          Nodes[I+1].NextLink := @Nodes[I  ];
          Nodes[I+2].NextLink := @Nodes[I+1];
          Nodes[I+3].NextLink := @Nodes[I+2];
          LastNode := @Nodes[I+3];
          I += 4;
        end;
      for I := I to NODES_PER_PAGE do
        begin
          Nodes[I].NextLink := LastNode;
          LastNode := @Nodes[I];
        end;
      FFreeListHead := LastNode;
    end;
  Inc(FPageCount);
  FFreeCount += NODES_PER_PAGE;
end;

class operator TGJoinablePageNodeManager<TNode>.Finalize(var nm: TGJoinablePageNodeManager<TNode>);
begin
  nm.Clear;
end;

function TGJoinablePageNodeManager<TNode>.NewNode: PNode;
begin
  if FFreeListHead = nil then
    NewPage;
  Result := FFreeListHead;
  FFreeListHead := Result^.NextLink;
  Result^.NextLink := nil;
  Dec(FFreeCount);
  if FFreeListHead = nil then
    FFreeListTail := nil;
end;

procedure TGJoinablePageNodeManager<TNode>.DisposeNode(aNode: PNode);
begin
  FreeNode(aNode);
end;

procedure TGJoinablePageNodeManager<TNode>.FreeNode(aNode: PNode);
begin
  aNode^.NextLink := FFreeListHead;
  FFreeListHead := aNode;
  Inc(FFreeCount);
  if FFreeListTail = nil then
    FFreeListTail := aNode;
end;

procedure TGJoinablePageNodeManager<TNode>.EnsureFreeCount(aCount: SizeInt);
begin
  while FreeCount < aCount do
    NewPage;
end;

procedure TGJoinablePageNodeManager<TNode>.ClearFreeList;
begin
  // do nothing
end;

procedure TGJoinablePageNodeManager<TNode>.Clear;
var
  CurrPage, NextPage: PPage;
begin
  FFreeListHead := nil;
  FFreeListTail := nil;
  CurrPage := FPageListHead;
  while CurrPage <> nil do
    begin
      NextPage := CurrPage^.NextPage;
      System.Dispose(CurrPage);
      CurrPage := NextPage;
      Dec(FPageCount);
    end;
  FPageListHead := nil;
  FPageListTail := nil;
  FFreeCount := 0;
  Assert(FPageCount = 0, Format('Inconsistent FPageCount value(%d)', [FPageCount]));
end;

procedure TGJoinablePageNodeManager<TNode>.Join(var nm: TGJoinablePageNodeManager<TNode>);
begin
  if nm.PagesAllocated > 0 then
    begin
      if FPageListTail <> nil then
        FPageListTail^.NextPage := nm.FPageListHead
      else
        FPageListHead := nm.FPageListHead;
      FPageListTail := nm.FPageListTail;
      FPageCount += nm.PagesAllocated;
      nm.FPageCount := 0;
      nm.FPageListHead := nil;
      nm.FPageListTail := nil;
      if nm.FreeCount > 0 then
        begin
          if FFreeListTail <> nil then
            FFreeListTail^.NextLink := nm.FFreeListHead
          else
            FFreeListHead := nm.FFreeListHead;
          FFreeListTail := nm.FFreeListTail;
          FFreeCount += nm.FreeCount;
          nm.FFreeCount := 0;
          nm.FFreeListHead := nil;
          nm.FFreeListTail := nil;
        end;
    end;
end;

end.

{****************************************************************************
*                                                                           *
*   This file is part of the LGenerics package.                             *
*   Generic vector implementations.                                         *
*                                                                           *
*   Copyright(c) 2018 A.Koverdyaev(avk)                                     *
*                                                                           *
*   This code is free software; you can redistribute it and/or modify it    *
*   under the terms of the Apache License, Version 2.0;                     *
*   You may obtain a copy of the License at                                 *
*     http://www.apache.org/licenses/LICENSE-2.0.                           *
*                                                                           *
*  Unless required by applicable law or agreed to in writing, software      *
*  distributed under the License is distributed on an "AS IS" BASIS,        *
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
*  See the License for the specific language governing permissions and      *
*  limitations under the License.                                           *
*                                                                           *
*****************************************************************************}
unit LGVector;

{$mode objfpc}{$H+}
{$INLINE ON}
{$MODESWITCH ADVANCEDRECORDS}
{$MODESWITCH NESTEDPROCVARS}

interface

uses

  SysUtils,
  math,
  LGUtils,
  {%H-}LGHelpers,
  LGCustomContainer,
  LGArrayHelpers,
  LGStrConst;

type

  { TGVector }

  generic TGVector<T> = class(specialize TGCustomArrayContainer<T>)
  public
  type
    TVector = specialize TGVector<T>;
  protected
    function  GetItem(aIndex: SizeInt): T; inline;
    procedure SetItem(aIndex: SizeInt; const aValue: T); virtual;
    procedure InsertItem(aIndex: SizeInt; constref aValue: T);
    function  InsertArray(aIndex: SizeInt; constref a: array of T): SizeInt;
    function  InsertContainer(aIndex: SizeInt; aContainer: TCustomContainer): SizeInt;
    function  InsertEnum(aIndex: SizeInt; e: IEnumerable): SizeInt;
    procedure FastSwap(L, R: SizeInt); inline;
    function  ExtractItem(aIndex: SizeInt): T;
    function  DoExtractRange(aIndex, aCount: SizeInt): TArray;
    function  DeleteItem(aIndex: SizeInt): T; virtual;
    function  DoDeleteRange(aIndex, aCount: SizeInt): SizeInt; virtual;
    function  DoSplit(aIndex: SizeInt): TVector;
  public
  { appends aValue and returns it index; will raise ELGUpdateLock if instance in iteration }
    function  Add(constref aValue: T): SizeInt;
  { appends all elements of array and returns count of added elements;
    will raise ELGUpdateLock if instance in iteration }
    function  AddAll(constref a: array of T): SizeInt;
    function  AddAll(e: IEnumerable): SizeInt;
  { inserts aValue into position aIndex;
    will raise ELGListError if aIndex out of bounds(aIndex = Count  is allowed);
    will raise ELGUpdateLock if instance in iteration}
    procedure Insert(aIndex: SizeInt; constref aValue: T);
  { will return False if aIndex out of bounds or instance in iteration }
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
  { inserts all elements of array a into position aIndex and returns count of inserted elements;
    will raise ELGListError if aIndex out of bounds(aIndex = Count  is allowed);
    will raise ELGUpdateLock if instance in iteration }
    function  InsertAll(aIndex: SizeInt; constref a: array of T): SizeInt;
  { inserts all elements of e into position aIndex and returns count of inserted elements;
    will raise ELGListError if aIndex out of bounds(aIndex = Count  is allowed);
    will raise ELGUpdateLock if instance in iteration}
    function  InsertAll(aIndex: SizeInt; e: IEnumerable): SizeInt;
  { extracts value from position aIndex;
    will raise ELGListError if aIndex out of bounds;
    will raise ELGUpdateLock if instance in iteration}
    function  Extract(aIndex: SizeInt): T; inline;
  { will return False if aIndex out of bounds or instance in iteration }
    function  TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
  { extracts aCount elements(if possible) starting from aIndex;
    will raise ELGListError if aIndex out of bounds;
    will raise ELGUpdateLock if instance in iteration}
    function  ExtractAll(aIndex, aCount: SizeInt): TArray;
  { deletes value in position aIndex;
    will raise ELGListError if aIndex out of bounds;
    will raise ELGUpdateLock if instance in iteration}
    procedure Delete(aIndex: SizeInt);
  { will return False if aIndex out of bounds or instance in iteration }
    function  TryDelete(aIndex: SizeInt): Boolean;
  { deletes aCount elements(if possible) starting from aIndex and returns those count;
    will raise ELGListError if aIndex out of bounds;
    will raise ELGUpdateLock if instance in iteration}
    function  DeleteAll(aIndex, aCount: SizeInt): SizeInt;
  { will raise ELGListError if aIndex out of bounds;
    will raise ELGUpdateLock if instance in iteration}
    function  Split(aIndex: SizeInt): TVector;
  { will return False if aIndex out of bounds or instance in iteration }
    function  TrySplit(aIndex: SizeInt; out aValue: TVector): Boolean;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
  end;

  { TGObjectVector
    note: for equality comparision of items uses TObjectHelper from LGHelpers }
  generic TGObjectVector<T: class> = class(specialize TGVector<T>)
  public
  type
    TObjectVector = specialize TGObjectVector<T>;
  private
    FOwnsObjects: Boolean;
  protected
    procedure SetItem(aIndex: SizeInt; const aValue: T); override;
    procedure DoClear; override;
    function  DeleteItem(aIndex: SizeInt): T; override;
    function  DoDeleteRange(aIndex, aCount: SizeInt): SizeInt; override;
    function  DoSplit(aIndex: SizeInt): TObjectVector;
  public
    constructor Create(aOwnsObjects: Boolean = True);
    constructor Create(aCapacity: SizeInt; aOwnsObjects: Boolean = True);
    constructor Create(constref A: array of T; aOwnsObjects: Boolean = True);
    constructor Create(e: IEnumerable; aOwnsObjects: Boolean = True);
  { will raise EArgumentOutOfRangeException if aIndex out of bounds }
    function  Split(aIndex: SizeInt): TObjectVector;
  { will return False if aIndex out of bounds }
    function  TrySplit(aIndex: SizeInt; out aValue: TObjectVector): Boolean;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  { TGThreadVector }

  generic TGThreadVector<T> = class
  public
  type
    TVector = specialize TGVector<T>;
  private
    FVector: TVector;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
  { returns reference to encapsulated vector, after use this reference one must call UnLock }
    function  Lock: TVector;
    procedure Unlock; inline;
    procedure Clear;
    function  Add(constref aValue: T): SizeInt;
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
    function  TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
    function  TryDelete(aIndex: SizeInt): Boolean;
  end;

  { TGLiteVector }

  generic TGLiteVector<T> = record
  private
  type
    TBuffer = specialize TGLiteDynBuffer<T>;

  public
  type
    TEnumerator = TBuffer.TEnumerator;
    TMutable    = TBuffer.TMutable;
    TReverse    = TBuffer.TReverse;
    PItem       = TBuffer.PItem;
    TArray      = TBuffer.TArray;

  private
    FBuffer: TBuffer;
    function  GetCapacity: SizeInt; inline;
    function  GetItem(aIndex: SizeInt): T; inline;
    procedure SetItem(aIndex: SizeInt; const aValue: T); inline;
    procedure InsertItem(aIndex: SizeInt; constref aValue: T);
    function  DeleteItem(aIndex: SizeInt): T; inline;

    procedure IndexOutOfBoundError(aIndex: SizeInt); inline;
    function  IndexInRange(aIndex: SizeInt): Boolean; inline;
    function  IndexInInsertRange(aIndex: SizeInt): Boolean; inline;
    procedure CheckIndexRange(aIndex: SizeInt); inline;
    procedure CheckInsertIndexRange(aIndex: SizeInt); inline;
  public
    function  GetEnumerator: TEnumerator; inline;
    function  Mutable: TMutable; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
  { appends aValue and returns it index }
    function  Add(constref aValue: T): SizeInt;
  { inserts aValue into position aIndex;
    will raise ELGListError if aIndex out of bounds(aIndex = Count  is allowed) }
    procedure Insert(aIndex: SizeInt; constref aValue: T); inline;
  { will return False if aIndex out of bounds }
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean; inline;
  { deletes and returns value from position aIndex;
    will raise ELGListError if aIndex out of bounds }
    function  Delete(aIndex: SizeInt): T; inline;
  { will return False if aIndex out of bounds }
    function  TryDelete(aIndex: SizeInt; out aValue: T): Boolean; inline;
    property  Count: SizeInt read FBuffer.FCount;
    property  Capacity: SizeInt read GetCapacity;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
  end;

  { TGLiteThreadVector }

  generic TGLiteThreadVector<T> = class
  public
  type
    TVector = specialize TGLiteVector<T>;
    PVector = ^TVector;

  private
    FVector: TVector;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
    function  Lock: PVector;
    procedure Unlock; inline;
    procedure Clear;
    function  Add(constref aValue: T): SizeInt;
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
    function  TryDelete(aIndex: SizeInt; out aValue: T): Boolean;
  end;

  { TGLiteObjectVector }

  generic TGLiteObjectVector<T: class> = record
  private
  type
    TVector = specialize TGLiteVector<T>;

  public
  type
    TEnumerator = TVector.TEnumerator;
    TReverse    = TVector.TReverse;
    TArray      = TVector.TArray;

  private
    FVector: TVector;
    FOwnsObjects: Boolean;
    function  GetCount: SizeInt; inline;
    function  GetCapacity: SizeInt; inline;
    function  GetItem(aIndex: SizeInt): T; inline;
    procedure SetItem(aIndex: SizeInt; const aValue: T); inline;
    procedure CheckFreeItems;
    class operator Initialize(var v: TGLiteObjectVector);
    class operator Finalize(var v: TGLiteObjectVector);
  public
  type
    PVector = ^TVector;
    function  InnerVector: PVector; inline;
    function  GetEnumerator: TEnumerator; inline;
    function  Reverse: TReverse; inline;
    function  ToArray: TArray; inline;
    procedure Clear; inline;
    function  IsEmpty: Boolean; inline;
    function  NonEmpty: Boolean; inline;
    procedure EnsureCapacity(aValue: SizeInt); inline;
    procedure TrimToFit; inline;
  { appends aValue and returns it index }
    function  Add(constref aValue: T): SizeInt;
  { inserts aValue into position aIndex;
    will raise ELGListError if aIndex out of bounds(aIndex = Count  is allowed) }
    procedure Insert(aIndex: SizeInt; constref aValue: T); inline;
  { will return False if aIndex out of bounds }
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean; inline;
  { extracts value from position aIndex;
    will raise ELGListError if aIndex out of bounds }
    function  Extract(aIndex: SizeInt): T; inline;
  { will return False if aIndex out of bounds }
    function  TryExtract(aIndex: SizeInt; out aValue: T): Boolean; inline;
  { deletes value in position aIndex; will raise ELGListError if aIndex out of bounds}
    procedure Delete(aIndex: SizeInt); inline;
  { will return False if aIndex out of bounds }
    function  TryDelete(aIndex: SizeInt): Boolean; inline;
    property  Count: SizeInt read GetCount;
    property  Capacity: SizeInt read GetCapacity;
    property  Items[aIndex: SizeInt]: T read GetItem write SetItem; default;
    property  OwnsObjects: Boolean read FOwnsObjects write FOwnsObjects;
  end;

  generic TGLiteThreadObjectVector<T: class> = class
  public
  type
    TVector = specialize TGLiteObjectVector<T>;
    PVector = ^TVector;

  private
    FVector: TVector;
    FLock: TRTLCriticalSection;
    procedure DoLock; inline;
  public
    constructor Create;
    destructor Destroy; override;
    function  Lock: PVector;
    procedure Unlock; inline;
    procedure Clear;
    function  Add(constref aValue: T): SizeInt;
    function  TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
    function  TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
    function  TryDelete(aIndex: SizeInt): Boolean;
  end;

  { TGVectorHelpUtil }

  generic TGVectorHelpUtil<T> = class
  private
  type
    THelper = specialize TGArrayHelpUtil<T>;
  public
  type
    TEqualityCompare = THelper.TEqualCompare;
    TVector          = class(specialize TGVector<T>);
    TLiteVector      = specialize TGLiteVector<T>;
    class procedure Reverse(v: TVector); static; inline;
    class procedure Reverse(var v: TLiteVector); static; inline;
    class procedure RandomShuffle(v: TVector); static; inline;
    class procedure RandomShuffle(var v: TLiteVector); static; inline;
    class function  SequentSearch(v: TVector; constref aValue: T; c: TEqualityCompare): SizeInt; static; inline;
    class function  SequentSearch(constref v: TLiteVector; constref aValue: T; c: TEqualityCompare): SizeInt;
                    static; inline;
  end;

  { TGBaseVectorHelper
      functor TCmpRel(comparision relation) must provide:
        class function Compare([const[ref]] L, R: T): SizeInt }
  generic TGBaseVectorHelper<T, TCmpRel> = class
  private
  type
    THelper = specialize TGBaseArrayHelper<T, TCmpRel>;
  public
  type
    TVector     = class(specialize TGVector<T>);
    TLiteVector = specialize TGLiteVector<T>;
    TOptional   = specialize TGOptional<T>;
  { returns position of aValue in vector V, -1 if not found }
    class function  SequentSearch(v: TVector; constref aValue: T): SizeInt; static; inline;
    class function  SequentSearch(constref v: TLiteVector; constref aValue: T): SizeInt; static; inline;
  { returns position of aValue in SORTED vector V, -1 if not found }
    class function  BinarySearch(v: TVector; constref aValue: T): SizeInt; static; inline;
    class function  BinarySearch(constref v: TLiteVector; constref aValue: T): SizeInt; static; inline;
  { returns position of minimal value in V, -1 if V is empty }
    class function  IndexOfMin(v: TVector): SizeInt; static; inline;
    class function  IndexOfMin(constref v: TLiteVector): SizeInt; static; inline;
  { returns position of maximal value in V, -1 if V is empty }
    class function  IndexOfMax(v: TVector): SizeInt; static; inline;
    class function  IndexOfMax(constref v: TLiteVector): SizeInt; static; inline;
  { returns smallest element of A in TOptional.Value if V is nonempty }
    class function  GetMin(v: TVector): TOptional; static; inline;
    class function  GetMin(constref v: TLiteVector): TOptional; static; inline;
  { returns greatest element of A in TOptional.Value if V is nonempty }
    class function  GetMax(v: TVector): TOptional; static; inline;
    class function  GetMax(constref v: TLiteVector): TOptional; static; inline;
  { returns True and smallest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMin(v: TVector; out aValue: T): Boolean; static; inline;
    class function  FindMin(constref v: TLiteVector; out aValue: T): Boolean; static; inline;
  { returns True and greatest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMax(v: TVector; out aValue: T): Boolean; static; inline;
    class function  FindMax(constref v: TLiteVector; out aValue: T): Boolean; static; inline;
  { returns True, smallest element of V in aMin and greatest element of V in aMax, if V is nonempty,
    False otherwise }
    class function  FindMinMax(v: TVector; out aMin, aMax: T): Boolean; static; inline;
    class function  FindMinMax(constref v: TLiteVector; out aMin, aMax: T): Boolean; static; inline;
  { returns True and V's Nth order statistic(0-based) in aValue if V is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is nondestuctive: creates temp copy of V }
    class function  FindNthSmallest(v: TVector; N: SizeInt; out aValue: T): Boolean; static; inline;
    class function  FindNthSmallest(constref v: TLiteVector; N: SizeInt; out aValue: T): Boolean; static; inline;
  { returns V's Nth order statistic(0-based) in TOptional.Value if V is nonempty;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is nondestuctive: creates temp copy of V }
    class function  NthSmallest(v: TVector; N: SizeInt): TOptional; static; inline;
    class function  NthSmallest(constref v: TLiteVector; N: SizeInt): TOptional; static; inline;
  { returns True if permutation towards nondescending state of V has done, False otherwise }
    class function  NextPermutation2Asc(v: TVector): Boolean; static; inline;
    class function  NextPermutation2Asc(var v: TLiteVector): Boolean; static; inline;
  { returns True if permutation towards nonascending state of V has done, False otherwise }
    class function  NextPermutation2Desc(v: TVector): Boolean; static; inline;
    class function  NextPermutation2Desc(var v: TLiteVector): Boolean; static; inline;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(v: TVector): Boolean; static; inline;
    class function  IsNonDescending(constref v: TLiteVector): Boolean; static; inline;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(v: TVector): Boolean; static; inline;
    class function  IsStrictAscending(constref v: TLiteVector): Boolean; static; inline;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(v: TVector): Boolean; static; inline;
    class function  IsNonAscending(constref v: TLiteVector): Boolean; static; inline;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(v: TVector): Boolean; static; inline;
    class function  IsStrictDescending(constref v: TLiteVector): Boolean; static; inline;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(A, B: TVector): Boolean; static;
    class function  Same(constref A, B: TLiteVector): Boolean; static;
  { slightly optimized quicksort with random pivot selection }
    class procedure QuickSort(v: TVector; o: TSortOrder = soAsc); static; inline;
    class procedure QuickSort(var v: TLiteVector; o: TSortOrder = soAsc); static; inline;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(v: TVector; o: TSortOrder = soAsc); static; inline;
    class procedure IntroSort(var v: TLiteVector; o: TSortOrder = soAsc); static; inline;
  { stable, adaptive mergesort, inspired by Java Timsort }
    class procedure MergeSort(v: TVector; o: TSortOrder = soAsc); static; inline;
    class procedure MergeSort(var v: TLiteVector; o: TSortOrder = soAsc); static; inline;
  { default sort algorithm, currently it is IntroSort}
    class procedure Sort(v: TVector; o: TSortOrder = soAsc); static; inline;
    class procedure Sort(var v: TLiteVector; o: TSortOrder = soAsc); static; inline;
  { copies only distinct values from v }
    class function  SelectDistinct(v: TVector): TVector.TArray; static; inline;
    class function  SelectDistinct(constref v: TLiteVector): TLiteVector.TArray; static; inline;
  end;

  { TGVectorHelper assumes that type T implements TCmpRel }
  generic TGVectorHelper<T> = class(specialize TGBaseVectorHelper<T, T>);

  { TGComparableVectorHelper assumes that type T defines comparision operators }
  generic TGComparableVectorHelper<T> = class
  private
  type
    THelper = specialize TGComparableArrayHelper<T>;
  public
  type
    TVector     = specialize TGVector<T>;
    TLiteVector = specialize TGLiteVector<T>;
    TOptional   = specialize TGOptional<T>;
  { returns position of aValue in vector V, -1 if not found }
    class function  SequentSearch(v: TVector; constref aValue: T): SizeInt; static; inline;
    class function  SequentSearch(constref v: TLiteVector; constref aValue: T): SizeInt; static; inline;
  { returns position of aValue in SORTED vector V, -1 if not found }
    class function  BinarySearch(v: TVector; constref aValue: T): SizeInt; static; inline;
    class function  BinarySearch(constref v: TLiteVector; constref aValue: T): SizeInt; static; inline;
  { returns position of minimal value in V, -1 if V is empty }
    class function  IndexOfMin(v: TVector): SizeInt; static; inline;
    class function  IndexOfMin(constref v: TLiteVector): SizeInt; static; inline;
  { returns position of maximal value in V, -1 if V is empty }
    class function  IndexOfMax(v: TVector): SizeInt; static; inline;
    class function  IndexOfMax(constref v: TLiteVector): SizeInt; static; inline;
  { returns smallest element of A in TOptional.Value if V is nonempty }
    class function  GetMin(v: TVector): TOptional; static; inline;
    class function  GetMin(constref v: TLiteVector): TOptional; static; inline;
  { returns greatest element of A in TOptional.Value if V is nonempty }
    class function  GetMax(v: TVector): TOptional; static; inline;
    class function  GetMax(constref v: TLiteVector): TOptional; static; inline;
  { returns True and smallest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMin(v: TVector; out aValue: T): Boolean; static; inline;
    class function  FindMin(constref v: TLiteVector; out aValue: T): Boolean; static; inline;
  { returns True and greatest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMax(v: TVector; out aValue: T): Boolean; static; inline;
    class function  FindMax(constref v: TLiteVector; out aValue: T): Boolean; static; inline;
  { returns True, smallest element of V in aMin and greatest element of V in aMax, if V is nonempty,
    False otherwise }
    class function  FindMinMax(v: TVector; out aMin, aMax: T): Boolean; static; inline;
    class function  FindMinMax(constref v: TLiteVector; out aMin, aMax: T): Boolean; static; inline;
  { returns True and V's Nth order statistic(0-based) in aValue if V is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is nondestuctive: creates temp copy of V }
    class function  FindNthSmallest(v: TVector; N: SizeInt; out aValue: T): Boolean; static; inline;
    class function  FindNthSmallest(constref v: TLiteVector; N: SizeInt; out aValue: T): Boolean; static; inline;
  { returns V's Nth order statistic(0-based) in TOptional.Value if V is nonempty;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is nondestuctive: creates temp copy of V }
    class function  NthSmallest(v: TVector; N: SizeInt): TOptional; static; inline;
    class function  NthSmallest(constref v: TLiteVector; N: SizeInt): TOptional; static; inline;
  { returns True if permutation towards nondescending state of V has done, False otherwise }
    class function  NextPermutation2Asc(v: TVector): Boolean; static; inline;
    class function  NextPermutation2Asc(var v: TLiteVector): Boolean; static; inline;
  { returns True if permutation towards nonascending state of V has done, False otherwise }
    class function  NextPermutation2Desc(v: TVector): Boolean; static; inline;
    class function  NextPermutation2Desc(var v: TLiteVector): Boolean; static; inline;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(v: TVector): Boolean; static; inline;
    class function  IsNonDescending(constref v: TLiteVector): Boolean; static; inline;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(v: TVector): Boolean; static; inline;
    class function  IsStrictAscending(constref v: TLiteVector): Boolean; static; inline;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(v: TVector): Boolean; static; inline;
    class function  IsNonAscending(constref v: TLiteVector): Boolean; static; inline;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(v: TVector): Boolean; static; inline;
    class function  IsStrictDescending(constref v: TLiteVector): Boolean; static; inline;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(A, B: TVector): Boolean; static;
    class function  Same(constref A, B: TLiteVector): Boolean; static;
  { slightly optimized quicksort with random pivot selection }
    class procedure QuickSort(v: TVector; o: TSortOrder = soAsc); static; inline;
    class procedure QuickSort(var v: TLiteVector; o: TSortOrder = soAsc); static; inline;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(v: TVector; o: TSortOrder = soAsc); static; inline;
    class procedure IntroSort(var v: TLiteVector; o: TSortOrder = soAsc); static; inline;
  { stable, adaptive mergesort, inspired by Java Timsort }
    class procedure MergeSort(v: TVector; o: TSortOrder = soAsc); static; inline;
    class procedure MergeSort(var v: TLiteVector; o: TSortOrder = soAsc); static; inline;
  { default sort algorithm, currently it is IntroSort}
    class procedure Sort(v: TVector; o: TSortOrder = soAsc); static; inline;
    class procedure Sort(var v: TLiteVector; o: TSortOrder = soAsc); static; inline;
  { copies only distinct values from v }
    class function  SelectDistinct(v: TVector): TVector.TArray; static; inline;
    class function  SelectDistinct(constref v: TLiteVector): TLiteVector.TArray; static; inline;
  end;

  { TGRegularVectorHelper: with regular comparator }
  generic TGRegularVectorHelper<T> = class
  private
  type
    THelper   = specialize TGRegularArrayHelper<T>;
  public
  type
    TVector     = specialize TGVector<T>;
    TLiteVector = specialize TGLiteVector<T>;
    TOptional   = specialize TGOptional<T>;
    TCompare    = specialize TGCompare<T>;
  { returns position of aValue in vector V, -1 if not found }
    class function  SequentSearch(v: TVector; constref aValue: T; c: TCompare): SizeInt; static; inline;
    class function  SequentSearch(constref v: TLiteVector; constref aValue: T; c: TCompare): SizeInt; static; inline;
  { returns position of aValue in SORTED vector V, -1 if not found }
    class function  BinarySearch(v: TVector; constref aValue: T; c: TCompare): SizeInt; static; inline;
    class function  BinarySearch(constref v: TLiteVector; constref aValue: T; c: TCompare): SizeInt; static; inline;
  { returns position of minimal value in V, -1 if V is empty }
    class function  IndexOfMin(v: TVector; c: TCompare): SizeInt; static; inline;
  { returns position of maximal value in V, -1 if V is empty }
    class function  IndexOfMax(v: TVector; c: TCompare): SizeInt; static; inline;
    class function  IndexOfMax(constref v: TLiteVector; c: TCompare): SizeInt; static; inline;
  { returns smallest element of A in TOptional.Value if V is nonempty }
    class function  GetMin(v: TVector; c: TCompare): TOptional; static; inline;
    class function  GetMin(constref v: TLiteVector; c: TCompare): TOptional; static; inline;
  { returns greatest element of A in TOptional.Value if V is nonempty }
    class function  GetMax(v: TVector; c: TCompare): TOptional; static; inline;
    class function  GetMax(constref v: TLiteVector; c: TCompare): TOptional; static; inline;
  { returns True and smallest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMin(v: TVector; out aValue: T; c: TCompare): Boolean; static; inline;
    class function  FindMin(constref v: TLiteVector; out aValue: T; c: TCompare): Boolean; static; inline;
  { returns True and greatest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMax(v: TVector; out aValue: T; c: TCompare): Boolean; static; inline;
    class function  FindMax(constref v: TLiteVector; out aValue: T; c: TCompare): Boolean; static; inline;
  { returns True, smallest element of V in aMin and greatest element of V in aMax, if V is nonempty,
    False otherwise }
    class function  FindMinMax(v: TVector; out aMin, aMax: T; c: TCompare): Boolean; static; inline;
    class function  FindMinMax(constref v: TLiteVector; out aMin, aMax: T; c: TCompare): Boolean; static; inline;
  { returns True and V's Nth order statistic(0-based) in aValue if V is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is nondestuctive: creates temp copy of V }
    class function  FindNthSmallest(v: TVector; N: SizeInt; out aValue: T; c: TCompare): Boolean; static; inline;
    class function  FindNthSmallest(constref v: TLiteVector; N: SizeInt; out aValue: T; c: TCompare): Boolean;
                    static; inline;
  { returns V's Nth order statistic(0-based) in TOptional.Value if V is nonempty;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is nondestuctive: creates temp copy of V }
    class function  NthSmallest(v: TVector; N: SizeInt; c: TCompare): TOptional; static; inline;
    class function  NthSmallest(constref v: TLiteVector; N: SizeInt; c: TCompare): TOptional; static; inline;
  { returns True if permutation towards nondescending state of V has done, False otherwise }
    class function  NextPermutation2Asc(v: TVector; c: TCompare): Boolean; static; inline;
    class function  NextPermutation2Asc(var v: TLiteVector; c: TCompare): Boolean; static; inline;
  { returns True if permutation towards nonascending state of V has done, False otherwise }
    class function  NextPermutation2Desc(v: TVector; c: TCompare): Boolean; static; inline;
    class function  NextPermutation2Desc(var v: TLiteVector; c: TCompare): Boolean; static; inline;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(v: TVector; c: TCompare): Boolean; static; inline;
    class function  IsNonDescending(constref v: TLiteVector; c: TCompare): Boolean; static; inline;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(v: TVector; c: TCompare): Boolean; static; inline;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(v: TVector; c: TCompare): Boolean; static; inline;
    class function  IsNonAscending(constref v: TLiteVector; c: TCompare): Boolean; static; inline;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(v: TVector; c: TCompare): Boolean; static; inline;
    class function  IsStrictDescending(constref v: TLiteVector; c: TCompare): Boolean; static; inline;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(A, B: TVector; c: TCompare): Boolean; static;
    class function  Same(constref A, B: TLiteVector; c: TCompare): Boolean; static;
  { slightly optimized quicksort with random pivot selection }
    class procedure QuickSort(v: TVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
    class procedure QuickSort(var v: TLiteVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(v: TVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
    class procedure IntroSort(var v: TLiteVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
  { stable, adaptive mergesort, inspired by Java Timsort }
    class procedure MergeSort(v: TVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
    class procedure MergeSort(var v: TLiteVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
  { default sort algorithm, currently it is IntroSort}
    class procedure Sort(v: TVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
    class procedure Sort(var v: TLiteVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
  { copies only distinct values from v }
    class function  SelectDistinct(v: TVector; c: TCompare): TVector.TArray; static; inline;
    class function  SelectDistinct(constref v: TLiteVector; c: TCompare): TLiteVector.TArray; static; inline;
  end;

  { TGDelegatedVectorHelper: with delegated comparator }
  generic TGDelegatedVectorHelper<T> = class
  private
  type
    THelper = specialize TGDelegatedArrayHelper<T>;
  public
  type
    TVector     = specialize TGVector<T>;
    TLiteVector = specialize TGLiteVector<T>;
    TOptional   = specialize TGOptional<T>;
    TOnCompare  = specialize TGOnCompare<T>;
  { returns position of aValue in vector V, -1 if not found }
    class function  SequentSearch(v: TVector; constref aValue: T; c: TOnCompare): SizeInt; static; inline;
    class function  SequentSearch(constref v: TLiteVector; constref aValue: T; c: TOnCompare): SizeInt; static; inline;
  { returns position of aValue in SORTED vector V, -1 if not found }
    class function  BinarySearch(v: TVector; constref aValue: T; c: TOnCompare): SizeInt; static; inline;
    class function  BinarySearch(constref v: TLiteVector; constref aValue: T; c: TOnCompare): SizeInt; static; inline;
  { returns position of minimal value in V, -1 if V is empty }
    class function  IndexOfMin(v: TVector; c: TOnCompare): SizeInt; static; inline;
    class function  IndexOfMin(constref v: TLiteVector; c: TOnCompare): SizeInt; static; inline;
  { returns position of maximal value in V, -1 if V is empty }
    class function  IndexOfMax(v: TVector; c: TOnCompare): SizeInt; static; inline;
    class function  IndexOfMax(constref v: TLiteVector; c: TOnCompare): SizeInt; static; inline;
  { returns smallest element of A in TOptional.Value if V is nonempty }
    class function  GetMin(v: TVector; c: TOnCompare): TOptional; static; inline;
    class function  GetMin(constref v: TLiteVector; c: TOnCompare): TOptional; static; inline;
  { returns greatest element of A in TOptional.Value if V is nonempty }
    class function  GetMax(v: TVector; c: TOnCompare): TOptional; static; inline;
    class function  GetMax(constref v: TLiteVector; c: TOnCompare): TOptional; static; inline;
  { returns True and smallest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMin(v: TVector; out aValue: T; c: TOnCompare): Boolean; static; inline;
    class function  FindMin(constref v: TLiteVector; out aValue: T; c: TOnCompare): Boolean; static; inline;
  { returns True and greatest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMax(v: TVector; out aValue: T; c: TOnCompare): Boolean; static; inline;
    class function  FindMax(constref v: TLiteVector; out aValue: T; c: TOnCompare): Boolean; static; inline;
  { returns True, smallest element of V in aMin and greatest element of V in aMax, if V is nonempty,
    False otherwise }
    class function  FindMinMax(v: TVector; out aMin, aMax: T; c: TOnCompare): Boolean; static; inline;
    class function  FindMinMax(constref v: TLiteVector; out aMin, aMax: T; c: TOnCompare): Boolean;
                    static; inline;
  { returns True and V's Nth order statistic(0-based) in aValue if V is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is destuctive: changes order of elements in V }
    class function  FindNthSmallest(v: TVector; N: SizeInt; out aValue: T; c: TOnCompare): Boolean;
                    static; inline;
    class function  FindNthSmallest(constref v: TLiteVector; N: SizeInt; out aValue: T; c: TOnCompare): Boolean;
                    static; inline;
  { returns V's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is destuctive: changes order of elements in V }
    class function  NthSmallest(v: TVector; N: SizeInt; c: TOnCompare): TOptional; static; inline;
    class function  NthSmallest(constref v: TLiteVector; N: SizeInt; c: TOnCompare): TOptional; static; inline;
  { returns True if permutation towards nondescending state of V has done, False otherwise }
    class function  NextPermutation2Asc(v: TVector; c: TOnCompare): Boolean; static; inline;
    class function  NextPermutation2Asc(var v: TLiteVector; c: TOnCompare): Boolean; static; inline;
  { returns True if permutation towards nonascending state of V has done, False otherwise }
    class function  NextPermutation2Desc(v: TVector; c: TOnCompare): Boolean; static; inline;
    class function  NextPermutation2Desc(var v: TLiteVector; c: TOnCompare): Boolean; static; inline;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(v: TVector; c: TOnCompare): Boolean; static; inline;
    class function  IsNonDescending(constref v: TLiteVector; c: TOnCompare): Boolean; static; inline;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(v: TVector; c: TOnCompare): Boolean; static; inline;
    class function  IsStrictAscending(constref v: TLiteVector; c: TOnCompare): Boolean; static; inline;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(v: TVector; c: TOnCompare): Boolean; static; inline;
    class function  IsNonAscending(constref v: TLiteVector; c: TOnCompare): Boolean; static; inline;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(v: TVector; c: TOnCompare): Boolean; static; inline;
    class function  IsStrictDescending(constref v: TLiteVector; c: TOnCompare): Boolean; static; inline;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(A, B: TVector; c: TOnCompare): Boolean; static;
    class function  Same(constref A, B: TLiteVector; c: TOnCompare): Boolean; static;
  { slightly optimized quicksort with random pivot selection }
    class procedure QuickSort(v: TVector; c: TOnCompare; o: TSortOrder = soAsc); static; inline;
    class procedure QuickSort(var v: TLiteVector; c: TOnCompare; o: TSortOrder = soAsc); static; inline;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(v: TVector; c: TOnCompare; o: TSortOrder = soAsc); static; inline;
    class procedure IntroSort(var v: TLiteVector; c: TOnCompare; o: TSortOrder = soAsc); static; inline;
  { stable, adaptive mergesort, inspired by Java Timsort }
    class procedure MergeSort(v: TVector; c: TOnCompare; o: TSortOrder = soAsc); static; inline;
    class procedure MergeSort(var v: TLiteVector; c: TOnCompare; o: TSortOrder = soAsc); static; inline;
  { default sort algorithm, currently it is IntroSort}
    class procedure Sort(v: TVector; c: TOnCompare; o: TSortOrder = soAsc); static; inline;
    class procedure Sort(var v: TLiteVector; c: TOnCompare; o: TSortOrder = soAsc); static; inline;
  { copies only distinct values from v }
    class function  SelectDistinct(v: TVector; c: TOnCompare): TVector.TArray; static; inline;
    class function  SelectDistinct(constref v: TLiteVector; c: TOnCompare): TLiteVector.TArray; static; inline;
  end;

  { TGNestedVectorHelper: with nested comparator }
  generic TGNestedVectorHelper<T> = class
  private
  type
    THelper = specialize TGNestedArrayHelper<T>;
  public
  type
    TVector     = specialize TGVector<T>;
    TLiteVector = specialize TGLiteVector<T>;
    TOptional   = specialize TGOptional<T>;
    TCompare    = specialize TGNestCompare<T>;
  { returns position of aValue in vector V, -1 if not found }
    class function  SequentSearch(v: TVector; constref aValue: T; c: TCompare): SizeInt; static; inline;
    class function  SequentSearch(constref v: TLiteVector; constref aValue: T; c: TCompare): SizeInt; static;
                    inline;
  { returns position of aValue in SORTED vector V, -1 if not found }
    class function  BinarySearch(v: TVector; constref aValue: T; c: TCompare): SizeInt; static; inline;
    class function  BinarySearch(constref v: TLiteVector; constref aValue: T; c: TCompare): SizeInt; static;
                    inline;
  { returns position of minimal value in V, -1 if V is empty }
    class function  IndexOfMin(v: TVector; c: TCompare): SizeInt; static; inline;
    class function  IndexOfMin(constref v: TLiteVector; c: TCompare): SizeInt; static; inline;
  { returns position of maximal value in V, -1 if V is empty }
    class function  IndexOfMax(v: TVector; c: TCompare): SizeInt; static; inline;
    class function  IndexOfMax(constref v: TLiteVector; c: TCompare): SizeInt; static; inline;
  { returns smallest element of A in TOptional.Value if V is nonempty }
    class function  GetMin(v: TVector; c: TCompare): TOptional; static; inline;
    class function  GetMin(constref v: TLiteVector; c: TCompare): TOptional; static; inline;
  { returns greatest element of A in TOptional.Value if V is nonempty }
    class function  GetMax(v: TVector; c: TCompare): TOptional; static; inline;
    class function  GetMax(constref v: TLiteVector; c: TCompare): TOptional; static; inline;
  { returns True and smallest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMin(v: TVector; out aValue: T; c: TCompare): Boolean; static; inline;
    class function  FindMin(constref v: TLiteVector; out aValue: T; c: TCompare): Boolean; static; inline;
  { returns True and greatest element of A in aValue if V is nonempty, False otherwise }
    class function  FindMax(v: TVector; out aValue: T; c: TCompare): Boolean; static; inline;
    class function  FindMax(constref v: TLiteVector; out aValue: T; c: TCompare): Boolean; static; inline;
  { returns True, smallest element of V in aMin and greatest element of V in aMax, if V is nonempty,
    False otherwise }
    class function  FindMinMax(v: TVector; out aMin, aMax: T; c: TCompare): Boolean; static; inline;
    class function  FindMinMax(constref v: TLiteVector; out aMin, aMax: T; c: TCompare): Boolean; static; inline;
  { returns True and V's Nth order statistic(0-based) in aValue if V is nonempty, False otherwise;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is destuctive: changes order of elements in V }
    class function  FindNthSmallest(v: TVector; N: SizeInt; out aValue: T; c: TCompare): Boolean; static; inline;
    class function  FindNthSmallest(constref v: TLiteVector; N: SizeInt; out aValue: T; c: TCompare): Boolean;
                    static; inline;
    { returns V's Nth order statistic(0-based) in TOptional.Value if A is nonempty;
    if N < 0 then N sets to 0; if N > High(V) then N sets to High(V);
    is destuctive: changes order of elements in V }
    class function  NthSmallest(v: TVector; N: SizeInt; c: TCompare): TOptional; static; inline;
    class function  NthSmallest(constref v: TLiteVector; N: SizeInt; c: TCompare): TOptional; static; inline;
  { returns True if permutation towards nondescending state of V has done, False otherwise }
    class function  NextPermutation2Asc(v: TVector; c: TCompare): Boolean; static; inline;
    class function  NextPermutation2Asc(var v: TLiteVector; c: TCompare): Boolean; static; inline;
  { returns True if permutation towards nonascending state of V has done, False otherwise }
    class function  NextPermutation2Desc(v: TVector; c: TCompare): Boolean; static; inline;
    class function  NextPermutation2Desc(var v: TLiteVector; c: TCompare): Boolean; static; inline;
  { note: an empty array or single element array is always nondescending }
    class function  IsNonDescending(v: TVector; c: TCompare): Boolean; static; inline;
    class function  IsNonDescending(constref v: TLiteVector; c: TCompare): Boolean; static; inline;
  { note: an empty array or single element array is never strict ascending }
    class function  IsStrictAscending(v: TVector; c: TCompare): Boolean; static; inline;
    class function  IsStrictAscending(constref v: TLiteVector; c: TCompare): Boolean; static; inline;
  { note: an empty array or single element array is always nonascending }
    class function  IsNonAscending(v: TVector; c: TCompare): Boolean; static; inline;
    class function  IsNonAscending(constref v: TLiteVector; c: TCompare): Boolean; static; inline;
  { note: an empty array or single element array is never strict descending}
    class function  IsStrictDescending(v: TVector; c: TCompare): Boolean; static; inline;
    class function  IsStrictDescending(constref v: TLiteVector; c: TCompare): Boolean; static; inline;
  { returns True if both A and B are identical sequence of elements }
    class function  Same(A, B: TVector; c: TCompare): Boolean; static;
    class function  Same(constref A, B: TLiteVector; c: TCompare): Boolean; static;
  { slightly optimized quicksort with random pivot selection }
    class procedure QuickSort(v: TVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
    class procedure QuickSort(var v: TLiteVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
  { slightly modified Introsort with pseudo-median-of-9 pivot selection }
    class procedure IntroSort(v: TVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
    class procedure IntroSort(var v: TLiteVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
  { stable, adaptive mergesort, inspired by Java Timsort }
    class procedure MergeSort(v: TVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
    class procedure MergeSort(var v: TLiteVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
  { default sort algorithm, currently it is IntroSort}
    class procedure Sort(v: TVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
    class procedure Sort(var v: TLiteVector; c: TCompare; o: TSortOrder = soAsc); static; inline;
  { copies only distinct values from v }
    class function  SelectDistinct(v: TVector; c: TCompare): TVector.TArray; static; inline;
    class function  SelectDistinct(constref v: TLiteVector; c: TCompare): TVector.TArray; static; inline;
  end;

implementation
{$B-}{$COPERATORS ON}

{ TGVector }

function TGVector.GetItem(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := FItems[aIndex];
end;

procedure TGVector.SetItem(aIndex: SizeInt; const aValue: T);
begin
  //CheckInIteration;
  CheckIndexRange(aIndex);
  FItems[aIndex] := aValue;
end;

procedure TGVector.InsertItem(aIndex: SizeInt; constref aValue: T);
begin
  if aIndex < ElemCount then
    begin
      ItemAdding;
      System.Move(FItems[aIndex], FItems[Succ(aIndex)], SizeOf(T) * (ElemCount - aIndex));
      System.FillChar(FItems[aIndex], SizeOf(T), 0);
      FItems[aIndex] := aValue;
      Inc(FCount);
    end
  else
    Append(aValue);
end;

function TGVector.InsertArray(aIndex: SizeInt; constref a: array of T): SizeInt;
begin
  if aIndex < ElemCount then
    begin
      Result := System.Length(a);
      if Result > 0 then
        begin
          EnsureCapacity(ElemCount + Result);
          System.Move(FItems[aIndex], FItems[aIndex + Result], SizeOf(T) * (ElemCount - aIndex));
          System.FillChar(FItems[aIndex], SizeOf(T) * Result, 0);
          TCopyArrayHelper.CopyItems(@a[0], @FItems[aIndex], Result);
          FCount += Result;
        end;
    end
  else
    Result := AppendArray(a);
end;

function TGVector.InsertContainer(aIndex: SizeInt; aContainer: TCustomContainer): SizeInt;
var
  v: T;
begin
  if aIndex < ElemCount then
    begin
      Result := aContainer.Count;
      if Result > 0 then
        begin
          EnsureCapacity(ElemCount + Result);
          System.Move(FItems[aIndex], FItems[aIndex + Result], SizeOf(T) * (ElemCount - aIndex));
          System.FillChar(FItems[aIndex], SizeOf(T) * Result, 0);
          if aContainer <> Self then
            for v in aContainer do
              begin
                FItems[aIndex] := v;
                Inc(aIndex);
              end
          else
            begin
              TCopyArrayHelper.CopyItems(@FItems[0], @FItems[aIndex], aIndex);
              TCopyArrayHelper.CopyItems(@FItems[aIndex + Result], @FItems[aIndex + aIndex], Result - aIndex);
            end;
          FCount += Result;
        end;
    end
  else
    Result := AppendContainer(aContainer);
end;

function TGVector.InsertEnum(aIndex: SizeInt; e: IEnumerable): SizeInt;
var
  o: TObject;
begin
  o := e._GetRef;
  if o is TCustomContainer then
    Result := InsertContainer(aIndex, TCustomContainer(o))
  else
    Result := InsertArray(aIndex, e.ToArray);
end;

procedure TGVector.FastSwap(L, R: SizeInt);
var
  v: TFake;
begin
  v := TFake(FItems[L]);
  TFake(FItems[L]) := TFake(FItems[R]);
  TFake(FItems[R]) := v;
end;

function TGVector.ExtractItem(aIndex: SizeInt): T;
begin
  Result := FItems[aIndex];
  FItems[aIndex] := Default(T);
  Dec(FCount);
  System.Move(FItems[Succ(aIndex)], FItems[aIndex], SizeOf(T) * (ElemCount - aIndex));
  System.FillChar(FItems[ElemCount], SizeOf(T), 0);
end;

function TGVector.DoExtractRange(aIndex, aCount: SizeInt): TArray;
begin
  if aCount < 0 then
    aCount := 0;
  aCount := Math.Min(aCount, ElemCount - aIndex);
  System.SetLength(Result, aCount);
  if aCount > 0 then
    begin
      System.Move(FItems[aIndex], Result[0], SizeOf(T) * aCount);
      FCount -= aCount;
      System.Move(FItems[aIndex + aCount], FItems[aIndex], SizeOf(T) * (ElemCount - aIndex));
      System.FillChar(FItems[ElemCount], SizeOf(T) * aCount, 0);
    end;
end;

function TGVector.DeleteItem(aIndex: SizeInt): T;
begin
  Result := ExtractItem(aIndex);
end;

function TGVector.DoDeleteRange(aIndex, aCount: SizeInt): SizeInt;
var
  I: SizeInt;
begin
  if aCount < 0 then
    aCount := 0;
  Result := Math.Min(aCount, ElemCount - aIndex);
  if Result > 0 then
    begin
      for I := aIndex to Pred(aIndex + Result) do
        FItems[I] := Default(T);
      FCount -= Result;
      System.Move(FItems[aIndex + Result], FItems[aIndex], SizeOf(T) * (ElemCount - aIndex));
      System.FillChar(FItems[ElemCount], SizeOf(T) * Result, 0);
    end;
end;

function TGVector.DoSplit(aIndex: SizeInt): TVector;
var
  RCount: SizeInt;
begin
  RCount := ElemCount - aIndex;
  Result := TGVector.Create(RCount);
  System.Move(FItems[aIndex], Result.FItems[0], SizeOf(T) * RCount);
  System.FillChar(FItems[aIndex], SizeOf(T) * RCount, 0);
  Result.FCount := RCount;
  FCount -= RCount;
end;

function TGVector.Add(constref aValue: T): SizeInt;
begin
  CheckInIteration;
  Result := Append(aValue);
end;

function TGVector.AddAll(constref a: array of T): SizeInt;
begin
  CheckInIteration;
  Result := AppendArray(a);
end;

function TGVector.AddAll(e: IEnumerable): SizeInt;
begin
  CheckInIteration;
  Result := AppendEnumerable(e);
end;

procedure TGVector.Insert(aIndex: SizeInt; constref aValue: T);
begin
  CheckInIteration;
  CheckInsertIndexRange(aIndex);
  InsertItem(aIndex, aValue);
end;

function TGVector.TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
begin
  Result := not InIteration and IndexInInsertRange(aIndex);
  if Result then
    InsertItem(aIndex, aValue);
end;

function TGVector.InsertAll(aIndex: SizeInt; constref a: array of T): SizeInt;
begin
  CheckInIteration;
  CheckInsertIndexRange(aIndex);
  Result := InsertArray(aIndex, a);
end;

function TGVector.InsertAll(aIndex: SizeInt; e: IEnumerable): SizeInt;
begin
  CheckInIteration;
  CheckInsertIndexRange(aIndex);
  Result := InsertEnum(aIndex, e);
end;

function TGVector.Extract(aIndex: SizeInt): T;
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  Result := ExtractItem(aIndex);
end;

function TGVector.TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
begin
  Result := not InIteration and IndexInRange(aIndex);
  if Result then
    aValue := ExtractItem(aIndex);
end;

function TGVector.ExtractAll(aIndex, aCount: SizeInt): TArray;
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  Result := DoExtractRange(aIndex, aCount);
end;

procedure TGVector.Delete(aIndex: SizeInt);
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  DeleteItem(aIndex);
end;

function TGVector.TryDelete(aIndex: SizeInt): Boolean;
begin
  Result := not InIteration and IndexInRange(aIndex);
  if Result then
    DeleteItem(aIndex);
end;

function TGVector.DeleteAll(aIndex, aCount: SizeInt): SizeInt;
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  Result := DoDeleteRange(aIndex, aCount);
end;

function TGVector.Split(aIndex: SizeInt): TVector;
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  Result := DoSplit(aIndex);
end;

function TGVector.TrySplit(aIndex: SizeInt; out aValue: TVector): Boolean;
begin
  Result := not InIteration and IndexInRange(aIndex);
  if Result then
    aValue := DoSplit(aIndex);
end;

{ TGObjectVector }

procedure TGObjectVector.SetItem(aIndex: SizeInt; const aValue: T);
begin
  //CheckInIteration;
  CheckIndexRange(aIndex);
  if OwnsObjects and not TObject.Equal(FItems[aIndex], aValue) then
    FItems[aIndex].Free;
  FItems[aIndex] := aValue;
end;

procedure TGObjectVector.DoClear;
var
  I: SizeInt;
begin
  if OwnsObjects and (ElemCount > 0) then
    for I := 0 to Pred(ElemCount) do
      FItems[I].Free;
  inherited;
end;

function TGObjectVector.DeleteItem(aIndex: SizeInt): T;
begin
  Result := inherited DeleteItem(aIndex);
  if OwnsObjects then
    Result.Free;
end;

function TGObjectVector.DoDeleteRange(aIndex, aCount: SizeInt): SizeInt;
var
  I: SizeInt;
begin
  if aCount < 0 then
    aCount := 0;
  Result := Math.Min(aCount, ElemCount - aIndex);
  if Result > 0 then
    begin
      if OwnsObjects then
        for I := aIndex to Pred(aIndex + Result) do
          FItems[I].Free;
      FCount -= Result;
      System.Move(FItems[aIndex + Result], FItems[aIndex], SizeOf(T) * (ElemCount - aIndex));
    end;
end;

function TGObjectVector.DoSplit(aIndex: SizeInt): TObjectVector;
var
  RCount: SizeInt;
begin
  RCount := ElemCount - aIndex;
  Result := TGObjectVector.Create(RCount, OwnsObjects);
  System.Move(FItems[aIndex], Result.FItems[0], SizeOf(T) * RCount);
  Result.FCount := RCount;
  FCount -= RCount;
end;

constructor TGObjectVector.Create(aOwnsObjects: Boolean);
begin
  inherited Create;
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectVector.Create(aCapacity: SizeInt; aOwnsObjects: Boolean);
begin
  inherited Create(aCapacity);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectVector.Create(constref A: array of T; aOwnsObjects: Boolean);
begin
  inherited Create(A);
  FOwnsObjects := aOwnsObjects;
end;

constructor TGObjectVector.Create(e: IEnumerable; aOwnsObjects: Boolean);
begin
  inherited Create(e);
  FOwnsObjects := aOwnsObjects;
end;

function TGObjectVector.Split(aIndex: SizeInt): TObjectVector;
begin
  CheckInIteration;
  CheckIndexRange(aIndex);
  Result := DoSplit(aIndex);
end;

function TGObjectVector.TrySplit(aIndex: SizeInt; out aValue: TObjectVector): Boolean;
begin
  Result := not InIteration and (aIndex >= 0) and (aIndex < ElemCount);
  if Result then
    aValue := DoSplit(aIndex);
end;

procedure TGThreadVector.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGThreadVector.Create;
begin
  System.InitCriticalSection(FLock);
  FVector := TVector.Create;
end;

destructor TGThreadVector.Destroy;
begin
  DoLock;
  try
    FVector.Free;
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

function TGThreadVector.Lock: TVector;
begin
  Result := FVector;
  DoLock;
end;

procedure TGThreadVector.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

procedure TGThreadVector.Clear;
begin
  DoLock;
  try
    FVector.Clear;
  finally
    UnLock;
  end;
end;

function TGThreadVector.Add(constref aValue: T): SizeInt;
begin
  DoLock;
  try
    Result := FVector.Add(aValue);
  finally
    UnLock;
  end;
end;

function TGThreadVector.TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FVector.TryInsert(aIndex, aValue);
  finally
    UnLock;
  end;
end;

function TGThreadVector.TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FVector.TryExtract(aIndex, aValue);
  finally
    UnLock;
  end;
end;

function TGThreadVector.TryDelete(aIndex: SizeInt): Boolean;
begin
  DoLock;
  try
    Result := FVector.TryDelete(aIndex);
  finally
    UnLock;
  end;
end;

{ TGLiteVector }

function TGLiteVector.GetCapacity: SizeInt;
begin
  Result := FBuffer.Capacity;
end;

function TGLiteVector.GetItem(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := FBuffer.FItems[aIndex];
end;

procedure TGLiteVector.SetItem(aIndex: SizeInt; const aValue: T);
begin
  CheckIndexRange(aIndex);
  FBuffer.FItems[aIndex] := aValue;
end;

procedure TGLiteVector.InsertItem(aIndex: SizeInt; constref aValue: T);
begin
  if aIndex < Count then
    begin
      FBuffer.ItemAdding;
      System.Move(FBuffer.FItems[aIndex], FBuffer.FItems[Succ(aIndex)], SizeOf(T) * (Count - aIndex));
      System.FillChar(FBuffer.FItems[aIndex], SizeOf(T), 0);
      FBuffer.FItems[aIndex] := aValue;
      Inc(FBuffer.FCount);
    end
  else
    Add(aValue);
end;

function TGLiteVector.DeleteItem(aIndex: SizeInt): T;
begin
  Result := FBuffer.FItems[aIndex];
  FBuffer.FItems[aIndex] := Default(T);
  Dec(FBuffer.FCount);
  System.Move(FBuffer.FItems[Succ(aIndex)], FBuffer.FItems[aIndex], SizeOf(T) * (Count - aIndex));
  System.FillChar(FBuffer.FItems[Count], SizeOf(T), 0);
end;

procedure TGLiteVector.IndexOutOfBoundError(aIndex: SizeInt);
begin
  raise ELGListError.CreateFmt(SEIndexOutOfBoundsFmt, [aIndex]);
end;

function TGLiteVector.IndexInRange(aIndex: SizeInt): Boolean;
begin
  Result := (aIndex >= 0) and (aIndex < Count);
end;

function TGLiteVector.IndexInInsertRange(aIndex: SizeInt): Boolean;
begin
  Result := (aIndex >= 0) and (aIndex <= Count);
end;

procedure TGLiteVector.CheckIndexRange(aIndex: SizeInt);
begin
  if not IndexInRange(aIndex) then
    IndexOutOfBoundError(aIndex);
end;

procedure TGLiteVector.CheckInsertIndexRange(aIndex: SizeInt);
begin
  if not IndexInInsertRange(aIndex) then
    IndexOutOfBoundError(aIndex);
end;

function TGLiteVector.GetEnumerator: TEnumerator;
begin
  Result := FBuffer.GetEnumerator;
end;

function TGLiteVector.Mutable: TMutable;
begin
  Result := FBuffer.Mutable;
end;

function TGLiteVector.Reverse: TReverse;
begin
  Result := FBuffer.Reverse;
end;

function TGLiteVector.ToArray: TArray;
begin
  Result := FBuffer.ToArray;
end;

procedure TGLiteVector.Clear;
begin
  FBuffer.Clear;
end;

function TGLiteVector.IsEmpty: Boolean;
begin
  Result := Count = 0;
end;

function TGLiteVector.NonEmpty: Boolean;
begin
  Result := Count <> 0;
end;

procedure TGLiteVector.EnsureCapacity(aValue: SizeInt);
begin
  FBuffer.EnsureCapacity(aValue);
end;

procedure TGLiteVector.TrimToFit;
begin
  FBuffer.TrimToFit;
end;

function TGLiteVector.Add(constref aValue: T): SizeInt;
begin
  Result := FBuffer.PushLast(aValue);
end;

procedure TGLiteVector.Insert(aIndex: SizeInt; constref aValue: T);
begin
  CheckInsertIndexRange(aIndex);
  InsertItem(aIndex, aValue);
end;

function TGLiteVector.TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
begin
  Result := IndexInInsertRange(aIndex);
  if Result then
    InsertItem(aIndex, aValue);
end;

function TGLiteVector.Delete(aIndex: SizeInt): T;
begin
  CheckIndexRange(aIndex);
  Result := DeleteItem(aIndex);
end;

function TGLiteVector.TryDelete(aIndex: SizeInt; out aValue: T): Boolean;
begin
  Result := IndexInRange(aIndex);
  if Result then
    aValue := DeleteItem(aIndex);
end;

{ TGLiteThreadVector }

procedure TGLiteThreadVector.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGLiteThreadVector.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteThreadVector.Destroy;
begin
  DoLock;
  try
    Finalize(FVector);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

function TGLiteThreadVector.Lock: PVector;
begin
  Result := @FVector;
  DoLock;
end;

procedure TGLiteThreadVector.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

procedure TGLiteThreadVector.Clear;
begin
  DoLock;
  try
    FVector.Clear;
  finally
    UnLock;
  end;
end;

function TGLiteThreadVector.Add(constref aValue: T): SizeInt;
begin
  DoLock;
  try
    Result := FVector.Add(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadVector.TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FVector.TryInsert(aIndex, aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadVector.TryDelete(aIndex: SizeInt; out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FVector.TryDelete(aIndex, aValue);
  finally
    UnLock;
  end;
end;

{ TGLiteObjectVector }

function TGLiteObjectVector.GetCount: SizeInt;
begin
  Result := FVector.Count;
end;

function TGLiteObjectVector.GetCapacity: SizeInt;
begin
  Result := FVector.Capacity;
end;

function TGLiteObjectVector.GetItem(aIndex: SizeInt): T;
begin
  Result := FVector.GetItem(aIndex);
end;

procedure TGLiteObjectVector.SetItem(aIndex: SizeInt; const aValue: T);
begin
  FVector.SetItem(aIndex, aValue);
end;

procedure TGLiteObjectVector.CheckFreeItems;
var
  I: SizeInt;
  InnerItems: TArray;
begin
  if OwnsObjects then
    begin
      InnerItems := FVector.FBuffer.FItems;
      for I := 0 to Pred(Count) do
        InnerItems[I].Free;
    end;
end;

class operator TGLiteObjectVector.Initialize(var v: TGLiteObjectVector);
begin
  v.OwnsObjects := True;
end;

class operator TGLiteObjectVector.Finalize(var v: TGLiteObjectVector);
begin
  v.Clear;
end;

function TGLiteObjectVector.InnerVector: PVector;
begin
  Result := @FVector;
end;

function TGLiteObjectVector.GetEnumerator: TEnumerator;
begin
  Result := FVector.GetEnumerator;
end;

function TGLiteObjectVector.Reverse: TReverse;
begin
  Result := FVector.Reverse;
end;

function TGLiteObjectVector.ToArray: TArray;
begin
  Result := FVector.ToArray;
end;

procedure TGLiteObjectVector.Clear;
begin
  CheckFreeItems;
  FVector.Clear;
end;

function TGLiteObjectVector.IsEmpty: Boolean;
begin
  Result := FVector.IsEmpty;
end;

function TGLiteObjectVector.NonEmpty: Boolean;
begin
  Result := FVector.NonEmpty;
end;

procedure TGLiteObjectVector.EnsureCapacity(aValue: SizeInt);
begin
  FVector.EnsureCapacity(aValue)
end;

procedure TGLiteObjectVector.TrimToFit;
begin
  FVector.TrimToFit;
end;

function TGLiteObjectVector.Add(constref aValue: T): SizeInt;
begin
  Result := FVector.Add(aValue);
end;

procedure TGLiteObjectVector.Insert(aIndex: SizeInt; constref aValue: T);
begin
  FVector.Insert(aIndex, aValue);
end;

function TGLiteObjectVector.TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
begin
  Result := FVector.TryInsert(aIndex, aValue);
end;

function TGLiteObjectVector.Extract(aIndex: SizeInt): T;
begin
  Result := FVector.Delete(aIndex);
end;

function TGLiteObjectVector.TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
begin
  Result := FVector.TryDelete(aIndex, aValue);
end;

procedure TGLiteObjectVector.Delete(aIndex: SizeInt);
var
  v: T;
begin
  v := FVector.Delete(aIndex);
  if OwnsObjects then
    v.Free;
end;

function TGLiteObjectVector.TryDelete(aIndex: SizeInt): Boolean;
var
  v: T;
begin
  Result := FVector.TryDelete(aIndex, v);
  if Result and OwnsObjects then
    v.Free;
end;

{ TGLiteThreadObjectVector }

procedure TGLiteThreadObjectVector.DoLock;
begin
  System.EnterCriticalSection(FLock);
end;

constructor TGLiteThreadObjectVector.Create;
begin
  System.InitCriticalSection(FLock);
end;

destructor TGLiteThreadObjectVector.Destroy;
begin
  DoLock;
  try
    Finalize(FVector);
    inherited;
  finally
    UnLock;
    System.DoneCriticalSection(FLock);
  end;
end;

function TGLiteThreadObjectVector.Lock: PVector;
begin
  Result := @FVector;
  DoLock;
end;

procedure TGLiteThreadObjectVector.Unlock;
begin
  System.LeaveCriticalSection(FLock);
end;

procedure TGLiteThreadObjectVector.Clear;
begin
  DoLock;
  try
    FVector.Clear;
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectVector.Add(constref aValue: T): SizeInt;
begin
  DoLock;
  try
    Result := FVector.Add(aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectVector.TryInsert(aIndex: SizeInt; constref aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FVector.TryInsert(aIndex, aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectVector.TryExtract(aIndex: SizeInt; out aValue: T): Boolean;
begin
  DoLock;
  try
    Result := FVector.TryExtract(aIndex, aValue);
  finally
    UnLock;
  end;
end;

function TGLiteThreadObjectVector.TryDelete(aIndex: SizeInt): Boolean;
begin
  DoLock;
  try
    Result := FVector.TryDelete(aIndex);
  finally
    UnLock;
  end;
end;

{ TGVectorHelpUtil }

class procedure TGVectorHelpUtil.Reverse(v: TVector);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.Reverse(v.FItems[0..Pred(v.ElemCount)]);
end;

class procedure TGVectorHelpUtil.Reverse(var v: TLiteVector);
begin
  if v.Count > 1 then
    THelper.Reverse(v.FBuffer.FItems[0..Pred(v.Count)]);
end;

class procedure TGVectorHelpUtil.RandomShuffle(v: TVector);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.RandomShuffle(v.FItems[0..Pred(v.ElemCount)]);
end;

class procedure TGVectorHelpUtil.RandomShuffle(var v: TLiteVector);
begin
  if v.Count > 1 then
    THelper.RandomShuffle(v.FBuffer.FItems[0..Pred(v.Count)]);
end;

class function TGVectorHelpUtil.SequentSearch(v: TVector; constref aValue: T; c: TEqualityCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.SequentSearch(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := -1;
end;

class function TGVectorHelpUtil.SequentSearch(constref v: TLiteVector; constref aValue: T;
  c: TEqualityCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.SequentSearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := -1;
end;


{ TGBaseVectorHelper }

class function TGBaseVectorHelper.SequentSearch(v: TVector; constref aValue: T): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.SequentSearch(v.FItems[0..Pred(v.ElemCount)], aValue)
  else
    Result := -1;
end;

class function TGBaseVectorHelper.SequentSearch(constref v: TLiteVector; constref aValue: T): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.SequentSearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue)
  else
    Result := -1;
end;

class function TGBaseVectorHelper.BinarySearch(v: TVector; constref aValue: T): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.BinarySearch(v.FItems[0..Pred(v.ElemCount)], aValue)
  else
    Result := -1;
end;

class function TGBaseVectorHelper.BinarySearch(constref v: TLiteVector; constref aValue: T): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.BinarySearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue)
  else
    Result := -1;
end;

class function TGBaseVectorHelper.IndexOfMin(v: TVector): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMin(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := -1;
end;

class function TGBaseVectorHelper.IndexOfMin(constref v: TLiteVector): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.IndexOfMin(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := -1;
end;

class function TGBaseVectorHelper.IndexOfMax(v: TVector): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMax(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := -1;
end;

class function TGBaseVectorHelper.IndexOfMax(constref v: TLiteVector): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.IndexOfMax(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := -1;
end;

class function TGBaseVectorHelper.GetMin(v: TVector): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMin(v.FItems[0..Pred(v.ElemCount)]);
end;

class function TGBaseVectorHelper.GetMin(constref v: TLiteVector): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMin(v.FBuffer.FItems[0..Pred(v.Count)]);
end;

class function TGBaseVectorHelper.GetMax(v: TVector): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMax(v.FItems[0..Pred(v.ElemCount)]);
end;

class function TGBaseVectorHelper.GetMax(constref v: TLiteVector): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMax(v.FBuffer.FItems[0..Pred(v.Count)]);
end;

class function TGBaseVectorHelper.FindMin(v: TVector; out aValue: T): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMin(v.FItems[0..Pred(v.ElemCount)], aValue)
  else
    Result := False;
end;

class function TGBaseVectorHelper.FindMin(constref v: TLiteVector; out aValue: T): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMin(v.FBuffer.FItems[0..Pred(v.Count)], aValue)
  else
    Result := False;
end;

class function TGBaseVectorHelper.FindMax(v: TVector; out aValue: T): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMax(v.FItems[0..Pred(v.ElemCount)], aValue)
  else
    Result := False;
end;

class function TGBaseVectorHelper.FindMax(constref v: TLiteVector; out aValue: T): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMax(v.FBuffer.FItems[0..Pred(v.Count)], aValue)
  else
    Result := False;
end;

class function TGBaseVectorHelper.FindMinMax(v: TVector; out aMin, aMax: T): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMinMax(v.FItems[0..Pred(v.ElemCount)], aMin, aMax)
  else
    Result := False;
end;

class function TGBaseVectorHelper.FindMinMax(constref v: TLiteVector; out aMin, aMax: T): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMinMax(v.FBuffer.FItems[0..Pred(v.Count)], aMin, aMax)
  else
    Result := False;
end;

class function TGBaseVectorHelper.FindNthSmallest(v: TVector; N: SizeInt; out aValue: T): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindNthSmallestND(v.FItems[0..Pred(v.ElemCount)], N, aValue)
  else
    Result := False;
end;

class function TGBaseVectorHelper.FindNthSmallest(constref v: TLiteVector; N: SizeInt; out aValue: T): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindNthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N, aValue)
  else
    Result := False;
end;

class function TGBaseVectorHelper.NthSmallest(v: TVector; N: SizeInt): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.NthSmallestND(v.FItems[0..Pred(v.ElemCount)], N);
end;

class function TGBaseVectorHelper.NthSmallest(constref v: TLiteVector; N: SizeInt): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.NthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N);
end;

class function TGBaseVectorHelper.NextPermutation2Asc(v: TVector): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Asc(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := False;
end;

class function TGBaseVectorHelper.NextPermutation2Asc(var v: TLiteVector): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Asc(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := False;
end;

class function TGBaseVectorHelper.NextPermutation2Desc(v: TVector): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Desc(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := False;
end;

class function TGBaseVectorHelper.NextPermutation2Desc(var v: TLiteVector): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Desc(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := False;
end;

class function TGBaseVectorHelper.IsNonDescending(v: TVector): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonDescending(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := True;
end;

class function TGBaseVectorHelper.IsNonDescending(constref v: TLiteVector): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonDescending(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := True;
end;

class function TGBaseVectorHelper.IsStrictAscending(v: TVector): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictAscending(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := False;
end;

class function TGBaseVectorHelper.IsStrictAscending(constref v: TLiteVector): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.IsStrictAscending(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := False;
end;

class function TGBaseVectorHelper.IsNonAscending(v: TVector): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonAscending(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := True;
end;

class function TGBaseVectorHelper.IsNonAscending(constref v: TLiteVector): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonAscending(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := True;
end;

class function TGBaseVectorHelper.IsStrictDescending(v: TVector): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictDescending(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := False;
end;

class function TGBaseVectorHelper.IsStrictDescending(constref v: TLiteVector): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.IsStrictDescending(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := False;
end;

class function TGBaseVectorHelper.Same(A, B: TVector): Boolean;
var
  c: SizeInt;
begin
  c := A.ElemCount;
  if B.ElemCount = c then
    Result := THelper.Same(A.FItems[0..Pred(c)], B.FItems[0..Pred(c)])
  else
    Result := False;
end;

class function TGBaseVectorHelper.Same(constref A, B: TLiteVector): Boolean;
var
  c: SizeInt;
begin
  c := A.Count;
  if B.Count = c then
    Result := THelper.Same(A.FBuffer.FItems[0..Pred(c)], B.FBuffer.FItems[0..Pred(c)])
  else
    Result := False;
end;

class procedure TGBaseVectorHelper.QuickSort(v: TVector; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.QuickSort(v.FItems[0..Pred(v.ElemCount)], o);
end;

class procedure TGBaseVectorHelper.QuickSort(var v: TLiteVector; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.QuickSort(v.FBuffer.FItems[0..Pred(v.Count)], o);
end;

class procedure TGBaseVectorHelper.IntroSort(v: TVector; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.IntroSort(v.FItems[0..Pred(v.ElemCount)], o);
end;

class procedure TGBaseVectorHelper.IntroSort(var v: TLiteVector; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.IntroSort(v.FBuffer.FItems[0..Pred(v.Count)], o);
end;

class procedure TGBaseVectorHelper.MergeSort(v: TVector; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.MergeSort(v.FItems[0..Pred(v.ElemCount)], o);
end;

class procedure TGBaseVectorHelper.MergeSort(var v: TLiteVector; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.MergeSort(v.FBuffer.FItems[0..Pred(v.Count)], o);
end;

class procedure TGBaseVectorHelper.Sort(v: TVector; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.Sort(v.FItems[0..Pred(v.ElemCount)], o);
end;

class procedure TGBaseVectorHelper.Sort(var v: TLiteVector; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.Sort(v.FBuffer.FItems[0..Pred(v.Count)], o);
end;

class function TGBaseVectorHelper.SelectDistinct(v: TVector): TVector.TArray;
begin
  if v.ElemCount > 0 then
    Result := THelper.SelectDistinct(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := nil;
end;

class function TGBaseVectorHelper.SelectDistinct(constref v: TLiteVector): TLiteVector.TArray;
begin
  if v.Count > 0 then
    Result := THelper.SelectDistinct(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := nil;
end;

{ TGComparableVectorHelper }

class function TGComparableVectorHelper.SequentSearch(v: TVector; constref aValue: T): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.SequentSearch(v.FItems[0..Pred(v.ElemCount)], aValue)
  else
    Result := -1;
end;

class function TGComparableVectorHelper.SequentSearch(constref v: TLiteVector; constref aValue: T): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.SequentSearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue)
  else
    Result := -1;
end;

class function TGComparableVectorHelper.BinarySearch(v: TVector; constref aValue: T): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.BinarySearch(v.FItems[0..Pred(v.ElemCount)], aValue)
  else
    Result := -1;
end;

class function TGComparableVectorHelper.BinarySearch(constref v: TLiteVector; constref aValue: T): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.BinarySearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue)
  else
    Result := -1;
end;

class function TGComparableVectorHelper.IndexOfMin(v: TVector): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMin(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := -1;
end;

class function TGComparableVectorHelper.IndexOfMin(constref v: TLiteVector): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.IndexOfMin(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := -1;
end;

class function TGComparableVectorHelper.IndexOfMax(v: TVector): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMax(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := -1;
end;

class function TGComparableVectorHelper.IndexOfMax(constref v: TLiteVector): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.IndexOfMax(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := -1;
end;

class function TGComparableVectorHelper.GetMin(v: TVector): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMin(v.FItems[0..Pred(v.ElemCount)]);
end;

class function TGComparableVectorHelper.GetMin(constref v: TLiteVector): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMin(v.FBuffer.FItems[0..Pred(v.Count)]);
end;

class function TGComparableVectorHelper.GetMax(v: TVector): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMax(v.FItems[0..Pred(v.ElemCount)]);
end;

class function TGComparableVectorHelper.GetMax(constref v: TLiteVector): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMax(v.FBuffer.FItems[0..Pred(v.Count)]);
end;

class function TGComparableVectorHelper.FindMin(v: TVector; out aValue: T): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMin(v.FItems[0..Pred(v.ElemCount)], aValue)
  else
    Result := False;
end;

class function TGComparableVectorHelper.FindMin(constref v: TLiteVector; out aValue: T): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMin(v.FBuffer.FItems[0..Pred(v.Count)], aValue)
  else
    Result := False;
end;

class function TGComparableVectorHelper.FindMax(v: TVector; out aValue: T): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMax(v.FItems[0..Pred(v.ElemCount)], aValue)
  else
    Result := False;
end;

class function TGComparableVectorHelper.FindMax(constref v: TLiteVector; out aValue: T): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMax(v.FBuffer.FItems[0..Pred(v.Count)], aValue)
  else
    Result := False;
end;

class function TGComparableVectorHelper.FindMinMax(v: TVector; out aMin, aMax: T): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMinMax(v.FItems[0..Pred(v.ElemCount)], aMin, aMax)
  else
    Result := False;
end;

class function TGComparableVectorHelper.FindMinMax(constref v: TLiteVector; out aMin, aMax: T): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMinMax(v.FBuffer.FItems[0..Pred(v.Count)], aMin, aMax)
  else
    Result := False;
end;

class function TGComparableVectorHelper.FindNthSmallest(v: TVector; N: SizeInt; out aValue: T): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindNthSmallestND(v.FItems[0..Pred(v.ElemCount)], N, aValue)
  else
    Result := False;
end;

class function TGComparableVectorHelper.FindNthSmallest(constref v: TLiteVector; N: SizeInt;
  out aValue: T): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindNthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N, aValue)
  else
    Result := False;
end;

class function TGComparableVectorHelper.NthSmallest(v: TVector; N: SizeInt): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.NthSmallestND(v.FItems[0..Pred(v.ElemCount)], N);
end;

class function TGComparableVectorHelper.NthSmallest(constref v: TLiteVector; N: SizeInt): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.NthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N);
end;

class function TGComparableVectorHelper.NextPermutation2Asc(v: TVector): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Asc(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := False;
end;

class function TGComparableVectorHelper.NextPermutation2Asc(var v: TLiteVector): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Asc(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := False;
end;

class function TGComparableVectorHelper.NextPermutation2Desc(v: TVector): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Desc(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := False;
end;

class function TGComparableVectorHelper.NextPermutation2Desc(var v: TLiteVector): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Desc(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := False;
end;

class function TGComparableVectorHelper.IsNonDescending(v: TVector): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonDescending(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := True;
end;

class function TGComparableVectorHelper.IsNonDescending(constref v: TLiteVector): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonDescending(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := True;
end;

class function TGComparableVectorHelper.IsStrictAscending(v: TVector): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictAscending(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := False;
end;

class function TGComparableVectorHelper.IsStrictAscending(constref v: TLiteVector): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.IsStrictAscending(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := False;
end;

class function TGComparableVectorHelper.IsNonAscending(v: TVector): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonAscending(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := True;
end;

class function TGComparableVectorHelper.IsNonAscending(constref v: TLiteVector): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonAscending(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := True;
end;

class function TGComparableVectorHelper.IsStrictDescending(v: TVector): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictDescending(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := False;
end;

class function TGComparableVectorHelper.IsStrictDescending(constref v: TLiteVector): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.IsStrictDescending(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := False;
end;

class function TGComparableVectorHelper.Same(A, B: TVector): Boolean;
var
  c: SizeInt;
begin
  c := A.ElemCount;
  if B.ElemCount = c then
    Result := THelper.Same(A.FItems[0..Pred(c)], B.FItems[0..Pred(c)])
  else
    Result := False;
end;

class function TGComparableVectorHelper.Same(constref A, B: TLiteVector): Boolean;
var
  c: SizeInt;
begin
  c := A.Count;
  if B.Count = c then
    Result := THelper.Same(A.FBuffer.FItems[0..Pred(c)], B.FBuffer.FItems[0..Pred(c)])
  else
    Result := False;
end;

class procedure TGComparableVectorHelper.QuickSort(v: TVector; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.QuickSort(v.FItems[0..Pred(v.ElemCount)], o);
end;

class procedure TGComparableVectorHelper.QuickSort(var v: TLiteVector; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.QuickSort(v.FBuffer.FItems[0..Pred(v.Count)], o);
end;

class procedure TGComparableVectorHelper.IntroSort(v: TVector; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.IntroSort(v.FItems[0..Pred(v.ElemCount)], o);
end;

class procedure TGComparableVectorHelper.IntroSort(var v: TLiteVector; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.IntroSort(v.FBuffer.FItems[0..Pred(v.Count)], o);
end;

class procedure TGComparableVectorHelper.MergeSort(v: TVector; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.MergeSort(v.FItems[0..Pred(v.ElemCount)], o);
end;

class procedure TGComparableVectorHelper.MergeSort(var v: TLiteVector; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.MergeSort(v.FBuffer.FItems[0..Pred(v.Count)], o);
end;

class procedure TGComparableVectorHelper.Sort(v: TVector; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.Sort(v.FItems[0..Pred(v.ElemCount)], o);
end;

class procedure TGComparableVectorHelper.Sort(var v: TLiteVector; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.Sort(v.FBuffer.FItems[0..Pred(v.Count)], o);
end;

class function TGComparableVectorHelper.SelectDistinct(v: TVector): TVector.TArray;
begin
  if v.ElemCount > 0 then
    Result := THelper.SelectDistinct(v.FItems[0..Pred(v.ElemCount)])
  else
    Result := nil;
end;

class function TGComparableVectorHelper.SelectDistinct(constref v: TLiteVector): TLiteVector.TArray;
begin
  if v.Count > 0 then
    Result := THelper.SelectDistinct(v.FBuffer.FItems[0..Pred(v.Count)])
  else
    Result := nil;
end;

{ TGRegularVectorHelper }

class function TGRegularVectorHelper.SequentSearch(v: TVector; constref aValue: T; c: TCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.SequentSearch(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := -1;
end;

class function TGRegularVectorHelper.SequentSearch(constref v: TLiteVector; constref aValue: T;
  c: TCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.SequentSearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := -1;
end;

class function TGRegularVectorHelper.BinarySearch(v: TVector; constref aValue: T; c: TCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.BinarySearch(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := -1;
end;

class function TGRegularVectorHelper.BinarySearch(constref v: TLiteVector; constref aValue: T;
  c: TCompare): SizeInt;
begin

end;

class function TGRegularVectorHelper.IndexOfMin(v: TVector; c: TCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMin(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := -1;
end;

class function TGRegularVectorHelper.IndexOfMax(v: TVector; c: TCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMax(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := -1;
end;

class function TGRegularVectorHelper.IndexOfMax(constref v: TLiteVector; c: TCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.IndexOfMax(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := -1;
end;

class function TGRegularVectorHelper.GetMin(v: TVector; c: TCompare): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMin(v.FItems[0..Pred(v.ElemCount)], c);
end;

class function TGRegularVectorHelper.GetMin(constref v: TLiteVector; c: TCompare): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMin(v.FBuffer.FItems[0..Pred(v.Count)], c);
end;

class function TGRegularVectorHelper.GetMax(v: TVector; c: TCompare): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMax(v.FItems[0..Pred(v.ElemCount)], c);
end;

class function TGRegularVectorHelper.GetMax(constref v: TLiteVector; c: TCompare): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMax(v.FBuffer.FItems[0..Pred(v.Count)], c);
end;

class function TGRegularVectorHelper.FindMin(v: TVector; out aValue: T; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMin(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.FindMin(constref v: TLiteVector; out aValue: T; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMin(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.FindMax(v: TVector; out aValue: T; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMax(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.FindMax(constref v: TLiteVector; out aValue: T; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMax(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.FindMinMax(v: TVector; out aMin, aMax: T; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMinMax(v.FItems[0..Pred(v.ElemCount)], aMin, aMax, c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.FindMinMax(constref v: TLiteVector; out aMin, aMax: T; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMinMax(v.FBuffer.FItems[0..Pred(v.Count)], aMin, aMax, c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.FindNthSmallest(v: TVector; N: SizeInt; out aValue: T; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindNthSmallestND(v.FItems[0..Pred(v.ElemCount)], N, aValue, c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.FindNthSmallest(constref v: TLiteVector; N: SizeInt; out aValue: T;
  c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindNthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N, aValue, c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.NthSmallest(v: TVector; N: SizeInt; c: TCompare): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.NthSmallestND(v.FItems[0..Pred(v.ElemCount)], N, c);
end;

class function TGRegularVectorHelper.NthSmallest(constref v: TLiteVector; N: SizeInt; c: TCompare): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.NthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N, c);
end;

class function TGRegularVectorHelper.NextPermutation2Asc(v: TVector; c: TCompare): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Asc(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.NextPermutation2Asc(var v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Asc(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.NextPermutation2Desc(v: TVector; c: TCompare): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Desc(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.NextPermutation2Desc(var v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Desc(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.IsNonDescending(v: TVector; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonDescending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := True;
end;

class function TGRegularVectorHelper.IsNonDescending(constref v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonDescending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := True;
end;

class function TGRegularVectorHelper.IsStrictAscending(v: TVector; c: TCompare): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictAscending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.IsNonAscending(v: TVector; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonAscending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := True;
end;

class function TGRegularVectorHelper.IsNonAscending(constref v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonAscending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := True;
end;

class function TGRegularVectorHelper.IsStrictDescending(v: TVector; c: TCompare): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictDescending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.IsStrictDescending(constref v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.IsStrictDescending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.Same(A, B: TVector; c: TCompare): Boolean;
var
  cnt: SizeInt;
begin
  cnt := A.ElemCount;
  if B.ElemCount = cnt then
    Result := THelper.Same(A.FItems[0..Pred(cnt)], B.FItems[0..Pred(cnt)], c)
  else
    Result := False;
end;

class function TGRegularVectorHelper.Same(constref A, B: TLiteVector; c: TCompare): Boolean;
var
  cnt: SizeInt;
begin
  cnt := A.Count;
  if B.Count = cnt then
    Result := THelper.Same(A.FBuffer.FItems[0..Pred(cnt)], B.FBuffer.FItems[0..Pred(cnt)], c)
  else
    Result := False;
end;

class procedure TGRegularVectorHelper.QuickSort(v: TVector; c: TCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.QuickSort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGRegularVectorHelper.QuickSort(var v: TLiteVector; c: TCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.QuickSort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class procedure TGRegularVectorHelper.IntroSort(v: TVector; c: TCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.IntroSort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGRegularVectorHelper.IntroSort(var v: TLiteVector; c: TCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.IntroSort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class procedure TGRegularVectorHelper.MergeSort(v: TVector; c: TCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.MergeSort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGRegularVectorHelper.MergeSort(var v: TLiteVector; c: TCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.MergeSort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class procedure TGRegularVectorHelper.Sort(v: TVector; c: TCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.Sort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGRegularVectorHelper.Sort(var v: TLiteVector; c: TCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.Sort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class function TGRegularVectorHelper.SelectDistinct(v: TVector; c: TCompare): TVector.TArray;
begin
  if v.ElemCount > 0 then
    Result := THelper.SelectDistinct(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := nil;
end;

class function TGRegularVectorHelper.SelectDistinct(constref v: TLiteVector; c: TCompare): TLiteVector.TArray;
begin
  if v.Count > 0 then
    Result := THelper.SelectDistinct(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := nil;
end;

{ TGDelegatedVectorHelper }

class function TGDelegatedVectorHelper.SequentSearch(v: TVector; constref aValue: T; c: TOnCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.SequentSearch(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := -1;
end;

class function TGDelegatedVectorHelper.SequentSearch(constref v: TLiteVector; constref aValue: T;
  c: TOnCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.SequentSearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := -1;
end;

class function TGDelegatedVectorHelper.BinarySearch(v: TVector; constref aValue: T; c: TOnCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.BinarySearch(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := -1;
end;

class function TGDelegatedVectorHelper.BinarySearch(constref v: TLiteVector; constref aValue: T;
  c: TOnCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.BinarySearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := -1;
end;

class function TGDelegatedVectorHelper.IndexOfMin(v: TVector; c: TOnCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMin(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := -1;
end;

class function TGDelegatedVectorHelper.IndexOfMin(constref v: TLiteVector; c: TOnCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.IndexOfMin(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := -1;
end;

class function TGDelegatedVectorHelper.IndexOfMax(v: TVector; c: TOnCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMax(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := -1;
end;

class function TGDelegatedVectorHelper.IndexOfMax(constref v: TLiteVector; c: TOnCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.IndexOfMax(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := -1;
end;

class function TGDelegatedVectorHelper.GetMin(v: TVector; c: TOnCompare): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMin(v.FItems[0..Pred(v.ElemCount)], c);
end;

class function TGDelegatedVectorHelper.GetMin(constref v: TLiteVector; c: TOnCompare): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMin(v.FBuffer.FItems[0..Pred(v.Count)], c);
end;

class function TGDelegatedVectorHelper.GetMax(v: TVector; c: TOnCompare): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMax(v.FItems[0..Pred(v.ElemCount)], c);
end;

class function TGDelegatedVectorHelper.GetMax(constref v: TLiteVector; c: TOnCompare): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMax(v.FBuffer.FItems[0..Pred(v.Count)], c);
end;

class function TGDelegatedVectorHelper.FindMin(v: TVector; out aValue: T; c: TOnCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMin(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.FindMin(constref v: TLiteVector; out aValue: T; c: TOnCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMin(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.FindMax(v: TVector; out aValue: T; c: TOnCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMax(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.FindMax(constref v: TLiteVector; out aValue: T; c: TOnCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMax(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.FindMinMax(v: TVector; out aMin, aMax: T; c: TOnCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMinMax(v.FItems[0..Pred(v.ElemCount)], aMin, aMax, c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.FindMinMax(constref v: TLiteVector; out aMin, aMax: T;
  c: TOnCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMinMax(v.FBuffer.FItems[0..Pred(v.Count)], aMin, aMax, c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.FindNthSmallest(v: TVector; N: SizeInt; out aValue: T;
  c: TOnCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindNthSmallestND(v.FItems[0..Pred(v.ElemCount)], N, aValue, c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.FindNthSmallest(constref v: TLiteVector; N: SizeInt; out aValue: T;
  c: TOnCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindNthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N, aValue, c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.NthSmallest(v: TVector; N: SizeInt; c: TOnCompare): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.NthSmallestND(v.FItems[0..Pred(v.ElemCount)], N, c);
end;

class function TGDelegatedVectorHelper.NthSmallest(constref v: TLiteVector; N: SizeInt;
  c: TOnCompare): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.NthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N, c);
end;

class function TGDelegatedVectorHelper.NextPermutation2Asc(v: TVector; c: TOnCompare): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Asc(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.NextPermutation2Asc(var v: TLiteVector; c: TOnCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Asc(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.NextPermutation2Desc(v: TVector; c: TOnCompare): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Desc(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.NextPermutation2Desc(var v: TLiteVector; c: TOnCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Desc(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.IsNonDescending(v: TVector; c: TOnCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonDescending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := True;
end;

class function TGDelegatedVectorHelper.IsNonDescending(constref v: TLiteVector; c: TOnCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonDescending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := True;
end;

class function TGDelegatedVectorHelper.IsStrictAscending(v: TVector; c: TOnCompare): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictAscending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.IsStrictAscending(constref v: TLiteVector; c: TOnCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.IsStrictAscending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.IsNonAscending(v: TVector; c: TOnCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonAscending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := True;
end;

class function TGDelegatedVectorHelper.IsNonAscending(constref v: TLiteVector; c: TOnCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonAscending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := True;
end;

class function TGDelegatedVectorHelper.IsStrictDescending(v: TVector; c: TOnCompare): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictDescending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.IsStrictDescending(constref v: TLiteVector; c: TOnCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.IsStrictDescending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.Same(A, B: TVector; c: TOnCompare): Boolean;
var
  cnt: SizeInt;
begin
  cnt := A.ElemCount;
  if B.ElemCount = cnt then
    Result := THelper.Same(A.FItems[0..Pred(cnt)], B.FItems[0..Pred(cnt)], c)
  else
    Result := False;
end;

class function TGDelegatedVectorHelper.Same(constref A, B: TLiteVector; c: TOnCompare): Boolean;
var
  cnt: SizeInt;
begin
  cnt := A.Count;
  if B.Count = cnt then
    Result := THelper.Same(A.FBuffer.FItems[0..Pred(cnt)], B.FBuffer.FItems[0..Pred(cnt)], c)
  else
    Result := False;
end;

class procedure TGDelegatedVectorHelper.QuickSort(v: TVector; c: TOnCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.QuickSort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGDelegatedVectorHelper.QuickSort(var v: TLiteVector; c: TOnCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.QuickSort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class procedure TGDelegatedVectorHelper.IntroSort(v: TVector; c: TOnCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.IntroSort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGDelegatedVectorHelper.IntroSort(var v: TLiteVector; c: TOnCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.IntroSort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class procedure TGDelegatedVectorHelper.MergeSort(v: TVector; c: TOnCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.MergeSort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGDelegatedVectorHelper.MergeSort(var v: TLiteVector; c: TOnCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.MergeSort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class procedure TGDelegatedVectorHelper.Sort(v: TVector; c: TOnCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.Sort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGDelegatedVectorHelper.Sort(var v: TLiteVector; c: TOnCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.Sort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class function TGDelegatedVectorHelper.SelectDistinct(v: TVector; c: TOnCompare): TVector.TArray;
begin
  if v.ElemCount > 0 then
    Result := THelper.SelectDistinct(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := nil;
end;

class function TGDelegatedVectorHelper.SelectDistinct(constref v: TLiteVector;
  c: TOnCompare): TLiteVector.TArray;
begin
  if v.Count > 0 then
    Result := THelper.SelectDistinct(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := nil;
end;

{ TGNestedVectorHelper }

class function TGNestedVectorHelper.SequentSearch(v: TVector; constref aValue: T; c: TCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.SequentSearch(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := -1;
end;

class function TGNestedVectorHelper.SequentSearch(constref v: TLiteVector; constref aValue: T;
  c: TCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.SequentSearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := -1;
end;

class function TGNestedVectorHelper.BinarySearch(v: TVector; constref aValue: T; c: TCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.BinarySearch(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := -1;
end;

class function TGNestedVectorHelper.BinarySearch(constref v: TLiteVector; constref aValue: T;
  c: TCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.BinarySearch(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := -1;
end;

class function TGNestedVectorHelper.IndexOfMin(v: TVector; c: TCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMin(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := -1;
end;

class function TGNestedVectorHelper.IndexOfMin(constref v: TLiteVector; c: TCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.IndexOfMin(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := -1;
end;

class function TGNestedVectorHelper.IndexOfMax(v: TVector; c: TCompare): SizeInt;
begin
  if v.ElemCount > 0 then
    Result := THelper.IndexOfMax(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := -1;
end;

class function TGNestedVectorHelper.IndexOfMax(constref v: TLiteVector; c: TCompare): SizeInt;
begin
  if v.Count > 0 then
    Result := THelper.IndexOfMax(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := -1;
end;

class function TGNestedVectorHelper.GetMin(v: TVector; c: TCompare): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMin(v.FItems[0..Pred(v.ElemCount)], c);
end;

class function TGNestedVectorHelper.GetMin(constref v: TLiteVector; c: TCompare): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMin(v.FBuffer.FItems[0..Pred(v.Count)], c);
end;

class function TGNestedVectorHelper.GetMax(v: TVector; c: TCompare): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.GetMax(v.FItems[0..Pred(v.ElemCount)], c);
end;

class function TGNestedVectorHelper.GetMax(constref v: TLiteVector; c: TCompare): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.GetMax(v.FBuffer.FItems[0..Pred(v.Count)], c);
end;

class function TGNestedVectorHelper.FindMin(v: TVector; out aValue: T; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMin(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.FindMin(constref v: TLiteVector; out aValue: T; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMin(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.FindMax(v: TVector; out aValue: T; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMax(v.FItems[0..Pred(v.ElemCount)], aValue, c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.FindMax(constref v: TLiteVector; out aValue: T; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMax(v.FBuffer.FItems[0..Pred(v.Count)], aValue, c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.FindMinMax(v: TVector; out aMin, aMax: T; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindMinMax(v.FItems[0..Pred(v.ElemCount)], aMin, aMax, c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.FindMinMax(constref v: TLiteVector; out aMin, aMax: T; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindMinMax(v.FBuffer.FItems[0..Pred(v.Count)], aMin, aMax, c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.FindNthSmallest(v: TVector; N: SizeInt; out aValue: T; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.FindNthSmallestND(v.FItems[0..Pred(v.ElemCount)], N, aValue, c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.FindNthSmallest(constref v: TLiteVector; N: SizeInt; out aValue: T;
  c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.FindNthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N, aValue, c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.NthSmallest(v: TVector; N: SizeInt; c: TCompare): TOptional;
begin
  if v.ElemCount > 0 then
    Result := THelper.NthSmallestND(v.FItems[0..Pred(v.ElemCount)], N, c);
end;

class function TGNestedVectorHelper.NthSmallest(constref v: TLiteVector; N: SizeInt; c: TCompare): TOptional;
begin
  if v.Count > 0 then
    Result := THelper.NthSmallestND(v.FBuffer.FItems[0..Pred(v.Count)], N, c);
end;

class function TGNestedVectorHelper.NextPermutation2Asc(v: TVector; c: TCompare): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Asc(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.NextPermutation2Asc(var v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Asc(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.NextPermutation2Desc(v: TVector; c: TCompare): Boolean;
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    Result := THelper.NextPermutation2Desc(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.NextPermutation2Desc(var v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.NextPermutation2Desc(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.IsNonDescending(v: TVector; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonDescending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := True;
end;

class function TGNestedVectorHelper.IsNonDescending(constref v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonDescending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := True;
end;

class function TGNestedVectorHelper.IsStrictAscending(v: TVector; c: TCompare): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictAscending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.IsStrictAscending(constref v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.IsStrictAscending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.IsNonAscending(v: TVector; c: TCompare): Boolean;
begin
  if v.ElemCount > 0 then
    Result := THelper.IsNonAscending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := True;
end;

class function TGNestedVectorHelper.IsNonAscending(constref v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 0 then
    Result := THelper.IsNonAscending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := True;
end;

class function TGNestedVectorHelper.IsStrictDescending(v: TVector; c: TCompare): Boolean;
begin
  if v.ElemCount > 1 then
    Result := THelper.IsStrictDescending(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.IsStrictDescending(constref v: TLiteVector; c: TCompare): Boolean;
begin
  if v.Count > 1 then
    Result := THelper.IsStrictDescending(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.Same(A, B: TVector; c: TCompare): Boolean;
var
  cnt: SizeInt;
begin
  cnt := A.ElemCount;
  if B.ElemCount = cnt then
    Result := THelper.Same(A.FItems[0..Pred(cnt)], B.FItems[0..Pred(cnt)], c)
  else
    Result := False;
end;

class function TGNestedVectorHelper.Same(constref A, B: TLiteVector; c: TCompare): Boolean;
var
  cnt: SizeInt;
begin
  cnt := A.Count;
  if B.Count = cnt then
    Result := THelper.Same(A.FBuffer.FItems[0..Pred(cnt)], B.FBuffer.FItems[0..Pred(cnt)], c)
  else
    Result := False;
end;

class procedure TGNestedVectorHelper.QuickSort(v: TVector; c: TCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.QuickSort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGNestedVectorHelper.QuickSort(var v: TLiteVector; c: TCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.QuickSort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class procedure TGNestedVectorHelper.IntroSort(v: TVector; c: TCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.IntroSort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGNestedVectorHelper.IntroSort(var v: TLiteVector; c: TCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.IntroSort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class procedure TGNestedVectorHelper.MergeSort(v: TVector; c: TCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.MergeSort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGNestedVectorHelper.MergeSort(var v: TLiteVector; c: TCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.MergeSort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class procedure TGNestedVectorHelper.Sort(v: TVector; c: TCompare; o: TSortOrder);
begin
  v.CheckInIteration;
  if v.ElemCount > 1 then
    THelper.Sort(v.FItems[0..Pred(v.ElemCount)], c, o);
end;

class procedure TGNestedVectorHelper.Sort(var v: TLiteVector; c: TCompare; o: TSortOrder);
begin
  if v.Count > 1 then
    THelper.Sort(v.FBuffer.FItems[0..Pred(v.Count)], c, o);
end;

class function TGNestedVectorHelper.SelectDistinct(v: TVector; c: TCompare): TVector.TArray;
begin
  if v.ElemCount > 0 then
    Result := THelper.SelectDistinct(v.FItems[0..Pred(v.ElemCount)], c)
  else
    Result := nil;
end;

class function TGNestedVectorHelper.SelectDistinct(constref v: TLiteVector; c: TCompare): TVector.TArray;
begin
  if v.Count > 0 then
    Result := THelper.SelectDistinct(v.FBuffer.FItems[0..Pred(v.Count)], c)
  else
    Result := nil;
end;

end.

